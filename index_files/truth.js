"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var Truth;
(function (Truth) {
    /**
     * Asynchronously reads a truth document, and all documents
     * it references from the specified file system or HTTP(s) path.
     * File system paths are only supported if this code is running
     * within a Node.js-compatible environment.
     *
     * @returns A reference to the document read, or an Error.
     */
    async function read(sourcePathOrUri, targetProgram = new Truth.Program()) {
        return await targetProgram.addDocumentFromUri(sourcePathOrUri);
    }
    Truth.read = read;
    /**
     * Parses the specified truth content into a new Truth program.
     *
     * @returns A reference to the parsed document.
     */
    async function parse(sourceText, targetProgram = new Truth.Program()) {
        return await targetProgram.addDocument(sourceText);
    }
    Truth.parse = parse;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A Map of the generic key and value types.
     * Supports keys that refer to multiple values.
     */
    class MultiMap {
        constructor() {
            /** */
            this.map = new Map();
        }
        /** */
        *[Symbol.iterator]() {
            for (const entry of this.map)
                yield entry;
        }
        /** */
        entries() {
            return this.map.entries();
        }
        /** */
        get(key) {
            return this.map.get(key);
        }
        /** */
        has(key, value) {
            const values = this.get(key);
            if (!values)
                return false;
            if (value !== undefined)
                return values.includes(value);
            return true;
        }
        /** */
        add(key, value) {
            if (value) {
                const values = this.get(key);
                if (values) {
                    if (!values.includes(value))
                        values.push(value);
                }
                else {
                    this.map.set(key, [value]);
                }
            }
            return this;
        }
        /** */
        delete(key, value) {
            if (value === undefined)
                return !!this.map.delete(key);
            const storedValues = this.map.get(key);
            if (storedValues === undefined)
                return false;
            if (storedValues.length === 1 && storedValues[0] === value) {
                this.map.delete(key);
                return true;
            }
            const valueIdx = storedValues.indexOf(value);
            if (valueIdx < 0)
                return false;
            storedValues.splice(valueIdx, 1);
            return true;
        }
        /** */
        values() {
            return this.map.values();
        }
        /** */
        get size() {
            return this.map.size;
        }
    }
    Truth.MultiMap = MultiMap;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Exposes the "fs" module used by the compiler,
     * as well as the ability to change the module used
     * with a custom implementation.
     */
    class Fs {
        /**
         * Assigns a new implementation of the node "fs" module.
         */
        static override(module) {
            this._module = module;
        }
        /** */
        static get module() {
            if (this._module)
                return this._module;
            this._module = require("fs");
            return Truth.Not.null(this._module);
        }
    }
    /** */
    Fs._module = null;
    Truth.Fs = Fs;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that encapsulates string hashing functionality.
     */
    Truth.Hash = new class Hash {
        constructor() {
            /** Stores the constant number of characters in a returned hash. */
            this.length = 8;
        }
        /**
         * Calculates a hash code from the specified string.
         */
        calculate(text) {
            if (text.length === 0)
                return "0".repeat(8);
            let hash = 0;
            for (let i = -1; ++i < text.length;) {
                const char = text.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash %= 2 ** 32;
            }
            return (hash + Math.pow(2, 31)).toString(16).toUpperCase();
        }
    }();
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that provides various higher-order functions
     * across data structures.
     */
    class HigherOrder {
        static copy(param) {
            if (param instanceof Array)
                return Object.freeze(param.slice());
            if (param instanceof Set) {
                const set = new Set();
                for (const value of param)
                    set.add(value);
                return Object.freeze(set);
            }
            if (param instanceof Map) {
                const map = new Map();
                for (const [key, value] of param)
                    map.set(key, value);
                return Object.freeze(map);
            }
            throw new TypeError();
        }
        constructor() { }
    }
    Truth.HigherOrder = HigherOrder;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Utility class for performing basic guarding.
     */
    class Not {
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's strictly equal to null.
         */
        static null(param) {
            if (param === null) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's strictly equal to undefined.
         */
        static undefined(param) {
            if (param === undefined) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's null or undefined.
         */
        static nullable(param) {
            if (param === null || param === undefined) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
    }
    Truth.Not = Not;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A general parsing utility class that provides consumption
     * methods that operate over a given input.
     */
    class Parser {
        /**
         * Constructs a new Parser object that operates over
         * the specified input string, optionally starting at the
         * specified position.
         */
        constructor(input) {
            this._position = 0;
            this.input = input.normalize();
            this._position = 0;
        }
        read(token) {
            if (!token)
                throw new TypeError();
            const pos = this._position;
            if (this.input.substr(pos, token.length) === token) {
                this._position += token.length;
                return token;
            }
            return "";
        }
        /**
         * Reads any whitespace characters and floating
         * escape characters.
         *
         * @returns The number of whitespace characters
         * read.
         */
        readWhitespace() {
            let count = 0;
            while (this.more()) {
                const c = count;
                if (this.read("\t" /* tab */))
                    count++;
                if (this.read(" " /* space */))
                    count++;
                if (this.read("\\" /* escapeChar */ + " " /* space */))
                    count++;
                if (this.read("\\" /* escapeChar */ + "\t" /* tab */))
                    count++;
                if (c === count)
                    break;
            }
            return count;
        }
        /**
         * Attempts to read a single stream-level grapheme from the
         * parse stream, using unicode-aware extraction method.
         * If the parse stream specifies a unicode escape sequence,
         * such as \uFFFF, these are seen as 6 individual graphemes.
         *
         * @returns The read grapheme, or an empty string in the case
         * when there is no more content in the parse stream.
         */
        readGrapheme() {
            if (this._position >= this.input.length)
                return "";
            const codeAtCursor = this.input.codePointAt(this._position) || -1;
            this._position += codeAtCursor > 0xFFFF ? 2 : 1;
            return String.fromCodePoint(codeAtCursor);
        }
        /**
         * Reads graphemes from the parse stream, until either
         * the cursor reaches one of the specified quit tokens,
         * or the parse stream terminates.
         */
        readUntil(...quitTokens) {
            let stream = "";
            while (this.more()) {
                if (quitTokens.some(t => this.peek(t)))
                    break;
                stream += this.readGrapheme();
            }
            return stream;
        }
        /**
         * Attempts to read the specified token from the parse stream,
         * if and only if it's at the end of the parse stream.
         */
        readThenTerminal(token) {
            if (this.peek(token) && this._position === this.input.length - token.length) {
                this._position += token.length;
                return token;
            }
            return "";
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified string exists immediately at the position of
         * the cursor.
         */
        peek(token) {
            return this.input.substr(this._position, token.length) === token;
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified string exists immediately at the position of
         * the cursor, and following this token is the end of the
         * parse stream.
         */
        peekThenTerminal(token) {
            return (this._position === this.input.length - token.length &&
                this.input.substr(this._position, token.length) === token);
        }
        /**
         * @returns A boolean value that indicates whether
         * there are more characters to read in the input.
         */
        more() {
            return this._position < this.input.length;
        }
        /**
         * Gets or sets the position of the cursor from where
         * reading takes place in the cursor.
         */
        get position() {
            return this._position;
        }
        set position(value) {
            if (value < 0)
                throw new RangeError();
            this._position = value;
        }
        //
        // DEAD
        //
        /**
         *
         */
        atRealBackslash() {
            const esc = "\\" /* escapeChar */;
            return this.input.substr(this._position, 2) === esc + esc;
        }
        /**
         * @deprecated
         * @returns A boolean value that indicates whether an
         * escape character exists behind the current character.
         * The algorithm used is respective of sequences of
         * multiple escape characters.
         */
        escaped() {
            let escaped = false;
            let backtrackPos = this._position;
            while (--backtrackPos >= 0)
                if (this.input[backtrackPos] === "\\" /* escapeChar */)
                    escaped = !escaped;
            return escaped;
        }
    }
    Truth.Parser = Parser;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Converts the names in the UnicodeBlocks object
     * to a map with lower case keys, for easy lookup.
     */
    function toMap(blocks) {
        const entries = Object.entries(blocks);
        const entriesFmt = entries.map(entry => [entry[0].toLowerCase(), entry[1]]);
        return Object.freeze(new Map(entriesFmt));
    }
    /**
     * Stores the maximum character code in the unicode set.
     */
    Truth.UnicodeMax = 65536;
    /**
     * Stores a map of the names of all unicode blocks,
     * and their character ranges.
     */
    Truth.UnicodeBlocks = toMap({
        "Control character": [0x0000, 0x001F],
        "Basic Latin": [0x0020, 0x007F],
        "Latin-1 Supplement": [0x0080, 0x00FF],
        "Latin Extended-A": [0x0100, 0x017F],
        "Latin Extended-B": [0x0180, 0x024F],
        "IPA Extensions": [0x0250, 0x02AF],
        "Spacing Modifier Letters": [0x02B0, 0x02FF],
        "Combining Diacritical Marks": [0x0300, 0x036F],
        "Greek and Coptic": [0x0370, 0x03FF],
        "Cyrillic": [0x0400, 0x04FF],
        "Cyrillic Supplement": [0x0500, 0x052F],
        "Armenian": [0x0530, 0x058F],
        "Hebrew": [0x0590, 0x05FF],
        "Arabic": [0x0600, 0x06FF],
        "Syriac": [0x0700, 0x074F],
        "Arabic Supplement": [0x0750, 0x077F],
        "Thaana": [0x0780, 0x07BF],
        "NKo": [0x07C0, 0x07FF],
        "Samaritan": [0x0800, 0x083F],
        "Mandaic": [0x0840, 0x085F],
        "Syriac Supplement": [0x0860, 0x086F],
        "Arabic Extended-A": [0x08A0, 0x08FF],
        "Devanagari": [0x0900, 0x097F],
        "Bengali": [0x0980, 0x09FF],
        "Gurmukhi": [0x0A00, 0x0A7F],
        "Gujarati": [0x0A80, 0x0AFF],
        "Oriya": [0x0B00, 0x0B7F],
        "Tamil": [0x0B80, 0x0BFF],
        "Telugu": [0x0C00, 0x0C7F],
        "Kannada": [0x0C80, 0x0CFF],
        "Malayalam": [0x0D00, 0x0D7F],
        "Sinhala": [0x0D80, 0x0DFF],
        "Thai": [0x0E00, 0x0E7F],
        "Lao": [0x0E80, 0x0EFF],
        "Tibetan": [0x0F00, 0x0FFF],
        "Myanmar": [0x1000, 0x109F],
        "Georgian": [0x10A0, 0x10FF],
        "Hangul Jamo": [0x1100, 0x11FF],
        "Ethiopic": [0x1200, 0x137F],
        "Ethiopic Supplement": [0x1380, 0x139F],
        "Cherokee": [0x13A0, 0x13FF],
        "Unified Canadian Aboriginal Syllabics": [0x1400, 0x167F],
        "Ogham": [0x1680, 0x169F],
        "Runic": [0x16A0, 0x16FF],
        "Tagalog": [0x1700, 0x171F],
        "Hanunoo": [0x1720, 0x173F],
        "Buhid": [0x1740, 0x175F],
        "Tagbanwa": [0x1760, 0x177F],
        "Khmer": [0x1780, 0x17FF],
        "Mongolian": [0x1800, 0x18AF],
        "Unified Canadian Aboriginal Syllabics Extended": [0x18B0, 0x18FF],
        "Limbu": [0x1900, 0x194F],
        "Tai Le": [0x1950, 0x197F],
        "New Tai Lue": [0x1980, 0x19DF],
        "Khmer Symbols": [0x19E0, 0x19FF],
        "Buginese": [0x1A00, 0x1A1F],
        "Tai Tham": [0x1A20, 0x1AAF],
        "Combining Diacritical Marks Extended": [0x1AB0, 0x1AFF],
        "Balinese": [0x1B00, 0x1B7F],
        "Sundanese": [0x1B80, 0x1BBF],
        "Batak": [0x1BC0, 0x1BFF],
        "Lepcha": [0x1C00, 0x1C4F],
        "Ol Chiki": [0x1C50, 0x1C7F],
        "Cyrillic Extended C": [0x1C80, 0x1C8F],
        "Sundanese Supplement": [0x1CC0, 0x1CCF],
        "Vedic Extensions": [0x1CD0, 0x1CFF],
        "Phonetic Extensions": [0x1D00, 0x1D7F],
        "Phonetic Extensions Supplement": [0x1D80, 0x1DBF],
        "Combining Diacritical Marks Supplement": [0x1DC0, 0x1DFF],
        "Latin Extended Additional": [0x1E00, 0x1EFF],
        "Greek Extended": [0x1F00, 0x1FFF],
        "General Punctuation": [0x2000, 0x206F],
        "Superscripts and Subscripts": [0x2070, 0x209F],
        "Currency Symbols": [0x20A0, 0x20CF],
        "Combining Diacritical Marks for Symbols": [0x20D0, 0x20FF],
        "Letterlike Symbols": [0x2100, 0x214F],
        "Number Forms": [0x2150, 0x218F],
        "Arrows": [0x2190, 0x21FF],
        "Mathematical Operators": [0x2200, 0x22FF],
        "Miscellaneous Technical": [0x2300, 0x23FF],
        "Control Pictures": [0x2400, 0x243F],
        "Optical Character Recognition": [0x2440, 0x245F],
        "Enclosed Alphanumerics": [0x2460, 0x24FF],
        "Box Drawing": [0x2500, 0x257F],
        "Block Elements": [0x2580, 0x259F],
        "Geometric Shapes": [0x25A0, 0x25FF],
        "Miscellaneous Symbols": [0x2600, 0x26FF],
        "Dingbats": [0x2700, 0x27BF],
        "Miscellaneous Mathematical Symbols-A": [0x27C0, 0x27EF],
        "Supplemental Arrows-A": [0x27F0, 0x27FF],
        "Braille Patterns": [0x2800, 0x28FF],
        "Supplemental Arrows-B": [0x2900, 0x297F],
        "Miscellaneous Mathematical Symbols-B": [0x2980, 0x29FF],
        "Supplemental Mathematical Operators": [0x2A00, 0x2AFF],
        "Miscellaneous Symbols and Arrows": [0x2B00, 0x2BFF],
        "Glagolitic": [0x2C00, 0x2C5F],
        "Latin Extended-C": [0x2C60, 0x2C7F],
        "Coptic": [0x2C80, 0x2CFF],
        "Georgian Supplement": [0x2D00, 0x2D2F],
        "Tifinagh": [0x2D30, 0x2D7F],
        "Ethiopic Extended": [0x2D80, 0x2DDF],
        "Cyrillic Extended-A": [0x2DE0, 0x2DFF],
        "Supplemental Punctuation": [0x2E00, 0x2E7F],
        "CJK Radicals Supplement": [0x2E80, 0x2EFF],
        "Kangxi Radicals": [0x2F00, 0x2FDF],
        "Ideographic Description Characters": [0x2FF0, 0x2FFF],
        "CJK Symbols and Punctuation": [0x3000, 0x303F],
        "Hiragana": [0x3040, 0x309F],
        "Katakana": [0x30A0, 0x30FF],
        "Bopomofo": [0x3100, 0x312F],
        "Hangul Compatibility Jamo": [0x3130, 0x318F],
        "Kanbun": [0x3190, 0x319F],
        "Bopomofo Extended": [0x31A0, 0x31BF],
        "CJK Strokes": [0x31C0, 0x31EF],
        "Katakana Phonetic Extensions": [0x31F0, 0x31FF],
        "Enclosed CJK Letters and Months": [0x3200, 0x32FF],
        "CJK Compatibility": [0x3300, 0x33FF],
        "CJK Unified Ideographs Extension A": [0x3400, 0x4DBF],
        "Yijing Hexagram Symbols": [0x4DC0, 0x4DFF],
        "CJK Unified Ideographs": [0x4E00, 0x9FFF],
        "Yi Syllables": [0xA000, 0xA48F],
        "Yi Radicals": [0xA490, 0xA4CF],
        "Lisu": [0xA4D0, 0xA4FF],
        "Vai": [0xA500, 0xA63F],
        "Cyrillic Extended-B": [0xA640, 0xA69F],
        "Bamum": [0xA6A0, 0xA6FF],
        "Modifier Tone Letters": [0xA700, 0xA71F],
        "Latin Extended-D": [0xA720, 0xA7FF],
        "Syloti Nagri": [0xA800, 0xA82F],
        "Common Indic Number Forms": [0xA830, 0xA83F],
        "Phags-pa": [0xA840, 0xA87F],
        "Saurashtra": [0xA880, 0xA8DF],
        "Devanagari Extended": [0xA8E0, 0xA8FF],
        "Kayah Li": [0xA900, 0xA92F],
        "Rejang": [0xA930, 0xA95F],
        "Hangul Jamo Extended-A": [0xA960, 0xA97F],
        "Javanese": [0xA980, 0xA9DF],
        "Myanmar Extended-B": [0xA9E0, 0xA9FF],
        "Cham": [0xAA00, 0xAA5F],
        "Myanmar Extended-A": [0xAA60, 0xAA7F],
        "Tai Viet": [0xAA80, 0xAADF],
        "Meetei Mayek Extensions": [0xAAE0, 0xAAFF],
        "Ethiopic Extended-A": [0xAB00, 0xAB2F],
        "Latin Extended-E": [0xAB30, 0xAB6F],
        "Cherokee Supplement": [0xAB70, 0xABBF],
        "Meetei Mayek": [0xABC0, 0xABFF],
        "Hangul Syllables": [0xAC00, 0xD7AF],
        "Hangul Jamo Extended-B": [0xD7B0, 0xD7FF],
        "High Surrogates": [0xD800, 0xDB7F],
        "High Private Use Surrogates": [0xDB80, 0xDBFF],
        "Low Surrogates": [0xDC00, 0xDFFF],
        "Private Use Area": [0xE000, 0xF8FF],
        "CJK Compatibility Ideographs": [0xF900, 0xFAFF],
        "Alphabetic Presentation Forms": [0xFB00, 0xFB4F],
        "Arabic Presentation Forms-A": [0xFB50, 0xFDFF],
        "Variation Selectors": [0xFE00, 0xFE0F],
        "Vertical Forms": [0xFE10, 0xFE1F],
        "Combining Half Marks": [0xFE20, 0xFE2F],
        "CJK Compatibility Forms": [0xFE30, 0xFE4F],
        "Small Form Variants": [0xFE50, 0xFE6F],
        "Arabic Presentation Forms-B": [0xFE70, 0xFEFF],
        "Halfwidth and Fullwidth Forms": [0xFF00, 0xFFEF],
        "Specials": [0xFFF0, 0xFFFF],
        "Linear B Syllabary": [0x10000, 0x1007F],
        "Linear B Ideograms": [0x10080, 0x100FF],
        "Aegean Numbers": [0x10100, 0x1013F],
        "Ancient Greek Numbers": [0x10140, 0x1018F],
        "Ancient Symbols": [0x10190, 0x101CF],
        "Phaistos Disc": [0x101D0, 0x101FF],
        "Lycian": [0x10280, 0x1029F],
        "Carian": [0x102A0, 0x102DF],
        "Coptic Epact Numbers": [0x102E0, 0x102FF],
        "Old Italic": [0x10300, 0x1032F],
        "Gothic": [0x10330, 0x1034F],
        "Old Permic": [0x10350, 0x1037F],
        "Ugaritic": [0x10380, 0x1039F],
        "Old Persian": [0x103A0, 0x103DF],
        "Deseret": [0x10400, 0x1044F],
        "Shavian": [0x10450, 0x1047F],
        "Osmanya": [0x10480, 0x104AF],
        "Osage": [0x104B0, 0x104FF],
        "Elbasan": [0x10500, 0x1052F],
        "Caucasian Albanian": [0x10530, 0x1056F],
        "Linear A": [0x10600, 0x1077F],
        "Cypriot Syllabary": [0x10800, 0x1083F],
        "Imperial Aramaic": [0x10840, 0x1085F],
        "Palmyrene": [0x10860, 0x1087F],
        "Nabataean": [0x10880, 0x108AF],
        "Hatran": [0x108E0, 0x108FF],
        "Phoenician": [0x10900, 0x1091F],
        "Lydian": [0x10920, 0x1093F],
        "Meroitic Hieroglyphs": [0x10980, 0x1099F],
        "Meroitic Cursive": [0x109A0, 0x109FF],
        "Kharoshthi": [0x10A00, 0x10A5F],
        "Old South Arabian": [0x10A60, 0x10A7F],
        "Old North Arabian": [0x10A80, 0x10A9F],
        "Manichaean": [0x10AC0, 0x10AFF],
        "Avestan": [0x10B00, 0x10B3F],
        "Inscriptional Parthian": [0x10B40, 0x10B5F],
        "Inscriptional Pahlavi": [0x10B60, 0x10B7F],
        "Psalter Pahlavi": [0x10B80, 0x10BAF],
        "Old Turkic": [0x10C00, 0x10C4F],
        "Old Hungarian": [0x10C80, 0x10CFF],
        "Rumi Numeral Symbols": [0x10E60, 0x10E7F],
        "Brahmi": [0x11000, 0x1107F],
        "Kaithi": [0x11080, 0x110CF],
        "Sora Sompeng": [0x110D0, 0x110FF],
        "Chakma": [0x11100, 0x1114F],
        "Mahajani": [0x11150, 0x1117F],
        "Sharada": [0x11180, 0x111DF],
        "Sinhala Archaic Numbers": [0x111E0, 0x111FF],
        "Khojki": [0x11200, 0x1124F],
        "Multani": [0x11280, 0x112AF],
        "Khudawadi": [0x112B0, 0x112FF],
        "Grantha": [0x11300, 0x1137F],
        "Newa": [0x11400, 0x1147F],
        "Tirhuta": [0x11480, 0x114DF],
        "Siddham": [0x11580, 0x115FF],
        "Modi": [0x11600, 0x1165F],
        "Mongolian Supplement": [0x11660, 0x1167F],
        "Takri": [0x11680, 0x116CF],
        "Ahom": [0x11700, 0x1173F],
        "Warang Citi": [0x118A0, 0x118FF],
        "Zanabazar Square": [0x11A00, 0x11A4F],
        "Soyombo": [0x11A50, 0x11AAF],
        "Pau Cin Hau": [0x11AC0, 0x11AFF],
        "Bhaiksuki": [0x11C00, 0x11C6F],
        "Marchen": [0x11C70, 0x11CBF],
        "Masaram Gondi": [0x11D00, 0x11D5F],
        "Cuneiform": [0x12000, 0x123FF],
        "Cuneiform Numbers and Punctuation": [0x12400, 0x1247F],
        "Early Dynastic Cuneiform": [0x12480, 0x1254F],
        "Egyptian Hieroglyphs": [0x13000, 0x1342F],
        "Anatolian Hieroglyphs": [0x14400, 0x1467F],
        "Bamum Supplement": [0x16800, 0x16A3F],
        "Mro": [0x16A40, 0x16A6F],
        "Bassa Vah": [0x16AD0, 0x16AFF],
        "Pahawh Hmong": [0x16B00, 0x16B8F],
        "Miao": [0x16F00, 0x16F9F],
        "Ideographic Symbols and Punctuation": [0x16FE0, 0x16FFF],
        "Tangut": [0x17000, 0x187FF],
        "Tangut Components": [0x18800, 0x18AFF],
        "Kana Supplement": [0x1B000, 0x1B0FF],
        "Kana Extended-A": [0x1B100, 0x1B12F],
        "Nushu": [0x1B170, 0x1B2FF],
        "Duployan": [0x1BC00, 0x1BC9F],
        "Shorthand Format Controls": [0x1BCA0, 0x1BCAF],
        "Byzantine Musical Symbols": [0x1D000, 0x1D0FF],
        "Musical Symbols": [0x1D100, 0x1D1FF],
        "Ancient Greek Musical Notation": [0x1D200, 0x1D24F],
        "Tai Xuan Jing Symbols": [0x1D300, 0x1D35F],
        "Counting Rod Numerals": [0x1D360, 0x1D37F],
        "Mathematical Alphanumeric Symbols": [0x1D400, 0x1D7FF],
        "Sutton SignWriting": [0x1D800, 0x1DAAF],
        "Glagolitic Supplement": [0x1E000, 0x1E02F],
        "Mende Kikakui": [0x1E800, 0x1E8DF],
        "Adlam": [0x1E900, 0x1E95F],
        "Arabic Mathematical Alphabetic Symbols": [0x1EE00, 0x1EEFF],
        "Mahjong Tiles": [0x1F000, 0x1F02F],
        "Domino Tiles": [0x1F030, 0x1F09F],
        "Playing Cards": [0x1F0A0, 0x1F0FF],
        "Enclosed Alphanumeric Supplement": [0x1F100, 0x1F1FF],
        "Enclosed Ideographic Supplement": [0x1F200, 0x1F2FF],
        "Miscellaneous Symbols and Pictographs": [0x1F300, 0x1F5FF],
        "Emoji": [0x1F600, 0x1F64F],
        "Ornamental Dingbats": [0x1F650, 0x1F67F],
        "Transport and Map Symbols": [0x1F680, 0x1F6FF],
        "Alchemical Symbols": [0x1F700, 0x1F77F],
        "Geometric Shapes Extended": [0x1F780, 0x1F7FF],
        "Supplemental Arrows-C": [0x1F800, 0x1F8FF],
        "Supplemental Symbols and Pictographs": [0x1F900, 0x1F9FF],
        "CJK Unified Ideographs Extension B": [0x20000, 0x2A6DF],
        "CJK Unified Ideographs Extension C": [0x2A700, 0x2B73F],
        "CJK Unified Ideographs Extension D": [0x2B740, 0x2B81F],
        "CJK Unified Ideographs Extension E": [0x2B820, 0x2CEAF],
        "CJK Unified Ideographs Extension F": [0x2CEB0, 0x2EBEF],
        "CJK Compatibility Ideographs Supplement": [0x2F800, 0x2FA1F],
        "Tags": [0xE0000, 0xE007F],
        "Variation Selectors Supplement": [0xE0100, 0xE01EF]
    });
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Stores unsorted general utility methods.
     */
    class Misc {
        static get(map, key, fallbackFn) {
            const value = map.get(key);
            if (value !== void 0)
                return value;
            const fallbackValue = fallbackFn();
            map.set(key, fallbackValue);
            return fallbackValue;
        }
        /**
         * Compresses the number sequence into a reasonably unique 53-bit hash number.
         * The hash is commutative in that the sequences [1, 2, 3] and [3, 2, 1] should result
         * in the same number.
         */
        static hashCommutative(numbers) {
            let mul = 1;
            let add = 0;
            for (let i = numbers.length; i-- > 0;) {
                const num = numbers[i];
                // 32 bits for the multiplying of numbers together
                mul = (mul *= num) % (2 ** 32);
                // 18 bits for the total of all the numbers
                add = (add += num) % (2 ** 18);
            }
            // 3 bits for the number of numbers
            const count = numbers.length % (2 ** 3);
            return (count << 50) | (add << 32) | mul;
        }
        /**
         * Counts incrementally through numbers, using the specified
         * radix sequence. For example, if the radixes [2, 2, 2] were to
         * be specified, this would result in binary counting starting at
         * [0, 0, 0] and ending at [1, 1, 1].
         */
        static *variableRadixCounter(radixes) {
            if (radixes.length === 0)
                return;
            if (radixes.length === 1) {
                for (let i = -1; ++i < radixes[0];)
                    yield [i];
                return;
            }
            const total = radixes.reduce((a, b) => a * b, 1);
            const digits = radixes.map(() => 0);
            const divideFactors = [1];
            for (let baseIdx = radixes.length - 1; --baseIdx >= 0;)
                divideFactors.unshift(radixes.slice(baseIdx + 1).reduce((a, b) => a * b, 1));
            for (let count = -1; ++count < total;) {
                const sequence = [];
                let remainder = count;
                for (let digitIdx = -1; ++digitIdx < digits.length;) {
                    const div = divideFactors[digitIdx];
                    sequence.push(remainder / div | 0);
                    remainder %= div;
                }
                yield sequence;
            }
        }
        /**
         *
         */
        static calculatePowerset(array) {
            const result = [[]];
            for (let i = 0; i < array.length; i++)
                for (let n = 0; n < result.length; n++)
                    result.push(result[n].concat(array[i]));
            return result;
        }
        /**
         * @returns Whether the items of the first set object form
         * a subset (not a proper subset) of the items of the second
         * set.
         */
        static isSubset(sourceSet, possibleSubset) {
            for (const item of possibleSubset)
                if (!sourceSet.has(item))
                    return false;
            return true;
        }
        /**
         * @returns Whether the items of the first set object form
         * a superset (not a proper superset) of the items of the
         * second set.
         */
        static isSuperset(sourceSet, possibleSuperset) {
            for (const item of sourceSet)
                if (!possibleSuperset.has(item))
                    return false;
            return true;
        }
        /**
         * @returns The number of items that are missing
         * from the second set that exist in the first set.
         */
        static computeSubsetFactor(a, b) {
            let count = 0;
            for (const item of a)
                count += b.includes(item) ? 0 : 1;
            return count;
        }
        /**
         * Performs a recursive reduction operation on an initial object
         * that represents some abstract node of a graph. The traversal
         * algorithm used ensures all provided nodes are only visited
         * once.
         */
        static reduceRecursive(initialObject, followFn, reduceFn) {
            const visited = new Set();
            const recurse = (object) => {
                visited.add(object);
                const reduceResult = [];
                for (const next of followFn(object))
                    if (!visited.has(next))
                        reduceResult.push(recurse(next));
                return reduceFn(object, Object.freeze(reduceResult));
            };
            return recurse(initialObject);
        }
        /**
         * @returns A proxy of the specified object, whose members
         * have been patched with the specified patch object.
         */
        static patch(source, patch) {
            const patchKeys = Object.freeze(Object.keys(patch));
            return new Proxy(source, {
                get(target, key) {
                    return patchKeys.includes(key) ?
                        patch[key] :
                        source[key];
                }
            });
        }
        /**
         * Safely parses a JSON object, silencing any thrown parse exceptions.
         */
        static tryParseJson(jsonText) {
            try {
                return JSON.parse(jsonText);
            }
            catch (e) {
                return null;
            }
        }
        constructor() { }
    }
    Truth.Misc = Misc;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * The base class of all domain objects in the system.
     * (The system is slowing being migrated so that more
     * classes make use of this feature).
     */
    class AbstractClass {
        constructor() {
            /** @internal */
            this.id = getNextClassId();
        }
    }
    Truth.AbstractClass = AbstractClass;
    let nextClassId = 0;
    /** */
    function getNextClassId() {
        return (++nextClassId) % 2 ** 32;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * The top-level object that manages Truth documents.
     */
    class Program {
        /**
         * Creates a new Program, into which Documents may
         * be added, and verified.
         */
        constructor() {
            this.memoryUriCount = 0;
            /** */
            this.queue = new Map();
            this._documents = [];
            /** @internal */
            this.causes = new Truth.MultiMap();
            /** Stores the version of this program when the last full verification occured. */
            this.lastFullVerify = null;
            /** Stores the result produced from the last full verification. */
            this.lastFullVerifyResult = true;
            /** */
            this.unverifiedStatements = [];
            /** */
            this.unverifiedDocuments = [];
            this._version = Truth.VersionStamp.next();
            this.reader = Truth.createDefaultUriReader();
            // The ordering of these instantations is relevant,
            // because it reflects the order in which each of
            // these services are going to process hooks.
            this.on(Truth.CauseDocumentCreate, data => {
                this.unverifiedDocuments.push(data.document);
            });
            this.on(Truth.CauseDocumentDelete, data => {
                const idx = this.unverifiedDocuments.indexOf(data.document);
                if (idx > -1)
                    this.unverifiedDocuments.splice(idx, 1);
            });
            this.on(Truth.CauseDocumentUriChange, () => {
                this._version = Truth.VersionStamp.next();
            });
            this.on(Truth.CauseAgentDetach, data => {
                for (const [cause, attachments] of this.causes)
                    for (const attachment of attachments)
                        if (attachment.uri && attachment.uri === data.uri)
                            this.causes.delete(cause, attachment);
            });
            this.agentCache = new Truth.AgentCache(this);
            this.graph = new Truth.HyperGraph(this);
            this.cycleDetector = new Truth.CycleDetector(this);
            this.on(Truth.CauseRevalidate, data => {
                for (let i = this.unverifiedStatements.length; i-- > 0;)
                    if (this.unverifiedStatements[i].isDisposed)
                        this.unverifiedStatements.splice(i, 1);
                for (const statement of data.parents)
                    if (!statement.isCruft)
                        this.unverifiedStatements.push(statement);
            });
            this.faults = new Truth.FaultService(this);
            this.on(Truth.CauseEditComplete, () => {
                this._version = Truth.VersionStamp.next();
            });
        }
        /**
         * Override the default UriReader used by the program.
         * This reader is used to load the contents of files that
         * are referenced within uri-containing statements within
         * Truth documents.
         */
        setReader(reader) {
            this.reader = reader;
        }
        /**
         * Adds a document to this program with the specified sourceText.
         * The URI for the document is an auto-generated, auto-incrementing
         * number.
         *
         * For example, the first document added in this way is considered
         * to have the URI "memory://memory/1.truth", the second being
         * "memory://memory/2.truth", and so on.
         */
        async addDocument(sourceText) {
            const memoryUri = Truth.KnownUri.createMemoryUri(++this.memoryUriCount);
            return await Truth.Document.new(this, memoryUri, sourceText, d => this.saveDocument(d));
        }
        /**
         * Adds a document to this program, by loading it from the specified
         * URI. In the case when there has already been a document loaded
         * from the URI specified, this pre-loaded document is returned.
         *
         * @param documentUri The URI that will represent the source
         * location of the loaded document.
         *
         * @param sourceText The source text to load into the document
         * by default. If omitted, the source text will be loaded from the
         * the URI specified in the `documentUri`  argument.
         *
         * Use this argument when the source text of the document being
         * added has already been loaded into a string by another means,
         * or when more control of the actual loaded content is required.
         */
        async addDocumentFromUri(documentUri, sourceText) {
            const uri = typeof documentUri === "string" ?
                Truth.KnownUri.fromString(documentUri) :
                documentUri;
            if (!uri)
                throw Truth.Exception.invalidUri();
            const existingDoc = this.getDocumentByUri(uri);
            if (existingDoc)
                return existingDoc;
            const promises = this.queue.get(uri);
            if (promises) {
                return new Promise(resolve => {
                    promises.push(resolve);
                });
            }
            // The problem with this design is that I don't know if the 
            // resolve function is going to be called synchronously.
            // If it is, this code structure will probably work.
            return new Promise(async (resolve) => {
                this.queue.set(uri, [resolve]);
                if (sourceText === undefined) {
                    const loadedSourceText = await (async () => {
                        const readResult = await this.reader.tryRead(uri);
                        if (readResult instanceof Error)
                            return readResult;
                        return readResult;
                    })();
                    if (loadedSourceText instanceof Error)
                        return loadedSourceText;
                    sourceText = loadedSourceText;
                }
                const docOrError = await Truth.Document.new(this, uri, sourceText, d => this.saveDocument(d));
                const resolveFns = this.queue.get(uri);
                if (resolveFns) {
                    this.queue.delete(uri);
                    for (const resolveFn of resolveFns)
                        resolveFn(docOrError);
                }
            });
        }
        /**
         * Adds the specified document to the internal list of documents.
         */
        saveDocument(doc) {
            this._documents.push(doc);
        }
        /**
         * @returns The loaded document with the specified URI.
         */
        getDocumentByUri(uri) {
            for (const doc of this._documents)
                if (doc.uri === uri)
                    return doc;
            return null;
        }
        /**
         * Gets a readonly array of truth documents
         * that have been loaded into this Program.
         */
        get documents() {
            return this._documents;
        }
        /** */
        get version() {
            return this._version;
        }
        /**
         * Probes the program and returns an array containing information
         * about the callbacks that will be triggered if a cause of the specified
         * type is broadcasted. Essentially, this method answers the question,
         * "Who is listening for Causes of type X?".
         *
         * If no agents have attached to the specified type, an empty array
         * is returned.
         */
        probe(causeType, scope = this) {
            if (scope instanceof Truth.Type)
                throw Truth.Exception.notImplemented();
            const results = [];
            const push = (ca) => results.push({ uri: ca.uri, scope: ca.scope });
            for (const [causeTypeKey, attachments] of this.causes)
                if (causeType === causeTypeKey)
                    for (const ca of attachments)
                        if (scope === ca.scope ||
                            scope instanceof Program && ca.scope instanceof Truth.Document)
                            push(ca);
            return results;
        }
        /**
         *
         */
        on(causeType, fn, scope) {
            const info = getHolderInfo(this);
            const usingScope = scope || info.scope || this;
            const ca = new CauseAttachment(info.uri, fn, usingScope);
            this.causes.add(causeType, ca);
        }
        /**
         * Progates the specified Cause object to all subscribers that
         * are listening for causes of object's type.
         *
         * @param cause A reference to the Cause instance to broadcast.
         *
         * @param filter An optional array of Uri instances that
         * specify the origin from where an agent that is attached
         * to the cause must loaded in order to be delivered the
         * cause instance.
         *
         * @returns An object that stores information about the
         * cause results that were returned, and the URI of the
         * agent that produced the result. In the case when the
         * agent was attached programmatically, the URI value
         * will be null.
         */
        cause(cause, ...filters) {
            const causeType = cause.constructor;
            const attachmentsAll = this.causes.get(causeType) || [];
            const attachments = attachmentsAll.filter(attachment => {
                if (filters.length === 0)
                    return true;
                const otherUri = attachment.uri;
                if (otherUri === null)
                    return true;
                return filters.find(uri => uri === otherUri);
            });
            if (attachments.length === 0)
                return [];
            const result = [];
            for (const attachment of attachments) {
                const returned = attachment.callback(cause);
                if (returned !== null && returned !== undefined)
                    result.push({ from: attachment.uri, returned });
            }
            return result;
        }
        /**
         * Augments the global scope of the agents attached to this
         * program with a variable whose name and value are specified
         * in the arguments to this method. (Note that this only affects
         * agents that are attached *after* this call has been made.)
         */
        augment(name, value) {
            this.agentCache.augment(name, value);
        }
        /**
         *
         */
        attach(agentUri) {
            return new Promise(() => {
                throw Truth.Exception.notImplemented();
            });
        }
        /**
         *
         */
        detach(agentUri) {
            throw Truth.Exception.notImplemented();
        }
        query(document, ...typePath) {
            if (arguments.length > 1 && typePath.length === 0)
                throw Truth.Exception.passedArrayCannotBeEmpty("typePath");
            if (typePath.length === 0)
                return Truth.Type.constructRoots(document);
            const phrase = document.phrase.forwardDeep(typePath);
            return Truth.Type.construct(phrase);
        }
        /**
         * Begin inspecting a document loaded
         * into this program, a specific location.
         */
        inspect(document, line, offset) {
            const statement = document.read(line);
            const zone = statement.getZone(offset);
            const position = {
                line,
                offset
            };
            switch (zone) {
                case Truth.StatementZone.void:
                    return new Truth.ProgramInspectionResult(position, zone, null, statement);
                // Return all the types in the declaration side of the parent.
                case Truth.StatementZone.whitespace:
                    {
                        const parent = document.getParentFromPosition(line, offset);
                        if (parent instanceof Truth.Document)
                            return new Truth.ProgramInspectionResult(position, zone, parent, statement);
                        const types = parent.declarations
                            .map(decl => decl.factor())
                            .reduce((spines, s) => spines.concat(s), [])
                            .map(spine => Truth.Type.construct(spine))
                            .filter((type) => !!type);
                        return new Truth.ProgramInspectionResult(position, zone, types, statement, null);
                    }
                //
                case Truth.StatementZone.pattern:
                    {
                        // TODO: This should not be returning a PatternLiteral,
                        // but rather a fully constructed IPattern object. This
                        // code is only here as a shim.
                        const patternTypes = [];
                        return new Truth.ProgramInspectionResult(position, zone, patternTypes, statement);
                    }
                // Return all the types related to the specified declaration.
                case Truth.StatementZone.declaration:
                    {
                        const decl = statement.getDeclaration(offset);
                        if (!decl)
                            throw Truth.Exception.unknownState();
                        const types = decl
                            .factor()
                            .map(spine => Truth.Type.construct(spine))
                            .filter((type) => !!type);
                        return new Truth.ProgramInspectionResult(position, zone, types, statement, decl);
                    }
                // 
                case Truth.StatementZone.annotation:
                    {
                        const anno = statement.getAnnotation(offset);
                        if (!anno)
                            throw Truth.Exception.unknownState();
                        const spine = statement.declarations[0].factor()[0];
                        let base = null;
                        const type = Truth.Type.construct(spine);
                        if (type) {
                            const annoText = anno.boundary.subject.toString();
                            base = type.bases.filter(b => b.name === annoText);
                            base.push(type);
                        }
                        return new Truth.ProgramInspectionResult(position, zone, base, statement, anno);
                    }
                case Truth.StatementZone.annotationVoid:
                    {
                        const anno = statement.getAnnotation(offset);
                        const spine = statement.declarations[0].factor()[0];
                        const type = Truth.Type.construct(spine);
                        const foundObject = type ? [type] : null;
                        return new Truth.ProgramInspectionResult(position, zone, foundObject, statement, anno);
                    }
            }
            return new Truth.ProgramInspectionResult(position, zone, null, statement, null);
        }
        /**
         * Performs a full verification of all documents loaded into the program.
         * This Program's .faults field is populated with any faults generated as
         * a result of the verification. If no documents loaded into this program
         * has been edited since the last verification, verification is not re-attempted.
         *
         * @returns A boolean value that indicates whether the verification passed.
         */
        verify() {
            if (this.lastFullVerify && !this.version.newerThan(this.lastFullVerify))
                return this.lastFullVerifyResult;
            for (const doc of this.documents)
                for (const { statement } of doc.eachDescendant())
                    this.verifyAssociatedDeclarations(statement);
            this.lastFullVerify = this.version;
            return this.lastFullVerifyResult = this.finalizeVerification();
        }
        /**
         * Performs verification on the parts of the document that have
         * not been verified since the last call to this method. Once this
         * method has completed, any detected faults will be available
         * by using the methods located in the `.faults` property of this
         * instance.
         *
         * @returns A boolean value that indicates whether verification
         * completed without detecting any faults in this Program.
         */
        reverify() {
            for (const doc of this.unverifiedDocuments)
                for (const { statement } of doc.eachDescendant())
                    this.verifyAssociatedDeclarations(statement);
            for (const smt of this.unverifiedStatements)
                this.verifyAssociatedDeclarations(smt);
            return this.finalizeVerification();
        }
        /** */
        verifyAssociatedDeclarations(statement) {
            if (!statement.isDisposed)
                for (const decl of statement.declarations)
                    decl.factor().map(spine => Truth.Type.construct(spine));
        }
        /** */
        finalizeVerification() {
            this.faults.refresh();
            this.unverifiedDocuments.length = 0;
            this.unverifiedStatements.length = 0;
            return this.faults.count === 0;
        }
    }
    Truth.Program = Program;
    /**
     * Gets information about the object that holds
     * the specified Program instance.
     */
    function getHolderInfo(program) {
        const ih = program.instanceHolder;
        return {
            uri: ih ? ih.uri : null,
            scope: (ih ? ih.scope : program)
        };
    }
    /**
     * @internal
     * Stores information about the attachment
     * of a cause callback function.
     */
    class CauseAttachment {
        /** */
        constructor(uri, callback, scope) {
            this.uri = uri;
            this.callback = callback;
            this.scope = scope;
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Stores the details about a precise location in a Document.
     */
    class ProgramInspectionResult {
        /** @internal */
        constructor(
        /**
         * Stores the location of the inspection point within a Document.
         */
        position, 
        /**
         * Stores the zone of the statement found at the specified location.
         */
        zone, 
        /**
         * Stores the compilation object that most closely represents
         * what was found at the specified location. Stores null in the
         * case when the specified location contains an object that
         * has been marked as cruft (the statement and span fields
         * are still populated in this case).
         */
        foundObject, 
        /**
         * Stores the Statement found at the specified location.
         */
        statement, 
        /**
         * Stores the Span found at the specified location, or
         * null in the case when no Span was found, such as if
         * the specified location is whitespace or a comment.
         */
        span = null) {
            this.position = position;
            this.zone = zone;
            this.foundObject = foundObject;
            this.statement = statement;
            this.span = span;
            if (Array.isArray(foundObject) && foundObject.length === 0)
                this.foundObject = null;
        }
    }
    Truth.ProgramInspectionResult = ProgramInspectionResult;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A cache that stores agent build function loaded by a single program instance.
     */
    class AgentCache {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.agentFunctionParameters = new Map();
            /**
             * Stores the number of lines that are introduced by the script
             * engine when a code block is wrapped in a new Function()
             * block, which is then toString()'d. This is used in order to calculate
             * source map line offsets (which varies by engine).
             */
            this.sourceMapLineOffset = (() => {
                // eslint-disable-next-line no-new-func
                const testFn = new Function("a", "b", "c", ";");
                const lineCount = testFn.toString().split("\n").length;
                return lineCount - 2;
            })();
            /**
             * Stores a map whose keys are agent URIs, and whose values
             * are a set of Statement instances that reference the agent,
             * or, in the case when the agent is added to the program
             * through another means (such as programmatically),
             * a reference to the program is stored instead.
             *
             * Technically an agent should be attached in only one place
             * in the program, however, this may not always be the case,
             * and the system needs to be able to handle the case when
             * it isn't.
             *
             * This array is used to reference count / garbage collect
             * the attached agents.
             */
            this.cache = new Map();
            /*
            program.on(CauseUriReferenceAdd, data =>
            {
                if (data.uri.ext === UriExtension.js)
                    this.attachAgent(data.uri, data.statement);
            });
            
            program.on(CauseUriReferenceRemove, data =>
            {
                if (data.uri.ext === UriExtension.js)
                    this.detachAgent(data.uri, data.statement);
            });
            */
        }
        /** * /
        private async attachAgent(uri: KnownUri, statement: Statement | null)
        {
            const existingCacheSet = this.cache.get(uri);
            const reference = statement || this.program;
            
            if (existingCacheSet)
            {
                existingCacheSet.add(reference);
                return;
            }
            
            const scope = statement instanceof Statement ?
                statement.document :
                this.program;
            
            const sourceRaw = await UriReader.tryRead(uri);
            if (sourceRaw instanceof Error)
                return sourceRaw;
            
            const source = this.maybeAdjustSourceMap(uri, sourceRaw);
            const patchedProgram = Misc.patch(this.program, {
                instanceHolder: { uri, scope }
            });
            
            const params = [
                "program",
                "Truth",
                "require",
                ...this.agentFunctionParameters.keys(),
                source
            ];
            
            const args = [
                patchedProgram,
                Truth,
                AgentCache.hijackedRequireFn,
                ...this.agentFunctionParameters.values()
            ];
            
            try
            {
                const fn = Object.freeze(Function.apply(Function, params));
                await fn.apply(fn, args as any);
            }
            catch (e)
            {
                this.reportUserLandError(e);
                return;
            }
            
            this.program.cause(new CauseAgentAttach(uri, scope));
            const set = new Set<Statement | Program>([reference]);
            this.cache.set(uri, set);
        }
        
        /** * /
        private detachAgent(uri: KnownUri, statement: Statement | null)
        {
            const existingCacheSet = this.cache.get(uri);
            if (!existingCacheSet)
                return;
            
            existingCacheSet.delete(statement || this.program);
            if (existingCacheSet.size === 0)
            {
                this.cache.delete(uri);
                this.program.cause(new CauseAgentDetach(uri));
            }
        }
        
        /**
         * @internal
         * (Called by Program)
         */
        augment(name, value) {
            if (this.agentFunctionParameters.has(name))
                throw Truth.Exception.causeParameterNameInUse(name);
            this.agentFunctionParameters.set(name, value);
        }
        /**
         * Adjusts the content of the sourcemap in the specified source code
         * file, to account for the discrepencies introduced by wrapping JavaScript
         * source code in a new Function() constructor.
         */
        maybeAdjustSourceMap(sourceUri, sourceCode) {
            // We can't do any of this source map mutation without Node.JS
            // access right now. Maybe this will change in the future.
            if (typeof require !== "function")
                return sourceCode;
            const lastLineStart = (() => {
                for (let i = sourceCode.length; i-- > 1;)
                    if (sourceCode[i - 1] === "\n")
                        return i;
                return -1;
            })();
            if (lastLineStart < 0)
                return sourceCode;
            const sourceMapUrl = ["//", "#", " source", "MappingURL="].join("");
            if (sourceCode.substr(lastLineStart, sourceMapUrl.length) !== sourceMapUrl)
                return sourceCode;
            const startPos = lastLineStart + sourceMapUrl.length;
            const ending = ";base64,";
            const endPos = sourceCode.indexOf(ending, startPos) + ending.length;
            // Unsupported source map format.
            if (endPos < ending.length)
                return sourceCode;
            const sourceMapRaw = this.fromBase64(sourceCode.slice(endPos));
            // There's probably some error in the source map
            if (!sourceMapRaw)
                return sourceCode;
            // The source map isn't parsing as a JSON object ... probably broken somehow
            const sourceMap = Truth.Misc.tryParseJson(sourceMapRaw);
            if (!sourceMap)
                return sourceCode;
            // Unsupported source map version
            if (typeof sourceMap.mappings !== "string")
                return sourceCode;
            // Placing a ; in the "mappings" property of the source map object
            // shifts the lines down by 1. It needs to be + 1, because we wrap
            // the code in our own setTimeout() block.
            const prefix = ";".repeat(this.sourceMapLineOffset + 1);
            const pathModule = require("path");
            // Should actually be .toString() without a file.
            debugger;
            const basePath = sourceUri.toString();
            sourceMap.mappings = prefix + sourceMap.mappings;
            if (sourceMap.sources instanceof Array)
                sourceMap.sources = sourceMap.sources.map(s => pathModule.join(basePath, s));
            const newSourceMap = this.toBase64(JSON.stringify(sourceMap));
            const newSourceCode = sourceCode.slice(0, lastLineStart);
            // The source code is wrapped in a setTimeout in order
            // to give any attached debuggers a chance to connect.
            const varName = "$$__RESOLVE_FUNCTION__$$";
            const newSourceCodeDelayed = `return new Promise(${varName} => setTimeout(() => {\n` +
                newSourceCode +
                `; ${varName}(); }, 1))\n`;
            const newPrefix = sourceCode.slice(lastLineStart, endPos);
            return newSourceCodeDelayed + newPrefix + newSourceMap;
        }
        /** */
        reportUserLandError(e) {
            // NOTE: This should probably be reporting the error
            // somewhere where it's visible.
            debugger;
            throw e;
        }
        /** */
        toBase64(plain) {
            return typeof btoa === "function" ?
                btoa(plain) :
                Buffer.from(plain, "ascii").toString("base64");
        }
        /** */
        fromBase64(encoded) {
            return typeof atob === "function" ?
                atob(encoded) :
                Buffer.from(encoded, "base64").toString("ascii");
        }
    }
    /**
     * The require() function is not available within the context of an
     * agent for numerous (and non-obvious) reasons. This function
     * is fed into all agent functions to prevent any otherwise available
     * require() function from being accessed.
     */
    AgentCache.hijackedRequireFn = Object.freeze((specifier) => {
        throw new Error("The require() function is not available in this context. " +
            "Multi-file agents should be bundled with a bundler " +
            "such as RollupJS.");
    });
    Truth.AgentCache = AgentCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Abstract base class for all Causes defined both within
     * the compiler core, and in user code.
     */
    class Cause {
        constructor() {
            /**
             * Stores the return type of the Cause, if any. In a cause callback function,
             * this property exists as an array of objects that have been returned
             * from other cause aids.
             */
            this.returns = null;
        }
    }
    Truth.Cause = Cause;
    // 
    // Causes
    // 
    /** */
    class CauseAgentAttach extends Cause {
        constructor(
        /**
         * Stores the URI from where the agent was loaded.
         */
        uri, 
        /**
         * Stores an object that represents the scope of where the agent
         * applies.
         *
         * If the value is `instanceof Program`, this indicates that
         * the agent's causes are scoped to a particular program (which
         * is effectively "unscoped").
         *
         * If the value is `instanceof Document`, this indicates that
         * the agent's causes are scoped to the causes that can
         * originate from a single document.
         *
         * (Not implemented). If the value is `instanceof Type`, this
         * indicates that the agent's causes are scoped to the causes
         * that can originate from a single type.
         */
        scope) {
            super();
            this.uri = uri;
            this.scope = scope;
        }
    }
    Truth.CauseAgentAttach = CauseAgentAttach;
    /** */
    class CauseAgentDetach extends Cause {
        constructor(uri) {
            super();
            this.uri = uri;
        }
    }
    Truth.CauseAgentDetach = CauseAgentDetach;
    /** A cause that runs immediately after a document has been created. */
    class CauseDocumentCreate extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseDocumentCreate = CauseDocumentCreate;
    /** A cause that runs immediately before a document is removed from the program. */
    class CauseDocumentDelete extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseDocumentDelete = CauseDocumentDelete;
    /** A cause that runs when a document's file name changes. */
    class CauseDocumentUriChange extends Cause {
        constructor(document, newUri) {
            super();
            this.document = document;
            this.newUri = newUri;
        }
    }
    Truth.CauseDocumentUriChange = CauseDocumentUriChange;
    /** Abstract cause class for the resolution causes */
    class CauseResolve extends Cause {
        constructor(program, spine) {
            super();
            this.program = program;
            this.spine = spine;
        }
    }
    Truth.CauseResolve = CauseResolve;
    /** A cause that runs before the compiler is about to resolve a term. */
    class CauseBeforeResolve extends CauseResolve {
    }
    Truth.CauseBeforeResolve = CauseBeforeResolve;
    /** A cause that runs after the compiler has resolved a term. */
    class CauseAfterResolve extends CauseResolve {
    }
    Truth.CauseAfterResolve = CauseAfterResolve;
    /** A cause that runs when the compiler is unable to resolve a term. */
    class CauseNotResolved extends CauseResolve {
    }
    Truth.CauseNotResolved = CauseNotResolved;
    /** */
    class CauseInvalidate extends Cause {
        constructor(
        /**
         * A reference to the Document object in which the Invalidation occured.
         */
        document, 
        /**
         * An array of statements whose descendants should be invalidated.
         * If the array is empty, the entire document should be invalidated.
         */
        parents, 
        /**
         * An array of indexes whose length is the same as the parents field,
         * that represents the index of each parent within the document.
         */
        indexes) {
            super();
            this.document = document;
            this.parents = parents;
            this.indexes = indexes;
        }
    }
    Truth.CauseInvalidate = CauseInvalidate;
    /** */
    class CauseRevalidate extends Cause {
        constructor(
        /**
         * A reference to the Document object in which the Revalidation will occur.
         */
        document, 
        /**
         * An array of statements whose descendants should be revalidated.
         */
        parents, 
        /**
         * An array of indexes whose length is the same as the parents field,
         * that represents the index of each parent within the document.
         */
        indexes) {
            super();
            this.document = document;
            this.parents = parents;
            this.indexes = indexes;
        }
    }
    Truth.CauseRevalidate = CauseRevalidate;
    /** A cause that runs when a document edit transaction has completed. */
    class CauseEditComplete extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseEditComplete = CauseEditComplete;
    /**
     * A hook that runs when the set of faults that are detected
     * within the document have changed.
     */
    class CauseFaultChange extends Cause {
        constructor(faultsAdded, faultsRemoved) {
            super();
            this.faultsAdded = faultsAdded;
            this.faultsRemoved = faultsRemoved;
        }
    }
    Truth.CauseFaultChange = CauseFaultChange;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** @internal */
    class Exception {
        /** */
        static objectDirty() {
            return error(`
				Cannot call this method or access this property,
				because the document has changed since it
				was created.`);
        }
        /** */
        static invalidArgument() {
            return error("Invalid argument.");
        }
        /** */
        static passedArrayCannotBeEmpty(paramName) {
            return error("Array cannot be empty for parameter: " + paramName);
        }
        /** */
        static unknownState() {
            return error("An unknown state has been reached in the program.");
        }
        /** */
        static invalidCall() {
            return error("Cannot call this method given the current state of the program.");
        }
        /** */
        static notImplemented() {
            return error("Not implemented.");
        }
        /** */
        static agentNotRead() {
            return error(`
				Cannot instantiate an agent of this type,
				added. See agents.add.`);
        }
        /** */
        static agentMissing(rawUri) {
            return error(`Could not load an agent from the URI ${rawUri}`);
        }
        /** */
        static agentImportError(agentUri, errorText) {
            return error(`
				An error occured while trying to evaluate the agent at "${agentUri}".
				The error message returned was: ${errorText}`);
        }
        /** */
        static agentInvalid(rawUri) {
            return error(`
				The code file at ${rawUri} does not export a function. Consider looking
				at the documention and examples for the proper way to stucture an
				agent code file.`);
        }
        /** */
        static noRemoteAgents() {
            return error(`
				Agents cannot be loaded from remote URIs in this context.
				(Most likely, this code is running in Node.js where the loading
				of remote code is a security risk).`);
        }
        /** */
        static causeParameterNameInUse(paramName) {
            return error(`
				Cannot use the name "${paramName}" as a parameter
				name because it's already in use.`);
        }
        /** */
        static doubleTransaction() {
            return error("Cannot start a new transaction while another is executing.");
        }
        /** */
        static invalidUriRetraction() {
            return error("URI contains too few path segments to perform this retraction.");
        }
        /** */
        static invalidUri(rawUri) {
            return error("Invalid URI" + (typeof rawUri === "string" ? ": " + rawUri : ""));
        }
        /** */
        static uriNotSupported() {
            return error("URIs of this type are not supported.");
        }
        /** */
        static cannotMakeAbsolute() {
            return error(`
				Cannot make this URI absolute because no 
				process or window object could be found`);
        }
        /** */
        static absoluteUriExpected() {
            return error(`This method expects an absolute URI to be specified.`);
        }
        /** */
        static mustSpecifyVia() {
            return error(`
				Must specify the "via" argument because the parsed URI 
				was found to be relative`);
        }
        /** */
        static viaCannotBeRelative() {
            return error(`URI instances specified in the "via" argument must not be relative`);
        }
        /** */
        static invalidTypePath() {
            return error(`
				One or more of the types in the specified type path are invalid,
				because they contain either leading or trailing whitespace, or
				is an empty string.`);
        }
        /** */
        static invalidExtension(requiredExtension) {
            return error(`
				This method requires URIs that have the 
				".${requiredExtension}" extension.`);
        }
        /** */
        static invalidDocumentReference() {
            return error(`
				This document cannot be added as a dependency
				of the target document because it's storage location
				(memory or disk) differs from the that of the target.`);
        }
        /** */
        static uriAlreadyExists() {
            return error(`
				Cannot assign this URI to this document, because
				another document is already loaded in the program
				with the Uri specified.`);
        }
        /** */
        static uriProtocolsMustMatch() {
            return error(`
				Cannot assign this URI to this document, because
				it's protocol differs from the URI current assigned 
				to this document`);
        }
        /** */
        static nonEmptyDocument() {
            return error("Cannot call this method on a non-empty document.");
        }
        /** */
        static invalidWhileInEditTransaction() {
            return error(`Cannot call this method, or run this hook while an edit
				transaction is underway.`);
        }
        /** */
        static uncachableDocument() {
            return error(`
				Cannot cache this document because it was not loaded from a file.`);
        }
        /** */
        static documentAlreadyLoaded() {
            return error(`
				A document with this URI has already been created.
				Use Document.fromUri() instead.`);
        }
        /** */
        static documentNotLoaded() {
            return error("This document has not been loaded into the current program.");
        }
        /** */
        static statementNotInDocument() {
            return error("The specified statement does not exist within this document.");
        }
        /** */
        static cannotRefresh() {
            return error(`
				This resource cannot be reloaded because it only exists in memory.`);
        }
        /** */
        static offsetRequired() {
            return error(`
				Offset argument is required because the a whitespace-only
				statement was passed.`);
        }
        /** */
        static unsupportedPlatform() {
            return error("This code appears to be operating in an unsupported platform.");
        }
    }
    Truth.Exception = Exception;
    /**
     * Generates a proper error object from the specified message.
     */
    function error(msg) {
        return new Error(msg.trim().replace(/\s\s+/g, " "));
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * An enumeration that lists all availble protocols
     * supported by the system. The list can be enumerated
     * via Uri.eachProtocol()
     */
    let UriProtocol;
    (function (UriProtocol) {
        UriProtocol["none"] = "";
        UriProtocol["unknown"] = "?";
        UriProtocol["file"] = "file:";
        UriProtocol["https"] = "https:";
        UriProtocol["http"] = "http:";
        /**
         * @internal
         * Internal URIs (which are URIs that refer to an in-memory document)
         * are sourced from the gopher protocol. Yes, the gopher protocol. This
         * is because it's the only protocol that will parse through the standard
         * URL constructor in V8, other than the standard protocols (http, https).
         * (Other JavaScript engines seem to parse all protocols, even made-up
         * ones).
         */
        UriProtocol["memory"] = "memory:";
    })(UriProtocol = Truth.UriProtocol || (Truth.UriProtocol = {}));
    (function (UriProtocol) {
        /**
         * @returns A UriProtocol member from the specified string.
         */
        function resolve(value) {
            const vals = Object.values(UriProtocol);
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        UriProtocol.resolve = resolve;
    })(UriProtocol = Truth.UriProtocol || (Truth.UriProtocol = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** @internal */
    function createDefaultUriReader() {
        return {
            tryRead: async (uri) => {
                const uriText = uri.toString();
                if (uri.protocol === Truth.UriProtocol.file)
                    return await readFileUri(uriText);
                else if (uri.protocol === Truth.UriProtocol.http ||
                    uri.protocol === Truth.UriProtocol.https)
                    return await readWebUri(uriText);
                throw Truth.Exception.notImplemented();
            }
        };
    }
    Truth.createDefaultUriReader = createDefaultUriReader;
    /** */
    async function readFileUri(path, opts = "utf8") {
        return new Promise(resolve => {
            path = decodeURI(path);
            Truth.Fs.module.readFile(path, opts, (error, data) => {
                resolve(error && error.errno ?
                    error :
                    data || "");
            });
        });
    }
    /** */
    async function readWebUri(url) {
        if (typeof fetch === "function") {
            try {
                const response = await fetch(url);
                if (response.status === 200)
                    return response.text();
                return new FetchError(response.status, response.statusText);
            }
            catch (e) {
                return new Error("Unknown error.");
            }
        }
        else if (typeof require === "function") {
            const getFn = url.startsWith("https:") ? require("https").get :
                url.startsWith("http:") ? require("http").get :
                    null;
            if (getFn === null)
                throw Truth.Exception.invalidUri(url);
            return await new Promise(resolve => {
                getFn(url, response => {
                    const data = [];
                    response.on("data", chunk => {
                        data.push(typeof chunk === "string" ?
                            chunk :
                            chunk.toString("utf8"));
                    });
                    response.on("error", error => {
                        resolve(error);
                    });
                    response.on("end", () => {
                        resolve(data.join(""));
                    });
                });
                return "";
            });
        }
        throw Truth.Exception.unsupportedPlatform();
    }
    /**
     *
     */
    class FetchError extends Error {
        constructor(statusCode, statusText) {
            super();
            this.statusCode = statusCode;
            this.statusText = statusText;
        }
    }
    Truth.FetchError = FetchError;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * An enumeration that stores the escape sequences
     * that only match a single kind of character. "Sign" in
     * this case refers to the fact that these are escape
     * sequences that refer to another character.
     */
    let RegexSyntaxSign;
    (function (RegexSyntaxSign) {
        RegexSyntaxSign["tab"] = "\\t";
        RegexSyntaxSign["lineFeed"] = "\\n";
        RegexSyntaxSign["carriageReturn"] = "\\r";
        RegexSyntaxSign["escapedFinalizer"] = "\\/";
        RegexSyntaxSign["backslash"] = "\\\\";
    })(RegexSyntaxSign = Truth.RegexSyntaxSign || (Truth.RegexSyntaxSign = {}));
    /** */
    (function (RegexSyntaxSign) {
        /**
         * @returns A RegexSyntaxSign member from the
         * specified sign literal (ex: "\t") or raw signable
         * character (ex: "	").
         */
        function resolve(value) {
            if (value.length < 1 || value.length > 2)
                return null;
            const vals = Object.values(RegexSyntaxSign);
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        RegexSyntaxSign.resolve = resolve;
        /** */
        function unescape(value) {
            switch (value) {
                case RegexSyntaxSign.tab: return String.fromCodePoint(9);
                case RegexSyntaxSign.lineFeed: return String.fromCodePoint(10);
                case RegexSyntaxSign.carriageReturn: return String.fromCodePoint(13);
                case RegexSyntaxSign.escapedFinalizer: return String.fromCodePoint(47);
                case RegexSyntaxSign.backslash: return String.fromCodePoint(92);
            }
            return "";
        }
        RegexSyntaxSign.unescape = unescape;
    })(RegexSyntaxSign = Truth.RegexSyntaxSign || (Truth.RegexSyntaxSign = {}));
    /**
     * An enumeration that stores the escape sequences
     * that can match more than one kind of character.
     */
    let RegexSyntaxKnownSet;
    (function (RegexSyntaxKnownSet) {
        RegexSyntaxKnownSet["digit"] = "\\d";
        RegexSyntaxKnownSet["digitNon"] = "\\D";
        RegexSyntaxKnownSet["alphanumeric"] = "\\w";
        RegexSyntaxKnownSet["alphanumericNon"] = "\\W";
        RegexSyntaxKnownSet["whitespace"] = "\\s";
        RegexSyntaxKnownSet["whitespaceNon"] = "\\S";
        RegexSyntaxKnownSet["wild"] = ".";
    })(RegexSyntaxKnownSet = Truth.RegexSyntaxKnownSet || (Truth.RegexSyntaxKnownSet = {}));
    /** */
    (function (RegexSyntaxKnownSet) {
        const vals = Object.values(RegexSyntaxKnownSet);
        function resolve(value) {
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        RegexSyntaxKnownSet.resolve = resolve;
    })(RegexSyntaxKnownSet = Truth.RegexSyntaxKnownSet || (Truth.RegexSyntaxKnownSet = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages the diagnostics that have been
     * reported for the current state of the program.
     */
    class FaultService {
        constructor(program) {
            // Listen for invalidations and clear out any faults
            // that correspond to objects that don't exist in the
            // document anymore. 
            this.program = program;
            /** */
            this.inEditTransaction = false;
            this.manualRefreshQueued = false;
            /**
             * Stores faults that are exposed to the outside when the
             * FaultService's accessor methods are used. These faults are
             * reported within an edit transaction, and clear automatically
             * when the Statement or Span to which they are connected is
             * disposed.
             */
            this.foregroundAutoFrame = new FaultFrame();
            /**
             * Stores a buffer of the faults that will eventually be exposed to the
             * outside. These faults clear automatically when the Statement or
             * Span to which they are connected is disposed.
             */
            this.backgroundAutoFrame = new FaultFrame();
            /**
             * Stores faults that are exposed to the outside when the
             * FaultService's accessor methods are used.
             */
            this.foregroundManualFrame = new FaultFrame();
            /**
             * Stores a buffer of the faults that will eventually be exposed to the
             * outside, after being copied to the foregroundManualFrame.
             * These faults are reported outside of an edit transacrtion, and must
             * be cleared manually (via reportManual).
             */
            this.backgroundManualFrame = new FaultFrame();
            program.on(Truth.CauseInvalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        for (const { statement } of smt.document.eachDescendant(smt, true))
                            this.removeStatementFaults(statement);
                }
                else
                    for (const { statement } of data.document.eachDescendant())
                        this.removeStatementFaults(statement);
                this.inEditTransaction = true;
            });
            program.on(Truth.CauseEditComplete, () => {
                this.inEditTransaction = false;
                this.refresh();
            });
        }
        /**
         * Removes all faults associated with the specified statement.
         */
        removeStatementFaults(statement) {
            this.backgroundManualFrame.removeSource(statement);
            this.backgroundAutoFrame.removeSource(statement);
            for (const span of statement.allSpans)
                this.backgroundAutoFrame.removeSource(span);
            for (const infixSpan of statement.infixSpans)
                this.backgroundAutoFrame.removeSource(infixSpan);
        }
        /**
         * Returns an array that contains all faults retained by this FaultService,
         * sorted in the order that they exist in the program, optionally filtered
         * by the document specified.
         */
        each(document) {
            let faults = [
                ...this.foregroundAutoFrame.faults.values(),
                ...this.foregroundManualFrame.faults.values()
            ]
                .map(faultMap => [...faultMap.values()])
                .reduce((a, b) => a.concat(b), []);
            if (document)
                faults = faults.filter(v => v.document === document);
            return faults.sort(this.compareFaults);
        }
        /**
         * @internal
         * Compares two fault instances, and returns a number that is suitable
         * as a return value for the callback function passed to JavaScript's
         * Array.sort() method.
         *
         * Returns 0 in the case when the faults appear to be equivalent.
         */
        compareFaults(a, b) {
            if (a.document !== b.document)
                return a.document.uri.toString() < b.document.uri.toString() ? -1 : 1;
            if (a.line !== b.line)
                return a.line - b.line;
            // When the faults exist on the same line, the ordering is based on 
            // the starting offset of the reported fault's range. This should cause
            // Statement faults to always be ordered before Span and InfixSpan
            // faults.
            const offsetDelta = a.range[0] - b.range[0];
            if (offsetDelta !== 0)
                return offsetDelta;
            // If there are multiple faults reported on the same span, the ordering
            // is based on the internal fault code. If the faults are the same, 0 is
            // returned, and the faults are considered to be equivalent.
            return a.type.code - b.type.code;
        }
        /**
         * Gets a number representing the number of
         * unrectified faults retained by this FaultService.
         */
        get count() {
            return this.foregroundAutoFrame.faults.size +
                this.foregroundManualFrame.faults.size;
        }
        /**
         * Reports a fault. If a similar Fault on the same area
         * of the document hasn't been reported, the method
         * runs the FaultReported hook.
         */
        report(fault) {
            this.backgroundAutoFrame.addFault(fault);
        }
        /**
         * Reports a fault outside the context of an edit transaction.
         * This method is to be used for faults that are reported in
         * asynchronous callbacks, such as network errors.
         */
        reportManual(fault) {
            this.backgroundManualFrame.addFault(fault);
            this.maybeQueueManualRefresh();
        }
        /**
         * Clears a fault that was previously reported outside
         * of an edit transaction.
         */
        resolveManual(fault) {
            this.backgroundManualFrame.removeFault(fault);
            this.maybeQueueManualRefresh();
        }
        /**
         * Queues the copying of the background fault buffer to the
         * foreground.
         */
        maybeQueueManualRefresh() {
            if (this.manualRefreshQueued)
                return;
            this.manualRefreshQueued = true;
            setTimeout(() => {
                this.manualRefreshQueued = false;
                if (!this.inEditTransaction)
                    this.refresh();
            }, 0);
        }
        /**
         * @returns An array of Fault objects that have been reported
         * at the specified source. If the source has no faults, an empty
         * array is returned.
         */
        inspect(source) {
            const out = [];
            for (const retainedFault of this.each())
                if (retainedFault.source === source)
                    out.push(retainedFault);
            return out;
        }
        /**
         * @returns An array of Fault objects that have been reported that
         * correspond to the specified Statement, or any Span or InfixSpan
         * objects contained within it.
         */
        inspectDeep(source) {
            const out = [];
            for (const retainedFault of this.each()) {
                const reSource = retainedFault.source;
                if (reSource === source)
                    out.push(retainedFault);
                else if (reSource instanceof Truth.Span || reSource instanceof Truth.InfixSpan)
                    if (reSource.statement === source)
                        out.push(retainedFault);
            }
            return out;
        }
        /**
         * @internal
         * Used internally to inform the FaultService that type-level fault
         * analysis is being done on the provided Node. This is necessary
         * because type-level faults do not live beyond a single edit frame,
         * so the FaultService needs to know which Nodes were analyzed
         * so that newly rectified faults can be cleared out.
         *
         * When this method is called, any faults corresponding to the
         * specified Node are cleared out, and are only added back in if
         * they were re-detected during this edit transaction.
         */
        inform(node) {
            const smts = node.statements.filter(smt => !smt.isDisposed);
            // Clear out any statement-level faults that touch the node
            for (const smt of smts)
                this.backgroundAutoFrame.removeSource(smt);
            // Clear out any span-level faults that touch the node
            const spans = smts
                .map(smt => smt.spans)
                .reduce((a, b) => a.concat(b), []);
            for (const span of spans)
                this.backgroundAutoFrame.removeSource(span);
            // Clear out any infix-level faults that touch the node
            const infixes = smts
                .map(smt => smt.infixSpans || [])
                .reduce((a, b) => a.concat(b), []);
            for (const infix of infixes)
                this.backgroundAutoFrame.removeSource(infix);
        }
        /**
         * @internal
         * Broadcasts any not-yet-reported faults to the FaultService.
         */
        refresh() {
            const [autoAdded, autoRemoved] = this.refreshFrameSet(this.backgroundAutoFrame, this.foregroundAutoFrame);
            const [manualAdded, manualRemoved] = this.refreshFrameSet(this.backgroundManualFrame, this.foregroundManualFrame);
            const autoChanged = autoAdded.length + autoRemoved.length > 0;
            if (autoChanged) {
                this.foregroundAutoFrame = this.backgroundAutoFrame;
                this.backgroundAutoFrame = this.backgroundAutoFrame.clone();
            }
            const manualChanged = manualAdded.length + manualRemoved.length > 0;
            if (manualChanged) {
                this.foregroundManualFrame = this.backgroundManualFrame;
                this.backgroundManualFrame = this.backgroundManualFrame.clone();
            }
            if (autoChanged || manualChanged)
                this.program.cause(new Truth.CauseFaultChange(autoAdded.concat(manualAdded), autoRemoved.concat(manualRemoved)));
        }
        /** */
        refreshFrameSet(bgFrame, fgFrame) {
            const faultsAdded = [];
            const faultsRemoved = [];
            for (const map of bgFrame.faults.values())
                for (const fault of map.values())
                    if (!fgFrame.hasFault(fault))
                        faultsAdded.push(fault);
            for (const map of fgFrame.faults.values())
                for (const fault of map.values())
                    if (!bgFrame.hasFault(fault))
                        faultsRemoved.push(fault);
            return [faultsAdded, faultsRemoved];
        }
    }
    Truth.FaultService = FaultService;
    /**
     * Stores a buffer of faults.
     */
    class FaultFrame {
        constructor() {
            /**
             * A doubly-nested map of fault sources, fault codes, and the actual fault.
             */
            this.faults = new Map();
        }
        /** */
        clone() {
            const newFrame = new FaultFrame();
            for (const [faultSource, existingMap] of this.faults) {
                const newMap = new Map();
                for (const [code, fault] of existingMap)
                    newMap.set(code, fault);
                newFrame.faults.set(faultSource, newMap);
            }
            return newFrame;
        }
        /** */
        addFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            if (faultsForSource) {
                faultsForSource.set(fault.type.code, fault);
            }
            else {
                const map = new Map();
                map.set(fault.type.code, fault);
                this.faults.set(fault.source, map);
            }
        }
        /** */
        removeSource(source) {
            this.faults.delete(source);
            if (source instanceof Truth.Statement)
                for (const cruftObject of source.cruftObjects)
                    this.faults.delete(cruftObject);
        }
        /** */
        removeFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            if (faultsForSource)
                faultsForSource.delete(fault.type.code);
        }
        /** */
        hasFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            return faultsForSource ?
                faultsForSource.has(fault.type.code) :
                false;
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Fault {
        constructor(
        /** */
        type, 
        /** The document object that caused the fault to be reported. */
        source, 
        /**
         * A human-readable message that contains more in-depth detail
         * of the fault that occured, in addition to the standard message.
         */
        additionalDetail = "") {
            this.type = type;
            this.source = source;
            this.additionalDetail = additionalDetail;
            const src = this.source;
            // The +1's are necessary in order to deal with the fact that
            // most editors are 1-based whereas the internal representation
            // of statement strings are 0-based.
            if (src instanceof Truth.Statement) {
                // The TabsAndSpaces fault is the only fault that needs a
                // special case where it has a different reporting location.
                this.range = type.code === Truth.Faults.TabsAndSpaces.code ?
                    [1, src.indent + 1] :
                    [src.indent + 1, src.sourceText.length + 1];
            }
            else if (src instanceof Truth.Span || src instanceof Truth.InfixSpan) {
                this.range = [
                    src.boundary.offsetStart + 1,
                    src.boundary.offsetEnd + 1
                ];
            }
            else
                throw Truth.Exception.unknownState();
        }
        /**
         * Converts this fault into a string representation,
         * suitable for output as an error message.
         */
        toString() {
            const doc = this.document;
            const avoidProtocols = [
                Truth.UriProtocol.memory,
                Truth.UriProtocol.none,
                Truth.UriProtocol.unknown
            ];
            const uriText = avoidProtocols.includes(doc.uri.protocol) ?
                "" : doc.uri.toString() + " ";
            const colNums = this.range.join("-");
            const colText = colNums ? ", Col " + colNums : "";
            return `${this.type.message} (${uriText}Line ${this.line}${colText})`;
        }
        /**
         * Gets a reference to the Document in which this Fault was detected.
         */
        get document() {
            return this.statement.document;
        }
        /**
         * Gets a reference to the Statement in which this Fault was detected.
         */
        get statement() {
            const src = this.source;
            return Truth.Not.null(src instanceof Truth.Statement ? src :
                src instanceof Truth.Span ? src.statement :
                    src instanceof Truth.InfixSpan ? src.statement :
                        null);
        }
        /**
         * Gets the 1-based line number of the Statement in which this Fault was detected.
         */
        get line() {
            const smt = this.statement;
            return smt.document.lineNumberOf(smt);
        }
    }
    Truth.Fault = Fault;
    /**
     *
     */
    class FaultType {
        constructor(
        /**
         * An error code, useful for reference purposes, or display in a user interface.
         */
        code, 
        /**
         * A human-readable description of the fault.
         */
        message, 
        /**
         *
         */
        severity) {
            this.code = code;
            this.message = message;
            this.severity = severity;
            this.message = message.trim().replace(/\s\s+/g, " ");
        }
        /**
         * Creates a fault of this type.
         */
        create(source) {
            return new Fault(this, source);
        }
    }
    Truth.FaultType = FaultType;
    /**
     * Utility function for creating frozen fault instances.
     */
    function createFault(code, message, severity = 8 /* error */) {
        return Object.freeze(new FaultType(code, message, severity));
    }
    const quantifiers = `(${"*" /* star */}, 
		${"+" /* plus */},
		${"{" /* quantifierStart */}..${"}" /* quantifierEnd */})`;
    /**
     *
     */
    Truth.Faults = Object.freeze({
        /** */
        *each() {
            const values = Object.values(Truth.Faults);
            for (const faultType of values)
                if (faultType instanceof FaultType)
                    yield faultType;
        },
        /**
         * @returns An object containing the FaultType instance
         * associated with the fault with the specified code, as
         * well as the name of the instance. In the case when the
         * faultCode was not found, null is returned.
         */
        nameOf(faultCode) {
            const entries = Object.entries(Truth.Faults);
            for (const [name, type] of entries)
                if (type instanceof FaultType)
                    if (type.code === faultCode)
                        return name;
            return "";
        },
        //# Resource-related faults
        /** */
        UnresolvedResource: createFault(100, "URI points to a resource that could not be resolved."),
        /** */
        CircularResourceReference: createFault(102, "URI points to a resource that would cause a circular reference."),
        /** */
        InsecureResourceReference: createFault(104, `Documents loaded from remote locations
			cannot reference documents stored locally.`),
        /** */
        DuplicateReference: createFault(106, "Document has already been referenced.", 8 /* error */),
        //# Type verification faults
        /** */
        UnresolvedAnnotation: createFault(201, "Unresolved annotation."),
        /** */
        CircularTypeReference: createFault(203, "Circular type reference detected."),
        /** */
        ContractViolation: createFault(
        //! CHANGE THIS TO 204
        205, "Overridden types must explicitly expand the type as defined in the base."),
        /** */
        TypeCannotBeRefreshed: createFault(206, `This type cannot be refreshed, because one or more base
			types are imposing a specific type contract on it. Consider
			omitting the ${":" /* joint */} operator here.`, 4 /* warning */),
        /** */
        IgnoredAnnotation: createFault(207, `This annotation is ignored because another annotation
			in this statement resolves to the same type.`),
        /** */
        IgnoredAlias: createFault(209, `Aliases (meaning annotations that are matched by patterns)
			can't be added onto types that have a contract put in place
			by a base type.`),
        /** */
        TypeSelfReferential: createFault(211, "Types cannot be self-referential"),
        //# List-related faults
        /** */
        AnonymousInListIntrinsic: createFault(300, "Types contained directly by List-intrinsic types cannot be anonymous.", 4 /* warning */),
        /** */
        ListContractViolation: createFault(301, "The containing list cannot contain children of this type.", 4 /* warning */),
        /** */
        ListIntrinsicExtendingList: createFault(303, "List intrinsic types cannot extend from other lists."),
        /** (This is the same thing as a list dimensionality conflict) */
        ListExtrinsicExtendingNonList: createFault(305, "Lists cannot extend from non-lists."),
        /** */
        ListDimensionalDiscrepancyFault: createFault(307, `A union cannot be created between these two types
			because they are lists of different dimensions.`),
        /** */
        ListAnnotationConflict: createFault(309, `All fragments of this annotation need to have
			a list operator (${"..." /* list */})`),
        //# Pattern-related faults
        /** */
        PatternInvalid: createFault(400, "Invalid pattern."),
        /** */
        PatternWithoutAnnotation: createFault(402, "Pattern has no annotations.", 4 /* warning */),
        /** */
        PatternCanMatchEmpty: createFault(404, "Patterns must not be able to match an empty input."),
        /** */
        PatternMatchingTypesAlreadyExists: createFault(406, `A pattern matching these types has 
			already been defined in this scope.`),
        /** */
        PatternMatchingList: createFault(407, "A pattern cannot match a list type."),
        /** */
        PatternCanMatchWhitespaceOnly: createFault(420, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternAcceptsLeadingWhitespace: createFault(422, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternRequiresLeadingWhitespace: createFault(424, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternAcceptsTrailingWhitespace: createFault(426, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternRequiresTrailingWhitespace: createFault(428, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternNonCovariant: createFault(440, "Pattern does not match it's base types."),
        /** */
        PatternPartialWithCombinator: createFault(442, "Partial patterns cannot explicitly match the comma character."),
        /** */
        PatternsFormDiscrepantUnion: createFault(499, "A union cannot be created between these types because their " +
            "associated patterns conflict with each other."),
        //# Infix related
        /** */
        InfixHasQuantifier: createFault(
        ///0,
        500, `Infixes cannot have quantifiers ${quantifiers} applied to them`),
        /** */
        InfixHasDuplicateTerm: createFault(
        ///0,
        501, "Infixes cannot have duplicate terms."),
        /** */
        InfixHasSelfReferentialType: createFault(
        ///410,
        503, "Infixes cannot be self-referential."),
        /** */
        InfixNonConvariant: createFault(
        ///412,
        505, "Infixes must be compatible with their bases."),
        /** */
        InfixCannotDefineNewTypes: createFault(
        ///422,
        507, `A type referenced in an infix must be contained
			by the pattern statement directly, or be contained
			by one of it's matched bases.`),
        /** */
        InfixReferencedTypeMustHavePattern: createFault(
        ///414,
        509, "Types applied to an infix must have at least one associated pattern."),
        /** */
        InfixReferencedTypeCannotBeRecursive: createFault(
        ///416,
        511, "Types applied to an infix must not create a recursive structure."),
        /** */
        InfixContractViolation: createFault(
        ///424,
        513, "Infix type annotations must explicitly expand the type as defined by the base."),
        /** */
        InfixPopulationChaining: createFault(
        ///426,
        515, "Population infixes cannot have multiple declarations."),
        /** */
        InfixUsingListOperator: createFault(
        ///0,
        517, `Infix terms cannot end with the list operator (${"..." /* list */}).`),
        /** */
        InfixReferencingList: createFault(
        ///428,
        519, "Infixes cannot reference list types."),
        /** */
        PortabilityInfixHasMultipleDefinitions: createFault(
        ///418,
        521, `Portability infixes with compatible types cannot
			be specified more than once.`),
        /** */
        PortabilityInfixHasUnion: createFault(
        ///418,
        523, "Portability infixes with unioned types are not supported at this time."),
        /** */
        PopulationInfixHasMultipleDefinitions: createFault(
        ///0,
        525, `Declarations in a population infix cannot be 
			defined twice in the same pattern`),
        /** */
        NominalInfixMustSubtype: createFault(
        ///430,
        527, "Patterns with nominal infixes require an input that is " +
            "a subtype of the type specified, not the type itself."),
        //# Parse errors
        /** */
        StatementBeginsWithComma: createFault(600, "Statements cannot begin with a comma."),
        /** */
        StatementBeginsWithEllipsis: createFault(602, "Statements cannot begin with an ellipsis (...)."),
        /** */
        StatementBeginsWithEscapedSpace: createFault(604, "Statements cannot begin with an escape character (\\) " +
            "that is followed by a tab or space."),
        /** */
        StatementContainsOnlyEscapeCharacter: createFault(606, "A statement cannot consist of a single escape character (\\)"),
        /** */
        StatementBeginsWithInvalidSequence: createFault(608, "A statement cannot begin with the sequences: /*, /+, or /?"),
        //# Parsing Faults
        /** */
        TabsAndSpaces: createFault(1000, "Statement indent contains a mixture of tabs and spaces.", 4 /* warning */),
        /** */
        DuplicateDeclaration: createFault(1001, "Duplicated declaration."),
        /** */
        UnterminatedCharacterSet: createFault(1002, `Unterminated character set. Pattern has an opening
			"${"[" /* setStart */}" character without a matching
			"${"]" /* setEnd */}" character.`),
        /** */
        UnterminatedGroup: createFault(1004, `Unterminated group. Pattern has an opening
			"${"(" /* groupStart */}" character without a matching
			"${")" /* groupEnd */}" character.`),
        /** */
        DuplicateQuantifier: createFault(1006, `Multiple consecutive quantifiers ${quantifiers} are not allowed.`),
        /** */
        UnterminatedInfix: createFault(1008, `Unterminated infix. Pattern has an opening ${"<" /* start */},
			${"<<" /* nominalStart */}, ${"</" /* patternStart */} delimiter without
			a matching closing delimiter.`),
        /** */
        EmptyPattern: createFault(1010, "Pattern has no matchable content.")
    });
    // Additional safety
    Array.from(Truth.Faults.each()).every(Object.freeze);
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A chain of Subjects that form a path to a particular
     * location within a Document.
     *
     * The lifetime of a Phrase is pinned (directly or indirectly)
     * to the lifetime of a Document. A Document object as a
     * reference to a root-level Phrase, and Phrase objects are
     * then store references to their nested Phrase children.
     */
    class Phrase extends Truth.AbstractClass {
        /** */
        constructor(parent, 
        /**
         * Stores a reference to the Document that ultimately
         * contains this Phrase.
         */
        containingDocument, 
        /**
         * Stores the subject that exists at the end of this phrase.
         */
        terminal, 
        /**
         * Stores the number of subjects in this Phrase. This value
         * is equivalent to the length of this Phrase's ancestry.
         */
        length) {
            super();
            this.containingDocument = containingDocument;
            this.terminal = terminal;
            this.length = length;
            /** */
            this.class = 3 /* phrase */;
            /** */
            this.forwardings = new Map();
            this._subjects = null;
            this._ancestry = null;
            /**
             * @internal
             * For reasons related to performance and architectural simplicity,
             * a reference to the Node to which this Phrase is associated is
             * stored here. This is so that we can avoid managing a separate
             * index to manage the relationship between these two objects.
             * Phrases are created before their associated Node, and so in this
             * case, this field is null.
             *
             * This field should only be assigned from within the Node class.
             */
            this.associatedNode = null;
            this.parent = parent || this;
        }
        /**
         * @internal
         * Creates a new root phrase.
         */
        static new(containingDocument) {
            return new Phrase(null, containingDocument, Truth.Term.void, 0);
        }
        /**
         * @internal
         * Finds or creates a Phrase object from the specified Spine.
         * Returns null in the case when the Spine passes through
         * statements that have been marked as cruft.
         */
        static fromSpine(spine) {
            let current = spine.document.phrase;
            for (const vert of spine.vertebrae) {
                if (!(vert instanceof Truth.Span))
                    return null;
                current = current.forward(vert.boundary.subject);
            }
            return current;
        }
        /**
         * @internal
         * Iterates through the first-level phrases of the specified document,
         * skipping over the phrases that don't have an associated node.
         */
        static *rootsOf(document) {
            for (const phrase of document.phrase.forwardings.values())
                if (phrase.associatedNode !== null)
                    yield phrase;
        }
        /**
         * Returns a reference to the phrase that is 1 subject shorter than
         * this one (counting from the end).
         */
        back() {
            return this.parent || this;
        }
        /**
         * Returns a reference to the phrase that is extended by the subject specified.
         */
        forward(subject) {
            return Truth.Misc.get(this.forwardings, subject, () => new Phrase(this, this.containingDocument, subject, this.length + 1));
        }
        /**
         * Returns a reference to the phrase that is extended by the array of subjects specified.
         */
        forwardDeep(path) {
            let current = this;
            for (const item of path) {
                const subject = typeof item === "string" ? Truth.Term.from(item) : item;
                current = current.forward(subject);
            }
            return current;
        }
        /**
         * Gets an array containing the subjects that compose this phrase.
         * Note that if only the number of subjects is required, the .length
         * field should be used instead.
         */
        get subjects() {
            return this._subjects ?
                this._subjects :
                this._subjects = this.ancestry.map(ph => ph.terminal);
        }
        /**
         * Gets an array of Phrase objects that form a path leading to this Phrase.
         * For example, if the subjects of this Phrase were to serialize to something
         * like AA / BB / CC, then this property would store an array of 3 Phrases,
         * which would serialize to:
         *
         * AA
         * AA / BB
         * AA / BB / CC
         *
         * Note that if only the length of the phrase is required, the .length
         * field should be used instead.
         */
        get ancestry() {
            if (this._ancestry === null) {
                this._ancestry = [];
                let current = this;
                // The ancestry never includes the 0-length phrase
                // attached to a document, and always includes itself.
                while (current.length > 0) {
                    this._ancestry.unshift(current);
                    current = current.parent;
                }
            }
            return this._ancestry;
        }
        /**
         * Returns a string representation of this Phrase, suitable for debugging purposes.
         */
        toString() {
            const uri = this.containingDocument.uri.toString();
            const path = this.subjects.map(sub => sub.toString()).join("/");
            return uri + "//" + path;
        }
    }
    Truth.Phrase = Phrase;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    const hashRegex = new RegExp("[a-f0-9]{" + Truth.Hash.length + "}", "i");
    /**
     * A reference type that encapsulates a unique term within a document.
     * A term may be the name of a type, such as "Product", or it may also
     * be some type alias to be matched by a pattern, such as "10cm".
     */
    class Term extends Truth.AbstractClass {
        /** */
        constructor(
        /**
         * Stores the inner content of this Term.
         */
        textContent, forceSingular) {
            super();
            this.textContent = textContent;
            /** */
            this.class = 4 /* term */;
            /**
             * Stores a pattern hash, in the case when this Term
             * relates to a pattern. Stores an empty string in other cases.
             */
            this.hash = "";
            this.hash = this.tryExtractHash(textContent);
            const listTok = "..." /* list */;
            const tokLen = listTok.length;
            const isList = textContent.length > tokLen + 1 && textContent.slice(-tokLen) === listTok;
            this.singular = isList && !forceSingular ?
                Term.internalFrom(textContent.slice(0, -tokLen), true) :
                this;
        }
        /**
         * Finds or creates a Term object whose inner textContent is equal
         * to the textContent value specified. This method is used to acquire
         * a reference to a Term, instead of using the Term constructor (which
         * is private), to ensure that there is only ever one instance of a Term
         * for each unique textContent value.
         *
         * @returns A term object that corresponds to the string specified.
         */
        static from(textContent) {
            return this.internalFrom(unescape(textContent), false);
        }
        /** */
        static internalFrom(textContent, forceSingular) {
            return Truth.Misc.get(this.cache, textContent, () => new Term(textContent, forceSingular));
        }
        /** */
        tryExtractHash(text) {
            const delim = "/" /* main */;
            const delimEsc = escape(delim);
            const delimLen = text.startsWith(delim) ? delim.length :
                text.startsWith(delimEsc) ? delimEsc.length :
                    -1;
            const hashLen = Truth.Hash.length;
            if (delimLen < 0 || text.length < delimLen + hashLen + 1)
                return "";
            const hash = text.substr(delimLen, hashLen);
            if (hash.length !== hashLen || !hashRegex.test(hash))
                return "";
            return hash;
        }
        /** Stores whether this component represents a pattern. */
        get isPattern() { return this.hash !== ""; }
        /**
         * Gets whether this Term conforms to the list syntax.
         */
        get isList() {
            return this.singular !== this;
        }
        /**
         * Converts this Term to it's string representation.
         * @param escape If true, preserves any necessary
         * escaping required to ensure the term string
         * is in a parsable format.
         */
        toString(escape = 0 /* none */) {
            const val = (() => {
                switch (escape) {
                    case 0 /* none */:
                        return this.textContent;
                    case 1 /* declaration */:
                        {
                            // Regex delimiters are escaped if and only if 
                            // they're the first character in a term.
                            const dlmReg = new RegExp("^" + "/" /* main */);
                            const jntRegS = new RegExp(":" /* joint */ + " " /* space */);
                            const jntRegT = new RegExp(":" /* joint */ + "\t" /* tab */);
                            const cmbReg = new RegExp("," /* combinator */);
                            return this.textContent
                                .replace(dlmReg, "\\" /* escapeChar */ + "/" /* main */)
                                .replace(jntRegS, "\\" /* escapeChar */ + ":" /* joint */ + " " /* space */)
                                .replace(jntRegT, "\\" /* escapeChar */ + ":" /* joint */ + "\t" /* tab */)
                                .replace(cmbReg, "\\" /* escapeChar */ + "," /* combinator */);
                        }
                    case 2 /* annotation */:
                        {
                            const reg = new RegExp("," /* combinator */);
                            const rep = "\\" /* escapeChar */ + "," /* combinator */;
                            return this.textContent.replace(reg, rep);
                        }
                }
            })();
            return val + (this.isList ? "..." /* list */ : "");
        }
    }
    /**
     * Stores a cache of all Terms created by the compiler.
     */
    Term.cache = new Map();
    /**
     * Stores an empty-string term, which is used as a marker term
     * to represent what is eventually presented as an anonymous type.
     */
    Term.void = Term.from("");
    Truth.Term = Term;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Infinite incremental counter.
     */
    class VersionStamp {
        /** */
        constructor(stamp) {
            this.stamp = stamp;
        }
        /** */
        static next() {
            const createStamp = (stamp) => new VersionStamp(Object.freeze(stamp));
            if (typeof BigInt !== "undefined") {
                if (this.nextStamp === undefined)
                    return createStamp(this.nextStamp = BigInt(1));
                // See: https://github.com/eslint/eslint/issues/10574
                // eslint-disable-next-line valid-typeof
                if (typeof this.nextStamp === "bigint")
                    return createStamp(++this.nextStamp);
            }
            else {
                if (this.nextStamp === undefined) {
                    this.nextStamp = [1];
                    return createStamp(this.nextStamp.slice());
                }
                const ns = this.nextStamp;
                if (Array.isArray(ns)) {
                    // Polyfill infinite number counter for use in the 
                    // absence of a native BigInt implementation.
                    for (let i = ns.length; i-- > 0;) {
                        if (ns[i] === 999999999999) {
                            ns[i] = 0;
                            if (i === 0)
                                ns.unshift(1);
                        }
                        else {
                            ns[i]++;
                            break;
                        }
                    }
                    return createStamp(ns.slice());
                }
            }
            throw Truth.Exception.unknownState();
        }
        /** */
        newerThan(otherStamp) {
            return this.stamp > otherStamp.stamp;
        }
        /** */
        toString() {
            return Array.isArray(this.stamp) ?
                this.stamp.join("") :
                this.stamp.toString();
        }
    }
    Truth.VersionStamp = VersionStamp;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class AlphabetRange {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
    }
    Truth.AlphabetRange = AlphabetRange;
    /**
     * @internal
     */
    class Alphabet {
        /** */
        constructor(...ranges) {
            /** */
            this.ranges = [];
            this.ranges = ranges;
        }
        /**
         * Iterates through each character defined in the alphabet.
         */
        *[Symbol.iterator]() {
            for (const range of this.ranges)
                for (let i = range.from; i <= range.to; i++)
                    yield String.fromCodePoint(i);
        }
        /**
         * Iterates through all defined ranges in the alphabet,
         * excluding the wildcard range.
         */
        *eachRange() {
            if (this.hasWildcard()) {
                for (let rangeIdx = 0; rangeIdx < this.ranges.length - 1;)
                    yield this.ranges[rangeIdx++];
            }
            else
                for (const range of this.ranges)
                    yield range;
        }
        /** */
        has(symbol) {
            if (symbol === Alphabet.wildcard)
                return this.hasWildcard();
            const code = toCharCode(symbol);
            for (const range of this.ranges)
                if (range.from >= code && range.to <= code)
                    return true;
            return false;
        }
        /** */
        hasWildcard() {
            const rng = this.ranges;
            return rng.length > 0 && rng[rng.length - 1] === Alphabet.wildcardRange;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const symbols = [];
            for (const range of this.ranges)
                symbols.push(range.from === range.to ?
                    String.fromCodePoint(range.from) :
                    String.fromCodePoint(range.from) + " - " + String.fromCodePoint(range.to));
            if (this.hasWildcard())
                symbols.push(Alphabet.wildcard);
            return "[" + symbols.join(", ") + "]";
        }
    }
    /**
     * Stores a special token that the system understands to be the
     * wildcard character. The length of the token is longer than any
     * other token that could otherwise be found in the alphabet.
     */
    Alphabet.wildcard = "((wild))";
    /**
     * Stores a range that represents the wildcard character.
     * The range of the wildcard is positive infinity in both directions,
     * to ensure that it's always sorted last in the ranges array.
     */
    Alphabet.wildcardRange = Object.freeze(new AlphabetRange(Infinity, Infinity));
    Truth.Alphabet = Alphabet;
    /**
     * @internal
     * A disposable class for easily creating Alphabet instances
     * (This design avoids introducing mutability into the Alphabet class).
     */
    class AlphabetBuilder {
        /** */
        constructor(...others) {
            /** */
            this.ranges = [];
            for (const item of others) {
                if (item instanceof Alphabet) {
                    const theRanges = Array.from(item.eachRange());
                    for (const range of theRanges)
                        this.ranges.push(range);
                }
                else if (item instanceof AlphabetRange) {
                    this.ranges.push(item);
                }
                else {
                    const code = toCharCode(item);
                    this.ranges.push(new AlphabetRange(code, code));
                }
            }
        }
        /**
         * Adds an entry to the alphabet.
         * If the second parameter is omitted, the entry refers to a
         * single character, rather than a range of characters.
         */
        add(from, to) {
            const toAsNum = to === undefined ? from : to;
            this.ranges.push(new AlphabetRange(toCharCode(from), toCharCode(toAsNum)));
            return this;
        }
        /** */
        addWild() {
            this.ranges.push(Alphabet.wildcardRange);
            return this;
        }
        /**
         * @returns An optimized Alphabet instances composed
         * from the characters and ranges applied to this AlphabetBuilder.
         *
         * @param invert In true, causes the entries in the generated
         * Alphabet to be reversed, such that every character marked
         * as included is excluded, and vice versa.
         */
        toAlphabet(invert) {
            if (this.ranges.length === 0)
                return new Alphabet();
            const ranges = this.ranges
                .slice()
                .sort((a, b) => a.from - b.from);
            // Quick optimization of ranges
            for (let i = 0; i < ranges.length - 1; i++) {
                const thisRange = ranges[i];
                while (i < ranges.length - 1) {
                    const nextRange = ranges[i + 1];
                    // Omit
                    if (thisRange.to >= nextRange.to) {
                        ranges.splice(i + 1, 1);
                    }
                    // Concat
                    else if (thisRange.to + 1 >= nextRange.from) {
                        ranges.splice(i + 1, 1);
                        ranges[i] = new AlphabetRange(thisRange.from, nextRange.to);
                    }
                    // Next
                    else
                        break;
                }
            }
            if (invert) {
                //
                // This alphabet inversion algorithm has to deal with 4 cases,
                // depending on the pattern of the ranges and the spaces.
                // After the ranges are sorted and optimized, the ranges
                // array represents a layout that alternates between ranges
                // and spaces. There are 4 basic layouts (R = Range, S = Space):
                //
                // RSRS - Starts with a range, ends with a space
                // SRSR - Starts with a space, ends with a range
                // RSRSR - Starts with a range, ends with a range
                // SRSRS - Starts with a space, ends with a space
                // 
                // The algorithm deal with any leading or trailing space
                // separately, to make the looping less complicated. 
                // 
                const rangesInv = [];
                const lastRange = ranges[ranges.length - 1];
                const matchesZero = ranges[0].from === 0;
                const matchesMax = lastRange.to === Truth.UnicodeMax;
                if (matchesZero && matchesMax && ranges.length === 1)
                    return new Alphabet();
                if (!matchesZero)
                    rangesInv.push(new AlphabetRange(0, ranges[0].from));
                const endAt = matchesMax ?
                    lastRange.from :
                    Truth.UnicodeMax;
                for (let i = 0; i < ranges.length; i++) {
                    const prevRangeEnd = ranges[i].to;
                    const nextRangeStart = i < ranges.length - 1 ?
                        ranges[i + 1].from :
                        Truth.UnicodeMax + 1;
                    rangesInv.push(new AlphabetRange(prevRangeEnd + 1, nextRangeStart - 1));
                    if (nextRangeStart >= endAt)
                        break;
                }
                if (!matchesMax)
                    rangesInv.push(new AlphabetRange(lastRange.from, Truth.UnicodeMax));
            }
            return new Alphabet(...ranges);
        }
    }
    Truth.AlphabetBuilder = AlphabetBuilder;
    /** */
    function toCharCode(symbol) {
        return typeof symbol === "string" ?
            symbol.charCodeAt(0) :
            symbol;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TransitionMap {
        /** */
        constructor(transitionLiteral) {
            const transitions = new Map();
            if (transitionLiteral) {
                for (const [stateIdText, tslObject] of Object.entries(transitionLiteral)) {
                    const stateId = parseInt(stateIdText, 10);
                    if (stateId !== stateId)
                        throw new TypeError();
                    if (!tslObject || typeof tslObject !== "object")
                        throw new TypeError();
                    const tsl = tslObject;
                    transitions.set(stateId, new Truth.TransitionState(tsl));
                }
            }
            this.transitions = transitions;
        }
        /** */
        *[Symbol.iterator]() {
            for (const [stateId, transitionState] of this.transitions.entries())
                yield [stateId, transitionState];
        }
        /** */
        clone() {
            const out = new TransitionMap({});
            for (const [key, value] of this.transitions)
                out.transitions.set(key, value.clone());
            return out;
        }
        /** */
        has(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                return false;
            if (symbol === undefined)
                return !!transitionState;
            return transitionState.has(symbol);
        }
        get(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                return undefined;
            if (symbol === undefined)
                return transitionState;
            return transitionState.get(symbol);
        }
        acquire(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                throw new Error();
            if (symbol === undefined)
                return transitionState;
            const subStateId = transitionState.get(symbol);
            if (subStateId === undefined)
                throw new Error();
            return subStateId;
        }
        /** */
        *eachStateId() {
            for (const stateId of this.transitions.keys())
                yield stateId;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const out = ["{"];
            for (const [stateId, tState] of this.transitions)
                out.push("\t" + stateId + ": " + tState.toString());
            out.push("}");
            return out.join("\n");
        }
    }
    Truth.TransitionMap = TransitionMap;
    /**
     * @internal
     */
    class MutableTransitionMap extends TransitionMap {
        /** */
        initialize(srcStateId) {
            this.transitions.set(srcStateId, new Truth.TransitionState());
        }
        /** */
        set(srcStateId, symbol, dstStateId) {
            const tState = this.transitions.get(srcStateId);
            if (!tState) {
                const tState = new Truth.TransitionState();
                tState.set(symbol, dstStateId);
                this.transitions.set(srcStateId, tState);
            }
            else {
                tState.set(symbol, dstStateId);
            }
        }
    }
    Truth.MutableTransitionMap = MutableTransitionMap;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TransitionState {
        /** */
        constructor(source) {
            this.stateMap = new Map();
            if (source)
                for (const [symbol, stateId] of Object.entries(source))
                    this.stateMap.set(symbol, stateId);
        }
        /** */
        clone() {
            const cloned = new TransitionState();
            for (const [symbol, stateId] of this.stateMap)
                cloned.stateMap.set(symbol, stateId);
            return cloned;
        }
        /** */
        has(symbol) {
            return this.stateMap.has(symbol);
        }
        /** */
        get(symbol) {
            return this.stateMap.get(symbol);
        }
        /** */
        set(symbol, stateId) {
            this.stateMap.set(symbol, stateId);
        }
        /** */
        *eachSymbol() {
            for (const symbol of this.stateMap.keys())
                yield symbol;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const out = [];
            for (const [symbol, stateId] of this.stateMap)
                out.push("{ " + symbol + ": " + stateId + " }");
            return out.length ? out.join(", ") : "{}";
        }
    }
    Truth.TransitionState = TransitionState;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class Guide {
        /** */
        constructor(from) {
            /** */
            this.hasDst = null;
            /** */
            this.isFrozen = false;
            /** */
            this.arrows = new Map();
            if (from instanceof Guide) {
                this.hasDst = from.hasDst;
                for (const [stateIdSrc, stateIdDst] of from.arrows)
                    this.arrows.set(stateIdSrc, stateIdDst);
            }
            else if (typeof from === "number") {
                this.add(from);
            }
            else if (from) {
                for (const [stateIdSrc, stateIdDst] of from)
                    this.arrows.set(stateIdSrc, stateIdDst);
            }
        }
        /** */
        clone() {
            const cloned = new Guide();
            for (const [stateIdSrc, stateIdDst] of this.arrows)
                cloned.arrows.set(stateIdSrc, stateIdDst);
            return cloned;
        }
        /** */
        has(stateIdSrc) {
            return this.arrows.has(stateIdSrc);
        }
        /** */
        get(stateIdSrc) {
            return this.arrows.get(stateIdSrc);
        }
        /** */
        add(stateIdSrc, stateIdDst = null) {
            if (this.isFrozen)
                throw new TypeError();
            if (this.hasDst === null) {
                this.arrows.set(stateIdSrc, stateIdDst);
            }
            else {
                if (stateIdDst !== stateIdDst)
                    throw new TypeError();
                if (this.hasDst === true && typeof stateIdDst !== "number" ||
                    this.hasDst === false && typeof stateIdDst === "number")
                    throw new Error("Parameters need to be kept consistent across the instance.");
                this.arrows.set(stateIdSrc, stateIdDst);
            }
            this.hasDst = stateIdDst !== null;
        }
        /** */
        append(other) {
            if (this.isFrozen)
                throw new TypeError();
            if (this.hasDst === null) {
                for (const [src, dst] of other.arrows) {
                    this.hasDst = typeof dst === "number";
                    this.arrows.set(src, dst);
                }
            }
            else if (other.hasDst === null) {
                if (other.size !== 0)
                    throw Truth.Exception.unknownState();
            }
            else {
                for (const [src, dst] of other.arrows)
                    this.arrows.set(src, dst);
            }
        }
        /** */
        first() {
            const out = this.arrows.get(0);
            if (out === null || out === undefined)
                throw new Error();
            return out;
        }
        /** */
        *keys() {
            for (const src of this.arrows.keys())
                yield src;
        }
        /** */
        *values() {
            if (this.hasDst === true)
                for (const dst of this.arrows.values())
                    yield Truth.Not.null(dst);
        }
        /** */
        *entries() {
            if (this.hasDst === false)
                throw new Error("Cannot enumerate the full entries of this instance.");
            for (const [stateIdSrc, stateIdDst] of this.arrows)
                yield [stateIdSrc, Truth.Not.null(stateIdDst)];
        }
        /** */
        get size() { return this.arrows.size; }
        /**
         * @returns A boolean value that indicates whether the contents
         * of this guide match the contents of the guide specified in the
         * parameter.
         */
        equals(other) {
            if (this.size !== other.size)
                return false;
            for (const [src, dst] of this.arrows)
                if (other.arrows.get(src) !== dst)
                    return false;
            return true;
        }
        /** */
        freeze() {
            this.isFrozen = true;
            return this;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            if (this.hasDst) {
                const literal = [];
                for (const [stateIdSrc, stateIdDst] of this.arrows)
                    literal.push(stateIdSrc + ": " + stateIdDst);
                return "{ " + literal.join(", ") + " }";
            }
            return "[" + Array.from(this.arrows.keys()).join(", ") + "]";
        }
    }
    Truth.Guide = Guide;
})(Truth || (Truth = {}));
/**
 * This code is a TypeScript conversion of a portion of the the Python
 * project "greenery", from GitHub user "qntm".
 *
 * The greenery project can be found here:
 * https://github.com/qntm/greenery
 *
 * Specifically, the code from where this code drew inspiration is:
 * https://github.com/qntm/greenery/blob/master/greenery/fsm.py
 *
 * Possibly relevant blog post:
 * https://qntm.org/algo
 *
 * The original MIT license from greenery is as follows:
 *
 * Copyright (C) 2012 to 2017 by qntm
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Truth;
/**
 * This code is a TypeScript conversion of a portion of the the Python
 * project "greenery", from GitHub user "qntm".
 *
 * The greenery project can be found here:
 * https://github.com/qntm/greenery
 *
 * Specifically, the code from where this code drew inspiration is:
 * https://github.com/qntm/greenery/blob/master/greenery/fsm.py
 *
 * Possibly relevant blog post:
 * https://qntm.org/algo
 *
 * The original MIT license from greenery is as follows:
 *
 * Copyright (C) 2012 to 2017 by qntm
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function (Truth) {
    /**
     * Oblivion is a Symbol object that is returned while calling crawl() if the Fsm
     * is transitioned to the oblivion state. For example while crawling two Fsms
     * in parallel we may transition to the oblivion state of both Fsms at once.
     * This warrants an out-of-bound signal which will reduce the complexity of
     * the new Fsm's map.
     */
    const Oblivion = Symbol();
    /**
     * @internal
     * A Finite State Machine or Fsm has an alphabet and a set of states. At any
     * given moment, the Fsm is in one state. When passed a symbol from the
     * alphabet, the Fsm jumps to another state (or possibly the same state).
     * A TransitionMap indicates where to jump. One state is nominated as the
     * initial state. Zero or more states are nominated as final states. If, after
     * consuming a string of symbols, the Fsm is in a final state, then it is said
     * to "accept" the string.
     */
    class Fsm {
        /** */
        constructor(
        /**
         * An iterable of symbols the Fsm can be fed.
         */
        alphabet, 
        /**
         * The set of possible states for the Fsm.
         */
        states, 
        /**
         * The initial state of the Fsm.
         */
        initial, 
        /**
         * The set of states that the Fsm accepts.
         */
        finals, 
        /**
         * May be sparse (i.e. it may omit transitions).
         * In the case of omitted transitions, a non-final
         * "oblivion" state is simulated.
         */
        transitions) {
            this.alphabet = alphabet;
            this.states = states;
            this.initial = initial;
            this.finals = finals;
            this.transitions = transitions;
        }
        /**
         * @returns A new Fsm instance that accept
         * no inputs, not even an empty string.
         */
        static empty(alphabet) {
            const tsl = {};
            for (const symbol of alphabet)
                tsl[symbol] = 0;
            return new Fsm(alphabet, new Set([0]), 0, new Set(), new Truth.TransitionMap({ 0: tsl }));
        }
        /**
         * @returns An Fsm that matches only an empty string.
         */
        static epsilon(alphabet) {
            return new Fsm(alphabet, new Set([0]), 0, new Set([0]), new Truth.TransitionMap());
        }
        /**
         * @returns A boolean value that indicates whether the present Fsm
         * accepts the supplied array of symbols. Equivalently, consider this
         * Fsm instance as a possibly-infinite set of strings and test whether
         * the input is a member of it.
         *
         * If the wildcard character is present in the specified alphabet, then
         * any symbol not in the specified alphabet will be assumed to be
         * wildcard.
         */
        accepts(input) {
            const thisHasWild = this.alphabet.hasWildcard();
            let stateId = this.initial;
            for (const char of input) {
                const symbol = thisHasWild && !this.alphabet.has(char) ?
                    Truth.Alphabet.wildcard :
                    char;
                // Missing transition = transition to dead state
                if (!this.transitions.has(stateId, symbol))
                    return false;
                const newStateId = this.transitions.get(stateId, symbol);
                if (newStateId === undefined)
                    throw new ReferenceError();
                stateId = newStateId;
            }
            return this.finals.has(stateId);
        }
        /**
         * @returns A reduced version of the Fsm, down to a minimal finite
         * state machine equivalent.
         *
         * (A result by Brzozowski (1963) shows that a minimal finite state
         * machine equivalent to the original can be obtained by reversing
         * the original twice.)
         */
        reduce() {
            return this.reverse().reverse();
        }
        /**
         * @returns A new Fsm instance that represents the concatenation
         * of the specified series of finite state machines.
         */
        concatenate(...fsms) {
            if (fsms.length === 0)
                throw new RangeError();
            if (fsms.length === 1)
                return fsms[0];
            /**
             * Take a state in the numbered Fsm and return a set containing it,
             * plus (if it's final) the first state from the next Fsm,
             * plus (if that's final) the first state from the next but one Fsm,
             * plus...
             */
            const connectAll = (idx, substateId) => {
                const result = new Truth.Guide();
                result.add(idx, substateId);
                let i = idx;
                let id = substateId;
                while (i < fsms.length - 1 && fsms[i].finals.has(id)) {
                    i++;
                    id = fsms[i].initial;
                    result.add(i, id);
                }
                return result;
            };
            /**
             * Use a superset containing states from all Fsms at once.
             * We start at the start of the first Fsm. If this state is final in the
             * first Fsm, then we are also at the start of the second Fsm. And so on.
             */
            const initial = new Truth.Guide();
            if (fsms.length > 0)
                initial.append(connectAll(0, fsms[0].initial));
            /**
             * If you're in a final state of the final Fsm, it's final.
             */
            const finalFn = (guide) => {
                for (const [i, substateId] of guide.entries())
                    if (i === fsms.length - 1 && fsms[i].finals.has(substateId))
                        return true;
                return false;
            };
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const [i, substateId] of guide.entries()) {
                    const fsm = fsms[i];
                    if (fsm.transitions.has(substateId, symbol)) {
                        const storedValue = fsm.transitions.acquire(substateId, symbol);
                        next.append(connectAll(i, storedValue));
                    }
                }
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            const alphabets = fsms.map(fsm => fsm.alphabet);
            const alphabet = new Truth.AlphabetBuilder(...alphabets).toAlphabet();
            return crawl(alphabet, initial, finalFn, followFn);
        }
        /**
         * Concatenate two finite state machines together.
         * For example, if this accepts "0*" and other accepts "1+(0|1)",
         * will return a finite state machine accepting "0*1+(0|1)".
         * Accomplished by effectively following non-deterministically.
         */
        add(other) {
            return this.concatenate(this, other);
        }
        /**
         * If the present Fsm accepts X, returns an Fsm accepting X*
         * (i.e. 0 or more instances of X). Note that this is not as simple
         * as naively connecting the final states back to the initial state:
         * see (b*ab)* for example.
         */
        star() {
            const initial = new Truth.Guide(this.initial);
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const substateId of guide.keys()) {
                    if (this.transitions.has(substateId, symbol))
                        next.add(this.transitions.acquire(substateId, symbol));
                    // If one of our substates is final, then we can also consider
                    // transitions from the initial state of the original Fsm.
                    if (this.finals.has(substateId) && this.transitions.has(this.initial, symbol))
                        next.add(this.transitions.acquire(this.initial, symbol));
                }
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            /** */
            const finalFn = (guide) => {
                for (const substateId of guide.keys())
                    if (this.finals.has(substateId))
                        return true;
                return false;
            };
            return crawl(this.alphabet, initial, finalFn, followFn).or(Fsm.epsilon(this.alphabet));
        }
        /**
         * Given an Fsm and a multiplication factor, return the multiplied Fsm.
         */
        multiply(factor) {
            if (factor < 0)
                throw new RangeError();
            const initial = new Truth.Guide([[this.initial, 0]]);
            /** */
            const finalFn = (guide) => {
                for (const [substateId, iteration] of guide.entries())
                    if (this.initial === substateId)
                        if (this.finals.has(this.initial) || iteration === factor)
                            return true;
                return false;
            };
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const [substateId, iteration] of guide.entries()) {
                    if (iteration < factor && this.transitions.has(substateId, symbol)) {
                        const num = this.transitions.acquire(substateId, symbol);
                        next.add(num, iteration);
                        if (this.finals.has(num))
                            next.add(this.initial, iteration + 1);
                    }
                }
                if (next.size === 0)
                    return Oblivion;
                return next;
            };
            return crawl(this.alphabet, initial, finalFn, followFn).reduce();
        }
        /**
         * @returns A new Fsm object that presents the union of
         * all supplied Fsm instances.
         */
        union(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.some(val => val));
        }
        /**
         * Performs logical alternation between this Fsm, and the Fsm
         * instance supplied in the argument.
         *
         * @returns A finite state machine which accepts any sequence of
         * symbols that is accepted by either self or other. Note that the set
         * of strings recognised by the two Fsms undergoes a set union.
         */
        or(other) {
            return this.union(other);
        }
        /**
         * @returns A new Fsm object that represents the
         * intersection of all supplied Fsm instances.
         */
        intersection(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.every(val => val));
        }
        /**
         * Treat the Fsms as sets of strings and return the
         * intersection of those sets in the form of a new Fsm.
         */
        and(other) {
            return this.intersection(other);
        }
        /**
         * @returns A new Fsm object that represents the computed
         * symmetric difference of all suppled Fsm instances.
         */
        symmetricDifference(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.filter(val => val).length % 2 === 1);
        }
        /**
         * @returns A new Fsm instances that recognises only the strings
         * recognised by this Fsm, or the Fsm instance supplied in the
         * other argument, but not both.
         */
        xor(other) {
            return this.symmetricDifference(other);
        }
        /**
         * @returns A new Fsm instance that recogizes all inputs that
         * would not be accepted by this Fsm.
         */
        not() {
            const initial = new Truth.Guide([[0, this.initial]]);
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                const first = guide.first();
                if (first !== undefined)
                    if (this.transitions.has(first, symbol))
                        next.add(0, this.transitions.get(first, symbol));
                return next;
            };
            /** */
            const finalFn = (guide) => {
                const first = guide.first();
                return !(first !== undefined && this.finals.has(first));
            };
            return crawl(this.alphabet, initial, finalFn, followFn);
        }
        /**
         * @returns A new Fsm such that for every input that the supplied
         * Fsm accepts, the new Fsm accepts the same input, but reversed.
         */
        reverse() {
            // Start from a composite "state-set" consisting of all final states.
            // If there are no final states, this set is empty and we'll find that
            // no other states get generated.
            const initial = new Truth.Guide();
            for (const stateId of this.finals)
                initial.add(stateId);
            // Find every possible way to reach the current state-set
            // using this symbol.
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const prevStateId of this.transitions.eachStateId())
                    for (const stateId of guide.keys())
                        if (this.transitions.has(prevStateId, symbol))
                            if (this.transitions.get(prevStateId, symbol) === stateId)
                                next.add(prevStateId);
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            /** */
            const finalFn = (guide) => guide.has(this.initial);
            return crawl(this.alphabet, initial, finalFn, followFn);
        }
        /**
         * @returns A boolean value indicating whether this Fsm instance
         * accepts the same set of inputs as the Fsm instance specified
         * in the argument.
         */
        equivalent(other) {
            return this.xor(other).isEmpty();
        }
        /**
         * @returns A boolean value indicating whether this Fsm instance
         * does not accept the same set of inputs as the Fsm instance
         * specified in the argument.
         */
        unequivalent(other) {
            return !this.xor(other).isEmpty();
        }
        /**
         * @returns An Fsm instance which recognises only the inputs
         * recognised by the first Fsm instance in the list, but none of
         * the others.
         */
        difference(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts[0] && accepts.slice(1).every(accepts => !accepts));
        }
        /**
         * @returns A boolean value that indicates whether a final state
         * can be reached from the specified state.
         */
        isStateLive(stateId) {
            const reachable = [stateId];
            for (let i = -1; ++i < reachable.length;) {
                const currentStateId = reachable[i];
                if (this.finals.has(currentStateId))
                    return true;
                if (this.transitions.has(currentStateId)) {
                    const transitionState = this.transitions.acquire(currentStateId);
                    for (const symbol of transitionState.eachSymbol()) {
                        const next = this.transitions.acquire(currentStateId, symbol);
                        if (!reachable.includes(next))
                            reachable.push(next);
                    }
                }
            }
            return false;
        }
        /**
         * An Fsm is empty if it recognises no strings. An Fsm may be arbitrarily
         * complicated and have arbitrarily many final states while still recognising
         * no strings because those final states may all be inaccessible from the
         * initial state. Equally, an Fsm may be non-empty despite having an empty
         * alphabet if the initial state is final.
         */
        isEmpty() {
            return !this.isStateLive(this.initial);
        }
        /**
         * Generate strings (lists of symbols) that this Fsm accepts. Since there may
         * be infinitely many of these we use a generator instead of constructing a
         * static list. Strings will be sorted in order of length and then lexically.
         * This procedure uses arbitrary amounts of memory but is very fast. There
         * may be more efficient ways to do this, that I haven't investigated yet.
         * You can use this in list comprehensions.
         */
        *eachString() {
            "Not implemented";
            debugger;
            yield "";
        }
        /**
         * @returns A boolean value that indicates whether the act of merging
         * this Fsm instance with the Fsm instance supplied in the argument
         * would result in an Fsm instance that accepts no inputs.
         */
        isDiscrepant(other) {
            return this.and(other).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a subset of the inputs accepted by
         * other Fsm instance specified.
         */
        isSubset(other) {
            return this.difference(other).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a proper subset of the inputs
         * accepted by other Fsm instance specified.
         */
        isProperSubset(other) {
            return this.difference(other).isEmpty() && this.unequivalent(other);
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a superset of the inputs accepted
         * by other Fsm instance specified.
         */
        isSuperset(other) {
            return other.difference(this).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a proper superset of the inputs
         * accepted by other Fsm instance specified.
         */
        isProperSuperset(other) {
            return other.difference(this).isEmpty() && other.unequivalent(this);
        }
        /**
         * Compute the Brzozowski derivative of this Fsm with respect to the input
         * string of symbols. <https://en.wikipedia.org/wiki/Brzozowski_derivative>
         * If any of the symbols are not members of the alphabet, that's a KeyError.
         * If you fall into oblivion, then the derivative is an Fsm accepting no
         * strings.
         *
         * @returns A new Fsm instance with the computed characteristics.
         */
        derive(input) {
            let stateId = this.initial;
            for (const char of input) {
                const symbol = (() => {
                    if (this.alphabet.has(char)) {
                        if (!this.alphabet.hasWildcard)
                            throw new Error(char);
                        return Truth.Alphabet.wildcard;
                    }
                    return char;
                })();
                if (!this.transitions.has(stateId, symbol))
                    return Oblivion;
                stateId = this.transitions.acquire(stateId, symbol);
            }
            return new Fsm(this.alphabet, this.states, stateId, this.finals, this.transitions.clone());
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            return [
                "alphabet = " + this.alphabet.toString(),
                "states = " + Array.from(this.states).join(),
                "inital = " + this.initial,
                "finals = " + Array.from(this.finals).join(),
                "transitions = " + this.transitions.toString()
            ].join("\n");
        }
    }
    Truth.Fsm = Fsm;
    /**
     * Utility function to prepend an Fsm instance to an Fsm array.
     */
    function prependFsm(fsm, fsms) {
        return [fsm].concat(...fsms);
    }
    /**
     * Crawl several Fsms in parallel, mapping the states of a larger meta-Fsm.
     * To determine whether a state in the larger Fsm is final, pass all of the
     * finality statuses (e.g. [true, false, false] to testFn.
     */
    function crawlParallel(fsms, testFn) {
        const initial = new Truth.Guide();
        for (const [index, fsm] of fsms.entries())
            initial.add(index, fsm.initial);
        /**
         * Dedicated function accepts a "superset" and returns the next "superset"
         * obtained by following this transition in the new Fsm.
         */
        const followFn = (guide, symbol) => {
            const next = new Truth.Guide();
            for (const [index, fsm] of fsms.entries()) {
                const stateId = guide.get(index);
                if (stateId === null || stateId === undefined)
                    continue;
                const substateId = fsm.transitions.get(stateId);
                if (substateId === undefined)
                    continue;
                const alpha = fsm.alphabet;
                const actualSymbol = alpha.has(symbol) && alpha.hasWildcard() ?
                    Truth.Alphabet.wildcard :
                    symbol;
                if (substateId.has(actualSymbol))
                    next.add(index, fsm.transitions.get(stateId, actualSymbol));
            }
            if (next.size === 0)
                return Oblivion;
            return next;
        };
        /**
         * Determine the "is final?" condition of each substateId, then pass it to the
         * test to determine finality of the overall Fsm.
         */
        const finalFn = (guide) => {
            const accepts = [];
            for (const [idx, fsm] of fsms.entries()) {
                const substateId = guide.get(idx);
                if (substateId !== null && substateId !== undefined)
                    accepts.push(guide.has(idx) && fsm.finals.has(substateId));
            }
            return testFn(accepts);
        };
        const alphabets = fsms.map(fsm => fsm.alphabet);
        const alphabet = new Truth.AlphabetBuilder(...alphabets).toAlphabet();
        return crawl(alphabet, initial, finalFn, followFn).reduce();
    }
    /**
     * Given the above conditions and instructions, crawl a new unknown Fsm,
     * mapping its states, final states and transitions. Return the new Fsm.
     */
    function crawl(alphabet, initial, finalFn, followFn) {
        const debugLines = [];
        const guides = [initial];
        const finals = new Set();
        const transitions = new Truth.MutableTransitionMap();
        // Iterate over a growing list
        for (const [i, guide] of guides.entries()) {
            // Add to finals
            if (finalFn(guide))
                finals.add(i);
            // Compute transitions for this state
            transitions.initialize(i);
            for (const symbol of alphabet) {
                const next = followFn(guide, symbol);
                if (next !== Oblivion) {
                    let nextIdx = guides.findIndex(guide => guide.equals(next));
                    if (nextIdx < 0) {
                        nextIdx = guides.length;
                        guides.push(next);
                    }
                    transitions.set(i, symbol, nextIdx);
                    debugLines.push(next.toString());
                }
            }
        }
        return new Fsm(alphabet, new Set(Array(guides.length).keys()), 0, finals, transitions);
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Translates Pattern instances into a corresponding Fsm.
     */
    class FsmTranslator {
        /** */
        static exec(units) {
            for (const unit of units) {
                if (unit instanceof Truth.RegexSet) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexGroup) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexGrapheme) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexSign) {
                    throw Truth.Exception.notImplemented();
                }
                else
                    throw Truth.Exception.unknownState();
            }
            return null;
        }
        /** */
        static translateSet(set, alpha = null) {
        }
        /** */
        static translateGroup(group, alpha = null) {
            const builder = alpha || new Truth.AlphabetBuilder().addWild();
        }
        /** */
        static createGroupAlphabet(group) {
            const builder = new Truth.AlphabetBuilder();
            builder.addWild();
            for (const element of group.cases) {
                throw Truth.Exception.notImplemented();
            }
        }
        /** */
        static translateGrapheme(grapheme, alpha = null) {
        }
        /** */
        static translateSign(sign, alpha = null) {
        }
    }
    Truth.FsmTranslator = FsmTranslator;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages a single Truth document loaded as part of
     * a Program.
     *
     * Truth documents may be loaded from files, or they may be loaded
     * from a string of Truth content directly (see the associated methods
     * in Truth.Program).
     */
    class Document extends Truth.AbstractClass {
        /** */
        constructor(program, sourceUri) {
            super();
            /** @internal */
            this.class = 0 /* document */;
            this._version = Truth.VersionStamp.next();
            /**
             * Stores the complete list of the Document's statements,
             * sorted in the order that they appear in the file.
             */
            this.statements = new Truth.Array1Based();
            this._types = null;
            /**
             * A state variable that stores whether an
             * edit transaction is currently underway.
             */
            this.inEdit = false;
            /**
             * Stores the Reference objects that are having some impact
             * on this document's relationship structure.
             */
            this.referencesReal = [];
            /**
             * Stores an array of Reference objects, where each item the array
             * corresponds to a unique URI-containing Statement objects.
             * Statement objects may not actually be affecting the document's
             * relationship structure, such as in the case when there are multiple
             * statements within this document all referencing the same document,
             * (only one statement would be affecting in this case), or when the
             * referenced document is unavailable for some reason.
             */
            this.referencesRaw = [];
            this._dependencies = [];
            this._dependents = [];
            this.program = program;
            this._uri = sourceUri;
            this.phrase = Truth.Phrase.new(this);
        }
        /**
         * @internal
         * Internal constructor for Document objects.
         * Document objects are created via a Program object.
         */
        static async new(program, fromUri, sourceText, saveFn) {
            const doc = new Document(program, fromUri);
            const uriStatements = [];
            const topLevelStatements = [];
            const topLevelStatementIndexes = [];
            let maxIndent = Number.MAX_SAFE_INTEGER;
            let lineNumber = 0;
            for (const statementText of this.readLines(sourceText)) {
                const smt = new Truth.Statement(doc, statementText);
                doc.statements.push(smt);
                if (smt.uri) {
                    uriStatements.push(smt);
                }
                else if (smt.indent <= maxIndent && !smt.isNoop) {
                    topLevelStatements.push(smt);
                    topLevelStatementIndexes.push(++lineNumber);
                    maxIndent = smt.indent;
                }
            }
            // Calling this function saves the document in the Program instance
            // that invoked this new Document. This is a bit spagetti-ish, but the
            // newly created document has to be in the Program's .documents
            // array, or the updating of references won't work.
            saveFn(doc);
            if (uriStatements.length > 0)
                await doc.updateReferences([], uriStatements);
            program.cause(new Truth.CauseRevalidate(doc, topLevelStatements, topLevelStatementIndexes));
            return doc;
        }
        /**
         * Generator function that yields all statements (unparsed lines)
         * of the given source text.
         */
        static *readLines(source) {
            let cursor = -1;
            let statementStart = 0;
            const char = () => source[cursor];
            for (;;) {
                if (cursor >= source.length - 1)
                    return yield source.slice(statementStart);
                cursor++;
                if (char() === "\n" /* terminal */) {
                    yield source.slice(statementStart, cursor);
                    statementStart = cursor + 1;
                }
            }
        }
        /**
         * Stores the URI from where this document was loaded.
         */
        get uri() {
            return this._uri;
        }
        /**
         * @internal
         * A rolling version stamp that increments after each edit transaction.
         */
        get version() {
            return this._version;
        }
        /**
         * Queries this document for the root-level types.
         *
         * @param uri The URI of the document to query. If the URI contains
         * a type path, it is factored into the search.
         *
         * @param typePath The type path within the document to search.
         *
         * @returns A fully constructed Type instance that corresponds to
         * the type at the URI specified, or null in the case when no type
         * could be found.
         */
        query(...typePath) {
            return this.program.query(this, ...typePath);
        }
        /**
         * Gets the root-level types that are defined within this document.
         */
        get types() {
            if (this._types)
                return this._types;
            return this._types = Object.freeze(this.program.query(this));
        }
        hasFault(faultType, line, termIndex = -1) {
            const comp = termIndex < 0 ?
                [faultType, line] :
                [faultType, line, termIndex];
            const compFault = this.createComparisonFault(comp);
            for (const fault of this.program.faults.each(this))
                if (this.program.faults.compareFaults(compFault, fault) === 0)
                    return true;
            return false;
        }
        hasFaults(...expectations) {
            const faultsReported = Array.from(this.program.faults.each(this));
            if (expectations.length === 0)
                return faultsReported.length > 0;
            if (expectations.length !== faultsReported.length)
                return false;
            const faultsExpected = expectations
                .map(exp => this.createComparisonFault(exp))
                .sort(this.program.faults.compareFaults);
            for (let i = -1; ++i < faultsReported.length;) {
                const rep = faultsReported[i];
                const exp = faultsExpected[i];
                if (this.program.faults.compareFaults(rep, exp) !== 0)
                    return false;
            }
            return true;
        }
        /** */
        createComparisonFault(comp) {
            const smt = this.read(comp[1]);
            if (comp.length === 2)
                return new Truth.Fault(comp[0], smt);
            const nfxLen = smt.infixSpans.length;
            const idx = comp[2];
            const span = nfxLen > 0 && idx === 0 ? smt.spans[0] :
                nfxLen > 0 && idx < nfxLen + 1 ? smt.infixSpans[idx - 1] :
                    smt.spans[idx - nfxLen];
            return new Truth.Fault(comp[0], span);
        }
        /**
         * @returns An array of Statement objects that represent
         * ancestry of the specified statement, or 1-based line number.
         * If the specified statement is not in this document, the
         * returned value is null.
         */
        getAncestry(statement) {
            const smt = this.toStatement(statement);
            // If the statement is root-level, it can't have an ancestry.
            if (smt.indent === 0)
                return [];
            let pos = this.statements.posOf(smt);
            if (pos < 0)
                return null;
            if (pos < 2)
                return [];
            const ancestry = [smt];
            let indentToBeat = smt.indent;
            for (const currentStatement of this.statements.enumerateBackward(pos)) {
                if (currentStatement.isNoop)
                    continue;
                if (currentStatement.indent < indentToBeat) {
                    ancestry.unshift(currentStatement);
                    indentToBeat = currentStatement.indent;
                }
                if (currentStatement.indent === 0)
                    break;
            }
            return ancestry.slice(0, -1);
        }
        /**
         * Gets the parent Statement object of the specified Statement.
         * If the statement is top level, a reference to this document object
         * is returned. If the statement is not found in the document, or the
         * specified statement is a no-op, the returned value is null.
         *
         * @param statement A statement object, or a 1-based line number
         * of a statement within this document.
         */
        getParent(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return null;
            // If the statement is root-level, it can't have a parent.
            if (smt.indent === 0)
                return this;
            let pos = this.statements.posOf(smt);
            if (pos < 0)
                return null;
            // Simple optimization
            if (pos < 2)
                return this;
            const indentToBeat = smt.indent;
            for (const currentStatement of this.statements.enumerateBackward(pos)) {
                if (currentStatement.isNoop)
                    continue;
                if (currentStatement.indent < indentToBeat)
                    return currentStatement;
            }
            // If a parent statement wasn't found, then the
            // input statement is top-level, and a reference
            // to this Document object is returned.
            return this;
        }
        /**
         * @returns The Statement that would act as the parent if a statement where to be
         * inserted at the specified virtual position in the document. If an inserted statement
         * would be top-level, a reference to this document object is returned.
         */
        getParentFromPosition(lineNumber, lineOffset) {
            if (lineNumber === 1 ||
                lineNumber === 0 ||
                lineOffset < 1 ||
                this.statements.length === 0)
                return this;
            for (const smt of this.statements.enumerateBackward(lineNumber))
                if (!smt.isNoop && smt.indent < lineOffset)
                    return smt;
            return this;
        }
        /**
         * @returns The sibling Statement objects of the  specified Statement.
         * If the specified statement is a no-op, the returned value is null.
         * @throws An error in the case when the statement is not found in
         * the document.
         */
        getSiblings(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return null;
            if (smt.indent === 0)
                return this.getChildren();
            const parent = this.getParent(smt);
            if (parent === null)
                return this.getChildren();
            if (parent === this)
                return parent.getChildren();
            return this.getChildren(parent);
        }
        /**
         * @returns The child Statement objects of the specified
         * Statement. If the argument is null or omitted, the
         * document's top-level statements are returned.
         *
         * @throws An error in the case when the specified
         * statement is not found in the document.
         */
        getChildren(statement) {
            const children = [];
            let pos = 1;
            // Stores the indent value that causes the loop
            // to terminate when reached.
            let stopIndent = -1;
            // Stores the indent value the indicates the maximum
            // value at which a statement is still considered to be
            // a child. This value can retract as the algorithm is
            // operating to deal with bizarre (but valid) indentation.
            let maxIndent = Number.MAX_SAFE_INTEGER;
            if (statement) {
                pos = this.statements.posOf(statement);
                if (pos < 0)
                    throw Truth.Exception.statementNotInDocument();
                stopIndent = statement.indent;
                // Start the iteration 1 position after the statement
                // specified, so that we're always passing through
                // potential children.
                pos++;
            }
            for (const smt of this.statements.enumerateForward(pos)) {
                if (smt.isNoop)
                    continue;
                // Check if we need to back up the indentation of child statements, 
                // in order to deal with bizarre (but valid) indentation.
                if (smt.indent < maxIndent)
                    maxIndent = smt.indent;
                if (smt.indent <= stopIndent)
                    break;
                if (smt.indent <= maxIndent)
                    children.push(smt);
            }
            return children;
        }
        /**
         * @returns A boolean value that indicates whether the specified
         * statement, or the statement at the specified index has any
         * descendants. If the argument is null, the returned value is a
         * boolean indicating whether this document has any non-noop
         * statements.
         */
        hasDescendants(statement) {
            if (statement === null) {
                for (const smt of this.statements.enumerateForward())
                    if (!smt.isNoop)
                        return true;
            }
            else {
                const smt = statement instanceof Truth.Statement ?
                    statement :
                    this.statements.get(statement);
                if (smt.isNoop)
                    return false;
                let idx = statement instanceof Truth.Statement ?
                    this.statements.posOf(statement) :
                    statement;
                for (const currentStatement of this.statements.enumerateForward(idx + 1)) {
                    if (currentStatement.isNoop)
                        continue;
                    return currentStatement.indent > smt.indent;
                }
            }
            return false;
        }
        /**
         * @returns The 1-based line number of the specified statement in
         * the document, relying on caching when available. If the statement
         * does not exist in the document, the returned value is -1.
         */
        lineNumberOf(statement) {
            return this.statements.posOf(statement);
        }
        /**
         * @returns An array of strings containing the content
         * written in the comments directly above the specified
         * statement. Whitespace lines are ignored. If the specified
         * statement is a no-op, an empty array is returned.
         */
        getNotes(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return [];
            const lineNum = this.lineNumberOf(smt);
            if (lineNum < 1)
                return [];
            const commentLines = [];
            const requiredIndent = smt.indent;
            for (const currentStatement of this.statements.enumerateBackward(lineNum)) {
                if (currentStatement.isWhitespace)
                    continue;
                const commentText = currentStatement.getCommentText();
                if (commentText === null)
                    break;
                if (currentStatement.indent !== requiredIndent)
                    break;
                commentLines.push(commentText);
            }
            return commentLines;
        }
        /**
         * Enumerates through each statement that is a descendant of the
         * specified statement. If the parameters are null or omitted, all
         * statements in this Document are yielded.
         *
         * The method yields an object that contains the yielded statement,
         * as well as a numeric level value that specifies the difference in
         * the number of nesting levels between the specified initialStatement
         * and the yielded statement.
         *
         * @param initialStatement A reference to the statement object
         * from where the enumeration should begin.
         *
         * @param includeInitial A boolean value indicating whether or
         * not the specified initialStatement should also be returned
         * as an element in the enumeration. If true, initialStatement
         * must be non-null.
         */
        *eachDescendant(initialStatement = undefined, includeInitial) {
            if (includeInitial) {
                if (!initialStatement)
                    throw Truth.Exception.invalidArgument();
                yield { statement: initialStatement, level: 0 };
            }
            const initialChildren = this.getChildren(initialStatement);
            if (!initialChildren)
                return;
            const self = this;
            // The initial level is 0 if the specified initialStatement is
            // null, because it indicates that the enumeration starts
            // at the root of the document.
            let level = initialStatement ? 1 : 0;
            function* recurse(statement) {
                yield { statement, level };
                level++;
                for (const childStatement of self.getChildren(statement) || [])
                    yield* recurse(childStatement);
                level--;
            }
            for (const statement of initialChildren)
                yield* recurse(statement);
        }
        /**
         * Enumerates through each statement in the document,
         * including comments and whitespace-only lines, starting
         * at the specified statement or numeric position.
         *
         * @yields The statements in the order that they appear
         * in the document, excluding whitespace-only statements.
         */
        *eachStatement(statement) {
            const startPos = (() => {
                if (!statement)
                    return 1;
                if (statement instanceof Truth.Statement)
                    return this.statements.posOf(statement);
                return statement;
            })();
            for (const smt of this.statements.enumerateForward(startPos))
                yield smt;
        }
        /**
         * Reads the Statement at the given 1-based line number.
         * Negative numbers read Statement starting from the end of the document.
         */
        read(lineNumber) {
            return this.statements.get(lineNumber);
        }
        /**
         * Convenience method that converts a statement or it's index
         * within this document to a statement object.
         */
        toStatement(statementOrIndex) {
            return statementOrIndex instanceof Truth.Statement ?
                statementOrIndex :
                this.read(statementOrIndex);
        }
        /**
         * Starts an edit transaction in the specified callback function.
         * Edit transactions are used to synchronize changes made in
         * an underlying file, typically done by a user in a text editing
         * environment. System-initiated changes such as automated
         * fixes, refactors, or renames do not go through this pathway.
         *
         * @param editFn The callback function in which to perform
         * document mutation operations.
         *
         * @returns A promise that resolves any external document
         * references added during the edit operation have been resolved.
         * If no such references were added, a promise is returned that
         * resolves immediately.
         */
        async edit(editFn) {
            if (this.inEdit)
                throw Truth.Exception.doubleTransaction();
            this.inEdit = true;
            const calls = [];
            let hasDelete = false;
            let hasInsert = false;
            let hasUpdate = false;
            editFn({
                delete: (pos = -1, count = 1) => {
                    if (count > 0) {
                        calls.push(new Truth.DeleteCall(pos, count));
                        hasDelete = true;
                    }
                },
                insert: (text, pos = -1) => {
                    calls.push(new Truth.InsertCall(new Truth.Statement(this, text), pos));
                    hasInsert = true;
                },
                update: (text, pos = -1) => {
                    if (this.read(pos).sourceText !== text) {
                        calls.push(new Truth.UpdateCall(new Truth.Statement(this, text), pos));
                        hasUpdate = true;
                    }
                }
            });
            if (calls.length === 0) {
                this.inEdit = false;
                return;
            }
            const deletedUriSmts = [];
            const addedUriSmts = [];
            // Begin the algorithm that determines the changeset,
            // and runs the appropriate invalidation and revalidation
            // hooks. This is wrapped in an IIFE because we need to
            // perform finalization at the bottom (and there are early
            // return points throughout the algorithm.
            (() => {
                const hasMixed = hasInsert && hasUpdate ||
                    hasInsert && hasDelete ||
                    hasUpdate && hasDelete;
                const doDelete = (call) => {
                    const smts = this.statements.splice(call.pos, call.count);
                    for (const smt of smts) {
                        smt.dispose();
                        if (smt.uri)
                            deletedUriSmts.push(smt);
                    }
                    return smts;
                };
                const doInsert = (call) => {
                    this.statements.splice(call.pos, 0, call.smt);
                    if (call.smt.uri)
                        addedUriSmts.push(call.smt);
                };
                const doUpdate = (call) => {
                    const existing = this.statements.get(call.pos);
                    if (existing.uri)
                        deletedUriSmts.push(existing);
                    this.statements.set(call.pos, call.smt);
                    if (call.smt.uri)
                        addedUriSmts.push(call.smt);
                    existing.dispose();
                };
                if (!hasMixed) {
                    // This handles the first optimization, which is the case where
                    // the only kinds of mutations where updates, and no structural
                    // changes occured. This handles typical "user is typing" cases.
                    // Most edits will be caught here.
                    if (hasUpdate) {
                        // Sort the update calls by their index, and prune updates
                        // that would be overridden in a following call.
                        const updateCallsTyped = calls;
                        const updateCalls = updateCallsTyped
                            .sort((a, b) => a.pos - b.pos)
                            .filter((call, i) => i >= calls.length - 1 || call.pos !== calls[i + 1].pos);
                        const oldStatements = updateCalls.map(c => this.statements.get(c.pos));
                        const newStatements = updateCalls.map(c => c.smt);
                        const indexes = Object.freeze(updateCalls.map(c => c.pos));
                        const noStructuralChanges = oldStatements.every((oldSmt, idx) => {
                            const newSmt = newStatements[idx];
                            return oldSmt.indent === newSmt.indent ||
                                oldSmt.isNoop && newSmt.isNoop;
                        });
                        if (noStructuralChanges) {
                            const hasOpStatements = oldStatements.some(smt => !smt.isNoop) ||
                                newStatements.some(smt => !smt.isNoop);
                            if (hasOpStatements) {
                                // Tell subscribers to blow away all the old statements.
                                this.program.cause(new Truth.CauseInvalidate(this, oldStatements, indexes));
                            }
                            // Run the actual mutations
                            for (const updateCall of updateCalls)
                                doUpdate(updateCall);
                            if (hasOpStatements) {
                                // Tell subscribers what changed
                                this.program.cause(new Truth.CauseRevalidate(this, newStatements, indexes));
                            }
                            return;
                        }
                    }
                    // This handles the second optimization, which is the case where
                    // only deletes occured, and none of the deleted statements have any
                    // descendants. This will handle the majority of "delete a line" cases.
                    if (hasDelete) {
                        const deleteCalls = calls;
                        const deadStatements = [];
                        const deadIndexes = [];
                        let hasOpStatements = false;
                        forCalls: for (const deleteCall of deleteCalls) {
                            for (let i = -1; ++i < deleteCall.count;) {
                                const deadSmt = this.statements.get(deleteCall.pos + i);
                                if (this.hasDescendants(deadSmt)) {
                                    deadStatements.length = 0;
                                    break forCalls;
                                }
                                deadStatements.push(deadSmt);
                                deadIndexes.push(i);
                                if (!deadSmt.isNoop)
                                    hasOpStatements = true;
                            }
                        }
                        if (deadStatements.length > 0) {
                            // Tell subscribers to blow away all the old statements.
                            // An edit transaction can be avoided completely in the case
                            // when the only statements that were deleted were noops.
                            if (hasOpStatements)
                                this.program.cause(new Truth.CauseInvalidate(this, deadStatements, deadIndexes));
                            // Run the actual mutations
                            deleteCalls.forEach(doDelete);
                            // Run an empty revalidation hook, to comply with the
                            // rule that for every invalidation hook, there is always a
                            // corresponding revalidation hook.
                            if (hasOpStatements)
                                this.program.cause(new Truth.CauseRevalidate(this, [], []));
                            return;
                        }
                    }
                    // This handles the third optimization, which is the case
                    // where there are only noop statements being inserted
                    // into the document.
                    if (hasInsert) {
                        const insertCalls = calls;
                        if (insertCalls.every(call => call.smt.isNoop)) {
                            insertCalls.forEach(doInsert);
                            return;
                        }
                    }
                }
                // At this point, the checks to see if we can get away with
                // performing simplistic updates have failed. So we need
                // to resort to invalidating and revalidating larger swaths 
                // of statements.
                // Stores an array of statements whose descendant statements
                // should be invalidated. 
                const invalidatedParents = new Map();
                // Stores a value indicating whether the entire document
                // needs to be invalidated.
                let mustInvalidateDoc = false;
                // The first step is to go through all the statements, and compute the 
                // set of parent statements from where invalidation should originate.
                // In the majority of cases, this will only be one single statement object.
                for (const call of calls) {
                    if (call instanceof Truth.DeleteCall) {
                        const deletedStatement = this.statements.get(call.pos);
                        if (deletedStatement.isNoop)
                            continue;
                        const parent = this.getParent(call.pos);
                        if (parent instanceof Truth.Statement) {
                            invalidatedParents.set(call.pos, parent);
                        }
                        else if (parent instanceof Document) {
                            mustInvalidateDoc = true;
                            break;
                        }
                        else
                            throw Truth.Exception.unknownState();
                    }
                    else {
                        if (call instanceof Truth.InsertCall) {
                            if (call.smt.isNoop)
                                continue;
                        }
                        else if (call instanceof Truth.UpdateCall) {
                            const oldStatement = this.statements.get(call.pos);
                            if (oldStatement.isNoop && call.smt.isNoop)
                                continue;
                        }
                        const parent = this.getParentFromPosition(call.pos, call.smt.indent);
                        if (parent instanceof Truth.Statement) {
                            invalidatedParents.set(call.pos, parent);
                        }
                        else if (parent === this) {
                            mustInvalidateDoc = true;
                            break;
                        }
                    }
                }
                // Although unclear how this could happen, if there
                // are no invalidated parents, we can safely return.
                if (!mustInvalidateDoc && invalidatedParents.size === 0)
                    return;
                // Prune any redundant parents. A parent is redundant
                // when it's a descendant of another parent in the 
                // invalidation array. The algorithm below compares the
                // statement ancestries of each possible pairs of invalidated
                // parents, and splices invalidated parents out of the 
                // array in the case when the parent is parented by some
                // other invalidated parent in the invalidatedParents array.
                const invalidatedAncestries = [];
                for (const line of invalidatedParents.keys()) {
                    const ancestry = this.getAncestry(line);
                    if (ancestry)
                        invalidatedAncestries.push(ancestry);
                }
                if (invalidatedAncestries.length > 1) {
                    for (let i = invalidatedAncestries.length; i--;) {
                        const ancestryA = invalidatedAncestries[i];
                        for (let n = i; n--;) {
                            const ancestryB = invalidatedAncestries[n];
                            if (ancestryA.length === ancestryB.length)
                                continue;
                            const aLessB = ancestryA.length < ancestryB.length;
                            const ancestryShort = aLessB ? ancestryA : ancestryB;
                            const ancestryLong = aLessB ? ancestryB : ancestryA;
                            if (ancestryShort.every((smt, idx) => smt === ancestryLong[idx]))
                                invalidatedAncestries.splice(aLessB ? n : i, 1);
                        }
                    }
                }
                const parents = mustInvalidateDoc ? [] : Array.from(invalidatedParents.values());
                const indexes = mustInvalidateDoc ? [] : Array.from(invalidatedParents.keys());
                // Notify observers of the Invalidate hook to invalidate the
                // descendants of the specified set of parent statements.
                this.program.cause(new Truth.CauseInvalidate(this, parents, indexes));
                const deletedStatements = [];
                // Perform the document mutations.
                for (const call of calls) {
                    if (call instanceof Truth.DeleteCall)
                        deletedStatements.push(...doDelete(call));
                    else if (call instanceof Truth.InsertCall)
                        doInsert(call);
                    else if (call instanceof Truth.UpdateCall)
                        doUpdate(call);
                }
                // Remove any deleted statements from the invalidatedParents map
                for (const deletedStatement of deletedStatements)
                    for (const [at, parentStatement] of invalidatedParents)
                        if (deletedStatement === parentStatement)
                            invalidatedParents.delete(at);
                // Notify observers of the Revalidate hook to update the
                // descendants of the specified set of parent statements.
                this.program.cause(new Truth.CauseRevalidate(this, Array.from(invalidatedParents.values()), Array.from(invalidatedParents.keys())));
            })();
            // Perform a debug-time check to be sure that there are
            // no disposed statements left hanging around in the document
            // after the edit transaction has completed.
            if ("DEBUG")
                for (const smt of this.statements.enumerateForward())
                    if (smt.isDisposed)
                        throw Truth.Exception.unknownState();
            // Clean out any type cache
            this._types = null;
            // Tell subscribers that the edit transaction completed.
            this.program.cause(new Truth.CauseEditComplete(this));
            this._version = Truth.VersionStamp.next();
            this.inEdit = false;
            if (addedUriSmts.length + deletedUriSmts.length > 0)
                await this.updateReferences(deletedUriSmts, addedUriSmts);
        }
        /**
         * Executes a complete edit transaction, applying the series
         * of edits specified in the `edits` parameter.
         *
         * @returns A promise that resolves any external document
         * references added during the edit operation have been resolved.
         * If no such references were added, a promise is returned that
         * resolves immediately.
         */
        async editAtomic(edits) {
            return this.edit(statements => {
                for (const editInfo of edits) {
                    if (!editInfo.range)
                        throw new TypeError("No range included.");
                    const startLine = editInfo.range.startLineNumber;
                    const endLine = editInfo.range.endLineNumber;
                    const startChar = editInfo.range.startColumn;
                    const endChar = editInfo.range.endColumn;
                    const startLineText = this.read(startLine).sourceText;
                    const endLineText = this.read(endLine).sourceText;
                    const prefixSegment = startLineText.slice(0, startChar);
                    const suffixSegment = endLineText.slice(endChar);
                    const segments = editInfo.text.split("\n");
                    const pastCount = endLine - startLine + 1;
                    const presentCount = segments.length;
                    const deltaCount = presentCount - pastCount;
                    // Detect the pure update cases
                    if (deltaCount === 0) {
                        if (pastCount === 1) {
                            statements.update(prefixSegment + editInfo.text + suffixSegment, startLine);
                        }
                        else {
                            statements.update(prefixSegment + segments[0], startLine);
                            for (let i = startLine; i <= endLine; i++) {
                                statements.update(prefixSegment + segments[i] + suffixSegment, startLine);
                            }
                            statements.update(segments.slice(-1)[0] + suffixSegment, endLine);
                        }
                        continue;
                    }
                    // Detect the pure delete cases
                    if (deltaCount < 0) {
                        const deleteCount = deltaCount * -1;
                        // Detect a delete ranging from the end of 
                        // one line, to the end of a successive line
                        if (startChar === startLineText.length)
                            if (endChar === endLineText.length) {
                                statements.delete(startLine + 1, deleteCount);
                                continue;
                            }
                        // Detect a delete ranging from the start of
                        // one line to the start of a successive line
                        if (startChar + endChar === 0) {
                            statements.delete(startLine, deleteCount);
                            continue;
                        }
                    }
                    // Detect the pure insert cases
                    if (deltaCount > 0) {
                        // Cursor is at the end of the line, and the first line of the 
                        // inserted content is empty (most likely, enter was pressed)						
                        if (startChar === startLineText.length && segments[0] === "") {
                            for (let i = 0; ++i < segments.length;)
                                statements.insert(segments[i], startLine + i);
                            continue;
                        }
                        // Cursor is at the beginning of the line, and the
                        // last line of the inserted content is empty.
                        if (startChar === 0 && segments.slice(-1)[0] === "") {
                            for (let i = -1; ++i < segments.length - 1;)
                                statements.insert(segments[i], startLine + i);
                            continue;
                        }
                    }
                    // This is the "fallback" behavior -- simply delete everything
                    // that is old, and insert everything that is new.
                    const deleteCount = endLine - startLine + 1;
                    statements.delete(startLine, deleteCount);
                    const insertLines = segments.slice();
                    insertLines[0] = prefixSegment + insertLines[0];
                    insertLines[insertLines.length - 1] += suffixSegment;
                    for (let i = -1; ++i < insertLines.length;)
                        statements.insert(insertLines[i], startLine + i);
                }
            });
        }
        /**
         *
         */
        async updateReferences(deleted, added) {
            // This algorithm always performs all deletes before adds.
            // For this reason, if a URI is both in the list of deleted URIs
            // as well as the list of added URIs, it means that the URI
            // started in the document, and is currently still there.
            var e_1, _a;
            var _b, _c;
            const rawRefsExisting = this.referencesRaw.slice();
            const rawRefsToAdd = [];
            const rawRefsToDelete = [];
            // The faults that are generated are stored in an array,
            // so that they can all be reported at once at the end.
            // This is because this method is async, and it's important
            // that all the faults are reported in the same turn of
            // the event loop.
            const faults = [];
            // Delete old URI statements from the array.
            for (const del of deleted) {
                const idx = rawRefsExisting.findIndex(v => v.statement === del);
                if (idx > -1)
                    rawRefsToDelete.push(rawRefsExisting.splice(idx, 1)[0]);
            }
            if ("DEBUG")
                if (deleted.length !== rawRefsToDelete.length)
                    throw Truth.Exception.unknownState();
            try {
                // Populate addedReferences array. This loop blindly attempts to load
                // all referenced documents, regardless of whether there's going to be
                // some fault generated as a result of attempting to establish a reference
                // to the document.
                for (var added_1 = __asyncValues(added), added_1_1; added_1_1 = await added_1.next(), !added_1_1.done;) {
                    const smt = added_1_1.value;
                    let refDoc = null;
                    // Bail if a document loaded from HTTP is trying to reference
                    // a document located on the file system.
                    const isToFile = smt.uri.protocol === Truth.UriProtocol.file;
                    const thisProto = this.uri.protocol;
                    if (isToFile && (thisProto === Truth.UriProtocol.http || thisProto === Truth.UriProtocol.https)) {
                        faults.push(Truth.Faults.InsecureResourceReference.create(smt));
                    }
                    else {
                        refDoc = this.program.getDocumentByUri(smt.uri);
                        if (!refDoc)
                            refDoc = await this.program.addDocumentFromUri(smt.uri);
                    }
                    // This is cheating a bit. It's unclear how this could result in an error
                    // at this point, or what to do if it did.
                    if (refDoc instanceof Error) {
                        refDoc = null;
                        faults.push(Truth.Faults.UnresolvedResource.create(smt));
                    }
                    rawRefsToAdd.push(new Truth.Reference(smt, refDoc));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (added_1_1 && !added_1_1.done && (_a = added_1.return)) await _a.call(added_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if ("DEBUG")
                if (added.length !== rawRefsToAdd.length)
                    throw Truth.Exception.unknownState();
            const toReferenceTuples = (refs) => refs.map(v => [this.lineNumberOf(v.statement), v]);
            const rawRefsProposed = [
                ...toReferenceTuples(rawRefsExisting),
                ...toReferenceTuples(rawRefsToAdd)
            ]
                .sort(([numA], [numB]) => numB - numA)
                .map(([num, ref]) => ref);
            const realRefs = [];
            const rawRefDocuments = rawRefsProposed.map(v => v.target);
            for (const [idx, doc] of rawRefDocuments.entries()) {
                if (!doc)
                    continue;
                if (rawRefDocuments.indexOf(doc) !== idx) {
                    const smt = rawRefsProposed[idx].statement;
                    faults.push(Truth.Faults.DuplicateReference.create(smt));
                }
                else {
                    realRefs.push(rawRefsProposed[idx]);
                }
            }
            const realRefsDeleted = this.referencesReal.filter(v => !realRefs.includes(v));
            const realRefsAdded = realRefs.filter(v => !this.referencesReal.includes(v));
            this.referencesRaw.length = 0;
            this.referencesRaw.push(...rawRefsProposed);
            this.referencesReal.length = 0;
            this.referencesReal.push(...realRefs);
            this._dependencies.length = 0;
            this._dependencies.push(...realRefs
                .map(v => v.target)
                .filter((v) => !!v));
            for (const ref of realRefsAdded) {
                const dependents = (_b = ref.target) === null || _b === void 0 ? void 0 : _b._dependents;
                if (dependents && !dependents.includes(this))
                    dependents.push(this);
            }
            for (const ref of realRefsDeleted) {
                const dependents = (_c = ref.target) === null || _c === void 0 ? void 0 : _c._dependents;
                if (dependents)
                    for (let i = dependents.length; i-- > 0;)
                        if (dependents[i] === this)
                            dependents.splice(i, 1);
            }
            let hasCircularFaults = false;
            for (const refDeleted of realRefsDeleted)
                if (this.program.cycleDetector.didDelete(refDeleted.statement))
                    hasCircularFaults = true;
            for (const refAdded of realRefsAdded)
                if (this.program.cycleDetector.didAdd(refAdded.statement))
                    hasCircularFaults = true;
            for (const fault of faults)
                this.program.faults.report(fault);
            if (faults.length || hasCircularFaults)
                this.program.faults.refresh();
            // TODO: Broadcast the added and removed dependencies to external
            // observers (outside the compiler). Make sure to broadcast only the
            // change in dependencies, not the change in references (which are different)
            // Implementing this will require a re-working of the cause system.
        }
        /**
         * (Not implemented)
         *
         * Updates this document's sourceUri with the new URI specified.
         * The value specified may be a relative URI, in which case, the final
         * URI will be made relative to this document.
         *
         * @throws An error in the case when a document has been loaded
         * into the Program that is already associated with the URI specified,
         * or when the value specified could not be parsed.
         */
        updateUri(newValue) {
            const newUri = Truth.KnownUri.fromString(newValue, this._uri);
            if (newUri === null)
                throw Truth.Exception.invalidUri(newValue);
            const existing = this.program.getDocumentByUri(newUri);
            if (existing)
                throw Truth.Exception.uriAlreadyExists();
            if (newUri.protocol !== this._uri.protocol)
                throw Truth.Exception.uriProtocolsMustMatch();
            const wasUri = this._uri;
            this._uri = newUri;
            for (const doc of this.program.documents)
                doc.didUpdateUri(this, wasUri);
        }
        /** */
        didUpdateUri(affectedDoc, was) {
            const newlyBrokenRaw = [];
            const newlyTargetedRaw = [];
            for (const ref of this.referencesRaw) {
                if (ref.statement.uri === was)
                    newlyBrokenRaw.push(ref);
                else if (ref.statement.uri === affectedDoc._uri)
                    newlyTargetedRaw.push(ref);
            }
            if (newlyBrokenRaw.length + newlyTargetedRaw.length === 0)
                return;
            throw Truth.Exception.notImplemented();
        }
        /**
         * Gets an array containing the other documents that this document has
         * as a dependency.
         *
         * Because circular document relationships are storable at the Document
         * level, performing a deep traversal on these dependencies is considered an
         * unsafe operation, due to the possibility of generating a stack overflow.
         *
         * To perform a deep traversal on document dependencies, considering
         * using the .traverseDependencies() method.
         */
        get dependencies() {
            return this._dependencies;
        }
        /**
         * Gets an array containing the other documents that depend on this
         * document.
         *
         * Because circular document relationships are storable at the Document
         * level, performing a deep traversal on these dependents is considered an
         * unsafe operation, due to the possibility of generating a stack overflow.
         */
        get dependents() {
            return this._dependents;
        }
        /** @internal */
        getStatementCausingDependency(dependency) {
            for (const ref of this.referencesReal)
                if (ref.target === dependency)
                    return ref.statement;
            return null;
        }
        /**
         * Performs a depth-first traversal on this Document's dependency structure.
         * The traversal pattern avoids following infinite loops due to circular dependencies.
         */
        *traverseDependencies() {
            const self = this;
            const yielded = [];
            function* recurse(doc) {
                if (doc === self)
                    return;
                if (!yielded.includes(doc)) {
                    yielded.push(doc);
                    yield doc;
                }
                for (const dependency of doc._dependencies)
                    yield* recurse(dependency);
            }
            ;
            for (const dependency of this._dependencies)
                yield* recurse(dependency);
        }
        /**
         * Returns a formatted version of the Document.
         */
        toString(keepOriginalFormatting) {
            const lines = [];
            if (keepOriginalFormatting) {
                for (const statement of this.statements.enumerateForward())
                    lines.push(statement.sourceText);
            }
            else
                for (const { statement, level } of this.eachDescendant()) {
                    const indent = "\t" /* tab */.repeat(level);
                    lines.push(indent + statement.toString());
                }
            return lines.join("\n");
        }
    }
    Truth.Document = Document;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** @internal */
    class InsertCall {
        constructor(smt, pos) {
            this.smt = smt;
            this.pos = pos;
        }
    }
    Truth.InsertCall = InsertCall;
    /** @internal */
    class UpdateCall {
        constructor(smt, pos) {
            this.smt = smt;
            this.pos = pos;
        }
    }
    Truth.UpdateCall = UpdateCall;
    /** @internal */
    class DeleteCall {
        constructor(pos, count) {
            this.pos = pos;
            this.count = count;
        }
    }
    Truth.DeleteCall = DeleteCall;
    /**
     * @internal
     * A class that stores information about a reference established by
     * one document (via a Statement) to another document.
     */
    class Reference extends Truth.AbstractClass {
        constructor(statement, target) {
            super();
            this.statement = statement;
            this.target = target;
            /** @internal */
            this.class = 2 /* reference */;
        }
    }
    Truth.Reference = Reference;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A class that detects circular relationships between
     * inter-referencing documents, and handles the reporting
     * and resolution of the necessary faults when circular
     * relationships are detected and resolved.
     * Instances of this class are owned by a Program instance,
     * and each Program owns exactly one CycleDetector.
     */
    class CycleDetector {
        constructor(program) {
            this.program = program;
            /**
             * Stores the array of cycles that were discovered in the program.
             */
            this.cycles = [];
        }
        /**
         * Informs the CycleDetector that a referentially-significant
         * statement (meaning that it was having an effect on the graph
         * of  connected documents) was deleted from a document.
         *
         * @returns A boolean value indicating whether faults were
         * reported to the FaultService.
         */
        didDelete(statement) {
            let hasFaults = false;
            for (let i = this.cycles.length; i-- > 0;) {
                const faults = this.cycles[i];
                if (faults.map(v => v.statement).includes(statement)) {
                    this.cycles.splice(i, 1);
                    for (const fault of faults)
                        this.program.faults.resolveManual(fault);
                    hasFaults = true;
                }
            }
            return hasFaults;
        }
        /**
         * Informs the CycleDetector that a referentially-significant
         * statement (meaning that it was having an effect on the graph
         * of  connected documents) was added to a document.
         *
         * @returns A boolean value indicating whether faults were
         * reported to the FaultService.
         */
        didAdd(statement) {
            let hasFaults = false;
            const startingDocument = statement.document;
            // The algorithm tracks the documents that have been visited,
            // and terminates the traversal when visited documents are
            // discovered. This is to prevent stack overflows.
            const visited = [];
            // The output of the recurse function below is a series of document
            // pairs, where the first document contains the statement that is
            // responsible for the introduction of the reference, and the second
            // document is the one being targetted by said reference. 
            const discoveredDocPairs = [];
            // While the recurse function is operating, it keeps track of a stack
            // of pairs (roughly corresponding to the call stack of the recurse
            // function). The stack is then copied to the discoveredDocPairs
            // array in the case that the stack is found to be a circular relationship.
            const stackPairs = [];
            const recurse = (srcDoc, dstDoc) => {
                // Don't follow previously visited destination documents.
                if (visited.includes(dstDoc))
                    return;
                // Found a cycle, add any new cyclical contributors
                // found in the current stack to the array.
                if (dstDoc === startingDocument) {
                    const pair = stackPairs.slice();
                    pair.push([srcDoc, dstDoc]);
                    discoveredDocPairs.push(pair);
                    visited.push(dstDoc);
                    return;
                }
                stackPairs.push([srcDoc, dstDoc]);
                for (const dependencyDoc of dstDoc.dependencies)
                    recurse(dstDoc, dependencyDoc);
                stackPairs.pop();
            };
            for (const dependency of startingDocument.dependencies)
                recurse(statement.document, dependency);
            // The discoveredDocPairs array is converted into a proper cycle,
            // (an array of faults), before being stored.
            for (const cyclePair of discoveredDocPairs) {
                const faults = [];
                for (const [srcDoc, dstDoc] of cyclePair) {
                    const smt = srcDoc.getStatementCausingDependency(dstDoc);
                    if (smt) {
                        const fault = Truth.Faults.CircularResourceReference.create(smt);
                        faults.push(fault);
                        this.program.faults.reportManual(fault);
                        hasFaults = true;
                    }
                }
                this.cycles.push(faults);
            }
            return hasFaults;
        }
    }
    Truth.CycleDetector = CycleDetector;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Parses a single line of Truth code, and returns
     * a Line object that contains information about
     * what was read.
     */
    class LineParser {
        /**
         * Generator function that yields all statements (unparsed lines)
         * of the given source text.
         */
        static *read(sourceText) {
            if (sourceText.length === 0)
                return;
            let cursor = 0;
            let statementStart = 0;
            for (; cursor < sourceText.length; cursor++) {
                if (sourceText[cursor] === "\n" /* terminal */) {
                    yield sourceText.slice(statementStart, cursor);
                    statementStart = cursor + 1;
                }
            }
            if (statementStart < cursor)
                yield sourceText.slice(statementStart);
        }
        /**
         * Main entry point for parsing a single line and producing a
         * RawStatement object.
         *
         * The parsing algorithm is some kind of quasi-recusive descent with
         * lookheads and backtracking in some places to make the logic easier
         * to follow. Technically, it's probably some mash-up of LL(k) & LALR.
         * Maybe if I blew 4 years of my life in some silly Comp Sci program
         * instead of dropping out of high school I could say for sure.
         *
         * @param lineText A string containing the line to parse.
         */
        static parse(lineText, options) {
            const parser = new Truth.Parser(lineText);
            const sourceText = lineText;
            const indent = parser.readWhitespace();
            const declarationEntries = [];
            const annotationEntries = [];
            const esc = "\\" /* escapeChar */;
            let flags = Truth.LineFlags.none;
            let jointPosition = -1;
            let sum = "";
            /**
             * Universal function for quickly producing a RawStatement
             * instance using the values of the constructed local variables.
             */
            const ret = (fault = null) => new Truth.Line(sourceText, indent, new Truth.BoundaryGroup(declarationEntries), new Truth.BoundaryGroup(annotationEntries), sum, jointPosition, flags, fault);
            // In the case when the line contains only whitespace characters,
            // this condition will pass, bypassing the entire parsing process
            // and returning an (basically) fresh RawStatement object.
            if (!parser.more()) {
                flags |= Truth.LineFlags.isWhitespace;
                return ret();
            }
            {
                const mark = parser.position;
                if (parser.read("//" /* comment */)) {
                    if (!parser.more() || parser.read(" " /* space */) || parser.read("\t" /* tab */)) {
                        flags |= Truth.LineFlags.isComment;
                        return ret();
                    }
                    parser.position = mark;
                }
            }
            {
                const unparsableFaultType = (() => {
                    if (parser.read("," /* combinator */))
                        return Truth.Faults.StatementBeginsWithComma;
                    if (parser.read("..." /* list */))
                        return Truth.Faults.StatementBeginsWithEllipsis;
                    if (parser.read(esc + " " /* space */) || parser.read(esc + "\t" /* tab */))
                        return Truth.Faults.StatementBeginsWithEscapedSpace;
                    if (parser.readThenTerminal(esc))
                        return Truth.Faults.StatementContainsOnlyEscapeCharacter;
                    return null;
                })();
                if (unparsableFaultType) {
                    flags |= Truth.LineFlags.isCruft;
                    return ret(unparsableFaultType);
                }
            }
            {
                const markBeforeUri = parser.position;
                const uri = maybeReadUri();
                if (uri) {
                    flags |= Truth.LineFlags.hasUri;
                    declarationEntries.push(new Truth.Boundary(markBeforeUri, parser.position, uri));
                    return then();
                }
                const markBeforePattern = parser.position;
                const pattern = maybeReadPattern();
                if (isFault(pattern)) {
                    flags |= Truth.LineFlags.isCruft;
                    return ret(pattern);
                }
                if (pattern) {
                    flags |= Truth.LineFlags.hasPattern;
                    flags |= pattern.isTotal ?
                        Truth.LineFlags.hasTotalPattern :
                        Truth.LineFlags.hasPartialPattern;
                    declarationEntries.push(new Truth.Boundary(markBeforePattern, parser.position, pattern));
                    return then();
                }
                for (const boundsEntry of readDeclarations([]))
                    declarationEntries.push(boundsEntry);
                return then();
            }
            function then() {
                jointPosition = maybeReadJoint();
                const readResult = readAnnotations([]);
                sum = readResult.raw.trim();
                for (const boundsEntry of readResult.annotations)
                    annotationEntries.push(boundsEntry);
                if (jointPosition > -1) {
                    const dLen = declarationEntries.length;
                    const aLen = readResult.annotations.length;
                    if (dLen === 0) {
                        declarationEntries.unshift(new Truth.Boundary(jointPosition, jointPosition, Truth.Term.void));
                        if (aLen === 0)
                            flags |= Truth.LineFlags.isVacuous;
                    }
                    else if (aLen === 0) {
                        flags |= Truth.LineFlags.isRefresh;
                    }
                }
                return ret();
            }
            /**
             * Reads the following series of declarations, which may be
             * either directly contained by a statement, or inside an infix.
             */
            function readDeclarations(quitTokens) {
                const entries = [];
                const until = quitTokens.concat(":" /* joint */);
                while (parser.more()) {
                    const readResult = maybeReadTerm(until);
                    if (readResult !== null)
                        entries.push(new Truth.Boundary(readResult.at, parser.position, readResult.term));
                    // The following combinator must be eaten before
                    // moving on to another declaration. If this fails,
                    // it's because the parse stream has ended.
                    if (!parser.read("," /* combinator */))
                        break;
                    if (peekJoint())
                        break;
                }
                return entries;
            }
            /**
             * Attempts to read the joint token from the parse stream.
             * Consumes all surrounding whitespace.
             * @returns A boolean value indicating whether the joint
             * token was read.
             */
            function maybeReadJoint() {
                const markBeforeWs = parser.position;
                parser.readWhitespace();
                const markAfterWs = parser.position;
                let foundJointPosition = -1;
                if (parser.read(":" /* joint */ + " " /* space */) ||
                    parser.read(":" /* joint */ + "\t" /* tab */) ||
                    parser.readThenTerminal(":" /* joint */)) {
                    foundJointPosition = markAfterWs;
                    parser.readWhitespace();
                }
                else {
                    parser.position = markBeforeWs;
                }
                return foundJointPosition;
            }
            /**
             * @returns A boolean value that indicates whether the joint
             * is the next logical token to be consumed. True is returned
             * in the case when whitespace characters sit between the
             * cursor and the joint operator.
             */
            function peekJoint() {
                const innerPeekJoint = () => {
                    return parser.peek(":" /* joint */ + " " /* space */) ||
                        parser.peek(":" /* joint */ + "\t" /* tab */) ||
                        parser.peekThenTerminal(":" /* joint */);
                };
                if (innerPeekJoint())
                    return true;
                if (!parser.peek(" " /* space */) && !parser.peek("\t" /* tab */))
                    return false;
                const mark = parser.position;
                parser.readWhitespace();
                const atJoint = innerPeekJoint();
                parser.position = mark;
                return atJoint;
            }
            /**
             *
             */
            function readAnnotations(quitTokens) {
                const annotations = [];
                let raw = "";
                while (parser.more()) {
                    const readResult = maybeReadTerm(quitTokens);
                    if (readResult !== null) {
                        annotations.push(new Truth.Boundary(readResult.at, parser.position, readResult.term));
                        raw += readResult.raw;
                    }
                    // If the next token is not a combinator, 
                    // the parse stream has ended.
                    if (!parser.read("," /* combinator */))
                        break;
                }
                return {
                    annotations,
                    raw
                };
            }
            /**
             * Attempts to read and return a term from the parse stream.
             */
            function maybeReadTerm(quitTokens) {
                const until = quitTokens
                    .concat("," /* combinator */)
                    .filter(tok => tok !== ":" /* joint */);
                const shouldQuitOnJoint = quitTokens.includes(":" /* joint */);
                const at = parser.position + parser.readWhitespace();
                let token = "";
                while (parser.more()) {
                    if (until.some(tok => parser.peek(tok)))
                        break;
                    if (shouldQuitOnJoint && peekJoint())
                        break;
                    const g1 = parser.readGrapheme();
                    if (parser.more()) {
                        // The only operators that can be meaningfully escaped at
                        // the term level are the joint, the combinator, and the
                        // pattern delimiter. Other occurences of the escape character
                        // append this character to the term.
                        if (g1 === esc) {
                            const g2 = parser.readGrapheme();
                            token += g2;
                            continue;
                        }
                    }
                    token += g1;
                }
                const tokenTrimmed = token.trim();
                if (!tokenTrimmed.length)
                    return null;
                return {
                    at,
                    term: Truth.Term.from(tokenTrimmed),
                    raw: token
                };
            }
            /**
             * Attempts to read a URI starting at the current position
             * of the cursor. The position of the cursor is not changed
             * in the case when a valid URI was not read.
             */
            function maybeReadUri() {
                if (!options.readUris)
                    return null;
                let prefix = parser.read("http://" /* httpPrefix */) ||
                    parser.read("https://" /* httpsPrefix */) ||
                    parser.read("../" /* retractingUriPrefix */) ||
                    parser.read("./" /* relativeUriPrefix */);
                if (prefix === "")
                    return null;
                const mark = parser.position;
                const maybeUriContent = parser.readUntil();
                if (maybeUriContent.endsWith(".truth" /* truthExtension */))
                    return Truth.KnownUri.fromString(prefix + maybeUriContent, options.assumedUri);
                parser.position = mark;
                return null;
            }
            /**
             * Attempts to read a pattern from the steam.
             */
            function maybeReadPattern(nested = false) {
                if (!nested && !parser.read("/" /* main */))
                    return null;
                if (!options.readPatterns)
                    return null;
                // These are reserved starting sequences. They're invalid
                // regex syntax, and we may use them in the future to pack
                // in other language features.
                if (parser.peek("+" /* plus */) ||
                    parser.peek("*" /* star */) ||
                    parser.peek("?" /* restrained */))
                    return Truth.Faults.StatementBeginsWithInvalidSequence;
                // TypeScript isn't perfect.
                const units = nested ?
                    readRegexUnits(true) :
                    readRegexUnits(false);
                if (isFault(units))
                    return units;
                // Right-trim any trailing whitespace
                while (units.length) {
                    const last = units[units.length - 1];
                    if (!(last instanceof Truth.RegexGrapheme))
                        break;
                    if (last.grapheme !== " " /* space */ && last.grapheme !== "\t" /* tab */)
                        break;
                    units.pop();
                }
                if (units.length === 0)
                    return Truth.Faults.EmptyPattern;
                const last = units[units.length - 1];
                const isTotal = last instanceof Truth.RegexGrapheme &&
                    last.quantifier === null &&
                    last.grapheme === "/" /* main */;
                // Need to pop off the 
                if (isTotal)
                    units.pop();
                // Now read the annotations, in order to compute the Pattern's hash
                const mark = parser.position;
                const foundJointPosition = maybeReadJoint();
                if (foundJointPosition < 0)
                    return new Truth.Pattern(Object.freeze(units), isTotal, "");
                const annos = readAnnotations([]).annotations;
                const annosArrayJoined = Array.from(annos.values())
                    .map(v => v.subject.toString())
                    .join("\n" /* terminal */);
                const hash = Truth.Hash.calculate(annosArrayJoined);
                parser.position = mark;
                return new Truth.Pattern(Object.freeze(units), isTotal, hash);
            }
            function readRegexUnits(nested) {
                const units = [];
                while (parser.more()) {
                    const setOrGroup = maybeReadRegexSet() || maybeReadRegexGroup();
                    if (isFault(setOrGroup))
                        return setOrGroup;
                    if (setOrGroup !== null) {
                        const quantifier = maybeReadRegexQuantifier();
                        if (isFault(quantifier))
                            return quantifier;
                        units.push(appendQuantifier(setOrGroup, quantifier));
                        continue;
                    }
                    if (nested) {
                        if (parser.peek("|" /* alternator */))
                            break;
                        if (parser.peek(")" /* groupEnd */))
                            break;
                    }
                    else {
                        // Infixes are not supported anywhere other 
                        // than at the top level of the pattern.
                        const infix = maybeReadInfix();
                        if (isFault(infix))
                            return infix;
                        if (infix !== null) {
                            const quantifier = maybeReadRegexQuantifier();
                            if (quantifier !== null)
                                return Truth.Faults.InfixHasQuantifier;
                            units.push(infix);
                            continue;
                        }
                        if (peekJoint())
                            break;
                    }
                    const grapheme = maybeReadRegexGrapheme();
                    if (!grapheme)
                        break;
                    // If the grapheme read is in the RegexSyntaxKnownSet
                    // enumeration, we need to convert the grapheme to a
                    // RegexSet instance, and push that on to the units array
                    // instead.
                    const regexKnownSet = (() => {
                        if (grapheme.character === Truth.RegexSyntaxKnownSet.wild && !grapheme.escaped)
                            return Truth.RegexSyntaxKnownSet.wild;
                        if (grapheme.escaped) {
                            const characterWithEscape = esc + grapheme.character;
                            const knownSet = Truth.RegexSyntaxKnownSet.resolve(characterWithEscape);
                            if (knownSet !== null)
                                return knownSet;
                        }
                        return null;
                    })();
                    const quantifier = maybeReadRegexQuantifier();
                    if (isFault(quantifier))
                        return quantifier;
                    if (regexKnownSet !== null) {
                        units.push(new Truth.RegexSet([regexKnownSet], [], [], [], false, quantifier));
                        continue;
                    }
                    if (grapheme.unicodeBlockName) {
                        const ubn = grapheme.unicodeBlockName;
                        units.push(new Truth.RegexSet([], [], [ubn], [], false, quantifier));
                        continue;
                    }
                    if (grapheme.escaped) {
                        const sign = Truth.RegexSyntaxSign.resolve(esc + grapheme.character);
                        if (sign !== null) {
                            units.push(new Truth.RegexSign(sign, quantifier));
                            continue;
                        }
                        // If this point is reached, it's because there was a unneccesarily
                        // escaped character found in the parse stream, such as "\a". In
                        // this case, the raw character can just be added as a regex unit.
                    }
                    units.push(new Truth.RegexGrapheme(grapheme.character, quantifier));
                }
                return units;
            }
            /**
             * Attempts to read a character set from the parse stream.
             * Example: [a-z0-9]
             */
            function maybeReadRegexSet() {
                if (!parser.read("[" /* setStart */))
                    return null;
                const rng = "-" /* range */;
                const knowns = [];
                const ranges = [];
                const blocks = [];
                const singles = [];
                const isNegated = !!parser.read("^" /* negate */);
                let closed = false;
                /**
                 * Stores all Graphemes read.
                 */
                const graphemes = [];
                /**
                 * Stores booleans that align with the items in "queue",
                 * that indicate whether or not the queued Grapheme
                 * can participate in a range.
                 */
                const rangableQueue = [];
                for (;;) {
                    const g = maybeReadRegexGrapheme();
                    if (g === null)
                        break;
                    if (!g.escaped && g.character === "]" /* setEnd */) {
                        closed = true;
                        break;
                    }
                    if (g.unicodeBlockName) {
                        blocks.push(g.unicodeBlockName);
                        rangableQueue.push(false);
                        graphemes.push(null);
                        continue;
                    }
                    const gFull = g.escaped ? esc + g.character : g.character;
                    const known = Truth.RegexSyntaxKnownSet.resolve(gFull);
                    if (known !== null) {
                        knowns.push(known);
                        rangableQueue.push(false);
                        graphemes.push(null);
                        continue;
                    }
                    graphemes.push(g);
                    rangableQueue.push(g.character.length > 0 &&
                        g.character !== "\\b" /* boundary */ &&
                        g.character !== "\\B" /* boundaryNon */);
                    if (g.unicodeBlockName)
                        continue;
                    const len = graphemes.length;
                    if (len < 3)
                        continue;
                    const maybeRng = graphemes[len - 2];
                    if (maybeRng !== null && maybeRng.character !== rng)
                        continue;
                    if (!rangableQueue[len - 3])
                        continue;
                    const maybeFrom = graphemes[len - 3];
                    if (maybeFrom === null)
                        throw Truth.Exception.unknownState();
                    // Peel back symbol queue, and add a range
                    // to the alphabet builder if the queue gets into
                    // a state where it's ending with something
                    // looking like: ?-?
                    const from = maybeFrom.character.codePointAt(0) || 0;
                    const to = g.character.codePointAt(0) || 0;
                    ranges.push(new Truth.RegexCharRange(from, to));
                    graphemes.length -= 3;
                    continue;
                }
                if (!closed)
                    return Truth.Faults.UnterminatedCharacterSet;
                for (const g of graphemes)
                    if (g !== null)
                        singles.push(g.character);
                const quantifier = maybeReadRegexQuantifier();
                if (isFault(quantifier))
                    return quantifier;
                return new Truth.RegexSet(knowns, ranges, blocks, singles, isNegated, quantifier);
            }
            /**
             * Attempts to read an alternation group from the parse stream.
             * Example: (A|B|C)
             */
            function maybeReadRegexGroup() {
                if (!parser.read("(" /* groupStart */))
                    return null;
                const cases = [];
                let closed = false;
                while (parser.more()) {
                    if (parser.read("|" /* alternator */))
                        continue;
                    if (parser.read(")" /* groupEnd */)) {
                        closed = true;
                        break;
                    }
                    const subUnits = readRegexUnits(true);
                    if (isFault(subUnits))
                        return subUnits;
                    // If the call to maybeReadPattern causes the cursor
                    // to reach the end of te parse stream, the expression
                    // is invalid because it would mean the input looks
                    // something like: /(aa|bb
                    if (!parser.more())
                        return Truth.Faults.UnterminatedGroup;
                    // A null subPattern could come back in the case when some
                    // bizarre syntax is found in the pattern such as: (a||b)
                    if (subUnits === null)
                        continue;
                    cases.push(Object.freeze(subUnits));
                }
                if (!closed)
                    return Truth.Faults.UnterminatedGroup;
                const quantifier = maybeReadRegexQuantifier();
                if (isFault(quantifier))
                    return quantifier;
                return new Truth.RegexGroup(Object.freeze(cases), quantifier);
            }
            /**
             * Attempts to read a pattern quantifier from the parse stream.
             * Checks for duplicates, which is necessary because the JavaScript
             * regular expression flavor (and others?) cannot parse an expression
             * with two consecutive quantifiers.
             */
            function maybeReadRegexQuantifier() {
                /** */
                function maybeReadQuantifier() {
                    const mark = parser.position;
                    if (parser.read("*" /* star */))
                        return new Truth.RegexQuantifier(0, Infinity, isRestrained());
                    if (parser.read("+" /* plus */))
                        return new Truth.RegexQuantifier(1, Infinity, isRestrained());
                    if (parser.read("?" /* restrained */))
                        return new Truth.RegexQuantifier(0, 1, false);
                    if (!parser.read("{" /* quantifierStart */))
                        return null;
                    const min = maybeReadInteger();
                    if (min !== null) {
                        const quantEnd = "}" /* quantifierEnd */;
                        // {2}
                        if (parser.read(quantEnd))
                            return new Truth.RegexQuantifier(min, min, isRestrained());
                        // {2,} or {2,3} or {2,???
                        if (parser.read("," /* quantifierSeparator */)) {
                            if (parser.read(quantEnd))
                                return new Truth.RegexQuantifier(min, Infinity, isRestrained());
                            const max = maybeReadInteger();
                            if (max !== null && parser.read(quantEnd))
                                return new Truth.RegexQuantifier(min, max, isRestrained());
                        }
                    }
                    parser.position = mark;
                    return null;
                }
                /** */
                function isRestrained() {
                    return !!parser.read("?" /* restrained */);
                }
                const quantifier = maybeReadQuantifier();
                if (quantifier)
                    if (maybeReadQuantifier())
                        return Truth.Faults.DuplicateQuantifier;
                return quantifier;
            }
            /**
             *
             */
            function maybeReadInteger() {
                let integerText = "";
                for (let i = 0; i < 16 && parser.more(); i++) {
                    const digit = (() => {
                        for (let digit = 0; digit <= 9; digit++)
                            if (parser.read(digit.toString()))
                                return digit.toString();
                        return "";
                    })();
                    if (!digit)
                        break;
                    integerText += digit;
                }
                return integerText.length > 0 ?
                    parseInt(integerText, 10) :
                    null;
            }
            /**
             *
             */
            function maybeReadInfix() {
                const mark = parser.position;
                const lhsEntries = [];
                const rhsEntries = [];
                const infixStart = parser.position;
                let infixFlags = Truth.InfixFlags.none;
                let quitToken = ">" /* end */;
                let hasJoint = false;
                if (parser.read("<<" /* nominalStart */)) {
                    infixFlags |= Truth.InfixFlags.nominal;
                    quitToken = ">>" /* nominalEnd */;
                }
                else if (parser.read("</" /* patternStart */)) {
                    infixFlags |= Truth.InfixFlags.pattern;
                    quitToken = "/>" /* patternEnd */;
                }
                else if (parser.read("<" /* start */)) {
                    infixFlags |= Truth.InfixFlags.population;
                    quitToken = ">" /* end */;
                }
                else
                    return null;
                parser.readWhitespace();
                if (parser.read(":" /* joint */)) {
                    infixFlags |= Truth.InfixFlags.portability;
                    parser.readWhitespace();
                    for (const boundsEntry of readAnnotations([quitToken]).annotations)
                        rhsEntries.push(new Truth.Boundary(boundsEntry.offsetStart, parser.position, boundsEntry.subject));
                }
                else {
                    for (const boundsEntry of readDeclarations([quitToken]))
                        lhsEntries.push(boundsEntry);
                    parser.readWhitespace();
                    if (maybeReadJoint() > -1) {
                        hasJoint = true;
                        parser.readWhitespace();
                        for (const boundsEntry of readAnnotations([quitToken]).annotations)
                            rhsEntries.push(new Truth.Boundary(boundsEntry.offsetStart, parser.position, boundsEntry.subject));
                    }
                }
                // Avoid producing an infix in weird cases such as:
                // < : >  </  />  <<:>>
                if (lhsEntries.length + rhsEntries.length === 0) {
                    parser.position = mark;
                    return null;
                }
                if (hasJoint)
                    infixFlags |= Truth.InfixFlags.hasJoint;
                parser.readWhitespace();
                if (!parser.read(quitToken))
                    return Truth.Faults.UnterminatedInfix;
                return new Truth.Infix(infixStart, parser.position, new Truth.BoundaryGroup(lhsEntries), new Truth.BoundaryGroup(rhsEntries), infixFlags);
            }
            /**
             * Attempts to read one single symbol from the parse stream,
             * while respecting unicode escape sequences, and escaped
             * characters.
             *
             * @returns The read string, or an empty string in the case when
             * there are no more characters in the parse stream.
             */
            function maybeReadRegexGrapheme() {
                if (!parser.more())
                    return null;
                const mark = parser.position;
                if (parser.read("\\u{" /* utf16GroupStart */)) {
                    const delim = "}" /* utf16GroupEnd */;
                    const unicodeRef = parser.readUntil(delim);
                    // Make sure the readUntil method stopped because it
                    // actually hit the delimiter, and not because it ran out
                    // of characters.
                    if (parser.more()) {
                        parser.read(delim);
                        if (Truth.UnicodeBlocks.has(unicodeRef.toLowerCase()))
                            return new Grapheme("", unicodeRef, true);
                        const len = unicodeRef.length;
                        if (len >= 1 && len <= 5) {
                            const num = parseInt(unicodeRef, 16);
                            if (num === num) {
                                const char = String.fromCodePoint(num);
                                return new Grapheme(char, "", true);
                            }
                        }
                    }
                    // Something came in that looked like a unicode escape
                    // sequence, but turned out not to be, like: \u
                    parser.position = mark;
                }
                if (parser.read(esc)) {
                    // If the parse stream ends with a backslash, we just
                    // return the actual backslash character as a character.
                    // This covers ridiculous but possible cases where a
                    // an unannotated type is named something like "Thing\".
                    if (!parser.more())
                        return new Grapheme(esc, "", false);
                    const g = parser.readGrapheme();
                    const decoded = Truth.RegexSyntaxSign.unescape(esc + g) || g;
                    return new Grapheme(decoded, "", true);
                }
                return new Grapheme(parser.readGrapheme(), "", false);
            }
            /** */
            function isFault(value) {
                return value instanceof Truth.FaultType;
            }
        }
        /** */
        constructor() { }
    }
    Truth.LineParser = LineParser;
    /** */
    class Grapheme {
        constructor(
        /**
         * Stores the character found in the parse stream in
         * their unescaped format. For example, in the case
         * when the field is referring to a unicode character,
         * the field would store "" ... not "\u1F407".
         */
        character, 
        /**
         * Stores the name of the unicode block specified,
         * or an empty string if the grapheme does not refer
         * to a unicode block.
         */
        unicodeBlockName, 
        /**
         * Stores whether the discovered grapheme was
         * escaped in the parse stream. Note that if the
         * grapheme refers to a special character, such
         * as "\d" for all digits, this will be true.
         */
        escaped) {
            this.character = character;
            this.unicodeBlockName = unicodeBlockName;
            this.escaped = escaped;
        }
    }
    /**
     * Slightly awkward hack function to attach a PatternQuantifier
     * to an already existing PatternUnit (without resorting to making
     * quantifier a mutable property.
     */
    function appendQuantifier(unit, quantifier = null) {
        if (quantifier === null)
            return unit;
        if (unit instanceof Truth.RegexSet)
            return new Truth.RegexSet(unit.knowns, unit.ranges, unit.unicodeBlocks, unit.singles, unit.isNegated, quantifier);
        if (unit instanceof Truth.RegexGroup)
            return new Truth.RegexGroup(unit.cases, quantifier);
        if (unit instanceof Truth.RegexGrapheme)
            return new Truth.RegexGrapheme(unit.grapheme, quantifier);
        throw Truth.Exception.notImplemented();
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Placeholder object to mark the position of
     * an anonymous type within a statement.
     */
    class Anon {
        constructor() {
            /**
             * @internal
             * No-op property used for debugging
             * purposes, and also to dodge structural
             * type compatibility bugs in TypeScript.
             */
            this.id = ++nextId;
        }
        /**
         * Returns a string representation of the Anon object which may be used to
         * uniquely identify it.
         *
         * Each Anon object serializes differently, otherwise, problems would arise
         * when trying to reference any of it's contained types (Ex. What specific
         * type is being refered to in "__ANON__" in the type URI "A/B/__ANON__/C"?
         */
        toString() {
            return `__ANON${this.id}__`;
        }
    }
    Truth.Anon = Anon;
    let nextId = 0;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Stores information about a line, after being parsed.
     * A Line is different from a Statement in that it has no
     * relationship to a Document.
     */
    class Line {
        /*** */
        constructor(sourceText, indent, declarations, annotations, sum, jointPosition, flags, faultType) {
            this.sourceText = sourceText;
            this.indent = indent;
            this.declarations = declarations;
            this.annotations = annotations;
            this.sum = sum;
            this.jointPosition = jointPosition;
            this.flags = flags;
            this.faultType = faultType;
        }
    }
    Truth.Line = Line;
    /**
     * A bit field enumeration used to efficiently store
     * meta data about a Line (or a Statement) object.
     */
    let LineFlags;
    (function (LineFlags) {
        LineFlags[LineFlags["none"] = 0] = "none";
        LineFlags[LineFlags["isRefresh"] = 1] = "isRefresh";
        LineFlags[LineFlags["isVacuous"] = 2] = "isVacuous";
        LineFlags[LineFlags["isComment"] = 4] = "isComment";
        LineFlags[LineFlags["isWhitespace"] = 8] = "isWhitespace";
        LineFlags[LineFlags["isDisposed"] = 16] = "isDisposed";
        LineFlags[LineFlags["isCruft"] = 32] = "isCruft";
        LineFlags[LineFlags["hasUri"] = 64] = "hasUri";
        LineFlags[LineFlags["hasTotalPattern"] = 128] = "hasTotalPattern";
        LineFlags[LineFlags["hasPartialPattern"] = 256] = "hasPartialPattern";
        LineFlags[LineFlags["hasPattern"] = 512] = "hasPattern";
    })(LineFlags = Truth.LineFlags || (Truth.LineFlags = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A marking object that stakes out a starting and ending
     * character offset within a statement, signifying the
     * boundary of a particular subject.
     */
    class Boundary {
        constructor(offsetStart, offsetEnd, subject) {
            this.offsetStart = offsetStart;
            this.offsetEnd = offsetEnd;
            this.subject = subject;
        }
    }
    Truth.Boundary = Boundary;
    /**
     * Groups together a series of related Boundary objects.
     */
    class BoundaryGroup {
        /** */
        constructor(boundaries) {
            this.entries = Object.freeze(boundaries.slice().sort((entryA, entryB) => {
                return entryA.offsetStart - entryB.offsetStart;
            }));
        }
        /** */
        *[Symbol.iterator]() {
            for (const entry of this.entries)
                yield entry;
        }
        /**
         * Iterates through each subject in the boundary group.
         */
        *eachSubject() {
            for (const entry of this.entries)
                yield entry.subject;
        }
        /**
         * Returns the subject at the specified offset, or null in the case
         * when no subject exists at the specified offset.
         */
        inspect(offset) {
            for (const entry of this.entries)
                if (offset >= entry.offsetStart && offset <= entry.offsetEnd)
                    return entry.subject;
            return null;
        }
        /**
         * Returns the first subject in the boundary group, or null in the
         * case when the boundary group contains no subjects.
         */
        first() {
            for (const entry of this)
                return entry;
            return null;
        }
        /** Gets the number of entries defined in the bounds. */
        get length() {
            return this.entries.length;
        }
    }
    Truth.BoundaryGroup = BoundaryGroup;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a single line within a Truth document.
     */
    class Statement extends Truth.AbstractClass {
        /**
         *
         */
        constructor(document, text) {
            super();
            /** @internal */
            this.class = 1 /* statement */;
            /**
             * @internal
             * Logical clock value used to make chronological
             * creation-time comparisons between Statements.
             */
            this.stamp = Truth.VersionStamp.next();
            /** @internal */
            this.flags = Truth.LineFlags.none;
            this._infixSpans = Object.freeze([]);
            const line = Truth.LineParser.parse(text, {
                readPatterns: true,
                readUris: true,
                assumedUri: document.uri
            });
            this.document = document;
            this.sourceText = line.sourceText;
            this.sum = line.sum;
            this.indent = line.indent;
            this.flags = line.flags;
            this.jointPosition = line.jointPosition;
            this.allDeclarations = Object.freeze(Array.from(line.declarations)
                .map(boundary => new Truth.Span(this, boundary)));
            this.allAnnotations = Object.freeze(Array.from(line.annotations)
                .map(boundary => new Truth.Span(this, boundary)));
            const faults = [];
            const cruftObjects = new Set();
            if (line.faultType !== null)
                faults.push(new Truth.Fault(line.faultType, this));
            for (const fault of this.eachParseFault()) {
                if (fault.type.severity === 8 /* error */)
                    cruftObjects.add(fault.source);
                faults.push(fault);
            }
            for (const fault of faults)
                // Check needed to support the unit tests, the feed
                // fake document objects into the statement constructor.
                if (document.program && document.program.faults)
                    document.program.faults.report(fault);
            this.cruftObjects = cruftObjects;
            this.faults = Object.freeze(faults);
            this.programStamp = document.program ?
                document.program.version :
                Truth.VersionStamp.next();
        }
        /**
         *
         */
        *eachParseFault() {
            // Check for tabs and spaces mixture
            if (this.indent > 0) {
                let hasTabs = false;
                let hasSpaces = false;
                for (let i = -1; ++i < this.indent;) {
                    const chr = this.sourceText[i];
                    if (chr === "\t" /* tab */)
                        hasTabs = true;
                    if (chr === " " /* space */)
                        hasSpaces = true;
                }
                if (hasTabs && hasSpaces)
                    yield new Truth.Fault(Truth.Faults.TabsAndSpaces, this);
            }
            if (this.allDeclarations.length > 1) {
                const subjects = [];
                for (const span of this.allDeclarations) {
                    const subText = span.toString();
                    if (subjects.includes(subText))
                        yield new Truth.Fault(Truth.Faults.DuplicateDeclaration, span);
                    else
                        subjects.push(subText);
                }
            }
            if (this.allAnnotations.length > 0) {
                // This performs an expedient check for "ListIntrinsicExtendingList",
                // however, full type analysis is required to cover all cases where
                // this fault may be reported.
                const getListSpans = (spans) => spans.filter(span => {
                    const sub = span.boundary.subject;
                    return sub instanceof Truth.Term && sub.isList;
                });
                const lhsListSpans = getListSpans(this.allDeclarations);
                const rhsListSpans = getListSpans(this.allAnnotations);
                if (lhsListSpans.length > 0 && rhsListSpans.length > 0)
                    for (const span of rhsListSpans)
                        yield new Truth.Fault(Truth.Faults.ListIntrinsicExtendingList, span);
            }
            const pattern = (() => {
                if (this.allDeclarations.length === 0)
                    return null;
                const hp = Truth.LineFlags.hasPattern;
                if ((this.flags & hp) !== hp)
                    return null;
                const subject = this.allDeclarations[0].boundary.subject;
                return subject instanceof Truth.Pattern ?
                    subject :
                    null;
            })();
            if (pattern === null)
                return;
            if (!pattern.isValid) {
                yield new Truth.Fault(Truth.Faults.PatternInvalid, this);
                return;
            }
            if (this.allAnnotations.length === 0)
                yield new Truth.Fault(Truth.Faults.PatternWithoutAnnotation, this);
            if (pattern.test(""))
                yield new Truth.Fault(Truth.Faults.PatternCanMatchEmpty, this);
            if (!pattern.isTotal)
                for (const unit of pattern.eachUnit())
                    if (unit instanceof Truth.RegexGrapheme)
                        if (unit.grapheme === "," /* combinator */) {
                            yield new Truth.Fault(Truth.Faults.PatternPartialWithCombinator, this);
                            break;
                        }
            const patternSpan = this.allDeclarations[0];
            if (patternSpan.infixes.length === 0)
                return;
            const infixSpans = [];
            for (const infix of patternSpan.infixes) {
                const lhs = Array.from(patternSpan.eachDeclarationForInfix(infix));
                const rhs = Array.from(patternSpan.eachAnnotationForInfix(infix));
                const all = lhs.concat(rhs);
                // This is a bit out of place ... but we need to populate the
                // infixSpans array and this is probably the most efficient
                // place to do that.
                infixSpans.push(...all);
                for (const infixSpan of all)
                    if (infixSpan.boundary.subject.isList)
                        yield new Truth.Fault(Truth.Faults.InfixUsingListOperator, infixSpan);
                yield* normalizeInfixSpans(lhs);
                yield* normalizeInfixSpans(rhs);
                const lhsSubjects = lhs.map(nfxSpan => nfxSpan.boundary.subject.toString());
                for (const infixSpan of rhs)
                    if (lhsSubjects.includes(infixSpan.boundary.subject.toString()))
                        yield new Truth.Fault(Truth.Faults.InfixHasSelfReferentialType, infixSpan);
                if (infix.isPopulation)
                    for (let idx = 1; idx < lhs.length; idx++)
                        yield new Truth.Fault(Truth.Faults.InfixPopulationChaining, lhs[idx]);
                yield* expedientListCheck(lhs);
                yield* expedientListCheck(rhs);
            }
            for (const infixSpan of eachRepeatedInfix(patternSpan, infix => patternSpan.eachDeclarationForInfix(infix))) {
                if (infixSpan.containingInfix.isPopulation)
                    yield new Truth.Fault(Truth.Faults.PopulationInfixHasMultipleDefinitions, infixSpan);
            }
            for (const infixSpan of eachRepeatedInfix(patternSpan, infix => patternSpan.eachAnnotationForInfix(infix))) {
                if (infixSpan.containingInfix.isPortability)
                    yield new Truth.Fault(Truth.Faults.PortabilityInfixHasMultipleDefinitions, infixSpan);
            }
            this._infixSpans = Object.freeze(infixSpans);
        }
        /**
         * Gets whether the joint operator exists at the
         * end of the statement, forcing the statement's
         * declarations to be "refresh types".
         */
        get isRefresh() {
            const f = Truth.LineFlags.isRefresh;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement contains nothing
         * other than a single joint operator.
         */
        get isVacuous() {
            const f = Truth.LineFlags.isVacuous;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement is a comment.
         */
        get isComment() {
            const f = Truth.LineFlags.isComment;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement contains
         * no non-whitespace characters.
         */
        get isWhitespace() {
            const f = Truth.LineFlags.isWhitespace;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement is a comment or whitespace.
         */
        get isNoop() {
            return this.isComment || this.isWhitespace;
        }
        /**
         * Gets whether this Statement has been removed from it's
         * containing document. Removal occurs after the statement
         * has been invalidated. Therefore, this property will be false
         * before the invalidation phase has occured, even if it will be
         * disposed in the current edit transaction.
         */
        get isDisposed() {
            const f = Truth.LineFlags.isDisposed;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the Statement has been marked as cruft,
         * due to a parsing error (and specifically not a type error).
         */
        get isCruft() {
            const f = Truth.LineFlags.isCruft;
            return (this.flags & f) === f;
        }
        /**
         * Gets the URI embedded within the Statement, in the case
         * when the statement is a URI statement.
         *
         * Gets null in the case when the Statement is not a URI
         * statement.
         */
        get uri() {
            const f = Truth.LineFlags.hasUri;
            return (this.flags & f) === f ?
                this.declarations[0].boundary.subject :
                null;
        }
        /**
         * Gets the line number of this statement in it's containing
         * document, or -1 if the statement is disposed and/or is not
         * in the document.
         */
        get line() {
            if (this.isDisposed)
                return -1;
            return this.document instanceof Truth.Document ?
                this.document.lineNumberOf(this) :
                -1;
        }
        /**
         * Gets an array of spans in that represent the declarations
         * of this statement, excluding those that have been marked
         * as object-level cruft.
         */
        get declarations() {
            if (this.cruftObjects.size === 0)
                return this.allDeclarations;
            const out = [];
            for (const span of this.allDeclarations)
                if (!this.cruftObjects.has(span))
                    out.push(span);
            return Object.freeze(out);
        }
        /**
         * Gets a list of all infixes defined in the pattern of this statement.
         */
        get infixSpans() {
            return this._infixSpans;
        }
        /**
         * Gets an array of spans in that represent the annotations
         * of this statement, from left to right, excluding those that
         * have been marked as object-level cruft.
         */
        get annotations() {
            if (this.cruftObjects.size === 0)
                return this.allAnnotations;
            const out = [];
            for (const span of this.allAnnotations)
                if (!this.cruftObjects.has(span))
                    out.push(span);
            return Object.freeze(out);
        }
        /**
         * Gets an array of spans in that represent both the declarations
         * and the annotations of this statement, excluding those that have
         * been marked as object-level cruft.
         */
        get spans() {
            return this.isCruft ?
                [] :
                this.declarations.concat(this.annotations);
        }
        /**
         *
         */
        get allSpans() {
            return this.declarations.concat(this.annotations);
        }
        /**
         * Gets a boolean value indicating whether or not the
         * statement contains a declaration of a pattern.
         */
        get hasPattern() {
            const d = this.allDeclarations;
            return d.length === 1 && d[0].boundary.subject instanceof Truth.Pattern;
        }
        /**
         * @internal
         * Marks the statement as being removed from it's containing document.
         */
        dispose() {
            this.flags = this.flags | Truth.LineFlags.isDisposed;
        }
        /**
         * @returns The kind of StatementZone that exists
         * at the given character offset within the Statement.
         */
        getZone(offset) {
            if (this.isComment || offset < this.indent || this.isCruft)
                return StatementZone.void;
            if (this.isWhitespace)
                return StatementZone.whitespace;
            if (this.hasPattern) {
                const bnd = this.allDeclarations[0].boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return StatementZone.pattern;
            }
            if (offset <= this.jointPosition || this.jointPosition < 0) {
                for (const span of this.allDeclarations) {
                    const bnd = span.boundary;
                    if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                        return StatementZone.declaration;
                }
                return StatementZone.declarationVoid;
            }
            for (const span of this.allAnnotations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return StatementZone.annotation;
            }
            return StatementZone.annotationVoid;
        }
        /**
         *
         */
        getSubject(offset) {
            return this.getDeclaration(offset) || this.getAnnotation(offset);
        }
        /**
         * @returns A span to the declaration subject at the
         * specified offset, or null if there is none was found.
         */
        getDeclaration(offset) {
            for (const span of this.declarations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return span;
            }
            return null;
        }
        /**
         * @returns A span to the annotation subject at the
         * specified offset, or null if there is none was found.
         */
        getAnnotation(offset) {
            for (const span of this.annotations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return span;
            }
            return null;
        }
        /**
         * @returns A string containing the inner comment text of
         * this statement, excluding the comment syntax token.
         * If the statement isn't a comment, an empty string is returned.
         */
        getCommentText() {
            return this.isComment ?
                this.sourceText.slice(this.indent + "//" /* comment */.length).trim() :
                "";
        }
        /**
         * Converts the statement to a formatted string representation.
         */
        toString(includeIndent = false) {
            const serializeSpans = (spans, escStyle) => {
                return spans
                    .filter(sp => !(sp.boundary.subject instanceof Truth.Anon))
                    .map(sp => Truth.SubjectSerializer.forExternal(sp, escStyle))
                    .join("," /* combinator */ + " " /* space */);
            };
            const indent = includeIndent ? "\t" /* tab */.repeat(this.indent) : "";
            if (this.isCruft)
                return indent + "(cruft)";
            if (this.isWhitespace)
                return indent;
            if (this.isVacuous)
                return indent + ":" /* joint */;
            const decls = serializeSpans(this.allDeclarations, 1 /* declaration */);
            const annos = serializeSpans(this.allAnnotations, 2 /* annotation */);
            const joint = annos.length > 0 || this.isRefresh ? ":" /* joint */ : "";
            const jointL = decls.length > 0 && joint !== "" ? " " /* space */ : "";
            const jointR = annos.length > 0 ? " " /* space */ : "";
            return indent + decls + jointL + joint + jointR + annos;
        }
    }
    Truth.Statement = Statement;
    /**
     * Defines the areas of a statement that are significantly
     * different when performing inspection.
     */
    let StatementZone;
    (function (StatementZone) {
        /**
         * Refers to the area within a comment statement,
         * or the whitespace preceeding a non-no-op.
         */
        StatementZone[StatementZone["void"] = 0] = "void";
        /**
         * Refers to the area in the indentation area.
         */
        StatementZone[StatementZone["whitespace"] = 1] = "whitespace";
        /**
         * Refers to the
         */
        StatementZone[StatementZone["pattern"] = 2] = "pattern";
        /** */
        StatementZone[StatementZone["declaration"] = 3] = "declaration";
        /** */
        StatementZone[StatementZone["annotation"] = 4] = "annotation";
        /** */
        StatementZone[StatementZone["declarationVoid"] = 5] = "declarationVoid";
        /** */
        StatementZone[StatementZone["annotationVoid"] = 6] = "annotationVoid";
    })(StatementZone = Truth.StatementZone || (Truth.StatementZone = {}));
    /**
     * Yields faults on infix spans in the case when a term
     * exists multiple times within the same infix.
     */
    function* normalizeInfixSpans(side) {
        if (side.length === 0)
            return;
        const subjects = new Set();
        for (const nfxSpan of side) {
            const sub = nfxSpan.boundary.subject;
            if (subjects.has(sub))
                yield new Truth.Fault(Truth.Faults.InfixHasDuplicateTerm, nfxSpan);
            else
                subjects.add(sub);
        }
    }
    /**
     * Yields faults on infix spans in the case when a term
     * has been re-declared multiple times across the infixes.
     *
     * Yields infixes that have terms that exist multiple times
     * within the same statement.
     */
    function* eachRepeatedInfix(span, infixFn) {
        const subjects = new Set();
        for (const infix of span.infixes) {
            const infixSpans = Array.from(infixFn(infix));
            for (const infixSpan of infixSpans) {
                const sub = infixSpan.boundary.subject;
                if (subjects.has(sub))
                    yield infixSpan;
                else
                    subjects.add(sub);
            }
        }
    }
    /**
     * Performs a quick and dirty check to see if the infix is referencing
     * a list, by looking to see if it has the list operator. A full check needs
     * to perform type inspection to see if any of the types that correspond
     * to the terms specified are actually lists.
     */
    function* expedientListCheck(side) {
        if (side.length === 0)
            return;
        for (const nfxSpan of side)
            if (nfxSpan.boundary.subject.isList)
                yield new Truth.Fault(Truth.Faults.InfixUsingListOperator, nfxSpan);
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Pattern {
        /** @internal */
        constructor(
        /**
         *
         */
        units, 
        /**
         * Stores whether the pattern is considered to be "Total"
         * or "Partial". Total patterns must match an entire annotation
         * set (the entire strip of content to the right of a joint, after
         * being trimmed). Partial patterns match individually
         * specified subjects (separated by commas).
         */
        isTotal, 
        /**
         * Stores a hash which is computed from the set of
         * annotations specified to the right of the pattern.
         */
        hash) {
            this.units = units;
            this.isTotal = isTotal;
            this.hash = hash;
            /** */
            this.compiledRegExp = null;
            this.compiledRegExp = Truth.PatternPrecompiler.exec(this);
            this.isValid = this.compiledRegExp instanceof RegExp;
        }
        /**
         * Recursively enumerates through this Pattern's unit structure.
         */
        *eachUnit() {
            function* recurse(units) {
                for (const unit of units) {
                    yield unit;
                    if (unit instanceof Truth.RegexGroup)
                        for (const unitCase of unit.cases)
                            recurse(unitCase);
                }
            }
            yield* recurse(this.units);
        }
        /**
         * @returns A boolean value that indicates whether
         * this Pattern has at least one infix, of any type.
         */
        hasInfixes() {
            return this.units.some(u => u instanceof Truth.Infix);
        }
        /**
         * @returns An array containing the infixes of the
         * specified type that are defined in this Pattern.
         * If the argument is omitted, all infixes of any type
         * defined on this Pattern are returned.
         */
        getInfixes(type = Truth.InfixFlags.none) {
            return this.units
                .filter((u) => u instanceof Truth.Infix)
                .filter(nfx => (nfx.flags & type) === type);
        }
        /**
         * Performs an "expedient" test that determines whether the
         * specified input has a chance of being matched by this pattern.
         * The check is considered expedient, rather than thorough,
         * because any infixes that exist in this pattern are replaced
         * with "catch all" regular expression sequence, rather than
         * embedding the pattern associated with the type specified
         * in the infix.
         */
        test(input) {
            const regExp = this.compiledRegExp;
            if (regExp === null)
                return false;
            const inputTrimmed = input.trim();
            if (inputTrimmed === "")
                return false;
            return regExp.test(input);
        }
        /**
         * Executes the pattern (like a function) using the specified
         * string as the input.
         *
         * @returns A ReadonlyMap whose keys align with the infixes
         * contained in this Pattern, and whose values are strings that
         * are the extracted "inputs", found in the place of each infix.
         * If this Pattern has no infixes, an empty map is returned.
         */
        exec(patternParameter) {
            const regExp = this.compiledRegExp;
            if (regExp === null)
                return new Map();
            const result = new Map();
            const infixes = this.getInfixes();
            if (this.getInfixes().length === 0)
                return result;
            const infixCaptureGroupIndexes = (() => {
                const idxArray = [];
                let idx = 0;
                for (const unit of this.eachUnit()) {
                    if (unit instanceof Truth.Infix)
                        idxArray.push(++idx);
                    if (unit instanceof Truth.RegexGroup)
                        idx++;
                }
                ///Make sure the above produces the same behavior before deleting
                ///const recurseUnits = (units: readonly (RegexUnit | Infix>)[]) =>
                ///{
                ///	for (const unit of units)
                ///	{
                ///		if (unit instanceof Infix)
                ///		{
                ///			idxArray.push(++idx);
                ///		}
                ///		else if (unit instanceof RegexGroup)
                ///		{
                ///			++idx;
                ///			for (const unitCase of unit.cases)
                ///				recurseUnits(unitCase);
                ///		}
                ///	}
                ///}
                ///recurseUnits(this.units);
                return idxArray;
            })();
            const reg = new RegExp(regExp.source, regExp.flags);
            const matches = reg.exec(patternParameter);
            if (matches === null)
                return result;
            for (const [idx, infix] of infixes.entries())
                result.set(infix, matches[infixCaptureGroupIndexes[idx]]);
            return result;
        }
        /**
         * Converts this Pattern to a string representation.
         * (Note that the serialized pattern cannot be used
         * as a parameter to a JavaScript RegExp object.)
         *
         * @param includeHashPrefix If true, the Pattern's hash
         * prefix will be prepended to the serialized result.
         */
        toString(includeHashPrefix) {
            const prefix = includeHashPrefix ? escape(this.hash) : "";
            const delim = "/" /* main */.toString();
            return delim + prefix +
                this.units.map(u => u.toString()).join("") +
                (this.isTotal ? delim : "");
        }
    }
    Truth.Pattern = Pattern;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    class PatternPrecompiler {
        /**
         * Compiles the specified pattern into a JS-native
         * RegExp object that can be used to execute regular
         * expression pre-matching (i.e. checks that essentially
         * ignore any infixes that the pattern may have).
         */
        static exec(pattern) {
            const result = [];
            for (const unit of pattern.units) {
                if (unit instanceof Truth.RegexGrapheme) {
                    if (mustEscapeChars.includes(unit.grapheme))
                        result.push("\\" /* escapeChar */ + unit.grapheme);
                    else
                        result.push(unit.grapheme);
                    if (unit.quantifier)
                        result.push(unit.quantifier.toString());
                }
                else if (unit instanceof Truth.Infix) {
                    result.push(expedientInfixPattern);
                }
                else {
                    result.push(unit.toString());
                }
            }
            result.unshift("^");
            result.push("$");
            const regText = result.join("");
            try {
                return new RegExp(regText, "u");
            }
            catch (e) {
                return null;
            }
        }
    }
    Truth.PatternPrecompiler = PatternPrecompiler;
    /**
     * Stores the list of characters that must be escaped
     * in order for the Truth regular expression flavor to
     * be compatible with the engine build into JavaScript.
     */
    const mustEscapeChars = ["$", "^", "{", "}"];
    /**
     * Stores the pattern that is fed into a pattern in
     * place of where infixes are, in order to be able to
     * do early tests on the regular expression without
     * doing a full resolution of the types that the infixes
     * reference. The pattern essentially means:
     *
     * "Match one non-whitespace character, or a series
     * of characters, provided that the string of characters
     * don't begin or end with whitespace."
     */
    const expedientInfixPattern = "(\\S+(\\s+\\S+)*)";
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Ambient unifier for all PatternUnit instances
     */
    class RegexUnit {
        constructor(quantifier) {
            this.quantifier = quantifier;
        }
    }
    Truth.RegexUnit = RegexUnit;
    /**
     *
     */
    class RegexSet extends RegexUnit {
        /** */
        constructor(knowns, ranges, unicodeBlocks, singles, isNegated, quantifier) {
            super(quantifier);
            this.knowns = knowns;
            this.ranges = ranges;
            this.unicodeBlocks = unicodeBlocks;
            this.singles = singles;
            this.isNegated = isNegated;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const kLen = this.knowns.length;
            const rLen = this.ranges.length;
            const uLen = this.unicodeBlocks.length;
            const cLen = this.singles.length;
            const setText = (() => {
                if (kLen === 1 && rLen + uLen + cLen === 0)
                    return this.knowns[0].toString();
                if (uLen === 1 && kLen + rLen + cLen === 0)
                    return [
                        "[" /* setStart */ +
                            serializeUnicodeBlock(this.unicodeBlocks[0]) +
                            "]" /* setEnd */
                    ].join("");
                if (cLen === 1 && kLen + rLen + uLen === 0)
                    return this.singles[0];
                return [
                    "[" /* setStart */,
                    ...this.knowns,
                    ...this.ranges.map(r => esc(r.from) + "-" + esc(r.to)),
                    ...this.unicodeBlocks.map(serializeUnicodeBlock),
                    ...escMany(this.singles),
                    "]" /* setEnd */
                ].join("");
            })();
            return setText + (this.quantifier ? this.quantifier.toString() : "");
        }
        /**
         * @internal
         */
        toAlphabet() {
            const alphabetBuilder = new Truth.AlphabetBuilder();
            const gt = (char) => char.charCodeAt(0) + 1;
            const lt = (char) => char.charCodeAt(0) - 1;
            for (const known of this.knowns) {
                switch (known) {
                    case Truth.RegexSyntaxKnownSet.digit:
                        alphabetBuilder.add("0", "9");
                        break;
                    case Truth.RegexSyntaxKnownSet.digitNon:
                        alphabetBuilder.add(0, lt("0"));
                        alphabetBuilder.add(gt("9"), Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.alphanumeric:
                        alphabetBuilder.add("0", "9");
                        alphabetBuilder.add("A", "Z");
                        alphabetBuilder.add("a", "z");
                        break;
                    case Truth.RegexSyntaxKnownSet.alphanumericNon:
                        alphabetBuilder.add(0, lt("0"));
                        alphabetBuilder.add(gt("9"), lt("A"));
                        alphabetBuilder.add(gt("Z"), lt("a"));
                        alphabetBuilder.add(gt("z"), Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.whitespace:
                        alphabetBuilder.add(9, 13);
                        alphabetBuilder.add(160);
                        alphabetBuilder.add(5760);
                        alphabetBuilder.add(8192, 8202);
                        alphabetBuilder.add(8232);
                        alphabetBuilder.add(8233);
                        alphabetBuilder.add(8239);
                        alphabetBuilder.add(8287);
                        alphabetBuilder.add(12288);
                        alphabetBuilder.add(65279);
                        break;
                    case Truth.RegexSyntaxKnownSet.whitespaceNon:
                        alphabetBuilder.add(0, 8);
                        alphabetBuilder.add(14, 159);
                        alphabetBuilder.add(161, 5759);
                        alphabetBuilder.add(5761, 8191);
                        alphabetBuilder.add(8203, 8231);
                        alphabetBuilder.add(8232);
                        alphabetBuilder.add(8233);
                        alphabetBuilder.add(8234, 8238);
                        alphabetBuilder.add(8240, 8286);
                        alphabetBuilder.add(8288, 12287);
                        alphabetBuilder.add(12289, 65278);
                        alphabetBuilder.add(65280, Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.wild:
                        alphabetBuilder.addWild();
                        break;
                }
            }
            for (const range of this.ranges)
                alphabetBuilder.add(range.from, range.to);
            for (const single of this.singles)
                alphabetBuilder.add(single);
            return alphabetBuilder.toAlphabet(this.isNegated);
        }
    }
    Truth.RegexSet = RegexSet;
    /**
     *
     */
    class RegexCharRange {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
    }
    Truth.RegexCharRange = RegexCharRange;
    /**
     *
     */
    class RegexGroup extends RegexUnit {
        constructor(
        /**
         *
         */
        cases, quantifier) {
            super(quantifier);
            this.cases = cases;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            if (this.cases.length === 0)
                return "";
            const start = "(" /* groupStart */;
            const mid = this.cases
                .map(ca => ca.map(unit => esc(unit.toString())).join(""))
                .join("|" /* alternator */);
            const end = ")" /* groupEnd */;
            const quant = this.quantifier ? this.quantifier.toString() : "";
            return start + mid + end + quant;
        }
    }
    Truth.RegexGroup = RegexGroup;
    /**
     * A pattern "grapheme" is a pattern unit class that
     * represents:
     *
     * a) A "Literal", which is a single unicode-aware character,
     * with possible representations being an ascii character,
     * a unicode character, or an ascii or unicode escape
     * sequence.
     *
     * or b) A "Special", which is a sequence that matches
     * something other than the character specified,
     * such as . \b \s
     */
    class RegexGrapheme extends RegexUnit {
        constructor(grapheme, quantifier) {
            super(quantifier);
            this.grapheme = grapheme;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const q = this.quantifier;
            const qEsc = q === null ? "" : esc(q.toString());
            const g = this.grapheme.toString();
            return escapableGraphemes.includes(g) ?
                "\\" + g + qEsc :
                g + qEsc;
        }
    }
    Truth.RegexGrapheme = RegexGrapheme;
    /** */
    const escapableGraphemes = [
        "*" /* star */,
        "+" /* plus */,
        "^" /* negate */,
        "?" /* restrained */,
        "(" /* groupStart */,
        ")" /* groupEnd */,
        "|" /* alternator */,
        "[" /* setStart */,
        "]" /* setEnd */,
        "{" /* quantifierStart */,
        "}" /* quantifierEnd */
    ];
    /**
     * A Regex "Sign" refers to an escape sequence that refers
     * to one other character, as opposed to that character
     * being written directly in the parse stream.
     */
    class RegexSign extends RegexUnit {
        constructor(sign, quantifier) {
            super(quantifier);
            this.sign = sign;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const q = this.quantifier;
            return this.sign.toString() + (q === null ? "" : esc(q.toString()));
        }
    }
    Truth.RegexSign = RegexSign;
    /**
     * A pattern unit class that represents +, *,
     * and explicit quantifiers such as {1,2}.
     */
    class RegexQuantifier {
        constructor(
        /**
         * Stores the lower bound of the quantifier,
         * or the fewest number of graphemes to be matched.
         */
        min = 0, 
        /**
         * Stores the upper bound of the quantifier,
         * or the most number of graphemes to be matched.
         */
        max = Infinity, 
        /**
         * Stores whether the the quantifier is restrained,
         * in that it matches the fewest possible number
         * of characters.
         *
         * (Some regular expression flavours awkwardly
         * refer to this as "non-greedy".)
         */
        restrained) {
            this.min = min;
            this.max = max;
            this.restrained = restrained;
        }
        /**
         * Converts the regex quantifier to an optimized string.
         */
        toString() {
            const rst = this.restrained ? "?" /* restrained */ : "";
            if (this.min === 0 && this.max === Infinity)
                return "*" /* star */ + rst;
            if (this.min === 1 && this.max === Infinity)
                return "+" /* plus */ + rst;
            if (this.min === 0 && this.max === 1)
                return "?" /* restrained */;
            const qs = "{" /* quantifierStart */;
            const qp = "," /* quantifierSeparator */;
            const qe = "}" /* quantifierEnd */;
            return this.min === this.max ?
                qs + this.min + qe :
                qs + this.min + qp + (this.max === Infinity ? "" : this.max.toString()) + qe;
        }
    }
    Truth.RegexQuantifier = RegexQuantifier;
    /**
     * Utility function that returns a double escape
     * if the passed value is a backslash.
     */
    function esc(maybeBackslash) {
        if (maybeBackslash === 92 || maybeBackslash === "\\")
            return "\\\\";
        if (typeof maybeBackslash === "number")
            return String.fromCodePoint(maybeBackslash);
        return maybeBackslash;
    }
    /**
     *
     */
    function escMany(array) {
        return array.map(esc).join("");
    }
    /**
     *
     */
    function serializeUnicodeBlock(blockName) {
        const block = Truth.UnicodeBlocks.get(blockName.toLowerCase());
        if (block === undefined)
            throw Truth.Exception.unknownState();
        const rng = "-" /* range */;
        const from = block[0].toString(16);
        const to = block[1].toString(16);
        return `\\u{${from}}${rng}\\u{${to}}`;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a portion of the content
     * within an Infix that spans a type reference.
     */
    class Infix {
        constructor(
        /**
         * Stores the left-most character position of the Infix
         * (before the delimiter), relative to the containing statement.
         */
        offsetStart, 
        /**
         * Stores the left-most character position of the Infix
         * (after the delimiter), relative to the containing statement.
         */
        offsetEnd, 
        /**
         * Stores the Bounds object that marks out the positions
         * of the terms in the Infix that are located before
         * any Joint operator.
         */
        lhs, 
        /**
         * Stores the Bounds object that marks out the positions
         * of the terms in the Infix that are located after
         * any Joint operator.
         */
        rhs, 
        /** */
        flags) {
            this.offsetStart = offsetStart;
            this.offsetEnd = offsetEnd;
            this.lhs = lhs;
            this.rhs = rhs;
            this.flags = flags;
        }
        /**
         * Gets whether this Infix is of the "pattern" variety.
         */
        get isPattern() {
            return (this.flags & InfixFlags.pattern) === InfixFlags.pattern;
        }
        /**
         * Gets whether this Infix is of the "portability" variety.
         */
        get isPortability() {
            return (this.flags & InfixFlags.portability) === InfixFlags.portability;
        }
        /**
         * Gets whether this Infix is of the "population" variety.
         */
        get isPopulation() {
            return (this.flags & InfixFlags.population) === InfixFlags.population;
        }
        /**
         * Gets whether this Infix has the "nominal" option set.
         */
        get isNominal() {
            return (this.flags & InfixFlags.nominal) === InfixFlags.nominal;
        }
        /** */
        toString() {
            const delimL = this.isPattern ? "</" /* patternStart */ :
                this.isNominal ? "<<" /* nominalStart */ :
                    this.isPortability ? "<" /* start */ + " " /* space */ + ":" /* joint */ + " " /* space */ :
                        "<" /* start */;
            const delimR = this.isPattern ? "/>" /* patternEnd */ :
                this.isNominal ? ">>" /* nominalEnd */ :
                    ">" /* end */;
            const join = (spans) => Array.from(spans)
                .map(entry => entry.subject)
                .join("," /* combinator */ + " " /* space */);
            if (this.isPortability)
                return join(this.rhs);
            if (this.isPattern)
                return join(this.lhs);
            const joint = this.rhs.length > 0 ?
                " " /* space */ + ":" /* joint */ + " " /* space */ :
                "";
            return delimL + join(this.lhs) + joint + join(this.rhs) + delimR;
        }
    }
    Truth.Infix = Infix;
    /**
     *
     */
    let InfixFlags;
    (function (InfixFlags) {
        InfixFlags[InfixFlags["none"] = 0] = "none";
        /**
         * Indicates that the joint was specified within
         * the infix. Can be used to determine if the infix
         * contains some (erroneous) syntax resembing
         * a refresh type, eg - /<Type : >/
         */
        InfixFlags[InfixFlags["hasJoint"] = 1] = "hasJoint";
        /**
         * Indicates that the </Pattern/> syntax was
         * used to embed the patterns associated
         * with a specified type.
         */
        InfixFlags[InfixFlags["pattern"] = 2] = "pattern";
        /**
         * Indicates that the infix is of the "portabiity"
         * variety, using the syntax < : Type>
         */
        InfixFlags[InfixFlags["portability"] = 4] = "portability";
        /**
         * Indicates that the infix is of the "popuation"
         * variety, using the syntax <Declaration : Annotation>
         * or <Declaration>
         */
        InfixFlags[InfixFlags["population"] = 8] = "population";
        /**
         * Indicates that the <<Double>> angle bracket
         * syntax was used to only match named types,
         * rather than aliases.
         */
        InfixFlags[InfixFlags["nominal"] = 16] = "nominal";
    })(InfixFlags = Truth.InfixFlags || (Truth.InfixFlags = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a position in a statement.
     */
    class Span {
        /**
         * @internal
         */
        constructor(
        /**
         * Stores a reference to the Statement that contains this Span.
         */
        statement, 
        /**
         * Stores the subject, and the location of it in the document.
         */
        boundary) {
            this.statement = statement;
            this.boundary = boundary;
            /**
             * @internal
             * Logical clock value used to make chronological
             * creation-time comparisons between Spans.
             */
            this.stamp = Truth.VersionStamp.next();
            this._infixes = null;
            /** */
            this.infixSpanTable = new Map();
            this._ancestry = null;
            /**  */
            this.factoredSpines = null;
            this.name =
                Truth.SubjectSerializer.forInternal(boundary) +
                    ` (${boundary.offsetStart}, ${boundary.offsetEnd})`;
        }
        /**
         * Gets the Infixes stored within this Span, in the case when
         * the Span corresponds to a Pattern. In other cases, and
         * empty array is returned.
         */
        get infixes() {
            return this._infixes || (this._infixes = Object.freeze((() => {
                return this.boundary.subject instanceof Truth.Pattern ?
                    Array.from(this.boundary.subject.getInfixes()) :
                    [];
            })()));
        }
        /** */
        *eachDeclarationForInfix(infix) {
            if (!this.infixes.includes(infix))
                throw Truth.Exception.invalidCall();
            const { lhs } = this.queryInfixSpanTable(infix);
            for (const infixSpan of lhs)
                yield infixSpan;
        }
        /** */
        *eachAnnotationForInfix(infix) {
            if (!this.infixes.includes(infix))
                throw Truth.Exception.invalidCall();
            const { rhs } = this.queryInfixSpanTable(infix);
            for (const infixSpan of rhs)
                yield infixSpan;
        }
        /** */
        queryInfixSpanTable(infix) {
            return this.infixSpanTable.get(infix) || (() => {
                const lhs = [];
                const rhs = [];
                for (const boundary of infix.lhs)
                    lhs.push(new Truth.InfixSpan(this, infix, boundary));
                for (const boundary of infix.rhs)
                    rhs.push(new Truth.InfixSpan(this, infix, boundary));
                return { lhs, rhs };
            })();
        }
        /**
         * Gets an array of statements that represent the statement
         * containment progression, all the way back to the containing
         * document.
         */
        get ancestry() {
            if (this._ancestry)
                if (this._ancestry.every(smt => !smt.isDisposed))
                    return this._ancestry;
            // If the ancestry has no yet been computed, or it has, but at least of
            // it's statements have been disposed, then it must be recomputed.
            this._ancestry = this.statement.document.getAncestry(this.statement);
            if (!this._ancestry)
                throw Truth.Exception.unknownState();
            return this._ancestry;
        }
        /**
         * Splits apart the groups subjects specified in the containing
         * statement's ancestry, and generates a series of spines,
         * each indicating a separate pathway of declarations through
         * the ancestry that reach the location in the document
         * referenced by this global span object.
         *
         * The generated spines are referentially opaque. Running this
         * method on the same Span object always returns the same
         * Spine instance.
         */
        factor() {
            if (this.factoredSpines)
                return this.factoredSpines;
            if (this.isCruft || this.statement.isCruft)
                return this.factoredSpines = Object.freeze([]);
            if (this.ancestry.length === 0)
                return this.factoredSpines = Object.freeze([new Truth.Spine([this])]);
            // We need to factor the ancestry. This means we're taking the
            // specified ancestry path, and splitting where any has-a side unions
            // exist, in effect creating all possible paths to the specified tip.
            // It's possible to have statements in the span path in the case
            // when the statement has been deemed as cruft, and therefore,
            // is impossible to extract any spans from it.
            const factoredSpanPaths = [];
            // An array of arrays. The first dimension corresponds to a statement. 
            // The second dimension stores the declaration spans themselves.
            const ancestryMatrix = this.ancestry.map(smt => Array.from(smt.declarations));
            // An array that stores the number of declaration spans in each statement.
            const ancestryLengths = ancestryMatrix.map(span => span.length);
            // Multiplying together the number of spans in each statement will
            // give the total number of unique spines that will be produced.
            const numSpines = ancestryLengths.reduce((a, b) => a * b, 1);
            // Start with an array of 0's, whose length matches the number
            // of statements in the ancestry. Each number in this array will be 
            // incremented by 1, from right to left, each number maxing out at
            // the number of declarations in the ancestor. After each incrementation,
            // the progression of numbers will run through all indexes required to
            // perform a full factorization of the terms in the ancestry. This array
            // tells the algorithm which indexes in ancestryMatrix to pull when
            // constructing a spine.
            const cherryPickIndexes = ancestryLengths.map(() => 0);
            // Stores the position in cherryPickIndexes that we're currently
            // incrementing. Moves backward when the number at 
            // the target position is >= the number of terms at that position.
            let targetIncLevel = 0;
            for (let i = -1; ++i < numSpines;) {
                // Do an insertion at the indexes specified by insertionIndexes
                const spanPath = [];
                // Cherry pick a series of terms from the ancestry terms,
                // according to the index set we're currently on.
                for (let level = -1; ++level < this.ancestry.length;) {
                    const statement = this.ancestry[level];
                    if (statement.isCruft) {
                        spanPath.push(statement);
                        continue;
                    }
                    const spansForStatement = ancestryMatrix[level];
                    const spanIndex = cherryPickIndexes[level];
                    const span = spansForStatement[spanIndex];
                    if (!span)
                        throw Truth.Exception.unknownState();
                    spanPath.push(span);
                }
                // The tip span specified in the method arguments
                // is added at the end of all generated span paths.
                spanPath.push(this);
                factoredSpanPaths.push(spanPath);
                // Bump up the current cherry pick index, 
                // or if we hit the roof, move to the next level,
                // and keep doing this until we find a number
                // to increment.
                while (cherryPickIndexes[targetIncLevel] >= ancestryLengths[targetIncLevel] - 1)
                    targetIncLevel++;
                cherryPickIndexes[targetIncLevel]++;
            }
            return this.factoredSpines =
                Object.freeze(factoredSpanPaths.map(spanPath => new Truth.Spine(spanPath)));
        }
        /**
         * Gets a boolean value that indicates whether this Span is considered
         * object-level cruft, and should therefore be ignored during type analysis.
         */
        get isCruft() {
            return this.statement.cruftObjects.has(this);
        }
        /**
         * Converts this Span to a string representation.
         *
         * @param includeHashPrefix If the subject inside this Span is a
         * Pattern, and this argument is true, the Pattern's hash prefix
         * will be prepended to the serialized result.
         */
        toString(includeHashPrefix) {
            const sub = this.boundary.subject;
            return sub instanceof Truth.Pattern ?
                sub.toString(!!includeHashPrefix) :
                sub.toString();
        }
    }
    Truth.Span = Span;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages an array of Span objects that
     * represent a specific spine of declarations, starting at
     * a document, passing through a series of spans,
     * and ending at a tip span.
     */
    class Spine {
        /** */
        constructor(vertebrae) {
            /** Stores an array of the Spans that compose the Spine. */
            this.vertebrae = [];
            if (vertebrae.length === 0)
                throw Truth.Exception.invalidCall();
            this.vertebrae = vertebrae.map(v => {
                if (v instanceof Truth.Span)
                    return v;
                const existCruftMarker = cruftMarkers.get(v);
                if (existCruftMarker !== undefined)
                    return existCruftMarker;
                const newCruftMarker = new CruftMarker(v);
                cruftMarkers.set(v, newCruftMarker);
                return newCruftMarker;
            });
            const tip = this.vertebrae[vertebrae.length - 1];
            if (tip instanceof CruftMarker)
                throw Truth.Exception.invalidCall();
            this.tip = tip;
        }
        /** */
        get statement() { return this.tip.statement; }
        /** Gets a reference to the document that sits at the top of the spine. */
        get document() { return this.statement.document; }
    }
    Truth.Spine = Spine;
    /**
     * A class that acts as a stand-in for a statement that has been
     * marked as cruft, suitable for usage in a Spine.
     */
    class CruftMarker {
        /** @internal */
        constructor(statement) {
            this.statement = statement;
        }
        /**
         * Converts this cruft marker to a string representation,
         * which is derived from a hash calculated from this
         * marker's underlying statement.
         */
        toString() {
            return "" + Truth.Hash.calculate(this.statement.sourceText);
        }
    }
    Truth.CruftMarker = CruftMarker;
    const cruftMarkers = new WeakMap();
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    class SubjectSerializer {
        /**
         * Universal method for serializing a subject to a string,
         * useful for debugging and supporting tests.
         */
        static forExternal(target, escapeStyle = 0 /* none */) {
            const subject = this.resolveSubject(target);
            return this.serialize(subject, escapeStyle, false);
        }
        /**
         * Serializes a subject, or a known subject containing object for internal use.
         */
        static forInternal(target) {
            const subject = this.resolveSubject(target);
            return this.serialize(subject, 0 /* none */, true);
        }
        /** */
        static resolveSubject(target) {
            return target instanceof Truth.Boundary ? target.subject :
                target instanceof Truth.Span ? target.boundary.subject :
                    target instanceof Truth.InfixSpan ? target.boundary.subject :
                        target;
        }
        /** */
        static serialize(subject, escapeStyle, includeHash) {
            if (subject instanceof Truth.Term)
                return subject.toString(escapeStyle);
            else if (subject instanceof Truth.Pattern)
                return subject.toString(includeHash);
            else if (subject instanceof Truth.KnownUri)
                return subject.toString();
            throw Truth.Exception.unknownState();
        }
    }
    Truth.SubjectSerializer = SubjectSerializer;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Stores a representation of a Truth program in a graph
     * format, which lays the foundation for type analysis.
     */
    class HyperGraph {
        /** */
        constructor(program) {
            this.program = program;
            /**
             * Stores a GraphTransaction instance in the case
             * when an edit transaction is underway.
             */
            this.activeTransactions = new Map();
            this.nodeIndex = new Truth.NodeIndex();
            if (HyperGraph.disabled)
                return;
            for (const doc of program.documents)
                this.include(doc);
            program.on(Truth.CauseDocumentCreate, data => {
                this.include(data.document);
            });
            program.on(Truth.CauseDocumentDelete, data => {
                this.exclude(data.document);
            });
            program.on(Truth.CauseInvalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        this.exclude(smt);
                }
                else
                    this.exclude(data.document);
            });
            program.on(Truth.CauseRevalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        this.include(smt);
                }
                else
                    this.include(data.document);
            });
            program.on(Truth.CauseEditComplete, data => {
                this.activeTransactions.delete(data.document);
            });
        }
        /**
         * Handles a document-level exclusion, which is the removal
         * of a section of Spans within a document, or possibly the
         * entire document itself.
         */
        exclude(root) {
            const { document, iterator } = this.methodSetup(root);
            const txn = this.getTransaction(root);
            const entries = Array.from(iterator);
            ///const maybeDestabilizedEdges: HyperEdge[] = [];
            for (const { statement } of entries) {
                for (const declaration of statement.declarations) {
                    const associatedNodes = new Set(declaration
                        .factor()
                        .map(spine => { var _a; return (_a = Truth.Phrase.fromSpine(spine)) === null || _a === void 0 ? void 0 : _a.associatedNode; })
                        .filter((n) => n instanceof Truth.Node));
                    for (const associatedNode of associatedNodes) {
                        associatedNode.removeDeclaration(declaration);
                        if (associatedNode.declarations.size === 0)
                            txn.destabilizedNodes.push(associatedNode);
                        for (const ob of associatedNode.outbounds)
                            if (ob.fragments.length === 0)
                                txn.destablizedEdges.push(ob);
                        ///for (const ib of associatedNode.inbounds)
                        ///	maybeDestabilizedEdges.push(ib);
                    }
                }
            }
            ///for (const edge of maybeDestabilizedEdges)
            ///	if (edge.successors.every(scsr => txn.destabilizedNodes.includes(scsr.node)))
            ///		txn.destablizedEdges.push(edge);
            this.activeTransactions.set(document, txn);
        }
        /**
         * Performs a revalidation of the Nodes that correspond to the
         * input argument.
         *
         * @param root The root object under which which revalidation
         * should occur. In the case when a Document instance is passed,
         * all Nodes present within the document are revalidated. In the
         * case when a Statement instance is passed, the Nodes that
         * correspond to the Statement, and all of it's contents are
         * revalidated.
         */
        include(root) {
            const { document, iterator } = this.methodSetup(root);
            const txn = this.getTransaction(document);
            // The first step is to collect all the Phrase objects in the invalidated area,
            // and the Spans and InfixSpans that are associated with that Phrase. The
            // data structure here is a MultiMap, to the correspondence is 
            // 1 Phrase to N Spans.
            const phraseSpansMap = new Truth.MultiMap();
            for (const { statement } of iterator) {
                for (const decl of statement.declarations) {
                    for (const spine of decl.factor()) {
                        const phrase = Truth.Phrase.fromSpine(spine);
                        if (!phrase)
                            continue;
                        phraseSpansMap.add(phrase, decl);
                        // If the declaration has population infixes, these
                        // need to be added to the map as though they
                        // were regular declarations.
                        for (const popInfix of decl.infixes.filter(nfx => nfx.isPopulation))
                            for (const infixSpan of decl.eachDeclarationForInfix(popInfix))
                                phraseSpansMap.add(phrase.forward(infixSpan.boundary.subject), infixSpan);
                    }
                }
            }
            if (phraseSpansMap.size === 0)
                return;
            // It's important that the Phrases are enumerated in breadth-first
            // order. For example, this means that all Phrases with a length of 2
            // (such as Object / Density) must be evaluated before all Phrases
            // with a length of 3 (such as Object / Density / Tolerance). This is
            // because in order to construct a 3rd-level Node, we have to 
            // guarantee that it's outer 2nd-level node was fully constructed,
            // otherwise, the 3rd-level node will have nowhere to connect.
            const newAreaSorted = Array.from(phraseSpansMap.entries())
                .sort((a, b) => a[0].length - b[0].length);
            // Stores all the nodes that have been affected by a new
            // fragment either being added or removed from it.
            const affectedNodes = new Map();
            // Stores a subset of the affectedNodes array. Contains
            // only the nodes that are at the outer-most level of depth
            // within the node set (not necessarily the document root).
            const affectedNodesApexes = [];
            /**
             * @returns The containing node that
             * corresponds to the specified phrase.
             */
            const findNode = (phrase) => {
                if (phrase.length === 0)
                    throw Truth.Exception.invalidArgument();
                return affectedNodes.get(phrase) || phrase.associatedNode;
            };
            // The following block populates the appropriate Nodes
            // in the graph with the new Span objects that were sent
            // in through the "root" parameter. New Node objects
            // are created if necessary.
            for (const [phrase, declarations] of newAreaSorted) {
                for (const declaration of declarations) {
                    const nodeAtPhrase = findNode(phrase);
                    if (nodeAtPhrase) {
                        // We add the phrase to the table of affected nodes,
                        // to handle the case when it was extracted from the
                        // cache.
                        affectedNodes.set(phrase, nodeAtPhrase);
                        nodeAtPhrase.addDeclaration(declaration);
                        continue;
                    }
                    const container = phrase.length > 1 ?
                        findNode(phrase.back()) :
                        null;
                    if (phrase.length > 1 && container === null)
                        throw Truth.Exception.unknownState();
                    // Note that when creating a Node, it's
                    // automatically bound to it's container.
                    const newNode = new Truth.Node(container, declaration);
                    affectedNodes.set(phrase, newNode);
                    // Populate the affectedNodesApexes array, 
                    // which is needed to find the nodes that are
                    // affected by the change, but are not located
                    // directly within the patch.
                    if (affectedNodesApexes.length === 0) {
                        affectedNodesApexes.push(newNode);
                    }
                    else {
                        // If we've encountered a node that is higher
                        // than the level of depth defined in the nodes
                        // currently in the affectedNodesApexes array.
                        const highestDepth = affectedNodesApexes[0].phrase.length;
                        const nodeDepth = newNode.phrase.length;
                        if (nodeDepth < highestDepth)
                            affectedNodesApexes.length = 0;
                        if (nodeDepth <= highestDepth)
                            affectedNodesApexes.push(newNode);
                    }
                }
            }
            // Add or update all new HyperEdges by feeding in all
            // annotation spans for each declaration span.
            // This needs to happen in a second pass because
            // all new nodes need to be created and positioned
            // in the graph before new "HyperEdge spans" can be added,
            // because doing this causes resolution to occur.
            for (const node of affectedNodes.values())
                for (const declaration of node.declarations) {
                    if (declaration instanceof Truth.Span) {
                        for (const annotation of declaration.statement.annotations)
                            node.addEdgeFragment(annotation);
                    }
                    else {
                        const nfx = declaration.containingInfix;
                        for (const boundary of nfx.rhs) {
                            node.addEdgeFragment(new Truth.InfixSpan(declaration.containingSpan, nfx, boundary));
                        }
                    }
                }
            // This is doing the reverse of what the above affectedNodes
            // loop is doing ... this is connecting other nodes to the affected
            // nodes, whereas the loop above is connecting affectedNodes
            // to others.
            if (affectedNodesApexes.length > 0) {
                // Stores the series of containers that any of the newly discovered
                // possibly affected nodes must have in their containment list
                // in order to be included in the "affectedNodes" array.
                const apexContainers = affectedNodesApexes
                    .map(node => node.container)
                    .filter((node) => node !== null)
                    .filter((v, i, a) => a.indexOf(v) === i);
                const checkRoot = apexContainers.length === 0;
                const isBelowAnApexContainer = (node) => node.containment.some(n => apexContainers.includes(n));
                for (const scsrNode of affectedNodesApexes) {
                    // Pattern and URI resolution doesn't occur in the
                    // Node graph, so when the node's subject isn't 
                    // a term, we don't add any edges to it.
                    if (!(scsrNode.subject instanceof Truth.Term))
                        continue;
                    const terms = this.nodeIndex.getAssociatedTerms(scsrNode);
                    for (const term of terms) {
                        const predecessors = this.nodeIndex.getNodesByTerm(term);
                        for (const predecessor of predecessors)
                            if (checkRoot || isBelowAnApexContainer(predecessor))
                                predecessor.addEdgeSuccessor(scsrNode);
                    }
                }
            }
            // If there's no active transaction the corresponds to the input
            // document, the most likely reason is that an entire document
            // is being included for the first time.
            if (txn) {
                for (const maybeDeadEdge of txn.destablizedEdges)
                    if (maybeDeadEdge.fragments.length > 0)
                        maybeDeadEdge.predecessor.disposeEdge(maybeDeadEdge);
                for (const maybeDeadNode of txn.destabilizedNodes)
                    if (maybeDeadNode.declarations.size === 0) {
                        maybeDeadNode.dispose();
                        this.nodeIndex.delete(maybeDeadNode);
                    }
            }
            // Populate nodeCache with any newly created nodes.
            for (const affectedNode of affectedNodes.values()) {
                affectedNode.sortOutbounds();
                const cachedNode = affectedNode.phrase.associatedNode;
                if (cachedNode) {
                    if (cachedNode !== affectedNode)
                        throw Truth.Exception.unknownState();
                    this.nodeIndex.update(affectedNode);
                }
                this.sanitize(affectedNode);
            }
        }
        /**
         * Performs setup for the invalidate and revalidate methods.
         */
        methodSetup(root) {
            const document = root instanceof Truth.Document ?
                root :
                root.document;
            const iterator = root instanceof Truth.Document ?
                document.eachDescendant() :
                document.eachDescendant(root, true);
            return { document, iterator };
        }
        /**
         * Reports any Node-level faults detected.
         */
        sanitize(node) {
            // Check for faulty refresh types
            // This can only happen on non-infix spans
            if (!(node.declarations.values().next().value instanceof Truth.Span))
                return;
            const smts = node.statements;
            const smtsRefresh = smts.filter(smt => smt.isRefresh);
            const smtsAnnotated = smts.filter(smt => smt.allAnnotations.length > 0);
            if (smtsRefresh.length > 0 && smtsAnnotated.length > 0)
                for (const smt of smtsRefresh)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.TypeCannotBeRefreshed, smt));
        }
        /**
         * Returns the GraphTransaction associated with the specified source object.
         * A new GraphTransaction is created in the case when no match active
         * transaction is available, or when the active transaction is from a previous
         * version of the document.
         */
        getTransaction(source) {
            const doc = source.class === 0 /* document */ ?
                source :
                source.document;
            let txn = this.activeTransactions.get(doc);
            if (!txn || doc.version.newerThan(txn.version))
                this.activeTransactions.set(doc, txn = new GraphTransaction(doc.version));
            return txn;
        }
        /**
         * Serializes the Graph into a format suitable
         * for debugging and comparing against baselines.
         */
        toString() {
            return this.nodeIndex.toString();
        }
    }
    Truth.HyperGraph = HyperGraph;
    /**
     * @internal
     */
    class GraphTransaction {
        constructor(
        /**
         * Stores the version of a document to which this GraphTransaction
         * is applied. GraphTransactions are expected to operate on documents
         * within the time frame of a single version. If a document's version
         * changes, the GraphTransaction is no longer applicable.
         */
        version) {
            this.version = version;
            /**
             * Stores an array of Nodes that no longer have any
             * underlying Span objects, due to their removal in
             * the invalidation phase.
             */
            this.destabilizedNodes = [];
            /**
             * Stores an array of Fans that no longer have any
             * underlying Span objects, due to their removal in
             * the invalidation phase.
             */
            this.destablizedEdges = [];
        }
    }
    /**
     * @internal
     * Debug utility.
     */
    function serializeNodes(nodes) {
        return "\n" + nodes.map(node => node.toString(true)).join("\n");
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A class that represents a single Node contained within
     * the Program's Graph. Nodes are long-lived, referentially
     * significant objects that persist between edit frames.
     *
     * Nodes are connected in a graph not by edges, but by
     * HyperEdges. A HyperEdge (from graph theory) is similar
     * to a directed edge in that it has a single predecessor,
     * but differs in that it has multiple successors.
     *
     * It is necessary for Nodes to be connected to each other
     * in this way, in order for further phases in the pipeline
     * to execute the various kinds of polymorphic type
     * resolution.
     */
    class Node {
        constructor(container, declaration) {
            /** */
            this.container = null;
            this._contents = new Map();
            this._portabilityTargets = null;
            this._inbounds = new Set();
            this._outbounds = [];
            this._containment = null;
            const span = declaration instanceof Truth.Span ?
                declaration :
                declaration.containingSpan;
            this.document = span.statement.document;
            this.stamp = this.document.version;
            this._declarations = new Set([declaration]);
            if (this._declarations.size === 0)
                throw Truth.Exception.unknownState();
            this.subject = declaration.boundary.subject;
            this.isListIntrinsic =
                this.subject instanceof Truth.Term &&
                    this.subject.isList;
            if (container) {
                this.container = container;
                this.phrase = container.phrase.forward(this.subject);
                container._contents.set(this.subject, this);
                // This appears to need to be brought back in the case
                // when the code below is uncommented.
                /// return this;
            }
            else {
                this.phrase = this.document.phrase.forward(this.subject);
                this.addRootNode(this);
            }
            // Performance shortcut. See notes in "associatedNode".
            this.phrase.associatedNode = this;
            ///if (!(declaration instanceof Span))
            ///	return this;
            ///
            ///const term = declaration.boundary.subject;
            ///
            ///if (!(term instanceof Term))
            ///	return this;
            ///
            ///const containerPattern = (() =>
            ///{
            ///	for (const decl of this.container.declarations)
            ///		if (decl.boundary.subject instanceof Pattern)
            ///			return decl.boundary.subject;
            ///})();
            ///
            ///if (!containerPattern)
            ///	return this;
            ///
            ///for (const nfx of containerPattern.getInfixes(InfixFlags.population))
            ///	for (const term of nfx.lhs.eachSubject())
            ///		if (term.fullName === term.fullName)
            ///			//return (this.containerInfix = nfx), this;
            ///			return this;
        }
        /**
         * Removes this Node, and all its contents from the graph.
         */
        dispose() {
            if (this.container === null) {
                const map = Node.rootNodes.get(this.document);
                if (map)
                    map.delete(this.subject);
            }
            else
                this.container._contents.delete(this.subject);
            for (const ib of this._inbounds)
                ib.removeSuccessor(this);
            function recurse(node) {
                if (node.phrase.associatedNode === node)
                    node.phrase.associatedNode = null;
                for (const edge of node._outbounds)
                    node.disposeEdge(edge);
                for (const containedNode of node._contents.values())
                    recurse(containedNode);
                // Manual memory management going on here.
                // Clearing out the Sets is probably unnecessary
                // because the GC would catch it anyways, but
                // these calls are here just to be safe.
                // It's still required that we clear out the inbounds
                // from the nodes to which this one is connected.
                node._declarations.clear();
                node._inbounds.clear();
            }
            recurse(this);
        }
        /**
         * Removes the specified HyperEdge from this Node's
         * set of outbounds.
         *
         * @throws In the case when the specified HyperEdge is
         * not owned by this Node.
         */
        disposeEdge(edge) {
            if (edge.predecessor !== this)
                throw Truth.Exception.invalidArgument();
            const idx = this._outbounds.indexOf(edge);
            this._outbounds.splice(idx, 1);
            for (const scsr of edge.successors)
                scsr.node._inbounds.delete(edge);
            edge.clearFragments();
        }
        /**
         * In the case when this node is a direct descendent of a
         * pattern node, and that pattern has population infixes,
         * and this node directly corresponds to one of those infixes,
         * this property gets a reference to said corresponding infix.
         */
        get containerInfix() {
            var _a;
            const flag = Truth.InfixFlags.population;
            if (((_a = this.container) === null || _a === void 0 ? void 0 : _a.subject) instanceof Truth.Pattern)
                for (const nfx of this.container.subject.getInfixes(flag))
                    if (nfx.lhs.length > 0)
                        return nfx;
            return null;
        }
        /**
         * @internal
         * Gets a text representation of this Node's subject,
         * for debugging purposes only.
         */
        get name() {
            return Truth.SubjectSerializer.forInternal(this.subject);
        }
        /**
         * Gets whether this Node has been explicitly defined as a list
         * extrinsic. It is worth noting that this property in and of itself is
         * not sufficient to determine whether any corresponding type is
         * actually a list (full type analysis is required to make this conclusion).
         */
        get isListExtrinsic() {
            for (const ob of this.outbounds)
                for (const source of ob.fragments)
                    if (source.boundary.subject instanceof Truth.Term)
                        if (source.boundary.subject.isList)
                            return true;
            return false;
        }
        /**
         * Gets a reference to the "opposite side of the list".
         *
         * If this Node represents a list intrinsic type, this property gets
         * a reference to the Node that represents the corresponding
         * extrinsic side.
         *
         * If this Node represents anything that *isn't* a list intrinsic type,
         * the property gets a reference to the Node that represents the
         * corresponding intrinsic side (whether the node is a list or not).
         *
         * Gets null in the case when there is no corresponding list intrinsic
         * or extrinsic Node to connect.
         */
        get intrinsicExtrinsicBridge() {
            if (this.subject instanceof Truth.Term)
                for (const adjacent of this.adjacents.values())
                    if (adjacent.subject instanceof Truth.Term)
                        if (adjacent.subject === this.subject)
                            if (adjacent.subject.isList !== this.isListIntrinsic)
                                return adjacent;
            return null;
        }
        /**
         * Stores the set of declaration-side Span instances that
         * compose this Node. If this the size of this set were to
         * reach zero, the Node would be marked for deletion.
         * (Node cleanup uses a reference counted collection
         * mechanism that uses the size of this set as it's guide).
         *
         * Note that although the type of this field is defined as
         * "Set<Span | InfixSpan>", in practice, it is either a set
         * of Span instances, or a set containing one single
         * InfixSpan instance. This is because it's possible to have
         * fragments of a type declared in multiple places in
         * a document, however, InfixSpans can only exist in one
         * place.
         */
        get declarations() {
            return this._declarations;
        }
        /** */
        addDeclaration(span) {
            this._declarations.add(span);
        }
        /** */
        removeDeclaration(span) {
            const wasDeleted = this._declarations.delete(span);
            if (wasDeleted) {
                // Remove all of the annotations that exist on the same
                // statement as the one that contains the declaration that
                // was removed. Note that this won't mess up fragmented
                // types. For example, consider the situation when the first
                // statement is removed from the following document:
                // 
                // A, B : X, Y
                // A, C : X, Y
                // 
                // Statements are removed atomically, so when the statement
                // is removed, this will result in 2 calls to this method: one for
                // the first "A", and one for the "B". When the second call is made,
                // the associated annotations will already have been removed.
                for (let i = this._outbounds.length; i-- > 0;) {
                    const ob = this._outbounds[i];
                    for (const anno of span.statement.allAnnotations)
                        ob.removeFragment(anno);
                    if (ob.fragments.length === 0)
                        this._outbounds.splice(i, 1);
                }
            }
        }
        /**
         * Gets an array containing the statements that
         * contain this Node.
         */
        get statements() {
            return Object.freeze(Array.from(this.declarations)
                .map(decl => decl.statement)
                .filter((v, i, a) => a.indexOf(v) === i));
        }
        /**
         * Gets a readonly map of Nodes that are contained
         * by this node in the containment hierarchy.
         */
        get contents() {
            return this._contents;
        }
        /**
         * Gets a readonly name of Nodes that are adjacent
         * to this Node in the containment hierarchy.
         */
        get adjacents() {
            const adjacentNodes = this.container ?
                this.container.contents :
                this.getRootNodes();
            // Filter this node out of the result set, because
            // Nodes cannot be adjacent to themselves.
            const out = new Map();
            for (const [subject, node] of adjacentNodes)
                if (node !== this)
                    out.set(subject, node);
            return out;
        }
        /**
         * Gets a 2-dimensional array containing the names of
         * the portability infixes that have been defined within
         * this node, with the first dimension corresponding to
         * a unique portability infix, and the second dimension
         * corresponding to the names defined within that infix.
         *
         * For example, given the following pattern:
         * /< : A, B, C>< : D, E, F> : ???
         *
         * The following result would be produced:
         * [["A", "B", "C"], ["D", "E", "F"]]
         */
        get portabilityTargets() {
            if (this._portabilityTargets !== null)
                return this._portabilityTargets;
            if (!(this.subject instanceof Truth.Pattern))
                return this._portabilityTargets = [];
            return this._portabilityTargets = this.subject
                .getInfixes(Truth.InfixFlags.portability)
                .map(nfx => Array.from(nfx.rhs.eachSubject()));
        }
        /**
         * @returns A set of nodes that are matched by
         * patterns of adjacent nodes.
         *
         * (Note that this is possible because annotations
         * that have been applied to a pattern cannot be
         * polymorphic)
         */
        getPatternNodesMatching(nodes) {
            const outNodes = [];
            //
            // This doesn't work because we don't know if
            // a node has been marked as cruft at this point.
            // This method may return junk results in the
            // case when one of the required nodes has
            // been marked as cruft (but then, wouldn't the
            // incoming node also be cruft?)
            //
            for (const node of this.adjacents.values()) {
                if (node.subject instanceof Truth.Pattern) {
                    const unorphaned = node.outbounds
                        .filter(ob => ob.successors.length > 0)
                        .map(ob => ob.successors[0].node);
                    if (unorphaned.length === 0)
                        continue;
                    if (unorphaned.length === nodes.length)
                        if (unorphaned.every(node => nodes.includes(node)))
                            outNodes.push(...unorphaned);
                }
            }
            return outNodes;
        }
        /**
         * Gets an immutable set of HyperEdges from adjacent
         * or contained Nodes that reference this Node.
         *
         * (The ordering of inbounds isn't important, as
         * they have no physical representation in the
         * document, which is why they're stored in a Set
         * rather than an array.)
         */
        get inbounds() {
            return this._inbounds;
        }
        /**
         * Gets an array of HyperEdges that connect this Node to
         * others, being either adjacents, or Nodes that
         * exists somewhere in the containment hierarchy.
         */
        get outbounds() {
            return this._outbounds;
        }
        /**
         * @internal
         * Sorts the outbound HyperEdges, so that they're ordering
         * is consistent with the way their corresponding
         * annotations appear in the underlying document.
         */
        sortOutbounds() {
            if (this._outbounds.length === 0)
                return;
            if (this._outbounds.length === 1) {
                const edge = this._outbounds[0];
                if (edge.fragments.length === 1)
                    return;
            }
            const edgeLookup = new Map();
            for (const edge of this._outbounds) {
                for (const src of edge.fragments.values()) {
                    const smt = src.statement;
                    const lineNum = smt.document.lineNumberOf(smt);
                    const existingTuple = edgeLookup.get(edge);
                    if (existingTuple !== undefined) {
                        const existingStmt = existingTuple[0];
                        const existingStmtLineNum = existingTuple[1];
                        if (lineNum < existingStmtLineNum) {
                            existingTuple[0] = existingStmt;
                            existingTuple[1] = existingStmtLineNum;
                        }
                    }
                    else {
                        edgeLookup.set(edge, [smt, lineNum]);
                    }
                }
            }
            // Sort the output edges in the array, so that the sorting of
            // the array aligns with the appearance of the underlying
            // spans in the document.
            this._outbounds.sort((edgeA, edgeB) => {
                const tupleA = edgeLookup.get(edgeA);
                const tupleB = edgeLookup.get(edgeB);
                const obs = this._outbounds;
                if (tupleA === undefined || tupleB === undefined)
                    throw Truth.Exception.unknownState();
                const [smtA, smtIdxA] = tupleA;
                const [smtB, smtIdxB] = tupleB;
                // If the top-most span of the predecessors of
                // the edges are located in different statements,
                // a simple comparison of the statement indexes
                // is possible.
                if (smtIdxA < smtIdxB)
                    return -1;
                if (smtIdxB < smtIdxA)
                    return 1;
                // At this point, statement A and statement B 
                // are actually equal.
                if (smtA !== smtB) {
                    throw Truth.Exception.unknownState();
                }
                const annos = smtA.annotations;
                const findMinIndex = (edge) => {
                    let minIdx = Infinity;
                    for (const src of edge.fragments) {
                        if (src instanceof Truth.InfixSpan)
                            throw Truth.Exception.unknownState();
                        const idx = annos.indexOf(src);
                        if (idx < minIdx)
                            minIdx = idx;
                    }
                    if (minIdx === Infinity)
                        throw Truth.Exception.unknownState();
                    return minIdx;
                };
                const edgeAIdx = findMinIndex(edgeA);
                const edgeBIdx = findMinIndex(edgeB);
                return edgeAIdx - edgeBIdx;
            });
        }
        /**
         * @internal
         * Adds a new edge to the node, or updates an existing one with
         * a new fragment.
         *
         * If no edge exists for the new fragment, a new one is created.
         */
        addEdgeFragment(fragment) {
            const term = fragment.boundary.subject;
            if (!(term instanceof Truth.Term))
                throw Truth.Exception.unknownState();
            // If the input source is "alone", it means that it refers to
            // a statement-level annotation that has no other annotations
            // beside it (e.g. in an annotation structure looking like "D: A1, A2")
            // This is relevant, because if the source is alone, it also needs
            // to be compared against any visible total patterns.
            const sourceIsAlone = fragment instanceof Truth.Span &&
                fragment.statement.annotations.length === 1;
            /**
             * Adds an edge to it's two applicable successor nodes.
             */
            const append = (edge) => {
                this._outbounds.push(edge);
                for (const suc of edge.successors)
                    suc.node._inbounds.add(edge);
            };
            // If there is already an existing outbound HyperEdge, we can
            // add the new Span to the edge's list of Spans, and quit.
            // This works whether the edge is for a type or pattern.
            const existingEdge = this._outbounds.find(edge => {
                return edge.term.singular === term.singular;
            });
            if (existingEdge) {
                existingEdge.addFragment(fragment);
            }
            else {
                const successors = [];
                for (const level of this.enumerateContainment()) {
                    const successorNode = level.container !== null &&
                        level.container !== this &&
                        level.container.subject === term ?
                        level.container :
                        level.adjacents.get(term);
                    if (successorNode !== undefined) {
                        successors.push(new Truth.Successor(successorNode, level.longitudeDelta));
                        // There should only ever be a single successor in the case when
                        // the node is a pattern node, because the annotations (which
                        // are eventually become bases) of these nodes do not have
                        // polymorphic behavior.
                        if (this.subject instanceof Truth.Pattern)
                            break;
                    }
                }
                append(new Truth.HyperEdge(this, fragment, successors));
            }
            // 
            // Refresh the sums before quitting.
            // 
            ///const sumEdgeForInputSpanIdx = this._outbounds.findIndex(edge => 
            ///{
            ///	if (edge.kind === HyperEdgeKind.summation)
            ///		for (const src of edge.sources)
            ///			return src.statement === smt;
            ///	
            ///	return false;
            ///});
            ///
            ///if (sumEdgeForInputSpanIdx > -1)
            ///	this._outbounds.splice(sumEdgeForInputSpanIdx, 1);
            ///
            ///if (!sourceIsAlone)
            ///	for (const { longitudeDelta, adjacents } of this.enumerateContainment())
            ///		for (const adjacentNode of adjacents.values())
            ///			if (adjacentNode.subject instanceof Pattern)
            ///				if (adjacentNode.subject.isTotal)
            ///					if (adjacentNode.subject.test(smt.sum))
            ///						append(new HyperEdge(
            ///							this,
            ///							smt.sum,
            ///							[new Successor(
            ///								adjacentNode,
            ///								longitudeDelta)],
            ///							HyperEdgeKind.summation));
        }
        /**
         *
         */
        addEdgeSuccessor(successorNode) {
            const term = successorNode.subject;
            if (!(term instanceof Truth.Term))
                throw Truth.Exception.unknownState();
            for (const ob of this.outbounds) {
                if (ob.term !== successorNode.subject)
                    continue;
                const scsrLong = successorNode.phrase.length;
                const predLong = ob.predecessor.phrase.length;
                ob.addSuccessor(successorNode, predLong - scsrLong);
                successorNode._inbounds.add(ob);
            }
        }
        /**
         * Enumerates upwards through the containment
         * hierarchy of the Nodes present in this Node's
         * containing document, yielding the adjacents at
         * every level, and then continues through to the
         * root level adjacents of each of the document's
         * dependencies.
         */
        *enumerateContainment() {
            let currentLevel = this;
            let longitudeCount = 0;
            do {
                yield {
                    sourceDocument: this.document,
                    container: currentLevel,
                    adjacents: currentLevel.adjacents,
                    longitudeDelta: longitudeCount++
                };
            } while ((currentLevel = currentLevel.container) !== null);
            for (const doc of this.document.traverseDependencies()) {
                yield {
                    sourceDocument: doc,
                    container: null,
                    adjacents: this.getRootNodes(doc),
                    longitudeDelta: longitudeCount
                };
            }
        }
        /**
         * @returns An array that stores the containment hierarchy
         * of the Nodes present in this Node's containing document,
         * yielding each containerof this Node.
         */
        get containment() {
            if (this._containment !== null)
                return this._containment;
            const nodes = [];
            let currentLevel = this;
            while ((currentLevel = currentLevel.container) !== null)
                nodes.push(currentLevel);
            return this._containment = Object.freeze(nodes);
        }
        /** */
        removeEdgeSource(src) {
            for (let i = this._outbounds.length; --i > 0;)
                this._outbounds[i].removeFragment(src);
        }
        /** */
        addRootNode(node) {
            const existingSet = Node.rootNodes.get(node.document);
            if (existingSet) {
                existingSet.set(node.subject, node);
            }
            else {
                const map = new Map();
                map.set(node.subject, node);
                Node.rootNodes.set(node.document, map);
            }
        }
        /** */
        removeRootNode(node) {
            const existingSet = Node.rootNodes.get(node.document);
            if (existingSet) {
                existingSet.delete(node.subject);
                // This is somewhat redundant as the set
                // is likely going to be GC'd away anyway in
                // this case. It's here for completeness sake.
                if (existingSet.size === 0)
                    Node.rootNodes.delete(node.document);
            }
        }
        /** */
        getRootNodes(fromDocument) {
            const fromDoc = fromDocument || this.document;
            const out = Node.rootNodes.get(fromDoc) || new Map();
            return Truth.HigherOrder.copy(out);
        }
        /** */
        toString(includePath = true) {
            const decls = Array.from(this.declarations);
            const spans = decls.filter((s) => s instanceof Truth.Span);
            const anchors = decls.filter((a) => a instanceof Truth.InfixSpan);
            const spansText = spans.map(s => Truth.SubjectSerializer.forInternal(s)).join(", ");
            const anchorText = anchors.map(a => Truth.SubjectSerializer.forInternal(a)).join(", ");
            const ob = this.outbounds.length;
            const ib = this.inbounds.size;
            const path = includePath ? this.phrase.toString() + " " : "";
            const simple = [
                path,
                spansText.length ? "spans=" + spansText : "",
                anchorText.length ? "anchor=" + anchorText : "",
                "out=" + ob,
                "in=" + ib
            ].filter(s => s.trim()).join(", ");
            const fmt = (str) => str.split("\n").map(s => "\t\t" + s).join("\n");
            const obsVerbose = this.outbounds
                .map(ob => fmt(ob.toString()));
            const ibsVerbose = Array.from(this.inbounds.values())
                .map(ib => fmt(ib.toString()));
            const verbose = "\n\tOuts:\n" + obsVerbose.join("\n\n") +
                "\n\tIns:\n" + ibsVerbose.join("\n\n");
            return simple + verbose;
        }
    }
    /** */
    Node.rootNodes = new WeakMap();
    Truth.Node = Node;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class NodeIndex {
        constructor() {
            /**
             * Stores a map which is indexed by a unique term, and which as
             * values that are the nodes that use that term, either as a declaration
             * or an annotation.
             *
             * The purpose of this cache is to get a quick answer to the question:
             * "We added a new term at position X ... what nodes might possibly
             * have been affected by this?"
             */
            this.termToNodesMap = new Map();
            /**
             * Stores a map which is essentially a reverse of termToNodesMap.
             * This is so that when nodes need to be deleted or updated, we can
             * quickly find the place in termToNodesMap where the node has
             * been referenced.
             */
            this.nodesToTermsMap = new WeakMap();
        }
        /**
         * Updates the index by refreshing in the set of terms
         * that are associated with the specified node.
         */
        update(node) {
            const pastTerms = this.nodesToTermsMap.get(node);
            const presentTerms = this.getAssociatedTerms(node);
            if (pastTerms !== undefined) {
                for (const [idx, term] of pastTerms.entries()) {
                    if (presentTerms.includes(term))
                        continue;
                    pastTerms.splice(idx, 1);
                    const map = this.termToNodesMap.get(term);
                    if (map === undefined)
                        continue;
                    map.delete(node);
                    if (map.size === 0)
                        this.termToNodesMap.delete(term);
                }
            }
            for (const term of presentTerms) {
                const nodesForTerm = this.termToNodesMap.get(term) || (() => {
                    const out = new Set();
                    this.termToNodesMap.set(term, out);
                    return out;
                })();
                nodesForTerm.add(node);
            }
            this.nodesToTermsMap.set(node, presentTerms);
        }
        /**
         * @returns An array that contains the nodes that are associated
         * with the specified term that exist at or below the specified
         * depth. "Associated" means that the term is either equivalent
         * to the Node's main subject, or it is referenced in one of it's edges.
         */
        getNodesByTerm(term) {
            const out = this.termToNodesMap.get(term);
            return out ? Array.from(out) : [];
        }
        /**
         * Removes the specified node from the index, if it exists.
         */
        delete(deadNode) {
            const existingTerms = this.nodesToTermsMap.get(deadNode);
            if (existingTerms === undefined)
                return;
            for (const term of existingTerms) {
                const nodes = this.termToNodesMap.get(term);
                if (nodes === undefined)
                    continue;
                nodes.delete(deadNode);
                if (nodes.size === 0)
                    this.termToNodesMap.delete(term);
            }
            this.nodesToTermsMap.delete(deadNode);
        }
        /**
         * @returns An array that contains the terms associated with
         * the specified Node.
         */
        getAssociatedTerms(node) {
            const terms = [];
            if (node.subject instanceof Truth.Term)
                terms.push(node.subject);
            for (const smt of node.statements)
                for (const anno of smt.allAnnotations)
                    if (anno.boundary.subject instanceof Truth.Term)
                        terms.push(anno.boundary.subject);
            return terms;
        }
        /**
         * Serializes the index into a format suitable
         * for debugging and comparing against baselines.
         */
        toString() {
            const out = ["(Term Cache)"];
            for (const [term, nodes] of this.termToNodesMap) {
                out.push("\t" + term);
                out.push("\t\t: " + Array.from(nodes)
                    .map(node => node.phrase.toString())
                    .join(", "));
            }
            return out.join("\n").trim();
        }
    }
    Truth.NodeIndex = NodeIndex;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A HyperEdge connects an origin predecessor Node to a series of
     * successor Nodes. From graph theory, a "hyper edge" is different
     * from an "edge" in that it can have many successors:
     * https://en.wikipedia.org/wiki/Hypergraph
     */
    class HyperEdge {
        constructor(
        /**
         * The Node from where the HyperEdge connection begins.
         * For example, given the following document:
         *
         * Foo
         * 	Bar : Foo
         *
         * Two Node objects would be created, one for the first instance
         * of "Foo", and another for the instance of "Bar". A HyperEdge
         * would be created between "Bar" and "Foo", and it's
         * precedessor would refer to the Node representing the
         * occurence of "Bar".
         */
        predecessor, source, successors) {
            this.predecessor = predecessor;
            if (!(source.boundary.subject instanceof Truth.Term))
                throw Truth.Exception.unknownState();
            const successorNodes = successors
                .map(scsr => scsr.node)
                .filter((v, i, a) => a.indexOf(v) === i);
            if (successorNodes.length !== successors.length)
                throw Truth.Exception.unknownState();
            this.term = source.boundary.subject;
            this._fragments = [source];
            this._successors = successors.slice();
        }
        /**
         * Attempts to add another fragment to the HyperEdge.
         * Reports a fault instead in the case when there is a
         * list conflict between the source provided and the
         * existing sources. (I.e. one of the sources is defined
         * as a list, and another is not).
         */
        addFragment(fragment) {
            ///const isPattern = this.predecessor.subject instanceof Pattern;
            ///const isInfix = source instanceof InfixSpan;
            ///if (isPattern !== isInfix)
            ///	throw Exception.invalidCall();
            if (this._fragments.includes(fragment))
                return;
            //! The ordering of the sources is not being handled here.
            this._fragments.push(fragment);
        }
        /**
         * Removes the specified annotation-side Span or InfixSpan
         * from this edge.
         */
        removeFragment(fragment) {
            const fragPos = this._fragments.indexOf(fragment);
            if (fragPos >= 0)
                this._fragments.splice(fragPos, 1);
        }
        /** */
        clearFragments() {
            this._fragments.length = 0;
        }
        /**
         * Gets the set of annotation-side Spans or annotation-side
         * InfixSpans that are responsible for the conception of this
         * HyperEdge.
         *
         * The array contains either Span instances or InfixSpan instances,
         * but never both. In the case when the array stores Span instances,
         * the location of those Spans are potentially scattered across many
         * statements.
         */
        get fragments() {
            return this._fragments;
        }
        /**
         *
         */
        addSuccessor(node, longitude) {
            if (!this._successors.find(scsr => scsr.node === node))
                this._successors.push(new Successor(node, longitude));
        }
        /**
         *
         */
        removeSuccessor(node) {
            for (let i = this._successors.length; i-- > 0;)
                if (this._successors[i].node === node)
                    this._successors.splice(i, 1);
        }
        /**
         * Stores all possible success Nodes to which the predecessor
         * Node is preemptively connected via this HyperEdge. The
         * connection is said to be preemptive, because the connection
         * might be ignored during polymorphic name resolution.
         */
        get successors() {
            return this._successors;
        }
        /**
         * Gets whether this HyperEdge has no immediately resolvable
         * successors. This means that the subject being referred to by
         * this HyperEdge is either a type alias which will be matched by
         * a pattern, or just a plain old fault.
         */
        get isDangling() {
            return this.successors.length === 0;
        }
        /**
         * Gets a value that indicates whether the sources of the edge
         * causes incrementation of the list dimensionality of the type
         * that corresponnds to this HyperEdge's predecessor Node.
         *
         * (Note that all sources need to agree on this value, and the
         * necessary faults are generated to ensure that this is always
         * the case.)
         */
        get isList() {
            for (const source of this.fragments) {
                const sub = source.boundary.subject;
                return sub instanceof Truth.Term && sub.isList;
            }
            return false;
        }
        /**
         * Gets a value that indicates the specific part of the
         * predecessor where this HyperEdge begins.
         */
        get predecessorOrigin() {
            //! Is this still necessary?
            if (this._fragments.length === 0)
                throw Truth.Exception.unknownState();
            const src = this._fragments[0];
            if (src instanceof Truth.Span)
                return HyperEdgeOrigin.statement;
            if (src.containingInfix.isPortability)
                return HyperEdgeOrigin.portabilityInfix;
            if (src.containingInfix.isPopulation)
                return HyperEdgeOrigin.populationInfix;
            if (src.containingInfix.isPattern)
                return HyperEdgeOrigin.patternInfix;
            throw Truth.Exception.unknownState();
        }
        /**
         * @returns A string representation of this HyperEdge,
         * suitable for debugging and testing purposes.
         */
        toString() {
            const print = (sub) => Truth.SubjectSerializer.forInternal(sub);
            return [
                "Value=" + this.term,
                "Predecessors=" + print(this.predecessor.subject),
                "Successors=" + this.successors
                    .map(n => print(n.node.subject) + " << " + n.longitude)
                    .join(", "),
                "Sources=" + Array.from(this.fragments)
                    .map(src => src.boundary.subject).join(", "),
                "---"
            ].join("\n");
        }
    }
    Truth.HyperEdge = HyperEdge;
    /**
     * @internal
     */
    class Successor {
        constructor(node, 
        /**
         * The the number of levels of depth in the containment
         * hierarchy that need to be crossed in order for the containing
         * HyperEdge to be established between the predecessor and
         * this successor.
         */
        longitude) {
            this.node = node;
            this.longitude = longitude;
            this.stamp = Truth.VersionStamp.next();
        }
    }
    Truth.Successor = Successor;
    /**
     * @internal
     * Indicates the place in a statement where a HyperEdge starts.
     * (HyperEdges can start either at the statement level, or within
     * various kinds of infixes.)
     */
    let HyperEdgeOrigin;
    (function (HyperEdgeOrigin) {
        HyperEdgeOrigin[HyperEdgeOrigin["statement"] = 0] = "statement";
        HyperEdgeOrigin[HyperEdgeOrigin["populationInfix"] = 1] = "populationInfix";
        HyperEdgeOrigin[HyperEdgeOrigin["portabilityInfix"] = 2] = "portabilityInfix";
        HyperEdgeOrigin[HyperEdgeOrigin["patternInfix"] = 3] = "patternInfix";
    })(HyperEdgeOrigin = Truth.HyperEdgeOrigin || (Truth.HyperEdgeOrigin = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that marks out the location of an infix term within
     * it's containing Infix, it's containing Span, and then it's containing
     * Statement, Document, and Program.
     */
    class InfixSpan {
        constructor(containingSpan, containingInfix, boundary) {
            this.containingSpan = containingSpan;
            this.containingInfix = containingInfix;
            this.boundary = boundary;
        }
        /**
         * Gets the Statement that contains this Anchor.
         */
        get statement() {
            return this.containingSpan.statement;
        }
        /**
         * Gets a boolean value that indicates whether this InfixSpan
         * is considered object-level cruft, and should therefore be
         * ignored during type analysis.
         */
        get isCruft() {
            return this.containingSpan.statement.cruftObjects.has(this);
        }
    }
    Truth.InfixSpan = InfixSpan;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A worker class that handles the construction of networks
     * of Parallel instances, which are eventually transformed
     * into type objects.
     */
    class ConstructionWorker {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.excavated = new WeakSet();
            /** A call queue used to prevent circular drilling. */
            this.drillQueue = [];
            /**
             * Used for safety purposes to catch unexpected behavior.
             */
            this.handledHyperEdges = new WeakSet();
            /** */
            this.parallels = new Truth.ParallelCache();
            /**
             * Stores the set of Parallel instances that have been "raked",
             * which means that that have gone through the process of
             * having their requested bases applied.
             *
             * This set may include both pattern and non-patterns Parallels,
             * (even though their raking processes are completely different).
             */
            this.rakedParallels = new WeakSet();
            this.cruft = new Truth.CruftCache(this.program);
        }
        /**
         * Constructs the corresponding Parallel instances for
         * all explicit types that exist within the provided Document,
         * or below the provided ExplicitParallel.
         */
        excavate(from) {
            if (this.excavated.has(from))
                return;
            this.excavated.add(from);
            const queue = [];
            if (from instanceof Truth.Document) {
                for (const phrase of Truth.Phrase.rootsOf(from)) {
                    const drilledParallel = this.drillFromNode(phrase.associatedNode);
                    if (drilledParallel !== null)
                        queue.push(drilledParallel);
                }
            }
            else
                for (const currentParallel of queue) {
                    for (const node of currentParallel.node.contents.values()) {
                        const drilledParallel = this.drillFromNode(node);
                        if (drilledParallel !== null)
                            queue.push(drilledParallel);
                    }
                }
        }
        /**
         * Constructs the fewest possible Parallel instances
         * to arrive at the type specified by the directive.
         */
        drill(directive) {
            const result = this.drillFromPhrase(directive);
            this.drillQueue.length = 0;
            return result;
        }
        /** */
        drillFromPhrase(directive) {
            if (this.parallels.has(directive))
                return Truth.Not.undefined(this.parallels.get(directive));
            if (directive.length === 0)
                throw Truth.Exception.invalidArgument();
            const ancestry = directive.ancestry;
            const surfaceNode = directive.containingDocument.phrase
                .forward(ancestry[0].terminal)
                .associatedNode;
            if (surfaceNode === null)
                return null;
            let typeIdx = 0;
            let lastSeed = this.parallels.get(directive.back()) ||
                this.rake(this.parallels.create(surfaceNode, this.cruft));
            // This code skips by any Parallel instances that have already
            // been constructed. The real work begins when we get to
            // the first point in the Phrase where there is no constructed
            // Parallel instance.
            for (const phrase of ancestry) {
                if (!this.parallels.has(phrase))
                    break;
                lastSeed = Truth.Not.undefined(this.parallels.get(phrase));
                if (++typeIdx >= directive.length)
                    return lastSeed;
            }
            do {
                const targetSubject = ancestry[typeIdx].terminal;
                const descended = this.descend(lastSeed, targetSubject);
                if (descended === null)
                    return null;
                lastSeed = this.rake(descended);
            } while (++typeIdx < directive.length);
            return lastSeed;
        }
        /**
         * An entrypoint into the drill function that operates
         * on a Node instead of a Phrase. Essentially, this method
         * calls "drillFromPhrase()" safely (meaning that it detects
         * circular invokations, and returns null in these cases).
         */
        drillFromNode(node) {
            // Circular drilling is only a problem if we're
            // drilling on the same level.
            const dq = this.drillQueue;
            if (dq.length === 0) {
                dq.push(node);
            }
            else if (dq[0].container === node.container) {
                if (dq.includes(node))
                    return null;
            }
            else {
                dq.length = 0;
                dq.push(node);
            }
            const drillResult = this.drillFromPhrase(node.phrase);
            if (drillResult === null)
                throw Truth.Exception.unknownState();
            if (!(drillResult instanceof Truth.ExplicitParallel))
                throw Truth.Exception.unknownState();
            return drillResult;
        }
        /**
         * "Raking" a Parallel is the process of deeply traversing it's
         * Parallel Graph (depth first), and for each visited Parallel,
         * deeply traversing it's Base Graph as well (also depth first).
         * Through this double-traversal process, the Parallel's edges
         * are constructed into a traversable graph.
         */
        rake(seed) {
            // If the seed's container is null, this means that the seed
            // is root-level, and so it cannot have any Parallel types.
            // It may however have Base types, and these need to be
            // handled.
            if (seed.container === null) {
                if (!(seed instanceof Truth.ExplicitParallel))
                    throw Truth.Exception.unknownState();
                this.rakeExplicitParallel(seed);
            }
            else
                this.rakeParallelGraph(seed);
            return seed;
        }
        /**
         * Recursive function that digs through the parallel graph,
         * and rakes all ExplicitParallels that are discovered.
         */
        rakeParallelGraph(par) {
            for (const edgePar of par.getParallels())
                this.rakeParallelGraph(edgePar);
            if (par instanceof Truth.ExplicitParallel)
                this.rakeExplicitParallel(par);
        }
        /**
         * Splitter method that rakes both a pattern and a non-pattern
         * containing ExplicitParallel.
         */
        rakeExplicitParallel(par) {
            if (this.rakedParallels.has(par))
                return par;
            this.rakedParallels.add(par);
            if (par.pattern)
                this.rakePatternBases(par);
            else
                this.rakeBaseGraph(par);
        }
        /**
         * Recursively follows the bases of the specified source Node.
         * Parallel instances are created for any visited Node instance
         * that does not have one already created.
         * Although the algorithm is careful to avoid circular bases, it's
         * too early in the processing pipeline to report these circular
         * bases as faults. This is because polymorphic name resolution
         * needs to take place before the system can be sure that a
         * seemingly-circular base structure is in fact what it seems.
         * True circular base detection is therefore handled at a future
         * point in the pipeline.
         */
        rakeBaseGraph(srcParallel) {
            if (srcParallel.pattern)
                throw Truth.Exception.unknownState();
            for (const hyperEdge of srcParallel.node.outbounds) {
                if (this.cruft.has(hyperEdge))
                    continue;
                const possibilities = hyperEdge.successors
                    .filter(scsr => !this.cruft.has(scsr.node))
                    .sort((a, b) => a.longitude - b.longitude);
                if (possibilities.length > 0) {
                    // This is where the polymorphic name resolution algorithm
                    // takes place. The algorithm operates by working it's way
                    // up the list of nodes (aka the scope chain), looking for
                    // a possible resolution target where the act of applying the
                    // associated Parallel as a base, causes at least one of the 
                    // conditions on the contract to be satisfied. Or, in the case
                    // when there are no conditions on the contract, the node
                    // that is the closest ancestor is used.
                    for (const possibleScsr of possibilities) {
                        const possibleNode = possibleScsr.node;
                        const baseParallel = this.drillFromNode(possibleNode);
                        // baseParallel will be null in the case when a circular
                        // relationship has been detected (and quitting is
                        // required here in order to avoid a stack overflow).
                        if (baseParallel === null)
                            continue;
                        this.rakeExplicitParallel(baseParallel);
                        // There are cases when an entire parallel needs to be
                        // "excavated", meaning that the Parallel's entire subtree
                        // of contents needs to be analyzed and converted into
                        // parallels. This is necessary because a fully defined set
                        // of parallels is required in order to detect discrepant
                        // unions (and therefore, report the attempt at a type
                        // union as faulty).
                        if (srcParallel.baseCount > 0) {
                            if (srcParallel.baseCount === 1)
                                this.excavate(srcParallel.firstBase);
                            this.excavate(baseParallel);
                        }
                        if (!srcParallel.tryAddLiteralBase(baseParallel, hyperEdge))
                            continue;
                        if (this.handledHyperEdges.has(hyperEdge))
                            throw Truth.Exception.unknownState();
                        this.handledHyperEdges.add(hyperEdge);
                        continue;
                    }
                }
                else {
                    // At this point, we've discovered an annotation that we're
                    // going to try to resolve as an alias. If this doesn't work,
                    // the edge will be marked as cruft. Possibly a future version
                    // of this compiler will allow other agents to hook into this
                    // process and augment the resolution strategy.
                    const candidatePatternPars = [];
                    for (const { patternParallel } of this.ascend(srcParallel)) {
                        this.rakePatternBases(patternParallel);
                        candidatePatternPars.push(patternParallel);
                    }
                    if (candidatePatternPars.length > 0) {
                        const terms = hyperEdge.fragments
                            .map(src => src.boundary.subject)
                            .filter((v) => v instanceof Truth.Term);
                        if (terms.length === 0)
                            continue;
                        const alias = terms[0].textContent;
                        if (srcParallel.tryAddAliasedBase(candidatePatternPars, hyperEdge, alias)) {
                            this.handledHyperEdges.add(hyperEdge);
                            continue;
                        }
                    }
                    if (!this.handledHyperEdges.has(hyperEdge))
                        this.cruft.add(hyperEdge, Truth.Faults.UnresolvedAnnotation);
                }
            }
            if (!srcParallel.isContractSatisfied)
                for (const smt of srcParallel.node.statements)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.ContractViolation, smt));
            return srcParallel;
        }
        /**
         * Finds the set of bases that should be applied to the provided
         * pattern-containing ExplicitParallel instance, and attempts
         * to have them applied.
         */
        rakePatternBases(patternParallel) {
            if (!patternParallel.pattern)
                throw Truth.Exception.unknownState();
            const bases = new Map();
            const obs = patternParallel.node.outbounds;
            const nameOf = (edge) => Truth.SubjectSerializer.forInternal(edge.fragments[0]);
            for (let i = -1; ++i < obs.length;) {
                const hyperEdge = obs[i];
                if (this.cruft.has(hyperEdge))
                    continue;
                const len = hyperEdge.successors.length;
                // Because resolving pattern bases has non-polymorphic behavior, 
                // we can get away with checking for these faults here without going
                // through the whole drilling process.
                if (len === 0) {
                    this.cruft.add(hyperEdge, Truth.Faults.UnresolvedAnnotation);
                    continue;
                }
                if (obs.findIndex(e => nameOf(e) === nameOf(hyperEdge)) !== i) {
                    this.cruft.add(hyperEdge, Truth.Faults.IgnoredAnnotation);
                    continue;
                }
                if (len > 1)
                    throw Truth.Exception.unknownState();
                const baseNode = hyperEdge.successors[0].node;
                const baseParallel = this.drillFromNode(baseNode);
                if (baseParallel !== null)
                    bases.set(baseParallel, hyperEdge);
            }
            // Circular bases still need to be checked. It's unclear how and
            // where to actually do this, while factoring in the constraint
            // that these can be caused through the use of aliases.
            // Anything that is a list (with any dimensionality) needs to be
            // cut off, because these bases can't be applied to patterns.
            for (const [base, via] of bases)
                if (base.getListDimensionality() > 0)
                    this.cruft.add(via, Truth.Faults.PatternMatchingList);
            // Now we need to determine if any of these bases are redundant.
            // This is done by checking to see if any of the bases are specified
            // somewhere in the base graph of all others.
            for (const [baseA] of bases)
                for (const [baseB, via] of bases)
                    if (baseA !== baseB)
                        if (baseA.hasBase(baseB))
                            this.cruft.add(via, Truth.Faults.IgnoredAnnotation);
            const pattern = patternParallel.node.subject;
            const span = patternParallel.node.declarations.values().next().value;
            const portInfixes = pattern.getInfixes(Truth.InfixFlags.portability);
            if (portInfixes.length > 0) {
                const validPortabilityInfixes = [];
                for (const portInfix of portInfixes) {
                    const nfxAnnosIter = span.eachAnnotationForInfix(portInfix);
                    const nfxAnnos = Array.from(nfxAnnosIter);
                    if (nfxAnnos.length === 0)
                        throw Truth.Exception.unknownState();
                    // At this time, we're currently generating a fault in the case when
                    // a portability infix has multiple definitions. Although the parser
                    // and the Graph-level infrastructure supports this, more study is
                    // required in order to determine if this is a characteristic of Truth.
                    if (nfxAnnos.length > 1) {
                        for (const nfx of nfxAnnos.slice(1))
                            this.cruft.add(nfx, Truth.Faults.PortabilityInfixHasUnion);
                    }
                    else
                        validPortabilityInfixes.push(portInfix);
                }
                // This code checks for overlapping types. The algorithm used here is
                // similar to the redundant bases check used above. However, in the case
                // of infixes, these aren't just redundant, they would be problematic if
                // left in. To explain why, try to figure out how a String type would draw
                // it's data out of an alias matching the following pattern:
                // 	/< : Email>< : String> : Type
                // (hint: it doesn't work)
                //! Not implemented
            }
            // TODO: Check for use of lists within any kind of infix.
            // It's possible for no collected bases to be returned
            // in the case when there were actually annotations
            // specified within the file, but they were all found to
            // be cruft.
            if (bases.size === 0)
                return;
            patternParallel.tryApplyPatternBases(bases);
        }
        /**
         * A generator function that works its way upwards, starting at the
         * provided ExplicitParallel. The function yields the series of
         * Parallels that contain Patterns that are visible to the provided
         * srcParallel. The bases of these parallels have not necessarily
         * been applied.
         *
         * The ordering of the Parallels yielded is relevant. The instances
         * that were yielded closer to the beginning take prescedence over
         * the ones yielded at the end.
         */
        *ascend(srcParallel) {
            const discoveredPatternNodes = new Set();
            const yieldable = (patternNode) => {
                discoveredPatternNodes.add(patternNode);
                return Truth.Not.null(this.parallels.get(patternNode) ||
                    this.parallels.create(patternNode, this.cruft));
            };
            function* recurse(current) {
                for (const { base } of current.eachBase())
                    yield* recurse(base);
                if (current instanceof Truth.ExplicitParallel)
                    for (const node of current.node.contents.values())
                        if (node.subject instanceof Truth.Pattern)
                            if (!discoveredPatternNodes.has(node))
                                yield {
                                    pattern: node.subject,
                                    patternParallel: yieldable(node)
                                };
            }
            // The process starts at the container of the current parallel,
            // even though this function needs to yield other parallels that
            // are adjacent to srcParallel, because we reach back into the
            // adjacents from the container.
            for (let current = srcParallel.container; current instanceof Truth.ExplicitParallel;) {
                yield* recurse(current);
                current = current.container;
            }
            for (const phrase of Truth.Phrase.rootsOf(srcParallel.node.document))
                if (phrase.terminal instanceof Truth.Pattern)
                    if (!discoveredPatternNodes.has(phrase.associatedNode))
                        yield {
                            pattern: phrase.terminal,
                            patternParallel: yieldable(phrase.associatedNode)
                        };
        }
        /**
         * Constructs and returns a new seed Parallel from the specified
         * zenith Parallel, navigating downwards to the specified target subject.
         */
        descend(zenith, targetSubject) {
            /**
             * @returns A new Parallel (either being a ExplicitParallel
             * or an ImplicitParallel instance), that corresponds to
             * the specified zenith parallel.
             */
            const descendOne = (zenith) => {
                if (zenith instanceof Truth.ExplicitParallel) {
                    const nextNode = zenith.node.contents.get(targetSubject);
                    if (nextNode) {
                        const out = this.parallels.get(nextNode) ||
                            this.parallels.create(nextNode, this.cruft);
                        this.verifyDescend(zenith, out);
                        return out;
                    }
                }
                const nextPhrase = zenith.phrase.forward(targetSubject);
                return (this.parallels.get(nextPhrase) ||
                    this.parallels.create(nextPhrase));
            };
            /**
             * @returns A boolean value that indicates whether the act
             * of descending from the specified Parallel to the typeName
             * passed to the containing method is going to result in a
             * ExplicitParallel instance.
             */
            function canDescendToExplicit(parallel) {
                return (parallel instanceof Truth.ExplicitParallel &&
                    parallel.node.contents.has(targetSubject));
            }
            //
            // TODO: These functions can probably be replaced with
            // a call to Misc.reduceRecursive()
            //
            function* recurseParallels(par) {
                for (const parEdge of par.getParallels())
                    yield* recurseParallels(parEdge);
                yield par;
            }
            function* recurseBases(par) {
                for (const { base } of par.eachBase())
                    yield* recurseBases(base);
                yield par;
            }
            function* recurse(par) {
                for (const parallelEdge of recurseParallels(par)) {
                    if (parallelEdge instanceof Truth.ExplicitParallel)
                        for (const baseEdge of recurseBases(parallelEdge))
                            yield baseEdge;
                    yield parallelEdge;
                }
            }
            // The following algorithm performs a recursive reduction on
            // the zenith, and produces a set of Parallels to prune from the
            // descension process. The Parallels that end up getting pruned
            // are the ones that, if unpruned, would result in a layer that
            // has ImplicitParallels that shouldn't actually exist. For
            // example, consider the following document:
            //
            // Class
            // 
            // SubClass : Class
            // 	Child
            // 
            // "Class" should not have an ImplicitParallel called "Child",
            // because that was introduced in the derived "SubClass" type.
            // And so this algorithm stakes out cut off points so that we don't
            // blindly just descend all Parallels in the layer.
            const prunedParallels = new Set();
            const pruneParallelsFollowFn = (par) => {
                const upperParallels = par.getParallels().slice();
                if (par instanceof Truth.ExplicitParallel)
                    for (const { base } of par.eachBase())
                        upperParallels.push(base);
                return upperParallels;
            };
            const hasExplicitContents = Truth.Misc.reduceRecursive(zenith, pruneParallelsFollowFn, (current, results) => {
                const prune = results.every(result => !result) &&
                    !canDescendToExplicit(current);
                if (prune)
                    prunedParallels.add(current);
                return !prune;
            });
            // In the case when the method is attempting to descend
            // to a level where there are no nodes whose name match
            // the type name specified (i.e. the whole layer would be 
            // implicit parallels), null is returned because a descend
            // wouldn't make sense.
            if (!hasExplicitContents)
                return null;
            const descendParallelsFollowFn = (par) => {
                if (!(par instanceof Truth.ExplicitParallel))
                    return [];
                const bases = Array.from(par.eachBase())
                    .map(entry => entry.base)
                    .slice();
                const result = bases
                    .concat(par.getParallels())
                    .filter(par => !prunedParallels.has(par));
                return result;
            };
            const seed = Truth.Misc.reduceRecursive(zenith, descendParallelsFollowFn, (current, nested) => {
                const nextPar = descendOne(current);
                for (const edge of nested)
                    nextPar.addParallel(edge);
                return nextPar;
            });
            return seed;
        }
        /**
         * Performs verification on the descend operation.
         * Reports any faults that can occur during this process.
         */
        verifyDescend(zenithParallel, descendParallel) {
            if (descendParallel.node.subject instanceof Truth.Anon)
                if (zenithParallel.isListIntrinsic)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.AnonymousInListIntrinsic, descendParallel.node.statements[0]));
        }
    }
    Truth.ConstructionWorker = ConstructionWorker;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(phrase, container) {
            this.phrase = phrase;
            this.container = container;
            /**
             * Stores a version number for this instance,
             * useful for debugging purposes.
             */
            this.version = Truth.VersionStamp.next();
            this._contents = new Map();
            this._parallels = [];
            if ("DEBUG") {
                this.name = phrase.toString();
                if (this.name.startsWith("/"))
                    this.name = unescape(this.name);
            }
            if (container !== null)
                container._contents.set(phrase.terminal, this);
        }
        /**
         *
         */
        get contents() {
            return this._contents;
        }
        /** */
        getParallels() {
            return Object.freeze(this._parallels.slice());
        }
        /** */
        get hasParallels() {
            return this._parallels.length > 0;
        }
        /** */
        addParallel(parallel) {
            if (!this._parallels.includes(parallel))
                this._parallels.push(parallel);
        }
        /**
         * Returns a string representation of this Parallel, suitable for debugging purposes.
         */
        toString() {
            return this.phrase.toString();
        }
    }
    Truth.Parallel = Parallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class ExplicitParallel extends Truth.Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(node, container, cruft) {
            super(node.phrase, container);
            this._contract = null;
            this._bases = new Map();
            this._intrinsicExtrinsicBridge = null;
            /**
             * Stores a string representation of the compiled regular expression
             * associated with this instance, in the case when this instance is
             * a pattern parallel.
             *
             * This string representation should have any infixes compiled away,
             * and should be passable to a JavaScript RegExp, or to the Fsm system.
             */
            this.compiledExpression = null;
            this.node = node;
            this.cruft = cruft;
            node.document.program.faults.inform(node);
        }
        /** */
        get isContractSatisfied() {
            return this.contract.unsatisfiedConditions.size === 0;
        }
        /** */
        get contract() {
            // It's important that this contract is computed lazily, because
            // if you try to compute it in the constructor, the Parallel graph
            // won't be constructed, and you'll end up with an empty contract.
            if (this._contract === null)
                this._contract = new Truth.Contract(this);
            return this._contract;
        }
        /**
         * Gets the first base contained by this instance.
         * @throws In the case when this instance contains no bases.
         */
        get firstBase() {
            for (const baseEntry of this._bases.values())
                return baseEntry.parallels[0];
            throw Truth.Exception.unknownState();
        }
        /**
         * Performs a shallow traversal on the non-cruft bases
         * defined directly on this ExplicitParallel.
         */
        *eachBase() {
            for (const [edge, baseEntry] of this._bases)
                if (!this.cruft.has(edge))
                    for (const base of baseEntry.parallels)
                        yield { base, edge, aliased: baseEntry.aliased };
        }
        /**
         *
         */
        addBaseEntry(base, edge, aliased) {
            const existing = this._bases.get(edge);
            if (existing)
                existing.parallels.push(base);
            else
                this._bases.set(edge, { parallels: [base], aliased });
        }
        /**
         * Performs a deep traversal on the non-cruft bases
         * defined on this Parallel.
         */
        *eachBaseDeep() {
            const queue = Array.from(this.eachBase()).map(e => e.base);
            for (let i = -1; ++i < queue.length;) {
                const current = queue[i];
                yield current;
                for (const { base } of current.eachBase())
                    if (!queue.includes(base))
                        queue.push(base);
            }
        }
        /**
         * @returns A boolean value that indicates whether the provided
         * ExplicitParallel instance exists somewhere, possibly nested,
         * in the base graph of this instance.
         */
        hasBase(testBase) {
            const queue = Array.from(this.eachBase()).map(e => e.base);
            for (let i = -1; ++i < queue.length;) {
                const current = queue[i];
                if (current === testBase)
                    return true;
                for (const { base } of current.eachBase())
                    if (!queue.includes(base))
                        queue.push(base);
            }
            return false;
        }
        /**
         * Attempts to add the provided ExplicitParallel as a base of
         * this instance. If the addition of the new base would not generate
         * any critical faults, it is added. Otherwise, it's marked as cruft.
         *
         * @returns A boolean value that indicates whether the base
         * was added successfully.
         */
        tryAddLiteralBase(base, via) {
            if (this._bases.has(via))
                throw Truth.Exception.unknownState();
            // Just as a reminder -- pattern-containing parallels 
            // don't come into this method. Bases are applied to
            // patterns in tryApplyPatternBases.
            if (this.pattern)
                throw Truth.Exception.unknownState();
            const numSatisfied = this.contract.trySatisfyCondition(base);
            if (numSatisfied === 0 && this.contract.hasConditions)
                return false;
            const sanitizer = new Truth.Sanitizer(this, base, via, this.cruft);
            // In this case, we only need to do a 
            // shallow check for circular inheritance.
            if (sanitizer.detectCircularReferences())
                return false;
            if (sanitizer.detectListFragmentConflicts())
                return false;
            if (this.baseCount > 0)
                if (sanitizer.detectListDimensionalityConflict())
                    return false;
            this.addBaseEntry(base, via, false);
            return true;
        }
        /**
         * Attempts to indirectly apply a base to this ExplicitParallel via an alias
         * and edge.
         *
         * @param patternParallelCandidates The pattern-containing
         * ExplicitParallel instance whose bases should be applied to this
         * ExplicitParallel, if the provided alias is a match.
         *
         * @param viaEdge The HyperEdge in which the alias was found.
         *
         * @param viaAlias The string to test against the parallel embedded
         * within patternParallelCandidates.
         *
         * @returns A boolean value that indicates whether a base was added
         * successfully.
         */
        tryAddAliasedBase(patternParallelCandidates, viaEdge, viaAlias) {
            if (this._bases.has(viaEdge))
                throw Truth.Exception.unknownState();
            const chosenParallels = patternParallelCandidates.slice();
            const conditions = this.contract.unsatisfiedConditions;
            const beganWithConditions = conditions.size > 0;
            if (beganWithConditions) {
                let maxMatchCount = 1;
                nextCandidate: for (const candidate of patternParallelCandidates) {
                    const entries = Array.from(candidate._bases.values());
                    const candidateBases = entries
                        .map(e => e.parallels)
                        .reduce((a, b) => a.concat(b), []);
                    if (candidateBases.length < maxMatchCount)
                        continue;
                    for (const candidateBase of candidateBases)
                        if (!conditions.has(candidateBase))
                            continue nextCandidate;
                    chosenParallels.push(candidate);
                    maxMatchCount = candidateBases.length;
                }
                if (chosenParallels.length === 0)
                    return false;
            }
            let wasAdded = false;
            for (const chosenParallel of chosenParallels) {
                // Just as a reminder -- pattern-containing parallels don't come
                // into this method ... only the aliases that might match them.
                if (this.pattern || !chosenParallel.pattern)
                    throw Truth.Exception.unknownState();
                // If the targetPattern has no infixes, we can get away with a simple
                // check to see if the alias matches the regular expression.
                if (!chosenParallel.pattern.hasInfixes()) {
                    if (!chosenParallel.pattern.test(viaAlias))
                        continue;
                    if (beganWithConditions)
                        if (this.contract.trySatisfyCondition(chosenParallel) === 0)
                            continue;
                    this.addBaseEntry(chosenParallel, viaEdge, true);
                    wasAdded = true;
                }
            }
            // Not implemented, but we shouldn't throw an exception here yet.
            return wasAdded;
        }
        /**
         * Attempts to apply a set of bases to a pattern-containing parallel.
         *
         * @example
         * /pattern : This, Function, Adds, These
         */
        tryApplyPatternBases(baseTable) {
            const bases = Array.from(baseTable.keys());
            // Non-Pattern nodes should never come to this method.
            if (!this.pattern)
                throw Truth.Exception.unknownState();
            const basesDeep = bases
                .map(b => Array.from(b.eachBaseDeep()))
                .reduce((a, b) => a.concat(b), [])
                .filter((v, i, a) => a.indexOf(v) === i);
            // Reminder: the ExplicitParallels in the basesDeep array
            // are expected to be fully processed by the time we get to
            // this method. It should be safe to touch them.
            if (basesDeep.length > 0) {
                const basesNodes = bases.map(b => b.node);
                // Finds all pattern nodes that have an edge that points
                // to at least one of the bases in the basesDeep array.
                const basesDeepSprawl = basesDeep
                    .map(b => Array.from(b.node.inbounds))
                    .reduce((a, b) => a.concat(b), [])
                    .map(inb => inb.predecessor)
                    .filter((v, i, a) => a.indexOf(v) === i)
                    .filter(node => node.subject instanceof Truth.Pattern)
                    .filter(node => node.outbounds
                    .filter(ob => ob.successors.length === 0)
                    .map(ob => ob.successors[0].node)
                    .every(node => basesNodes.includes(node)));
                const basesDeepSprawlPatterns = basesDeepSprawl
                    .map(n => n.subject)
                    .filter((s) => s instanceof Truth.Pattern);
                /**
                 * At this point, we need to test every single one of the
                 * patterns in basesDeepSprawlPatterns against this
                 * this.node.subject to make sure the two patterns are
                 * compliant.
                 *
                 * If they're not compliant, we need to start marking
                 * bases as cruft until they are.
                 *
                 * There is also a recursive infix embed process that
                 * needs to happen here, but maybe we should just
                 * put this off until the basic pattern functionality
                 * is working?
                 */
            }
            /**
             * This also needs to take into account any other patterns
             * that are applied to any of the bases defined directly
             * inline.
             */
            // Here we're just adding all the bases regardless of whether
            // or not any of the associated edges were marked as cruft.
            // The other enumerators skip over cruft edges, so this likely
            // isn't a problem, and it keeps it consistent with the way the
            // rest of the system works.
            for (const [base, via] of baseTable)
                this.addBaseEntry(base, via, false);
        }
        /**
         * Gets the number of bases that have
         * been explicitly applied to this Parallel.
         */
        get baseCount() {
            return this._bases.size;
        }
        /** */
        get isListIntrinsic() {
            return this.node.isListIntrinsic;
        }
        /** */
        get intrinsicExtrinsicBridge() {
            return this._intrinsicExtrinsicBridge;
        }
        /**
         * Establishes a bridge between this ExplicitParallel and the
         * one provided.
         */
        createIntrinsicExtrinsicBridge(parallel) {
            if (this._intrinsicExtrinsicBridge !== null)
                throw Truth.Exception.unknownState();
            if (parallel._intrinsicExtrinsicBridge !== null)
                throw Truth.Exception.unknownState();
            if (parallel.node.isListIntrinsic === this.node.isListIntrinsic)
                throw Truth.Exception.unknownState();
            this._intrinsicExtrinsicBridge = parallel;
            parallel._intrinsicExtrinsicBridge = this;
        }
        /** */
        getListDimensionality() {
            // NOTE: This actually needs to be "each base inferred"
            // This is purposely only returning the dimensionality of
            // the first base. There is a guarantee that all dimensionalities
            // will be the same here.
            for (const { base, edge } of this.eachBase()) {
                const initialDim = base.getListDimensionality();
                return edge.isList ? initialDim + 1 : initialDim;
            }
            return 0;
        }
        /**
         *
         */
        comparePatternTo(other) {
        }
        /**
         *
         */
        maybeCompilePattern() {
            ///if (!this.pattern)
            ///	return;
            ///if (!pattern.hasInfixes())
            ///	this.compiledExpression = pattern.
        }
        /**
         * Gets the Pattern instance that resides inside this ExplicitParallel,
         * or null in the case when this ExplicitParallel does not have an
         * inner Pattern.
         */
        get pattern() {
            return this.node.subject instanceof Truth.Pattern ?
                this.node.subject :
                null;
        }
    }
    Truth.ExplicitParallel = ExplicitParallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class ImplicitParallel extends Truth.Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(phrase, container) {
            super(phrase, container);
        }
    }
    Truth.ImplicitParallel = ImplicitParallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A simple class for handling objects marked as cruft.
     */
    class CruftCache {
        /** */
        constructor(program) {
            this.program = program;
            /** Stores a set of objects that have been marked as cruft. */
            this.cruft = new Set();
        }
        /**
         * Adds a fault of the specified type to the internal set,
         * marks all relevant objects as cruft, and reports the
         * relevant fault type.
         */
        add(cruft, relevantFaultType) {
            const faultSources = cruft instanceof Truth.Node ? cruft.statements :
                cruft instanceof Truth.HyperEdge ? cruft.fragments :
                    [cruft];
            for (const faultSrc of faultSources) {
                const fault = new Truth.Fault(relevantFaultType, faultSrc);
                this.program.faults.report(fault);
                this.cruft.add(faultSrc);
            }
            this.cruft.add(cruft);
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified object has been marked as cruft.
         */
        has(source) {
            return this.cruft.has(source);
        }
    }
    Truth.CruftCache = CruftCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class ParallelCache {
        constructor() {
            /**
             * Stores a map of all Parallel objects that have been constructed,
             * keyed by the Phrase to which they correspond.
             */
            this.parallels = new Map();
        }
        create(key, cruft) {
            if (this.has(key))
                throw Truth.Exception.unknownState();
            const save = (par) => {
                const keyVal = this.getKeyVal(key);
                this.parallels.set(keyVal, par);
                return par;
            };
            const container = (() => {
                if (key instanceof Truth.Node)
                    return key.container !== null ?
                        Truth.Not.undefined(this.get(key.container)) :
                        null;
                return key.length > 1 ?
                    Truth.Not.undefined(this.get(key.back())) :
                    null;
            })();
            if (key instanceof Truth.Phrase)
                return save(new Truth.ImplicitParallel(key, container));
            if (!(container instanceof Truth.ExplicitParallel) && container !== null)
                throw Truth.Exception.unknownState();
            if (cruft === undefined)
                throw Truth.Exception.unknownState();
            const outPar = new Truth.ExplicitParallel(key, container, cruft);
            if (key.intrinsicExtrinsicBridge === null)
                return save(outPar);
            if (this.has(key.intrinsicExtrinsicBridge))
                throw Truth.Exception.unknownState();
            const bridgePar = new Truth.ExplicitParallel(key.intrinsicExtrinsicBridge, container, cruft);
            outPar.createIntrinsicExtrinsicBridge(bridgePar);
            return save(outPar);
        }
        get(key) {
            const keyVal = this.getKeyVal(key);
            const out = this.parallels.get(keyVal);
            if (key instanceof Truth.Node)
                if (out !== undefined)
                    if (!(out instanceof Truth.ExplicitParallel))
                        throw Truth.Exception.unknownState();
            return out;
        }
        /** */
        has(key) {
            return this.parallels.has(this.getKeyVal(key));
        }
        /** */
        getKeyVal(key) {
            return key instanceof Truth.Node ? key.phrase : key;
        }
        /** */
        get debug() {
            const text = [];
            for (const parallel of this.parallels.values())
                text.push(parallel.name || "(undefined)");
            return text.join("\n");
        }
    }
    Truth.ParallelCache = ParallelCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Contract {
        /** */
        constructor(sourceParallel) {
            this._unsatisfiedConditions = new Set();
            const recurse = (srcParallel) => {
                if (srcParallel instanceof Truth.ImplicitParallel) {
                    for (const nestedParallel of srcParallel.getParallels())
                        recurse(nestedParallel);
                }
                else if (srcParallel instanceof Truth.ExplicitParallel) {
                    for (const { base } of srcParallel.eachBase())
                        this._unsatisfiedConditions.add(base);
                }
            };
            for (const higherParallel of sourceParallel.getParallels())
                recurse(higherParallel);
            this.allConditions = Object.freeze(Array.from(this._unsatisfiedConditions));
        }
        /**
         * Computes whether the input ExplicitParallel is a more derived
         * type of the ExplicitParallel that corresponds to this Contract.
         *
         * @returns A number that indicates the number of conditions that
         * were satisfied as a result of adding the provided ExplicitParallel
         * to the Contract.
         */
        trySatisfyCondition(foreignParallel) {
            if (this.allConditions.length === 0)
                return 0;
            const foreignParallelBases = new Set();
            foreignParallelBases.add(foreignParallel);
            let satisfied = 0;
            const addForeignParallelBases = (srcParallel) => {
                for (const { base } of srcParallel.eachBase())
                    addForeignParallelBases(base);
                foreignParallelBases.add(srcParallel);
            };
            for (const { base } of foreignParallel.eachBase())
                addForeignParallelBases(base);
            for (const foreignBase of foreignParallelBases)
                for (const condition of this.allConditions)
                    if (foreignBase === condition)
                        satisfied += this._unsatisfiedConditions.delete(condition) ? 1 : 0;
            return satisfied;
        }
        /** */
        get hasConditions() {
            return this.allConditions.length > 0;
        }
        /** */
        get unsatisfiedConditions() {
            return this._unsatisfiedConditions;
        }
    }
    Truth.Contract = Contract;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that encapsulates the actual fault detection behavior,
     * with facilities to perform analysis on Parallel instances, before
     * the actual base has been applied to it.
     */
    class Sanitizer {
        /** */
        constructor(targetParallel, proposedBase, proposedEdge, cruft) {
            this.targetParallel = targetParallel;
            this.proposedBase = proposedBase;
            this.proposedEdge = proposedEdge;
            this.cruft = cruft;
            this._foundCruft = false;
        }
        /**
         * Detects list operartor conflicts between the fragments of an
         * annotation. For example, conflicts of the following type are
         * caught here:
         *
         * List : Item
         * List : Item...
         */
        detectListFragmentConflicts() {
            const sources = this.proposedEdge.fragments;
            if (sources.length === 0)
                return false;
            const spans = sources.filter((src) => src instanceof Truth.Span);
            const terms = spans
                .map(f => f.boundary.subject)
                .filter((sub) => sub instanceof Truth.Term);
            const termsList = terms.filter(id => id.isList);
            const termsNonList = terms.filter(id => !id.isList);
            if (termsList.length > 0 && termsNonList.length > 0)
                for (const span of spans)
                    this.addFault(span, Truth.Faults.ListAnnotationConflict);
            return this.foundCruft;
        }
        /** */
        detectCircularReferences() {
            const circularEdgePaths = [];
            const recurse = (srcBase, path) => {
                for (const { base, edge } of this.basesOf(srcBase)) {
                    if (path.includes(edge))
                        circularEdgePaths.push(path.slice());
                    else
                        recurse(base, path.concat(edge));
                }
            };
            for (const { base, edge } of this.basesOf(this.targetParallel))
                recurse(base, []);
            for (const item of circularEdgePaths)
                for (const circularEdge of item)
                    this.addFault(circularEdge, Truth.Faults.CircularTypeReference);
            return this.foundCruft;
        }
        /** */
        detectListDimensionalityConflict() {
            const targetDim = this.targetParallel.getListDimensionality();
            const proposedDim = this.proposedBase.getListDimensionality() +
                (this.proposedEdge.isList ? 1 : 0);
            if (targetDim !== proposedDim)
                this.addFault(this.proposedEdge, Truth.Faults.ListDimensionalDiscrepancyFault);
            return this.foundCruft;
        }
        /** Gets a boolean value that indicates whether a fault has been reported. */
        get foundCruft() {
            return this._foundCruft;
        }
        /** */
        *basesOf(par) {
            for (const { base, edge } of par.eachBase())
                yield { base, edge };
            if (this.targetParallel === par)
                yield { base: this.proposedBase, edge: this.proposedEdge };
        }
        /** */
        addFault(source, relevantFaultType) {
            this._foundCruft = true;
            this.cruft.add(source, relevantFaultType);
        }
    }
    Truth.Sanitizer = Sanitizer;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a fully constructed type within the program.
     */
    class Type {
        /**
         *
         */
        constructor(seed, container) {
            /**
             * Stores whether this type represents the intrinsic
             * side of a list.
             */
            this.isListIntrinsic = false;
            /**
             * Stores whether this type represents the extrinsic
             * side of a list.
             */
            this.isListExtrinsic = false;
            /**
             * Stores whether this Type instance has no annotations applied to it.
             */
            this.isFresh = false;
            /**
             * Stores a value that indicates if this Type was directly specified
             * in the document, or if it's existence was inferred.
             */
            this.isExplicit = false;
            /** */
            this.isAnonymous = false;
            /** */
            this.isPattern = false;
            /** */
            this.isUri = false;
            /** */
            this.isList = false;
            this.private = new TypePrivate(seed);
            this.name = seed.phrase.terminal.toString();
            this.phrase = seed.phrase;
            this.outer = container;
            this.private.parallels = new Truth.TypeProxyArray(seed.getParallels().map(edge => new Truth.TypeProxy(edge.phrase)));
            const getBases = (ep) => {
                const bases = Array.from(ep.eachBase());
                return bases.map(entry => new Truth.TypeProxy(entry.base.node.phrase));
            };
            if (seed instanceof Truth.ExplicitParallel) {
                this.private.bases = new Truth.TypeProxyArray(getBases(seed));
            }
            else if (seed instanceof Truth.ImplicitParallel) {
                const queue = [seed];
                const explicitParallels = [];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    if (current instanceof Truth.ImplicitParallel)
                        queue.push(...current.getParallels());
                    else if (current instanceof Truth.ExplicitParallel)
                        explicitParallels.push(current);
                }
                const bases = explicitParallels
                    .map(par => getBases(par))
                    .reduce((a, b) => a.concat(b), [])
                    .filter((v, i, a) => a.indexOf(v) === i);
                this.private.bases = new Truth.TypeProxyArray(bases);
            }
            this.isList = false;
            if (seed instanceof Truth.ExplicitParallel) {
                const sub = seed.node.subject;
                this.isPattern = sub instanceof Truth.Pattern;
                this.isUri = sub instanceof Truth.KnownUri;
                this.isAnonymous = sub instanceof Truth.Anon;
                this.isExplicit = true;
                this.isFresh = seed.getParallels().length === 0;
            }
        }
        static construct(param) {
            const phrase = param instanceof Truth.Phrase ?
                param :
                Truth.Phrase.fromSpine(param);
            if (!phrase || phrase.length === 0)
                return null;
            if (Truth.TypeCache.has(phrase)) {
                const cached = Truth.TypeCache.get(phrase);
                // If the cached type exists, but hasn't been compiled yet,
                // we can't return it, we need to compile it first.
                if (!(cached instanceof Truth.TypeProxy))
                    return cached;
            }
            const program = phrase.containingDocument.program;
            const worker = (() => {
                const stored = this.parallelContextMap.get(program);
                if (stored === undefined) {
                    const newStored = {
                        version: program.version,
                        worker: new Truth.ConstructionWorker(program)
                    };
                    this.parallelContextMap.set(program, newStored);
                    return newStored.worker;
                }
                else if (program.version.newerThan(stored.version)) {
                    stored.version = program.version;
                    stored.worker = new Truth.ConstructionWorker(program);
                }
                return stored.worker;
            })();
            const parallel = worker.drill(phrase);
            if (parallel === null) {
                Truth.TypeCache.set(phrase, null);
                return null;
            }
            const parallelLineage = [parallel];
            for (let currentParallel = parallel.container; currentParallel !== null;) {
                parallelLineage.unshift(currentParallel);
                currentParallel = currentParallel.container;
            }
            let lastType = null;
            for (const currentParallel of parallelLineage) {
                if (Truth.TypeCache.has(currentParallel.phrase)) {
                    const existingType = Truth.TypeCache.get(currentParallel.phrase);
                    if (existingType instanceof Truth.TypeProxy)
                        throw Truth.Exception.unknownState();
                    if (existingType === null)
                        throw Truth.Exception.unknownState();
                    lastType = existingType;
                }
                else {
                    const type = new Type(currentParallel, lastType);
                    Truth.TypeCache.set(currentParallel.phrase, type);
                    lastType = type;
                }
            }
            return lastType;
        }
        /**
         * @internal
         * Constructs the invisible root-level Type object that corresponds
         * to the specified document.
         */
        static constructRoots(document) {
            const roots = [];
            for (const phrase of Truth.Phrase.rootsOf(document)) {
                const type = this.construct(phrase);
                if (type !== null)
                    roots.push(type);
            }
            return Object.freeze(roots);
        }
        /**
         * Stores an array of Statement objects that are responsible
         * for the initiation of this type. In the case when this Type
         * object represents a path that is implicitly defined, the
         * array is empty. For example, given the following document:
         *
         * ```
         * Class
         * 	Field
         * SubClass : Class
         * ```
         *
         * The type at path SubClass/Field is an implicit type, and
         * therefore, although a valid type object, has no phyisical
         * statements associated.
         */
        get statements() {
            this.private.throwOnDirty();
            if (this.private.statements !== null)
                return this.private.statements;
            if (!(this.private.seed instanceof Truth.ExplicitParallel))
                return this.private.statements = Object.freeze([]);
            return this.private.statements = this.private.seed.node.statements.slice();
        }
        /**
         * Stores a reference to the type, as it's defined in it's
         * next most applicable type.
         */
        get parallels() {
            this.private.throwOnDirty();
            return Truth.Not.null(this.private.parallels).maybeCompile();
        }
        /**
         * Stores a reference to the parallel roots of this type.
         * The parallel roots are the endpoints found when
         * traversing upward through the parallel graph.
         */
        get parallelRoots() {
            this.private.throwOnDirty();
            if (this.private.parallelRoots !== null)
                return this.private.parallelRoots;
            const roots = [];
            for (const { type } of this.iterate(t => t.parallels))
                if (type !== this && type.parallels.length === 0)
                    roots.push(type);
            return this.private.parallelRoots = Object.freeze(roots);
        }
        /**
         * Stores the array of types that are contained directly by this
         * one. In the case when this type is a list type, this array does
         * not include the list's intrinsic types.
         */
        get inners() {
            if (this.private.inners !== null)
                return this.private.inners;
            this.private.throwOnDirty();
            const innerSubs = [];
            // Dig through the parallel graph recursively, and at each parallel,
            // dig through the base graph recursively, and collect all the names
            // that are found.
            for (const { type: parallelType } of this.iterate(t => t.parallels, true))
                for (const { type: baseType } of parallelType.iterate(t => t.bases, true))
                    if (baseType.private.seed instanceof Truth.ExplicitParallel)
                        for (const subject of baseType.private.seed.node.contents.keys())
                            if (!innerSubs.includes(subject))
                                innerSubs.push(subject);
            const inners = innerSubs
                .map(innerSub => {
                const maybeInnerPhrase = this.phrase.forward(innerSub);
                return Type.construct(maybeInnerPhrase);
            })
                .filter((t) => t !== null);
            return this.private.inners = Object.freeze(inners);
        }
        /**
         * @internal
         * Stores the array of types that are contained directly by this
         * one. In the case when this type is not a list type, this array
         * is empty.
         */
        get innersIntrinsic() {
            if (this.private.innersIntrinsic !== null)
                return this.private.innersIntrinsic;
            if (!this.isList)
                return this.private.innersIntrinsic = Object.freeze([]);
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
        }
        /**
         * Stores the array of types from which this type extends.
         * If this Type extends from a pattern, it is included in this
         * array.
         */
        get bases() {
            this.private.throwOnDirty();
            if (this.private.bases === null)
                throw Truth.Exception.unknownState();
            return this.private.bases.maybeCompile();
        }
        /**
         * @internal
         * Not implemented.
         */
        get superordinates() {
            if (this.private.superordinates !== null)
                return this.private.superordinates;
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
            // eslint-disable-next-line no-unreachable
            return this.private.superordinates = Object.freeze([]);
        }
        /**
         * @internal
         * Not implemented.
         */
        get subordinates() {
            if (this.private.subordinates !== null)
                return this.private.subordinates;
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
            // eslint-disable-next-line no-unreachable
            return this.private.subordinates = Object.freeze([]);
        }
        /**
         * Gets an array that contains the types that derive from the
         * this Type instance.
         *
         * The types that derive from this one as a result of the use of
         * an alias are excluded from this array.
         */
        get derivations() {
            if (this.private.derivations !== null)
                return this.private.derivations;
            this.private.throwOnDirty();
            if (!(this.private.seed instanceof Truth.ExplicitParallel))
                return this.private.derivations = Object.freeze([]);
            const derivations = Array.from(this.private.seed.node.inbounds)
                .map(ib => ib.predecessor.phrase)
                .map(phrase => Type.construct(phrase))
                .filter((t) => t instanceof Type)
                .filter(type => type.bases.includes(this));
            return this.private.derivations = Object.freeze(derivations);
        }
        /**
         * Gets an array that contains the that share the same containing
         * type as this one.
         */
        get adjacents() {
            if (this.private.adjacents !== null)
                return this.private.adjacents;
            this.private.throwOnDirty();
            if (this.outer)
                return this.private.adjacents = this.outer.inners.filter(t => t !== this);
            const document = this.phrase.containingDocument;
            const roots = Array.from(Truth.Phrase.rootsOf(document));
            const adjacents = roots
                .map(phrase => Type.construct(phrase))
                .filter((t) => t !== null && t !== this);
            return this.private.adjacents = Object.freeze(adjacents);
        }
        /**
         * Gets an array that contains the patterns that resolve to this type.
         */
        get patterns() {
            if (this.private.patterns !== null)
                return this.private.patterns;
            this.private.throwOnDirty();
            // Stores a map whose keys are a concatenation of the Uris of all
            // the bases that are matched by a particular pattern, and whose
            // values are the type object containing that pattern. This map
            // provides an easy way to determine if there is already a pattern
            // that matches a particular set of types in the type scope.
            const patternMap = new Map();
            for (const { type } of this.iterate(t => t.outer)) {
                const applicablePatternTypes = type.adjacents
                    .filter(t => t.isPattern)
                    .filter(t => t.bases.includes(type));
                const applicablePatternsBasesLabels = applicablePatternTypes.map(p => p.bases
                    .map(b => b.phrase.toString())
                    .join("\n" /* terminal */));
                for (let i = -1; ++i < applicablePatternTypes.length;) {
                    const baseLabel = applicablePatternsBasesLabels[i];
                    if (!patternMap.has(baseLabel))
                        patternMap.set(baseLabel, applicablePatternTypes[i]);
                }
            }
            const out = Array.from(patternMap.values());
            return this.private.patterns = Object.freeze(out);
        }
        /**
         * Gets an array that contains the raw string values representing
         * the type aliases with which this type has been annotated.
         *
         * If this type is unspecified, the parallel graph is searched,
         * and any applicable type aliases will be present in the returned
         * array.
         */
        get aliases() {
            if (this.private.aliases !== null)
                return this.private.aliases;
            this.private.throwOnDirty();
            const aliases = [];
            const extractAlias = (ep) => {
                for (const { edge, aliased } of ep.eachBase())
                    if (aliased)
                        aliases.push(edge.term.toString());
            };
            if (this.private.seed instanceof Truth.ExplicitParallel) {
                extractAlias(this.private.seed);
            }
            else if (this.private.seed instanceof Truth.ImplicitParallel) {
                const queue = [this.private.seed];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    for (const parallel of current.getParallels()) {
                        if (parallel instanceof Truth.ExplicitParallel)
                            extractAlias(parallel);
                        else if (parallel instanceof Truth.ImplicitParallel)
                            queue.push(parallel);
                    }
                }
            }
            return this.private.aliases = aliases;
        }
        /**
         *
         */
        get values() {
            if (this.private.values !== null)
                return this.private.values;
            this.private.throwOnDirty();
            const values = [];
            const extractType = (ep) => {
                for (const { edge, aliased } of ep.eachBase())
                    values.push({
                        aliased,
                        value: edge.term.toString(),
                        base: Type.construct(edge.predecessor.phrase)
                    });
            };
            if (this.private.seed instanceof Truth.ExplicitParallel) {
                extractType(this.private.seed);
            }
            else if (this.private.seed instanceof Truth.ImplicitParallel) {
                const queue = [this.private.seed];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    for (const parallel of current.getParallels()) {
                        if (parallel instanceof Truth.ExplicitParallel)
                            extractType(parallel);
                        else if (parallel instanceof Truth.ImplicitParallel)
                            queue.push(parallel);
                    }
                }
            }
            return this.private.values = values;
        }
        /**
         * Gets the first alias stored in the .values array, or null if the
         * values array is empty.
         */
        get value() {
            return this.aliases.length > 0 ? this.aliases[0] : null;
        }
        /** */
        get isOverride() { return this.parallels.length > 0; }
        /** */
        get isIntroduction() { return this.parallels.length === 0; }
        /**
         * Gets a boolean value that indicates whether this Type
         * instance was created from a previous edit frame, and
         * should no longer be used.
         */
        get isDirty() {
            return this.private.program.version.newerThan(this.private.stamp);
        }
        /**
         * Performs an arbitrary recursive, breadth-first traversal
         * that begins at this Type instance. Ensures that no types
         * types are yielded multiple times.
         *
         * @param nextFn A function that returns a type, or an
         * iterable of types that are to be visited next.
         * @param reverse An optional boolean value that indicates
         * whether types in the returned array should be sorted
         * with the most deeply visited nodes occuring first.
         *
         * @returns An array that stores the list of types that were
         * visited.
         */
        visit(nextFn, reverse) {
            return Array.from(this.iterate(nextFn, reverse)).map(entry => entry.type);
        }
        /**
         * Performs an arbitrary recursive, breadth-first iteration
         * that begins at this Type instance. Ensures that no types
         * types are yielded multiple times.
         *
         * @param nextFn A function that returns a type, or an iterable
         * of types that are to be visited next.
         * @param reverse An optional boolean value that indicates
         * whether the iterator should yield types starting with the
         * most deeply nested types first.
         *
         * @yields An object that contains a `type` property that is the
         * the Type being visited, and a `via` property that is the Type
         * that was returned in the previous call to `nextFn`.
         */
        *iterate(nextFn, reverse) {
            const yielded = [];
            function* recurse(type, via) {
                if (yielded.includes(type))
                    return;
                if (!reverse) {
                    yielded.push(type);
                    yield { type, via };
                }
                const reduced = nextFn(type);
                if (reduced !== null && reduced !== undefined) {
                    if (reduced instanceof Type)
                        return yield* recurse(reduced, type);
                    for (const nextType of reduced)
                        if (nextType instanceof Type)
                            yield* recurse(nextType, type);
                }
                if (reverse) {
                    yielded.push(type);
                    yield { type, via };
                }
            }
            yield* recurse(this, null);
        }
        /**
         * Queries for a Type that is nested underneath this Type,
         * at the specified type path.
         */
        query(...typePath) {
            let currentType = null;
            for (const typeName of typePath) {
                const nextType = this.inners.find(type => type.name === typeName);
                if (!nextType)
                    break;
                currentType = nextType;
            }
            return currentType;
        }
        /**
         * Checks whether this Type has the specified type
         * somewhere in it's base graph.
         */
        is(baseType) {
            for (const { type } of this.iterate(t => t.bases))
                if (type === baseType)
                    return true;
            return false;
        }
        /**
         * Checks whether the specified type is in this Type's
         * `.inners` property, either directly, or indirectly via
         * the parallel graphs of the `.inners` Types.
         */
        has(type) {
            if (this.inners.includes(type))
                return true;
            for (const innerType of this.inners)
                if (type.name === innerType.name)
                    for (const parallel of innerType.iterate(t => t.parallels))
                        if (parallel.type === type)
                            return true;
            return false;
        }
    }
    /** */
    Type.parallelContextMap = new WeakMap();
    Truth.Type = Type;
    /**
     * @internal
     * A hidden class that stores the private information of
     * a Type instance, used to mitigate the risk of low-rank
     * developers from getting themselves into trouble.
     */
    class TypePrivate {
        constructor(seed) {
            this.seed = seed;
            /** */
            this.statements = null;
            /** */
            this.inners = null;
            /** */
            this.innersIntrinsic = null;
            /** */
            this.bases = null;
            /** */
            this.parallels = null;
            /** */
            this.parallelRoots = null;
            /** */
            this.patterns = null;
            /** */
            this.aliases = null;
            /** */
            this.values = null;
            /** */
            this.superordinates = null;
            /** */
            this.subordinates = null;
            /** */
            this.derivations = null;
            /** */
            this.adjacents = null;
            this.stamp = this.program.version;
        }
        /** */
        get program() {
            return this.seed.phrase.containingDocument.program;
        }
        /** */
        throwOnDirty() {
            if (this.program.version.newerThan(this.stamp))
                throw Truth.Exception.objectDirty();
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeProxy {
        /** */
        constructor(phrase) {
            this.phrase = phrase;
            /** */
            this.compiledType = undefined;
        }
        /** */
        maybeCompile() {
            if (this.compiledType !== undefined)
                return this.compiledType;
            return this.compiledType = Truth.Type.construct(this.phrase);
        }
    }
    Truth.TypeProxy = TypeProxy;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeProxyArray {
        /**
         *
         */
        constructor(array) {
            this.array = array;
            this.compiledArray = undefined;
        }
        /**
         *
         */
        maybeCompile() {
            if (this.compiledArray !== undefined)
                return this.compiledArray;
            const out = this.array
                .map(lazy => lazy.maybeCompile())
                .filter((type) => type !== null);
            return this.compiledArray = Object.freeze(out);
        }
    }
    Truth.TypeProxyArray = TypeProxyArray;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeCache {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.map = new Map();
            this.version = program.version;
        }
        /** */
        static has(phrase) {
            const cache = this.getCache(phrase.containingDocument.program);
            return cache.map.has(phrase);
        }
        /** */
        static get(phrase) {
            const program = phrase.containingDocument.program;
            const cache = this.getCache(program);
            if (cache.map.has(phrase))
                return Truth.Not.undefined(cache.map.get(phrase));
            const proxy = new Truth.TypeProxy(phrase);
            this.set(phrase, proxy);
            return proxy;
        }
        /** */
        static set(phrase, type) {
            const cache = this.getCache(phrase.containingDocument.program);
            cache.map.set(phrase, type);
            return type;
        }
        /** */
        static getCache(program) {
            const cache = this.allCaches.get(program) || (() => {
                const cache = new TypeCache(program);
                this.allCaches.set(program, cache);
                return cache;
            })();
            cache.maybeClear();
            return cache;
        }
        /** */
        maybeClear() {
            if (this.program.version.newerThan(this.version)) {
                this.map.clear();
                this.version = this.program.version;
            }
        }
    }
    /**
     *
     */
    TypeCache.allCaches = new WeakMap();
    Truth.TypeCache = TypeCache;
})(Truth || (Truth = {}));
// Util
/// <reference path="./Util/Helpers.ts" />
/// <reference path="./Util/MultiMap.ts" />
/// <reference path="./Util/Fs.ts" />
/// <reference path="./Util/Hash.ts" />
/// <reference path="./Util/HigherOrder.ts" />
/// <reference path="./Util/Not.ts" />
/// <reference path="./Util/Parser.ts" />
/// <reference path="./Util/UnicodeBlocks.ts" />
/// <reference path="./Util/Misc.ts" />
// System
/// <reference path="./System/AbstractClass.ts" />
/// <reference path="./System/Program.ts" />
/// <reference path="./System/ProgramInspectionResult.ts" />
/// <reference path="./System/AgentCache.ts" />
/// <reference path="./System/Cause.ts" />
/// <reference path="./System/Exception.ts" />
/// <reference path="./System/UriProtocol.ts" />
/// <reference path="./System/UriReader.ts" />
/// <reference path="./System/Syntax.ts" />
/// <reference path="./System/FaultService.ts" />
/// <reference path="./System/Faults.ts" />
/// <reference path="./System/Phrase.ts" />
/// <reference path="./System/Term.ts" />
/// <reference path="./System/VersionStamp.ts" />
// Finite State Machine
/// <reference path="./Fsm/Alphabet.ts" />
/// <reference path="./Fsm/TransitionMap.ts" />
/// <reference path="./Fsm/TransitionState.ts" />
/// <reference path="./Fsm/Guide.ts" />
/// <reference path="./Fsm/Fsm.ts" />
/// <reference path="./Fsm/FsmTranslator.ts" />
// Phases / File Representation
/// <reference path="./Phases/File/Document.ts" />
/// <reference path="./Phases/File/DocumentTypes.ts" />
/// <reference path="./Phases/File/CycleDetector.ts" />
/// <reference path="./Phases/File/LineParser.ts" />
/// <reference path="./Phases/File/Anon.ts" />
/// <reference path="./Phases/File/Line.ts" />
/// <reference path="./Phases/File/Boundary.ts" />
/// <reference path="./Phases/File/Statement.ts" />
/// <reference path="./Phases/File/Pattern.ts" />
/// <reference path="./Phases/File/PatternPrecompiler.ts" />
/// <reference path="./Phases/File/RegexTypes.ts" />
/// <reference path="./Phases/File/Infix.ts" />
/// <reference path="./Phases/File/Span.ts" />
/// <reference path="./Phases/File/Spine.ts" />
/// <reference path="./Phases/File/Subject.ts" />
// Phases / Graph Representation
/// <reference path="./Phases/Graph/HyperGraph.ts" />
/// <reference path="./Phases/Graph/Node.ts" />
/// <reference path="./Phases/Graph/NodeIndex.ts" />
/// <reference path="./Phases/Graph/HyperEdge.ts" />
/// <reference path="./Phases/Graph/InfixSpan.ts" />
// Phases / Parallel Representation
/// <reference path="./Phases/Parallel/ConstructionWorker.ts" />
/// <reference path="./Phases/Parallel/Parallel.ts" />
/// <reference path="./Phases/Parallel/ExplicitParallel.ts" />
/// <reference path="./Phases/Parallel/ImplicitParallel.ts" />
/// <reference path="./Phases/Parallel/CruftCache.ts" />
/// <reference path="./Phases/Parallel/ParallelCache.ts" />
/// <reference path="./Phases/Parallel/Contract.ts" />
/// <reference path="./Phases/Parallel/Sanitizer.ts" />
// Phases / Type Representation
/// <reference path="./Phases/Type/Type.ts" />
/// <reference path="./Phases/Type/TypeProxy.ts" />
/// <reference path="./Phases/Type/TypeProxyArray.ts" />
/// <reference path="./Phases/Type/TypeCache.ts" />
// Node compatibility
if (typeof module !== "undefined" && module.exports)
    module.exports = Truth;
var Truth;
(function (Truth) {
    /**
     * @internal
     * A minimal abstraction of a JavaScript array, but where the indexes
     * are treated as 1-based.
     */
    class Array1Based {
        constructor() {
            /** */
            this.items = [];
        }
        /**
         * Yields items starting at the specified position, and continues forward
         * until the end of the array is reached.
         */
        *enumerateForward(from = 1) {
            const len = this.items.length;
            for (let idx = this.toZeroBased(from); idx < len; idx++)
                yield this.items[idx];
        }
        /**
         * Yields items starting at the specified position, and continues backward
         * until the start of the array is reached.
         */
        *enumerateBackward(from = -1) {
            for (let idx = this.toZeroBased(from); idx >= 0; idx--)
                yield this.items[idx];
        }
        /**
         * Get the length of the array.
         */
        get length() {
            return this.items.length;
        }
        /**
         * Returns the item at the specified position.
         * If the specified position is less than 0, the position
         * is assumed to be relative to the end of the array.
         */
        get(pos) {
            return this.items[this.toZeroBased(pos)];
        }
        /**
         *
         */
        set(pos, item) {
            this.items[this.toZeroBased(pos)] = item;
        }
        /**
         * Returns a 1-based position of the specified item.
         * Returns -1 in the case when the item was not found in the array.
         */
        posOf(item) {
            const idx = this.items.indexOf(item);
            return idx < 0 ? -1 : idx + 1;
        }
        /**
         * Adds an item to the array.
         */
        push(item) {
            return this.items.push(item);
        }
        /**
         * Performs a standard Array.splice() call on the array.
         */
        splice(pos, deleteCount, ...items) {
            return this.items.splice(this.toZeroBased(pos), deleteCount, ...items);
        }
        /**
         * Converts a 1-based position into a 0-based index.
         */
        toZeroBased(pos) {
            const len = this.items.length;
            if (pos < 0)
                return Math.max(0, len - pos);
            if (pos > len)
                return len - 1;
            if (pos === 0)
                throw Truth.Exception.invalidArgument();
            return pos - 1;
        }
    }
    Truth.Array1Based = Array1Based;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * This is a class that wraps the built-in URL object.
     * It ensures that the system only every stores references
     * to unique URLs, so that equality of two Uris can be tested
     * by doing a simple referential comparison.
     */
    class KnownUri {
        /** */
        constructor(innerUrl) {
            this.innerUrl = innerUrl;
            // Generates an error if the URL isn't from a known protocol.
            this.protocol;
        }
        /**
         * @internal
         * Returns a KnownUri suitable for internal documents that aren't actually
         * stored anywhere other than in memory. The number provided ends up
         * as the fictitious name of the truth file specified in the URI.
         */
        static createMemoryUri(number) {
            const uriText = Truth.UriProtocol.memory + "//memory/" + number + ".truth";
            return Truth.Misc.get(this.cache, uriText, () => new KnownUri(new URL(uriText)));
        }
        /**
         * Returns the KnownUri object associated with the text representation
         * of the URI specified, or null in the case when the text value specified
         * could not be parsed as a URI.
         */
        static fromString(uriText, base) {
            let mergedUrl = null;
            try {
                mergedUrl = new URL(uriText, base ? base.innerUrl : void 0);
            }
            catch (e) { }
            if (mergedUrl === null)
                return null;
            const url = mergedUrl;
            return Truth.Misc.get(this.cache, mergedUrl.href, () => new KnownUri(url));
        }
        /**
         * Gets the protocol of the underlying URL.
         */
        get protocol() {
            return Truth.Not.null(Truth.UriProtocol.resolve(this.innerUrl.protocol));
        }
        /**
         * Returns a fully-qualified string representation of this KnownUri.
         */
        toString() {
            return this.innerUrl.protocol === Truth.UriProtocol.file ?
                this.innerUrl.pathname :
                this.innerUrl.href;
        }
    }
    /**
     * Stores a cache of all KnownUris created by the compiler,
     * keyed by a string representation of the KnownUri's inner URL.
     */
    KnownUri.cache = new Map();
    Truth.KnownUri = KnownUri;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * (Not implemented)
     * A class that specifies behavior around the recognition
     * of patterns found within documents.
     */
    class Recognition {
        /** */
        constructor() {
            /** Whether File URIs should be recognized in statements. */
            this.fileUris = 0 /* on */;
            /** Whether HTTP URIs should be recognized in statements. */
            this.httpUris = 0 /* on */;
            /** Whether regular expressions should be recognized in statements. */
            this.regularExpressions = 0 /* on */;
            /** Whether comments should be recognized in statements. */
            this.comments = 0 /* on */;
        }
    }
    Truth.Recognition = Recognition;
})(Truth || (Truth = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1dGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9jb3JlL1V0aWwvSGVscGVycy50cyIsIi4uL2NvcmUvVXRpbC9NdWx0aU1hcC50cyIsIi4uL2NvcmUvVXRpbC9Gcy50cyIsIi4uL2NvcmUvVXRpbC9IYXNoLnRzIiwiLi4vY29yZS9VdGlsL0hpZ2hlck9yZGVyLnRzIiwiLi4vY29yZS9VdGlsL05vdC50cyIsIi4uL2NvcmUvVXRpbC9QYXJzZXIudHMiLCIuLi9jb3JlL1V0aWwvVW5pY29kZUJsb2Nrcy50cyIsIi4uL2NvcmUvVXRpbC9NaXNjLnRzIiwiLi4vY29yZS9TeXN0ZW0vQWJzdHJhY3RDbGFzcy50cyIsIi4uL2NvcmUvU3lzdGVtL1Byb2dyYW0udHMiLCIuLi9jb3JlL1N5c3RlbS9Qcm9ncmFtSW5zcGVjdGlvblJlc3VsdC50cyIsIi4uL2NvcmUvU3lzdGVtL0FnZW50Q2FjaGUudHMiLCIuLi9jb3JlL1N5c3RlbS9DYXVzZS50cyIsIi4uL2NvcmUvU3lzdGVtL0V4Y2VwdGlvbi50cyIsIi4uL2NvcmUvU3lzdGVtL1VyaVByb3RvY29sLnRzIiwiLi4vY29yZS9TeXN0ZW0vVXJpUmVhZGVyLnRzIiwiLi4vY29yZS9TeXN0ZW0vU3ludGF4LnRzIiwiLi4vY29yZS9TeXN0ZW0vRmF1bHRTZXJ2aWNlLnRzIiwiLi4vY29yZS9TeXN0ZW0vRmF1bHRzLnRzIiwiLi4vY29yZS9TeXN0ZW0vUGhyYXNlLnRzIiwiLi4vY29yZS9TeXN0ZW0vVGVybS50cyIsIi4uL2NvcmUvU3lzdGVtL1ZlcnNpb25TdGFtcC50cyIsIi4uL2NvcmUvRnNtL0FscGhhYmV0LnRzIiwiLi4vY29yZS9Gc20vVHJhbnNpdGlvbk1hcC50cyIsIi4uL2NvcmUvRnNtL1RyYW5zaXRpb25TdGF0ZS50cyIsIi4uL2NvcmUvRnNtL0d1aWRlLnRzIiwiLi4vY29yZS9Gc20vRnNtLnRzIiwiLi4vY29yZS9Gc20vRnNtVHJhbnNsYXRvci50cyIsIi4uL2NvcmUvUGhhc2VzL0ZpbGUvRG9jdW1lbnQudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL0RvY3VtZW50VHlwZXMudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL0N5Y2xlRGV0ZWN0b3IudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL0xpbmVQYXJzZXIudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL0Fub24udHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL0xpbmUudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL0JvdW5kYXJ5LnRzIiwiLi4vY29yZS9QaGFzZXMvRmlsZS9TdGF0ZW1lbnQudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL1BhdHRlcm4udHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL1BhdHRlcm5QcmVjb21waWxlci50cyIsIi4uL2NvcmUvUGhhc2VzL0ZpbGUvUmVnZXhUeXBlcy50cyIsIi4uL2NvcmUvUGhhc2VzL0ZpbGUvSW5maXgudHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL1NwYW4udHMiLCIuLi9jb3JlL1BoYXNlcy9GaWxlL1NwaW5lLnRzIiwiLi4vY29yZS9QaGFzZXMvRmlsZS9TdWJqZWN0LnRzIiwiLi4vY29yZS9QaGFzZXMvR3JhcGgvSHlwZXJHcmFwaC50cyIsIi4uL2NvcmUvUGhhc2VzL0dyYXBoL05vZGUudHMiLCIuLi9jb3JlL1BoYXNlcy9HcmFwaC9Ob2RlSW5kZXgudHMiLCIuLi9jb3JlL1BoYXNlcy9HcmFwaC9IeXBlckVkZ2UudHMiLCIuLi9jb3JlL1BoYXNlcy9HcmFwaC9JbmZpeFNwYW4udHMiLCIuLi9jb3JlL1BoYXNlcy9QYXJhbGxlbC9Db25zdHJ1Y3Rpb25Xb3JrZXIudHMiLCIuLi9jb3JlL1BoYXNlcy9QYXJhbGxlbC9QYXJhbGxlbC50cyIsIi4uL2NvcmUvUGhhc2VzL1BhcmFsbGVsL0V4cGxpY2l0UGFyYWxsZWwudHMiLCIuLi9jb3JlL1BoYXNlcy9QYXJhbGxlbC9JbXBsaWNpdFBhcmFsbGVsLnRzIiwiLi4vY29yZS9QaGFzZXMvUGFyYWxsZWwvQ3J1ZnRDYWNoZS50cyIsIi4uL2NvcmUvUGhhc2VzL1BhcmFsbGVsL1BhcmFsbGVsQ2FjaGUudHMiLCIuLi9jb3JlL1BoYXNlcy9QYXJhbGxlbC9Db250cmFjdC50cyIsIi4uL2NvcmUvUGhhc2VzL1BhcmFsbGVsL1Nhbml0aXplci50cyIsIi4uL2NvcmUvUGhhc2VzL1R5cGUvVHlwZS50cyIsIi4uL2NvcmUvUGhhc2VzL1R5cGUvVHlwZVByb3h5LnRzIiwiLi4vY29yZS9QaGFzZXMvVHlwZS9UeXBlUHJveHlBcnJheS50cyIsIi4uL2NvcmUvUGhhc2VzL1R5cGUvVHlwZUNhY2hlLnRzIiwiLi4vY29yZS8hLnRzIiwiLi4vY29yZS9waGFzZXMvZmlsZS9BcnJheTFCYXNlZC50cyIsIi4uL2NvcmUvc3lzdGVtL0tub3duVXJpLnRzIiwiLi4vY29yZS9zeXN0ZW0vUmVjb2duaXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQSxJQUFVLEtBQUssQ0E0QmQ7QUE1QkQsV0FBVSxLQUFLO0lBRWQ7Ozs7Ozs7T0FPRztJQUNJLEtBQUssVUFBVSxJQUFJLENBQ3pCLGVBQXVCLEVBQ3ZCLGFBQWEsR0FBRyxJQUFJLE1BQUEsT0FBTyxFQUFFO1FBRTdCLE9BQU8sTUFBTSxhQUFhLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUxxQixVQUFJLE9BS3pCLENBQUE7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxVQUFVLEtBQUssQ0FDMUIsVUFBa0IsRUFDbEIsYUFBYSxHQUFHLElBQUksTUFBQSxPQUFPLEVBQUU7UUFFN0IsT0FBTyxNQUFNLGFBQWEsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUxxQixXQUFLLFFBSzFCLENBQUE7QUFDRixDQUFDLEVBNUJTLEtBQUssS0FBTCxLQUFLLFFBNEJkO0FDNUJELElBQVUsS0FBSyxDQW9HZDtBQXBHRCxXQUFVLEtBQUs7SUFFZDs7OztPQUlHO0lBQ0gsTUFBYSxRQUFRO1FBQXJCO1lBMEZDLE1BQU07WUFDRSxRQUFHLEdBQUcs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LElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM5RCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxRQUFRO1lBRVAsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxNQUFBLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7UUFDckIsQ0FBQzs7SUE3QkQ7OztPQUdHO0lBQ3FCLGNBQUssR0FBRyxJQUFJLEdBQUcsRUFBb0IsQ0FBQztJQXhDaEQsY0FBUSxXQWtFcEIsQ0FBQTtBQUNGLENBQUMsRUEzRVMsS0FBSyxLQUFMLEtBQUssUUEyRWQ7QUMzRUQsSUFBVSxLQUFLLENBcUNkO0FBckNELFdBQVUsS0FBSztJQUVkOzs7OztPQUtHO0lBQ0gsTUFBYSxXQUFXO1FBRXZCLE1BQU07UUFDTjtZQUVBLDREQUE0RDtZQUM1RCxhQUFRLGNBQXVCO1lBRS9CLDREQUE0RDtZQUM1RCxhQUFRLGNBQXVCO1lBRS9CLHNFQUFzRTtZQUN0RSx1QkFBa0IsY0FBdUI7WUFFekMsMkRBQTJEO1lBQzNELGFBQVEsY0FBdUI7UUFaZixDQUFDO0tBYWpCO0lBaEJZLGlCQUFXLGNBZ0J2QixDQUFBO0FBYUYsQ0FBQyxFQXJDUyxLQUFLLEtBQUwsS0FBSyxRQXFDZCIsInNvdXJjZXNDb250ZW50IjpbIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSByZWFkcyBhIHRydXRoIGRvY3VtZW50LCBhbmQgYWxsIGRvY3VtZW50c1xuXHQgKiBpdCByZWZlcmVuY2VzIGZyb20gdGhlIHNwZWNpZmllZCBmaWxlIHN5c3RlbSBvciBIVFRQKHMpIHBhdGguXG5cdCAqIEZpbGUgc3lzdGVtIHBhdGhzIGFyZSBvbmx5IHN1cHBvcnRlZCBpZiB0aGlzIGNvZGUgaXMgcnVubmluZ1xuXHQgKiB3aXRoaW4gYSBOb2RlLmpzLWNvbXBhdGlibGUgZW52aXJvbm1lbnQuXG5cdCAqIFxuXHQgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgcmVhZCwgb3IgYW4gRXJyb3IuXG5cdCAqL1xuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZChcblx0XHRzb3VyY2VQYXRoT3JVcmk6IHN0cmluZyxcblx0XHR0YXJnZXRQcm9ncmFtID0gbmV3IFByb2dyYW0oKSlcblx0e1xuXHRcdHJldHVybiBhd2FpdCB0YXJnZXRQcm9ncmFtLmFkZERvY3VtZW50RnJvbVVyaShzb3VyY2VQYXRoT3JVcmkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBzcGVjaWZpZWQgdHJ1dGggY29udGVudCBpbnRvIGEgbmV3IFRydXRoIHByb2dyYW0uXG5cdCAqIFxuXHQgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgcGFyc2VkIGRvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlKFxuXHRcdHNvdXJjZVRleHQ6IHN0cmluZyxcblx0XHR0YXJnZXRQcm9ncmFtID0gbmV3IFByb2dyYW0oKSlcblx0e1xuXHRcdHJldHVybiBhd2FpdCB0YXJnZXRQcm9ncmFtLmFkZERvY3VtZW50KHNvdXJjZVRleHQpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgTWFwIG9mIHRoZSBnZW5lcmljIGtleSBhbmQgdmFsdWUgdHlwZXMuXG5cdCAqIFN1cHBvcnRzIGtleXMgdGhhdCByZWZlciB0byBtdWx0aXBsZSB2YWx1ZXMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTXVsdGlNYXA8VEtleSwgVFZhbD5cblx0e1xuXHRcdC8qKiAqL1xuXHRcdCpbU3ltYm9sLml0ZXJhdG9yXSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcClcblx0XHRcdFx0eWllbGQgZW50cnk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGVudHJpZXMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLm1hcC5lbnRyaWVzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldChrZXk6IFRLZXkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoa2V5OiBUS2V5LCB2YWx1ZT86IFRWYWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXQoa2V5KTtcblx0XHRcdGlmICghdmFsdWVzKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHZhbHVlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFkZChrZXk6IFRLZXksIHZhbHVlOiBUVmFsKVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXQoa2V5KTtcblx0XHRcdFx0aWYgKHZhbHVlcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLm1hcC5zZXQoa2V5LCBbdmFsdWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZGVsZXRlKGtleTogVEtleSwgdmFsdWU/OiBUVmFsKVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gISF0aGlzLm1hcC5kZWxldGUoa2V5KTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3RvcmVkVmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG5cdFx0XHRpZiAoc3RvcmVkVmFsdWVzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHN0b3JlZFZhbHVlcy5sZW5ndGggPT09IDEgJiYgc3RvcmVkVmFsdWVzWzBdID09PSB2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5tYXAuZGVsZXRlKGtleSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCB2YWx1ZUlkeCA9IHN0b3JlZFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdGlmICh2YWx1ZUlkeCA8IDApXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0c3RvcmVkVmFsdWVzLnNwbGljZSh2YWx1ZUlkeCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dmFsdWVzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAudmFsdWVzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBzaXplKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAuc2l6ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBtYXAgPSBuZXcgTWFwPFRLZXksIFRWYWxbXT4oKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0ZGVjbGFyZSBjb25zdCBOb2RlRnM6IHR5cGVvZiBpbXBvcnQoXCJmc1wiKTtcblx0XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogRXhwb3NlcyB0aGUgXCJmc1wiIG1vZHVsZSB1c2VkIGJ5IHRoZSBjb21waWxlciwgXG5cdCAqIGFzIHdlbGwgYXMgdGhlIGFiaWxpdHkgdG8gY2hhbmdlIHRoZSBtb2R1bGUgdXNlZFxuXHQgKiB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEZzXG5cdHtcblx0XHQvKipcblx0XHQgKiBBc3NpZ25zIGEgbmV3IGltcGxlbWVudGF0aW9uIG9mIHRoZSBub2RlIFwiZnNcIiBtb2R1bGUuXG5cdFx0ICovXG5cdFx0c3RhdGljIG92ZXJyaWRlKG1vZHVsZTogdHlwZW9mIE5vZGVGcylcblx0XHR7XG5cdFx0XHR0aGlzLl9tb2R1bGUgPSBtb2R1bGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBnZXQgbW9kdWxlKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fbW9kdWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbW9kdWxlO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9tb2R1bGUgPSByZXF1aXJlKFwiZnNcIik7XG5cdFx0XHRyZXR1cm4gTm90Lm51bGwodGhpcy5fbW9kdWxlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgX21vZHVsZTogdHlwZW9mIE5vZGVGcyB8IG51bGwgPSBudWxsO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyBzdHJpbmcgaGFzaGluZyBmdW5jdGlvbmFsaXR5LlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IEhhc2ggPSBuZXcgY2xhc3MgSGFzaFxuXHR7XG5cdFx0LyoqIFN0b3JlcyB0aGUgY29uc3RhbnQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gYSByZXR1cm5lZCBoYXNoLiAqL1xuXHRcdHJlYWRvbmx5IGxlbmd0aCA9IDg7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlcyBhIGhhc2ggY29kZSBmcm9tIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdGNhbGN1bGF0ZSh0ZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKHRleHQubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gXCIwXCIucmVwZWF0KDgpO1xuXHRcdFx0XG5cdFx0XHRsZXQgaGFzaCA9IDA7XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHRleHQubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2hhciA9IHRleHQuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNoYXI7XG5cdFx0XHRcdGhhc2ggJT0gMiAqKiAzMjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIChoYXNoICsgTWF0aC5wb3coMiwgMzEpKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0XHR9XG5cdH0oKTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcHJvdmlkZXMgdmFyaW91cyBoaWdoZXItb3JkZXIgZnVuY3Rpb25zXG5cdCAqIGFjcm9zcyBkYXRhIHN0cnVjdHVyZXMuXG5cdCAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgSGlnaGVyT3JkZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgcmVhZG9ubHkgY29weSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5LCBzZXQsIG9yIGxpc3QuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNvcHk8VD4oYXJyYXk6IHJlYWRvbmx5IFRbXSk6IHJlYWRvbmx5IFRbXTtcblx0XHRzdGF0aWMgY29weTxUPihzZXQ6IFJlYWRvbmx5U2V0PFQ+KTogUmVhZG9ubHlTZXQ8VD47XG5cdFx0c3RhdGljIGNvcHk8SywgVj4obWFwOiBSZWFkb25seU1hcDxLLCBWPik6IFJlYWRvbmx5TWFwPEssIFY+O1xuXHRcdHN0YXRpYyBjb3B5KHBhcmFtOiBvYmplY3QpOiBvYmplY3Rcblx0XHR7XG5cdFx0XHRpZiAocGFyYW0gaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUocGFyYW0uc2xpY2UoKSk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbSBpbnN0YW5jZW9mIFNldClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiBwYXJhbSlcblx0XHRcdFx0XHRzZXQuYWRkKHZhbHVlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHNldCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbSBpbnN0YW5jZW9mIE1hcClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyYW0pXG5cdFx0XHRcdFx0bWFwLnNldChrZXksIHZhbHVlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKG1hcCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHR9XG5cdFx0XG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgfVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFV0aWxpdHkgY2xhc3MgZm9yIHBlcmZvcm1pbmcgYmFzaWMgZ3VhcmRpbmcuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTm90XG5cdHtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgYXJndW1lbnQgYXMgc3BlY2lmaWVkLCBidXQgdGhyb3dzIGFuXG5cdFx0ICogZXhjZXB0aW9uIGluIHRoZSBjYXNlIHdoZW4gaXQncyBzdHJpY3RseSBlcXVhbCB0byBudWxsLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBudWxsPFQ+KHBhcmFtOiBUKVxuXHRcdHtcblx0XHRcdGlmIChwYXJhbSA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0ZGVidWdnZXI7XG5cdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcGFyYW0gYXMgTm90TnVsbDxUPjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGFyZ3VtZW50IGFzIHNwZWNpZmllZCwgYnV0IHRocm93cyBhblxuXHRcdCAqIGV4Y2VwdGlvbiBpbiB0aGUgY2FzZSB3aGVuIGl0J3Mgc3RyaWN0bHkgZXF1YWwgdG8gdW5kZWZpbmVkLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyB1bmRlZmluZWQ8VD4ocGFyYW06IFQpXG5cdFx0e1xuXHRcdFx0aWYgKHBhcmFtID09PSB1bmRlZmluZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGRlYnVnZ2VyO1xuXHRcdFx0XHR0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHBhcmFtIGFzIE5vdFVuZGVmaW5lZDxUPjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGFyZ3VtZW50IGFzIHNwZWNpZmllZCwgYnV0IHRocm93cyBhblxuXHRcdCAqIGV4Y2VwdGlvbiBpbiB0aGUgY2FzZSB3aGVuIGl0J3MgbnVsbCBvciB1bmRlZmluZWQuXG5cdFx0ICovXG5cdFx0c3RhdGljIG51bGxhYmxlPFQ+KHBhcmFtOiBUKVxuXHRcdHtcblx0XHRcdGlmIChwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHRkZWJ1Z2dlcjtcblx0XHRcdFx0dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBwYXJhbSBhcyBOb3ROdWxsPFQ+IHwgTm90VW5kZWZpbmVkPFQ+O1xuXHRcdH1cblx0fVxuXG5cdHR5cGUgTm90TnVsbDxUPiA9IFQgZXh0ZW5kcyBudWxsID8gbmV2ZXIgOiBUO1xuXHR0eXBlIE5vdFVuZGVmaW5lZDxUPiA9IFQgZXh0ZW5kcyB1bmRlZmluZWQgPyBuZXZlciA6IFQ7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBnZW5lcmFsIHBhcnNpbmcgdXRpbGl0eSBjbGFzcyB0aGF0IHByb3ZpZGVzIGNvbnN1bXB0aW9uXG5cdCAqIG1ldGhvZHMgdGhhdCBvcGVyYXRlIG92ZXIgYSBnaXZlbiBpbnB1dC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQYXJzZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdHMgYSBuZXcgUGFyc2VyIG9iamVjdCB0aGF0IG9wZXJhdGVzIG92ZXJcblx0XHQgKiB0aGUgc3BlY2lmaWVkIGlucHV0IHN0cmluZywgb3B0aW9uYWxseSBzdGFydGluZyBhdCB0aGVcblx0XHQgKiBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoaW5wdXQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHR0aGlzLmlucHV0ID0gaW5wdXQubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgdGhlIHNwZWNpZmllZCB0b2tlbiBpbW1lZGlhdGVseSBcblx0XHQgKiBmb2xsb3dpbmcgdGhlIGN1cnNvci5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBUaGUgY29udGVudCByZWFkLiBJbiB0aGUgY2FzZSB3aGVuIG5vXG5cdFx0ICogbWF0Y2ggY291bGQgYmUgZm91bmQsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRyZWFkPFMgZXh0ZW5kcyBzdHJpbmc+KHRva2VuPzogUyk6IFMgfCBcIlwiXG5cdFx0cmVhZCgpOiBzdHJpbmdcblx0XHRyZWFkKHRva2VuPzogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGlmICghdG9rZW4pXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcG9zID0gdGhpcy5fcG9zaXRpb247XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlucHV0LnN1YnN0cihwb3MsIHRva2VuLmxlbmd0aCkgPT09IHRva2VuKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiArPSB0b2tlbi5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiB0b2tlbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlYWRzIGFueSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYW5kIGZsb2F0aW5nXG5cdFx0ICogZXNjYXBlIGNoYXJhY3RlcnMuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgVGhlIG51bWJlciBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHQgKiByZWFkLlxuXHRcdCAqL1xuXHRcdHJlYWRXaGl0ZXNwYWNlKClcblx0XHR7XG5cdFx0XHRsZXQgY291bnQgPSAwO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAodGhpcy5tb3JlKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGMgPSBjb3VudDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnJlYWQoU3ludGF4LnRhYikpXG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnJlYWQoU3ludGF4LnNwYWNlKSlcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMucmVhZChTeW50YXguZXNjYXBlQ2hhciArIFN5bnRheC5zcGFjZSkpXG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnJlYWQoU3ludGF4LmVzY2FwZUNoYXIgKyBTeW50YXgudGFiKSlcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGMgPT09IGNvdW50KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgYSBzaW5nbGUgc3RyZWFtLWxldmVsIGdyYXBoZW1lIGZyb20gdGhlXG5cdFx0ICogcGFyc2Ugc3RyZWFtLCB1c2luZyB1bmljb2RlLWF3YXJlIGV4dHJhY3Rpb24gbWV0aG9kLlxuXHRcdCAqIElmIHRoZSBwYXJzZSBzdHJlYW0gc3BlY2lmaWVzIGEgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2UsXG5cdFx0ICogc3VjaCBhcyBcXHVGRkZGLCB0aGVzZSBhcmUgc2VlbiBhcyA2IGluZGl2aWR1YWwgZ3JhcGhlbWVzLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIFRoZSByZWFkIGdyYXBoZW1lLCBvciBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIGNhc2Vcblx0XHQgKiB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdCAqL1xuXHRcdHJlYWRHcmFwaGVtZSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX3Bvc2l0aW9uID49IHRoaXMuaW5wdXQubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29kZUF0Q3Vyc29yID0gdGhpcy5pbnB1dC5jb2RlUG9pbnRBdCh0aGlzLl9wb3NpdGlvbikgfHwgLTE7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiArPSBjb2RlQXRDdXJzb3IgPiAweEZGRkYgPyAyIDogMTtcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlQXRDdXJzb3IpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWFkcyBncmFwaGVtZXMgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLCB1bnRpbCBlaXRoZXJcblx0XHQgKiB0aGUgY3Vyc29yIHJlYWNoZXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgcXVpdCB0b2tlbnMsXG5cdFx0ICogb3IgdGhlIHBhcnNlIHN0cmVhbSB0ZXJtaW5hdGVzLlxuXHRcdCAqL1xuXHRcdHJlYWRVbnRpbCguLi5xdWl0VG9rZW5zOiBzdHJpbmdbXSlcblx0XHR7XG5cdFx0XHRsZXQgc3RyZWFtID0gXCJcIjtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKHRoaXMubW9yZSgpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocXVpdFRva2Vucy5zb21lKHQgPT4gdGhpcy5wZWVrKHQpKSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdHN0cmVhbSArPSB0aGlzLnJlYWRHcmFwaGVtZSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc3RyZWFtO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byByZWFkIHRoZSBzcGVjaWZpZWQgdG9rZW4gZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLFxuXHRcdCAqIGlmIGFuZCBvbmx5IGlmIGl0J3MgYXQgdGhlIGVuZCBvZiB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdCAqL1xuXHRcdHJlYWRUaGVuVGVybWluYWwodG9rZW46IHN0cmluZylcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wZWVrKHRva2VuKSAmJiB0aGlzLl9wb3NpdGlvbiA9PT0gdGhpcy5pbnB1dC5sZW5ndGggLSB0b2tlbi5sZW5ndGgpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uICs9IHRva2VuLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG5cdFx0ICogc3BlY2lmaWVkIHN0cmluZyBleGlzdHMgaW1tZWRpYXRlbHkgYXQgdGhlIHBvc2l0aW9uIG9mXG5cdFx0ICogdGhlIGN1cnNvci5cblx0XHQgKi9cblx0XHRwZWVrKHRva2VuOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuX3Bvc2l0aW9uLCB0b2tlbi5sZW5ndGgpID09PSB0b2tlbjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG5cdFx0ICogc3BlY2lmaWVkIHN0cmluZyBleGlzdHMgaW1tZWRpYXRlbHkgYXQgdGhlIHBvc2l0aW9uIG9mXG5cdFx0ICogdGhlIGN1cnNvciwgYW5kIGZvbGxvd2luZyB0aGlzIHRva2VuIGlzIHRoZSBlbmQgb2YgdGhlXG5cdFx0ICogcGFyc2Ugc3RyZWFtLlxuXHRcdCAqL1xuXHRcdHBlZWtUaGVuVGVybWluYWwodG9rZW46IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9PT0gdGhpcy5pbnB1dC5sZW5ndGggLSB0b2tlbi5sZW5ndGggJiZcblx0XHRcdFx0dGhpcy5pbnB1dC5zdWJzdHIodGhpcy5fcG9zaXRpb24sIHRva2VuLmxlbmd0aCkgPT09IHRva2VuKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXJcblx0XHQgKiB0aGVyZSBhcmUgbW9yZSBjaGFyYWN0ZXJzIHRvIHJlYWQgaW4gdGhlIGlucHV0LlxuXHRcdCAqL1xuXHRcdG1vcmUoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbiA8IHRoaXMuaW5wdXQubGVuZ3RoO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIG9yIHNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgZnJvbSB3aGVyZVxuXHRcdCAqIHJlYWRpbmcgdGFrZXMgcGxhY2UgaW4gdGhlIGN1cnNvci5cblx0XHQgKi9cblx0XHRnZXQgcG9zaXRpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcblx0XHR9XG5cdFx0c2V0IHBvc2l0aW9uKHZhbHVlOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKHZhbHVlIDwgMClcblx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSB2YWx1ZTtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfcG9zaXRpb24gPSAwO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgaW5wdXQ6IHN0cmluZztcblx0XHRcblx0XHRcblx0XHQvL1xuXHRcdC8vIERFQURcblx0XHQvL1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYXRSZWFsQmFja3NsYXNoKClcblx0XHR7XG5cdFx0XHRjb25zdCBlc2MgPSBTeW50YXguZXNjYXBlQ2hhcjtcblx0XHRcdHJldHVybiB0aGlzLmlucHV0LnN1YnN0cih0aGlzLl9wb3NpdGlvbiwgMikgPT09IGVzYyArIGVzYztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhblxuXHRcdCAqIGVzY2FwZSBjaGFyYWN0ZXIgZXhpc3RzIGJlaGluZCB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG5cdFx0ICogVGhlIGFsZ29yaXRobSB1c2VkIGlzIHJlc3BlY3RpdmUgb2Ygc2VxdWVuY2VzIG9mXG5cdFx0ICogbXVsdGlwbGUgZXNjYXBlIGNoYXJhY3RlcnMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBlc2NhcGVkKClcblx0XHR7XG5cdFx0XHRsZXQgZXNjYXBlZCA9IGZhbHNlO1xuXHRcdFx0bGV0IGJhY2t0cmFja1BvcyA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoLS1iYWNrdHJhY2tQb3MgPj0gMClcblx0XHRcdFx0aWYgKHRoaXMuaW5wdXRbYmFja3RyYWNrUG9zXSA9PT0gU3ludGF4LmVzY2FwZUNoYXIpXG5cdFx0XHRcdFx0ZXNjYXBlZCA9ICFlc2NhcGVkO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZXNjYXBlZDtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdHR5cGUgVCA9IFtudW1iZXIsIG51bWJlcl07XG5cdHR5cGUgVFVuaWNvZGVCbG9ja3MgPSB7IFtibG9ja05hbWU6IHN0cmluZ106IFQgfTtcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgbmFtZXMgaW4gdGhlIFVuaWNvZGVCbG9ja3Mgb2JqZWN0XG5cdCAqIHRvIGEgbWFwIHdpdGggbG93ZXIgY2FzZSBrZXlzLCBmb3IgZWFzeSBsb29rdXAuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b01hcChibG9ja3M6IFRVbmljb2RlQmxvY2tzKVxuXHR7XG5cdFx0Y29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGJsb2Nrcyk7XG5cdFx0Y29uc3QgZW50cmllc0ZtdCA9IGVudHJpZXMubWFwKGVudHJ5ID0+IDxbc3RyaW5nLCBUXT5bZW50cnlbMF0udG9Mb3dlckNhc2UoKSwgZW50cnlbMV1dKTtcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgTWFwPHN0cmluZywgVD4oZW50cmllc0ZtdCkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU3RvcmVzIHRoZSBtYXhpbXVtIGNoYXJhY3RlciBjb2RlIGluIHRoZSB1bmljb2RlIHNldC5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBVbmljb2RlTWF4ID0gNjU1MzY7XG5cdFxuXHQvKipcblx0ICogU3RvcmVzIGEgbWFwIG9mIHRoZSBuYW1lcyBvZiBhbGwgdW5pY29kZSBibG9ja3MsXG5cdCAqIGFuZCB0aGVpciBjaGFyYWN0ZXIgcmFuZ2VzLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IFVuaWNvZGVCbG9ja3MgPSB0b01hcCg8VFVuaWNvZGVCbG9ja3M+e1xuXHRcdFwiQ29udHJvbCBjaGFyYWN0ZXJcIjogWzB4MDAwMCwgMHgwMDFGXSxcblx0XHRcIkJhc2ljIExhdGluXCI6IFsweDAwMjAsIDB4MDA3Rl0sXG5cdFx0XCJMYXRpbi0xIFN1cHBsZW1lbnRcIjogWzB4MDA4MCwgMHgwMEZGXSxcblx0XHRcIkxhdGluIEV4dGVuZGVkLUFcIjogWzB4MDEwMCwgMHgwMTdGXSxcblx0XHRcIkxhdGluIEV4dGVuZGVkLUJcIjogWzB4MDE4MCwgMHgwMjRGXSxcblx0XHRcIklQQSBFeHRlbnNpb25zXCI6IFsweDAyNTAsIDB4MDJBRl0sXG5cdFx0XCJTcGFjaW5nIE1vZGlmaWVyIExldHRlcnNcIjogWzB4MDJCMCwgMHgwMkZGXSxcblx0XHRcIkNvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrc1wiOiBbMHgwMzAwLCAweDAzNkZdLFxuXHRcdFwiR3JlZWsgYW5kIENvcHRpY1wiOiBbMHgwMzcwLCAweDAzRkZdLFxuXHRcdFwiQ3lyaWxsaWNcIjogWzB4MDQwMCwgMHgwNEZGXSxcblx0XHRcIkN5cmlsbGljIFN1cHBsZW1lbnRcIjogWzB4MDUwMCwgMHgwNTJGXSxcblx0XHRcIkFybWVuaWFuXCI6IFsweDA1MzAsIDB4MDU4Rl0sXG5cdFx0XCJIZWJyZXdcIjogWzB4MDU5MCwgMHgwNUZGXSxcblx0XHRcIkFyYWJpY1wiOiBbMHgwNjAwLCAweDA2RkZdLFxuXHRcdFwiU3lyaWFjXCI6IFsweDA3MDAsIDB4MDc0Rl0sXG5cdFx0XCJBcmFiaWMgU3VwcGxlbWVudFwiOiBbMHgwNzUwLCAweDA3N0ZdLFxuXHRcdFwiVGhhYW5hXCI6IFsweDA3ODAsIDB4MDdCRl0sXG5cdFx0XCJOS29cIjogWzB4MDdDMCwgMHgwN0ZGXSxcblx0XHRcIlNhbWFyaXRhblwiOiBbMHgwODAwLCAweDA4M0ZdLFxuXHRcdFwiTWFuZGFpY1wiOiBbMHgwODQwLCAweDA4NUZdLFxuXHRcdFwiU3lyaWFjIFN1cHBsZW1lbnRcIjogWzB4MDg2MCwgMHgwODZGXSxcblx0XHRcIkFyYWJpYyBFeHRlbmRlZC1BXCI6IFsweDA4QTAsIDB4MDhGRl0sXG5cdFx0XCJEZXZhbmFnYXJpXCI6IFsweDA5MDAsIDB4MDk3Rl0sXG5cdFx0XCJCZW5nYWxpXCI6IFsweDA5ODAsIDB4MDlGRl0sXG5cdFx0XCJHdXJtdWtoaVwiOiBbMHgwQTAwLCAweDBBN0ZdLFxuXHRcdFwiR3VqYXJhdGlcIjogWzB4MEE4MCwgMHgwQUZGXSxcblx0XHRcIk9yaXlhXCI6IFsweDBCMDAsIDB4MEI3Rl0sXG5cdFx0XCJUYW1pbFwiOiBbMHgwQjgwLCAweDBCRkZdLFxuXHRcdFwiVGVsdWd1XCI6IFsweDBDMDAsIDB4MEM3Rl0sXG5cdFx0XCJLYW5uYWRhXCI6IFsweDBDODAsIDB4MENGRl0sXG5cdFx0XCJNYWxheWFsYW1cIjogWzB4MEQwMCwgMHgwRDdGXSxcblx0XHRcIlNpbmhhbGFcIjogWzB4MEQ4MCwgMHgwREZGXSxcblx0XHRcIlRoYWlcIjogWzB4MEUwMCwgMHgwRTdGXSxcblx0XHRcIkxhb1wiOiBbMHgwRTgwLCAweDBFRkZdLFxuXHRcdFwiVGliZXRhblwiOiBbMHgwRjAwLCAweDBGRkZdLFxuXHRcdFwiTXlhbm1hclwiOiBbMHgxMDAwLCAweDEwOUZdLFxuXHRcdFwiR2VvcmdpYW5cIjogWzB4MTBBMCwgMHgxMEZGXSxcblx0XHRcIkhhbmd1bCBKYW1vXCI6IFsweDExMDAsIDB4MTFGRl0sXG5cdFx0XCJFdGhpb3BpY1wiOiBbMHgxMjAwLCAweDEzN0ZdLFxuXHRcdFwiRXRoaW9waWMgU3VwcGxlbWVudFwiOiBbMHgxMzgwLCAweDEzOUZdLFxuXHRcdFwiQ2hlcm9rZWVcIjogWzB4MTNBMCwgMHgxM0ZGXSxcblx0XHRcIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcIjogWzB4MTQwMCwgMHgxNjdGXSxcblx0XHRcIk9naGFtXCI6IFsweDE2ODAsIDB4MTY5Rl0sXG5cdFx0XCJSdW5pY1wiOiBbMHgxNkEwLCAweDE2RkZdLFxuXHRcdFwiVGFnYWxvZ1wiOiBbMHgxNzAwLCAweDE3MUZdLFxuXHRcdFwiSGFudW5vb1wiOiBbMHgxNzIwLCAweDE3M0ZdLFxuXHRcdFwiQnVoaWRcIjogWzB4MTc0MCwgMHgxNzVGXSxcblx0XHRcIlRhZ2JhbndhXCI6IFsweDE3NjAsIDB4MTc3Rl0sXG5cdFx0XCJLaG1lclwiOiBbMHgxNzgwLCAweDE3RkZdLFxuXHRcdFwiTW9uZ29saWFuXCI6IFsweDE4MDAsIDB4MThBRl0sXG5cdFx0XCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzIEV4dGVuZGVkXCI6IFsweDE4QjAsIDB4MThGRl0sXG5cdFx0XCJMaW1idVwiOiBbMHgxOTAwLCAweDE5NEZdLFxuXHRcdFwiVGFpIExlXCI6IFsweDE5NTAsIDB4MTk3Rl0sXG5cdFx0XCJOZXcgVGFpIEx1ZVwiOiBbMHgxOTgwLCAweDE5REZdLFxuXHRcdFwiS2htZXIgU3ltYm9sc1wiOiBbMHgxOUUwLCAweDE5RkZdLFxuXHRcdFwiQnVnaW5lc2VcIjogWzB4MUEwMCwgMHgxQTFGXSxcblx0XHRcIlRhaSBUaGFtXCI6IFsweDFBMjAsIDB4MUFBRl0sXG5cdFx0XCJDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgRXh0ZW5kZWRcIjogWzB4MUFCMCwgMHgxQUZGXSxcblx0XHRcIkJhbGluZXNlXCI6IFsweDFCMDAsIDB4MUI3Rl0sXG5cdFx0XCJTdW5kYW5lc2VcIjogWzB4MUI4MCwgMHgxQkJGXSxcblx0XHRcIkJhdGFrXCI6IFsweDFCQzAsIDB4MUJGRl0sXG5cdFx0XCJMZXBjaGFcIjogWzB4MUMwMCwgMHgxQzRGXSxcblx0XHRcIk9sIENoaWtpXCI6IFsweDFDNTAsIDB4MUM3Rl0sXG5cdFx0XCJDeXJpbGxpYyBFeHRlbmRlZCBDXCI6IFsweDFDODAsIDB4MUM4Rl0sXG5cdFx0XCJTdW5kYW5lc2UgU3VwcGxlbWVudFwiOiBbMHgxQ0MwLCAweDFDQ0ZdLFxuXHRcdFwiVmVkaWMgRXh0ZW5zaW9uc1wiOiBbMHgxQ0QwLCAweDFDRkZdLFxuXHRcdFwiUGhvbmV0aWMgRXh0ZW5zaW9uc1wiOiBbMHgxRDAwLCAweDFEN0ZdLFxuXHRcdFwiUGhvbmV0aWMgRXh0ZW5zaW9ucyBTdXBwbGVtZW50XCI6IFsweDFEODAsIDB4MURCRl0sXG5cdFx0XCJDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgU3VwcGxlbWVudFwiOiBbMHgxREMwLCAweDFERkZdLFxuXHRcdFwiTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbFwiOiBbMHgxRTAwLCAweDFFRkZdLFxuXHRcdFwiR3JlZWsgRXh0ZW5kZWRcIjogWzB4MUYwMCwgMHgxRkZGXSxcblx0XHRcIkdlbmVyYWwgUHVuY3R1YXRpb25cIjogWzB4MjAwMCwgMHgyMDZGXSxcblx0XHRcIlN1cGVyc2NyaXB0cyBhbmQgU3Vic2NyaXB0c1wiOiBbMHgyMDcwLCAweDIwOUZdLFxuXHRcdFwiQ3VycmVuY3kgU3ltYm9sc1wiOiBbMHgyMEEwLCAweDIwQ0ZdLFxuXHRcdFwiQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzIGZvciBTeW1ib2xzXCI6IFsweDIwRDAsIDB4MjBGRl0sXG5cdFx0XCJMZXR0ZXJsaWtlIFN5bWJvbHNcIjogWzB4MjEwMCwgMHgyMTRGXSxcblx0XHRcIk51bWJlciBGb3Jtc1wiOiBbMHgyMTUwLCAweDIxOEZdLFxuXHRcdFwiQXJyb3dzXCI6IFsweDIxOTAsIDB4MjFGRl0sXG5cdFx0XCJNYXRoZW1hdGljYWwgT3BlcmF0b3JzXCI6IFsweDIyMDAsIDB4MjJGRl0sXG5cdFx0XCJNaXNjZWxsYW5lb3VzIFRlY2huaWNhbFwiOiBbMHgyMzAwLCAweDIzRkZdLFxuXHRcdFwiQ29udHJvbCBQaWN0dXJlc1wiOiBbMHgyNDAwLCAweDI0M0ZdLFxuXHRcdFwiT3B0aWNhbCBDaGFyYWN0ZXIgUmVjb2duaXRpb25cIjogWzB4MjQ0MCwgMHgyNDVGXSxcblx0XHRcIkVuY2xvc2VkIEFscGhhbnVtZXJpY3NcIjogWzB4MjQ2MCwgMHgyNEZGXSxcblx0XHRcIkJveCBEcmF3aW5nXCI6IFsweDI1MDAsIDB4MjU3Rl0sXG5cdFx0XCJCbG9jayBFbGVtZW50c1wiOiBbMHgyNTgwLCAweDI1OUZdLFxuXHRcdFwiR2VvbWV0cmljIFNoYXBlc1wiOiBbMHgyNUEwLCAweDI1RkZdLFxuXHRcdFwiTWlzY2VsbGFuZW91cyBTeW1ib2xzXCI6IFsweDI2MDAsIDB4MjZGRl0sXG5cdFx0XCJEaW5nYmF0c1wiOiBbMHgyNzAwLCAweDI3QkZdLFxuXHRcdFwiTWlzY2VsbGFuZW91cyBNYXRoZW1hdGljYWwgU3ltYm9scy1BXCI6IFsweDI3QzAsIDB4MjdFRl0sXG5cdFx0XCJTdXBwbGVtZW50YWwgQXJyb3dzLUFcIjogWzB4MjdGMCwgMHgyN0ZGXSxcblx0XHRcIkJyYWlsbGUgUGF0dGVybnNcIjogWzB4MjgwMCwgMHgyOEZGXSxcblx0XHRcIlN1cHBsZW1lbnRhbCBBcnJvd3MtQlwiOiBbMHgyOTAwLCAweDI5N0ZdLFxuXHRcdFwiTWlzY2VsbGFuZW91cyBNYXRoZW1hdGljYWwgU3ltYm9scy1CXCI6IFsweDI5ODAsIDB4MjlGRl0sXG5cdFx0XCJTdXBwbGVtZW50YWwgTWF0aGVtYXRpY2FsIE9wZXJhdG9yc1wiOiBbMHgyQTAwLCAweDJBRkZdLFxuXHRcdFwiTWlzY2VsbGFuZW91cyBTeW1ib2xzIGFuZCBBcnJvd3NcIjogWzB4MkIwMCwgMHgyQkZGXSxcblx0XHRcIkdsYWdvbGl0aWNcIjogWzB4MkMwMCwgMHgyQzVGXSxcblx0XHRcIkxhdGluIEV4dGVuZGVkLUNcIjogWzB4MkM2MCwgMHgyQzdGXSxcblx0XHRcIkNvcHRpY1wiOiBbMHgyQzgwLCAweDJDRkZdLFxuXHRcdFwiR2VvcmdpYW4gU3VwcGxlbWVudFwiOiBbMHgyRDAwLCAweDJEMkZdLFxuXHRcdFwiVGlmaW5hZ2hcIjogWzB4MkQzMCwgMHgyRDdGXSxcblx0XHRcIkV0aGlvcGljIEV4dGVuZGVkXCI6IFsweDJEODAsIDB4MkRERl0sXG5cdFx0XCJDeXJpbGxpYyBFeHRlbmRlZC1BXCI6IFsweDJERTAsIDB4MkRGRl0sXG5cdFx0XCJTdXBwbGVtZW50YWwgUHVuY3R1YXRpb25cIjogWzB4MkUwMCwgMHgyRTdGXSxcblx0XHRcIkNKSyBSYWRpY2FscyBTdXBwbGVtZW50XCI6IFsweDJFODAsIDB4MkVGRl0sXG5cdFx0XCJLYW5neGkgUmFkaWNhbHNcIjogWzB4MkYwMCwgMHgyRkRGXSxcblx0XHRcIklkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcIjogWzB4MkZGMCwgMHgyRkZGXSxcblx0XHRcIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiOiBbMHgzMDAwLCAweDMwM0ZdLFxuXHRcdFwiSGlyYWdhbmFcIjogWzB4MzA0MCwgMHgzMDlGXSxcblx0XHRcIkthdGFrYW5hXCI6IFsweDMwQTAsIDB4MzBGRl0sXG5cdFx0XCJCb3BvbW9mb1wiOiBbMHgzMTAwLCAweDMxMkZdLFxuXHRcdFwiSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1wiOiBbMHgzMTMwLCAweDMxOEZdLFxuXHRcdFwiS2FuYnVuXCI6IFsweDMxOTAsIDB4MzE5Rl0sXG5cdFx0XCJCb3BvbW9mbyBFeHRlbmRlZFwiOiBbMHgzMUEwLCAweDMxQkZdLFxuXHRcdFwiQ0pLIFN0cm9rZXNcIjogWzB4MzFDMCwgMHgzMUVGXSxcblx0XHRcIkthdGFrYW5hIFBob25ldGljIEV4dGVuc2lvbnNcIjogWzB4MzFGMCwgMHgzMUZGXSxcblx0XHRcIkVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHNcIjogWzB4MzIwMCwgMHgzMkZGXSxcblx0XHRcIkNKSyBDb21wYXRpYmlsaXR5XCI6IFsweDMzMDAsIDB4MzNGRl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBBXCI6IFsweDM0MDAsIDB4NERCRl0sXG5cdFx0XCJZaWppbmcgSGV4YWdyYW0gU3ltYm9sc1wiOiBbMHg0REMwLCAweDRERkZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBoc1wiOiBbMHg0RTAwLCAweDlGRkZdLFxuXHRcdFwiWWkgU3lsbGFibGVzXCI6IFsweEEwMDAsIDB4QTQ4Rl0sXG5cdFx0XCJZaSBSYWRpY2Fsc1wiOiBbMHhBNDkwLCAweEE0Q0ZdLFxuXHRcdFwiTGlzdVwiOiBbMHhBNEQwLCAweEE0RkZdLFxuXHRcdFwiVmFpXCI6IFsweEE1MDAsIDB4QTYzRl0sXG5cdFx0XCJDeXJpbGxpYyBFeHRlbmRlZC1CXCI6IFsweEE2NDAsIDB4QTY5Rl0sXG5cdFx0XCJCYW11bVwiOiBbMHhBNkEwLCAweEE2RkZdLFxuXHRcdFwiTW9kaWZpZXIgVG9uZSBMZXR0ZXJzXCI6IFsweEE3MDAsIDB4QTcxRl0sXG5cdFx0XCJMYXRpbiBFeHRlbmRlZC1EXCI6IFsweEE3MjAsIDB4QTdGRl0sXG5cdFx0XCJTeWxvdGkgTmFncmlcIjogWzB4QTgwMCwgMHhBODJGXSxcblx0XHRcIkNvbW1vbiBJbmRpYyBOdW1iZXIgRm9ybXNcIjogWzB4QTgzMCwgMHhBODNGXSxcblx0XHRcIlBoYWdzLXBhXCI6IFsweEE4NDAsIDB4QTg3Rl0sXG5cdFx0XCJTYXVyYXNodHJhXCI6IFsweEE4ODAsIDB4QThERl0sXG5cdFx0XCJEZXZhbmFnYXJpIEV4dGVuZGVkXCI6IFsweEE4RTAsIDB4QThGRl0sXG5cdFx0XCJLYXlhaCBMaVwiOiBbMHhBOTAwLCAweEE5MkZdLFxuXHRcdFwiUmVqYW5nXCI6IFsweEE5MzAsIDB4QTk1Rl0sXG5cdFx0XCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXCI6IFsweEE5NjAsIDB4QTk3Rl0sXG5cdFx0XCJKYXZhbmVzZVwiOiBbMHhBOTgwLCAweEE5REZdLFxuXHRcdFwiTXlhbm1hciBFeHRlbmRlZC1CXCI6IFsweEE5RTAsIDB4QTlGRl0sXG5cdFx0XCJDaGFtXCI6IFsweEFBMDAsIDB4QUE1Rl0sXG5cdFx0XCJNeWFubWFyIEV4dGVuZGVkLUFcIjogWzB4QUE2MCwgMHhBQTdGXSxcblx0XHRcIlRhaSBWaWV0XCI6IFsweEFBODAsIDB4QUFERl0sXG5cdFx0XCJNZWV0ZWkgTWF5ZWsgRXh0ZW5zaW9uc1wiOiBbMHhBQUUwLCAweEFBRkZdLFxuXHRcdFwiRXRoaW9waWMgRXh0ZW5kZWQtQVwiOiBbMHhBQjAwLCAweEFCMkZdLFxuXHRcdFwiTGF0aW4gRXh0ZW5kZWQtRVwiOiBbMHhBQjMwLCAweEFCNkZdLFxuXHRcdFwiQ2hlcm9rZWUgU3VwcGxlbWVudFwiOiBbMHhBQjcwLCAweEFCQkZdLFxuXHRcdFwiTWVldGVpIE1heWVrXCI6IFsweEFCQzAsIDB4QUJGRl0sXG5cdFx0XCJIYW5ndWwgU3lsbGFibGVzXCI6IFsweEFDMDAsIDB4RDdBRl0sXG5cdFx0XCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1CXCI6IFsweEQ3QjAsIDB4RDdGRl0sXG5cdFx0XCJIaWdoIFN1cnJvZ2F0ZXNcIjogWzB4RDgwMCwgMHhEQjdGXSxcblx0XHRcIkhpZ2ggUHJpdmF0ZSBVc2UgU3Vycm9nYXRlc1wiOiBbMHhEQjgwLCAweERCRkZdLFxuXHRcdFwiTG93IFN1cnJvZ2F0ZXNcIjogWzB4REMwMCwgMHhERkZGXSxcblx0XHRcIlByaXZhdGUgVXNlIEFyZWFcIjogWzB4RTAwMCwgMHhGOEZGXSxcblx0XHRcIkNKSyBDb21wYXRpYmlsaXR5IElkZW9ncmFwaHNcIjogWzB4RjkwMCwgMHhGQUZGXSxcblx0XHRcIkFscGhhYmV0aWMgUHJlc2VudGF0aW9uIEZvcm1zXCI6IFsweEZCMDAsIDB4RkI0Rl0sXG5cdFx0XCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcIjogWzB4RkI1MCwgMHhGREZGXSxcblx0XHRcIlZhcmlhdGlvbiBTZWxlY3RvcnNcIjogWzB4RkUwMCwgMHhGRTBGXSxcblx0XHRcIlZlcnRpY2FsIEZvcm1zXCI6IFsweEZFMTAsIDB4RkUxRl0sXG5cdFx0XCJDb21iaW5pbmcgSGFsZiBNYXJrc1wiOiBbMHhGRTIwLCAweEZFMkZdLFxuXHRcdFwiQ0pLIENvbXBhdGliaWxpdHkgRm9ybXNcIjogWzB4RkUzMCwgMHhGRTRGXSxcblx0XHRcIlNtYWxsIEZvcm0gVmFyaWFudHNcIjogWzB4RkU1MCwgMHhGRTZGXSxcblx0XHRcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlwiOiBbMHhGRTcwLCAweEZFRkZdLFxuXHRcdFwiSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcIjogWzB4RkYwMCwgMHhGRkVGXSxcblx0XHRcIlNwZWNpYWxzXCI6IFsweEZGRjAsIDB4RkZGRl0sXG5cdFx0XCJMaW5lYXIgQiBTeWxsYWJhcnlcIjogWzB4MTAwMDAsIDB4MTAwN0ZdLFxuXHRcdFwiTGluZWFyIEIgSWRlb2dyYW1zXCI6IFsweDEwMDgwLCAweDEwMEZGXSxcblx0XHRcIkFlZ2VhbiBOdW1iZXJzXCI6IFsweDEwMTAwLCAweDEwMTNGXSxcblx0XHRcIkFuY2llbnQgR3JlZWsgTnVtYmVyc1wiOiBbMHgxMDE0MCwgMHgxMDE4Rl0sXG5cdFx0XCJBbmNpZW50IFN5bWJvbHNcIjogWzB4MTAxOTAsIDB4MTAxQ0ZdLFxuXHRcdFwiUGhhaXN0b3MgRGlzY1wiOiBbMHgxMDFEMCwgMHgxMDFGRl0sXG5cdFx0XCJMeWNpYW5cIjogWzB4MTAyODAsIDB4MTAyOUZdLFxuXHRcdFwiQ2FyaWFuXCI6IFsweDEwMkEwLCAweDEwMkRGXSxcblx0XHRcIkNvcHRpYyBFcGFjdCBOdW1iZXJzXCI6IFsweDEwMkUwLCAweDEwMkZGXSxcblx0XHRcIk9sZCBJdGFsaWNcIjogWzB4MTAzMDAsIDB4MTAzMkZdLFxuXHRcdFwiR290aGljXCI6IFsweDEwMzMwLCAweDEwMzRGXSxcblx0XHRcIk9sZCBQZXJtaWNcIjogWzB4MTAzNTAsIDB4MTAzN0ZdLFxuXHRcdFwiVWdhcml0aWNcIjogWzB4MTAzODAsIDB4MTAzOUZdLFxuXHRcdFwiT2xkIFBlcnNpYW5cIjogWzB4MTAzQTAsIDB4MTAzREZdLFxuXHRcdFwiRGVzZXJldFwiOiBbMHgxMDQwMCwgMHgxMDQ0Rl0sXG5cdFx0XCJTaGF2aWFuXCI6IFsweDEwNDUwLCAweDEwNDdGXSxcblx0XHRcIk9zbWFueWFcIjogWzB4MTA0ODAsIDB4MTA0QUZdLFxuXHRcdFwiT3NhZ2VcIjogWzB4MTA0QjAsIDB4MTA0RkZdLFxuXHRcdFwiRWxiYXNhblwiOiBbMHgxMDUwMCwgMHgxMDUyRl0sXG5cdFx0XCJDYXVjYXNpYW4gQWxiYW5pYW5cIjogWzB4MTA1MzAsIDB4MTA1NkZdLFxuXHRcdFwiTGluZWFyIEFcIjogWzB4MTA2MDAsIDB4MTA3N0ZdLFxuXHRcdFwiQ3lwcmlvdCBTeWxsYWJhcnlcIjogWzB4MTA4MDAsIDB4MTA4M0ZdLFxuXHRcdFwiSW1wZXJpYWwgQXJhbWFpY1wiOiBbMHgxMDg0MCwgMHgxMDg1Rl0sXG5cdFx0XCJQYWxteXJlbmVcIjogWzB4MTA4NjAsIDB4MTA4N0ZdLFxuXHRcdFwiTmFiYXRhZWFuXCI6IFsweDEwODgwLCAweDEwOEFGXSxcblx0XHRcIkhhdHJhblwiOiBbMHgxMDhFMCwgMHgxMDhGRl0sXG5cdFx0XCJQaG9lbmljaWFuXCI6IFsweDEwOTAwLCAweDEwOTFGXSxcblx0XHRcIkx5ZGlhblwiOiBbMHgxMDkyMCwgMHgxMDkzRl0sXG5cdFx0XCJNZXJvaXRpYyBIaWVyb2dseXBoc1wiOiBbMHgxMDk4MCwgMHgxMDk5Rl0sXG5cdFx0XCJNZXJvaXRpYyBDdXJzaXZlXCI6IFsweDEwOUEwLCAweDEwOUZGXSxcblx0XHRcIktoYXJvc2h0aGlcIjogWzB4MTBBMDAsIDB4MTBBNUZdLFxuXHRcdFwiT2xkIFNvdXRoIEFyYWJpYW5cIjogWzB4MTBBNjAsIDB4MTBBN0ZdLFxuXHRcdFwiT2xkIE5vcnRoIEFyYWJpYW5cIjogWzB4MTBBODAsIDB4MTBBOUZdLFxuXHRcdFwiTWFuaWNoYWVhblwiOiBbMHgxMEFDMCwgMHgxMEFGRl0sXG5cdFx0XCJBdmVzdGFuXCI6IFsweDEwQjAwLCAweDEwQjNGXSxcblx0XHRcIkluc2NyaXB0aW9uYWwgUGFydGhpYW5cIjogWzB4MTBCNDAsIDB4MTBCNUZdLFxuXHRcdFwiSW5zY3JpcHRpb25hbCBQYWhsYXZpXCI6IFsweDEwQjYwLCAweDEwQjdGXSxcblx0XHRcIlBzYWx0ZXIgUGFobGF2aVwiOiBbMHgxMEI4MCwgMHgxMEJBRl0sXG5cdFx0XCJPbGQgVHVya2ljXCI6IFsweDEwQzAwLCAweDEwQzRGXSxcblx0XHRcIk9sZCBIdW5nYXJpYW5cIjogWzB4MTBDODAsIDB4MTBDRkZdLFxuXHRcdFwiUnVtaSBOdW1lcmFsIFN5bWJvbHNcIjogWzB4MTBFNjAsIDB4MTBFN0ZdLFxuXHRcdFwiQnJhaG1pXCI6IFsweDExMDAwLCAweDExMDdGXSxcblx0XHRcIkthaXRoaVwiOiBbMHgxMTA4MCwgMHgxMTBDRl0sXG5cdFx0XCJTb3JhIFNvbXBlbmdcIjogWzB4MTEwRDAsIDB4MTEwRkZdLFxuXHRcdFwiQ2hha21hXCI6IFsweDExMTAwLCAweDExMTRGXSxcblx0XHRcIk1haGFqYW5pXCI6IFsweDExMTUwLCAweDExMTdGXSxcblx0XHRcIlNoYXJhZGFcIjogWzB4MTExODAsIDB4MTExREZdLFxuXHRcdFwiU2luaGFsYSBBcmNoYWljIE51bWJlcnNcIjogWzB4MTExRTAsIDB4MTExRkZdLFxuXHRcdFwiS2hvamtpXCI6IFsweDExMjAwLCAweDExMjRGXSxcblx0XHRcIk11bHRhbmlcIjogWzB4MTEyODAsIDB4MTEyQUZdLFxuXHRcdFwiS2h1ZGF3YWRpXCI6IFsweDExMkIwLCAweDExMkZGXSxcblx0XHRcIkdyYW50aGFcIjogWzB4MTEzMDAsIDB4MTEzN0ZdLFxuXHRcdFwiTmV3YVwiOiBbMHgxMTQwMCwgMHgxMTQ3Rl0sXG5cdFx0XCJUaXJodXRhXCI6IFsweDExNDgwLCAweDExNERGXSxcblx0XHRcIlNpZGRoYW1cIjogWzB4MTE1ODAsIDB4MTE1RkZdLFxuXHRcdFwiTW9kaVwiOiBbMHgxMTYwMCwgMHgxMTY1Rl0sXG5cdFx0XCJNb25nb2xpYW4gU3VwcGxlbWVudFwiOiBbMHgxMTY2MCwgMHgxMTY3Rl0sXG5cdFx0XCJUYWtyaVwiOiBbMHgxMTY4MCwgMHgxMTZDRl0sXG5cdFx0XCJBaG9tXCI6IFsweDExNzAwLCAweDExNzNGXSxcblx0XHRcIldhcmFuZyBDaXRpXCI6IFsweDExOEEwLCAweDExOEZGXSxcblx0XHRcIlphbmFiYXphciBTcXVhcmVcIjogWzB4MTFBMDAsIDB4MTFBNEZdLFxuXHRcdFwiU295b21ib1wiOiBbMHgxMUE1MCwgMHgxMUFBRl0sXG5cdFx0XCJQYXUgQ2luIEhhdVwiOiBbMHgxMUFDMCwgMHgxMUFGRl0sXG5cdFx0XCJCaGFpa3N1a2lcIjogWzB4MTFDMDAsIDB4MTFDNkZdLFxuXHRcdFwiTWFyY2hlblwiOiBbMHgxMUM3MCwgMHgxMUNCRl0sXG5cdFx0XCJNYXNhcmFtIEdvbmRpXCI6IFsweDExRDAwLCAweDExRDVGXSxcblx0XHRcIkN1bmVpZm9ybVwiOiBbMHgxMjAwMCwgMHgxMjNGRl0sXG5cdFx0XCJDdW5laWZvcm0gTnVtYmVycyBhbmQgUHVuY3R1YXRpb25cIjogWzB4MTI0MDAsIDB4MTI0N0ZdLFxuXHRcdFwiRWFybHkgRHluYXN0aWMgQ3VuZWlmb3JtXCI6IFsweDEyNDgwLCAweDEyNTRGXSxcblx0XHRcIkVneXB0aWFuIEhpZXJvZ2x5cGhzXCI6IFsweDEzMDAwLCAweDEzNDJGXSxcblx0XHRcIkFuYXRvbGlhbiBIaWVyb2dseXBoc1wiOiBbMHgxNDQwMCwgMHgxNDY3Rl0sXG5cdFx0XCJCYW11bSBTdXBwbGVtZW50XCI6IFsweDE2ODAwLCAweDE2QTNGXSxcblx0XHRcIk1yb1wiOiBbMHgxNkE0MCwgMHgxNkE2Rl0sXG5cdFx0XCJCYXNzYSBWYWhcIjogWzB4MTZBRDAsIDB4MTZBRkZdLFxuXHRcdFwiUGFoYXdoIEhtb25nXCI6IFsweDE2QjAwLCAweDE2QjhGXSxcblx0XHRcIk1pYW9cIjogWzB4MTZGMDAsIDB4MTZGOUZdLFxuXHRcdFwiSWRlb2dyYXBoaWMgU3ltYm9scyBhbmQgUHVuY3R1YXRpb25cIjogWzB4MTZGRTAsIDB4MTZGRkZdLFxuXHRcdFwiVGFuZ3V0XCI6IFsweDE3MDAwLCAweDE4N0ZGXSxcblx0XHRcIlRhbmd1dCBDb21wb25lbnRzXCI6IFsweDE4ODAwLCAweDE4QUZGXSxcblx0XHRcIkthbmEgU3VwcGxlbWVudFwiOiBbMHgxQjAwMCwgMHgxQjBGRl0sXG5cdFx0XCJLYW5hIEV4dGVuZGVkLUFcIjogWzB4MUIxMDAsIDB4MUIxMkZdLFxuXHRcdFwiTnVzaHVcIjogWzB4MUIxNzAsIDB4MUIyRkZdLFxuXHRcdFwiRHVwbG95YW5cIjogWzB4MUJDMDAsIDB4MUJDOUZdLFxuXHRcdFwiU2hvcnRoYW5kIEZvcm1hdCBDb250cm9sc1wiOiBbMHgxQkNBMCwgMHgxQkNBRl0sXG5cdFx0XCJCeXphbnRpbmUgTXVzaWNhbCBTeW1ib2xzXCI6IFsweDFEMDAwLCAweDFEMEZGXSxcblx0XHRcIk11c2ljYWwgU3ltYm9sc1wiOiBbMHgxRDEwMCwgMHgxRDFGRl0sXG5cdFx0XCJBbmNpZW50IEdyZWVrIE11c2ljYWwgTm90YXRpb25cIjogWzB4MUQyMDAsIDB4MUQyNEZdLFxuXHRcdFwiVGFpIFh1YW4gSmluZyBTeW1ib2xzXCI6IFsweDFEMzAwLCAweDFEMzVGXSxcblx0XHRcIkNvdW50aW5nIFJvZCBOdW1lcmFsc1wiOiBbMHgxRDM2MCwgMHgxRDM3Rl0sXG5cdFx0XCJNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHNcIjogWzB4MUQ0MDAsIDB4MUQ3RkZdLFxuXHRcdFwiU3V0dG9uIFNpZ25Xcml0aW5nXCI6IFsweDFEODAwLCAweDFEQUFGXSxcblx0XHRcIkdsYWdvbGl0aWMgU3VwcGxlbWVudFwiOiBbMHgxRTAwMCwgMHgxRTAyRl0sXG5cdFx0XCJNZW5kZSBLaWtha3VpXCI6IFsweDFFODAwLCAweDFFOERGXSxcblx0XHRcIkFkbGFtXCI6IFsweDFFOTAwLCAweDFFOTVGXSxcblx0XHRcIkFyYWJpYyBNYXRoZW1hdGljYWwgQWxwaGFiZXRpYyBTeW1ib2xzXCI6IFsweDFFRTAwLCAweDFFRUZGXSxcblx0XHRcIk1haGpvbmcgVGlsZXNcIjogWzB4MUYwMDAsIDB4MUYwMkZdLFxuXHRcdFwiRG9taW5vIFRpbGVzXCI6IFsweDFGMDMwLCAweDFGMDlGXSxcblx0XHRcIlBsYXlpbmcgQ2FyZHNcIjogWzB4MUYwQTAsIDB4MUYwRkZdLFxuXHRcdFwiRW5jbG9zZWQgQWxwaGFudW1lcmljIFN1cHBsZW1lbnRcIjogWzB4MUYxMDAsIDB4MUYxRkZdLFxuXHRcdFwiRW5jbG9zZWQgSWRlb2dyYXBoaWMgU3VwcGxlbWVudFwiOiBbMHgxRjIwMCwgMHgxRjJGRl0sXG5cdFx0XCJNaXNjZWxsYW5lb3VzIFN5bWJvbHMgYW5kIFBpY3RvZ3JhcGhzXCI6IFsweDFGMzAwLCAweDFGNUZGXSxcblx0XHRcIkVtb2ppXCI6IFsweDFGNjAwLCAweDFGNjRGXSxcblx0XHRcIk9ybmFtZW50YWwgRGluZ2JhdHNcIjogWzB4MUY2NTAsIDB4MUY2N0ZdLFxuXHRcdFwiVHJhbnNwb3J0IGFuZCBNYXAgU3ltYm9sc1wiOiBbMHgxRjY4MCwgMHgxRjZGRl0sXG5cdFx0XCJBbGNoZW1pY2FsIFN5bWJvbHNcIjogWzB4MUY3MDAsIDB4MUY3N0ZdLFxuXHRcdFwiR2VvbWV0cmljIFNoYXBlcyBFeHRlbmRlZFwiOiBbMHgxRjc4MCwgMHgxRjdGRl0sXG5cdFx0XCJTdXBwbGVtZW50YWwgQXJyb3dzLUNcIjogWzB4MUY4MDAsIDB4MUY4RkZdLFxuXHRcdFwiU3VwcGxlbWVudGFsIFN5bWJvbHMgYW5kIFBpY3RvZ3JhcGhzXCI6IFsweDFGOTAwLCAweDFGOUZGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEJcIjogWzB4MjAwMDAsIDB4MkE2REZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQ1wiOiBbMHgyQTcwMCwgMHgyQjczRl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBEXCI6IFsweDJCNzQwLCAweDJCODFGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEVcIjogWzB4MkI4MjAsIDB4MkNFQUZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gRlwiOiBbMHgyQ0VCMCwgMHgyRUJFRl0sXG5cdFx0XCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzIFN1cHBsZW1lbnRcIjogWzB4MkY4MDAsIDB4MkZBMUZdLFxuXHRcdFwiVGFnc1wiOiBbMHhFMDAwMCwgMHhFMDA3Rl0sXG5cdFx0XCJWYXJpYXRpb24gU2VsZWN0b3JzIFN1cHBsZW1lbnRcIjogWzB4RTAxMDAsIDB4RTAxRUZdXG5cdH0pO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBTdG9yZXMgdW5zb3J0ZWQgZ2VuZXJhbCB1dGlsaXR5IG1ldGhvZHMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTWlzY1xuXHR7XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHZhbHVlIGZyb20gdGhlIHNwZWNpZmllZCBNYXAuIEluIHRoZSBjYXNlIHdoZW4gdGhlIGtleVxuXHRcdCAqIGhhcyBub3QgYmVlbiBlbnRlcmVkIGludG8gdGhlIE1hcCwgaXQncyBhZGRlZCB0byB0aGUgbWFwIHZpYSB0aGVcblx0XHQgKiB0aGUgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyBhIGZhbGxiYWNrIHZhbHVlLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBnZXQ8SywgVj4obWFwOiBNYXA8SywgVj4sIGtleTogSywgZmFsbGJhY2tGbjogKCkgPT4gVik6IFZcblx0XHRzdGF0aWMgZ2V0PEsgZXh0ZW5kcyBvYmplY3QsIFY+KG1hcDogV2Vha01hcDxLLCBWPiwga2V5OiBLLCBmYWxsYmFja0ZuOiAoKSA9PiBWKTogVlxuXHRcdHN0YXRpYyBnZXQ8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEssIGZhbGxiYWNrRm46ICgpID0+IFYpOiBWXG5cdFx0e1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBtYXAuZ2V0KGtleSk7XG5cdFx0XHRpZiAodmFsdWUgIT09IHZvaWQgMClcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBmYWxsYmFja1ZhbHVlID0gZmFsbGJhY2tGbigpO1xuXHRcdFx0bWFwLnNldChrZXksIGZhbGxiYWNrVmFsdWUpO1xuXHRcdFx0cmV0dXJuIGZhbGxiYWNrVmFsdWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbXByZXNzZXMgdGhlIG51bWJlciBzZXF1ZW5jZSBpbnRvIGEgcmVhc29uYWJseSB1bmlxdWUgNTMtYml0IGhhc2ggbnVtYmVyLlxuXHRcdCAqIFRoZSBoYXNoIGlzIGNvbW11dGF0aXZlIGluIHRoYXQgdGhlIHNlcXVlbmNlcyBbMSwgMiwgM10gYW5kIFszLCAyLCAxXSBzaG91bGQgcmVzdWx0XG5cdFx0ICogaW4gdGhlIHNhbWUgbnVtYmVyLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBoYXNoQ29tbXV0YXRpdmUobnVtYmVyczogbnVtYmVyW10pXG5cdFx0e1xuXHRcdFx0bGV0IG11bCA9IDE7XG5cdFx0XHRsZXQgYWRkID0gMDtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IG51bWJlcnMubGVuZ3RoOyBpLS0gPiAwOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbnVtID0gbnVtYmVyc1tpXTtcblx0XHRcdFx0Ly8gMzIgYml0cyBmb3IgdGhlIG11bHRpcGx5aW5nIG9mIG51bWJlcnMgdG9nZXRoZXJcblx0XHRcdFx0bXVsID0gKG11bCAqPSBudW0pICUgKDIgKiogMzIpO1xuXHRcdFx0XHQvLyAxOCBiaXRzIGZvciB0aGUgdG90YWwgb2YgYWxsIHRoZSBudW1iZXJzXG5cdFx0XHRcdGFkZCA9IChhZGQgKz0gbnVtKSAlICgyICoqIDE4KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gMyBiaXRzIGZvciB0aGUgbnVtYmVyIG9mIG51bWJlcnNcblx0XHRcdGNvbnN0IGNvdW50ID0gbnVtYmVycy5sZW5ndGggJSAoMiAqKiAzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIChjb3VudCA8PCA1MCkgfCAoYWRkIDw8IDMyKSB8IG11bDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ291bnRzIGluY3JlbWVudGFsbHkgdGhyb3VnaCBudW1iZXJzLCB1c2luZyB0aGUgc3BlY2lmaWVkXG5cdFx0ICogcmFkaXggc2VxdWVuY2UuIEZvciBleGFtcGxlLCBpZiB0aGUgcmFkaXhlcyBbMiwgMiwgMl0gd2VyZSB0b1xuXHRcdCAqIGJlIHNwZWNpZmllZCwgdGhpcyB3b3VsZCByZXN1bHQgaW4gYmluYXJ5IGNvdW50aW5nIHN0YXJ0aW5nIGF0XG5cdFx0ICogWzAsIDAsIDBdIGFuZCBlbmRpbmcgYXQgWzEsIDEsIDFdLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyAqdmFyaWFibGVSYWRpeENvdW50ZXIocmFkaXhlczogbnVtYmVyW10pXG5cdFx0e1xuXHRcdFx0aWYgKHJhZGl4ZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGlmIChyYWRpeGVzLmxlbmd0aCA9PT0gMSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCByYWRpeGVzWzBdOylcblx0XHRcdFx0XHR5aWVsZCBbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHRvdGFsID0gcmFkaXhlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcblx0XHRcdGNvbnN0IGRpZ2l0cyA9IHJhZGl4ZXMubWFwKCgpID0+IDApO1xuXHRcdFx0Y29uc3QgZGl2aWRlRmFjdG9ycyA9IFsxXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgYmFzZUlkeCA9IHJhZGl4ZXMubGVuZ3RoIC0gMTsgLS1iYXNlSWR4ID49IDA7KVxuXHRcdFx0XHRkaXZpZGVGYWN0b3JzLnVuc2hpZnQocmFkaXhlcy5zbGljZShiYXNlSWR4ICsgMSkucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSkpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBjb3VudCA9IC0xOyArK2NvdW50IDwgdG90YWw7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzZXF1ZW5jZTogbnVtYmVyW10gPSBbXTtcblx0XHRcdFx0bGV0IHJlbWFpbmRlciA9IGNvdW50O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChsZXQgZGlnaXRJZHggPSAtMTsgKytkaWdpdElkeCA8IGRpZ2l0cy5sZW5ndGg7KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZGl2ID0gZGl2aWRlRmFjdG9yc1tkaWdpdElkeF07XG5cdFx0XHRcdFx0c2VxdWVuY2UucHVzaChyZW1haW5kZXIgLyBkaXYgfCAwKTtcblx0XHRcdFx0XHRyZW1haW5kZXIgJT0gZGl2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCBzZXF1ZW5jZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0c3RhdGljIGNhbGN1bGF0ZVBvd2Vyc2V0PFQ+KGFycmF5OiBUW10pOiBUW11bXVxuXHRcdHtcblx0XHRcdGNvbnN0IHJlc3VsdDogVFtdW10gPSBbW11dO1xuXHRcdFx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcblx0XHRcdFx0Zm9yIChsZXQgbiA9IDA7IG4gPCByZXN1bHQubGVuZ3RoOyBuKyspXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2gocmVzdWx0W25dLmNvbmNhdChhcnJheVtpXSkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBpdGVtcyBvZiB0aGUgZmlyc3Qgc2V0IG9iamVjdCBmb3JtXG5cdFx0ICogYSBzdWJzZXQgKG5vdCBhIHByb3BlciBzdWJzZXQpIG9mIHRoZSBpdGVtcyBvZiB0aGUgc2Vjb25kXG5cdFx0ICogc2V0LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBpc1N1YnNldChcblx0XHRcdHNvdXJjZVNldDogUmVhZG9ubHlTZXQ8dW5rbm93bj4sXG5cdFx0XHRwb3NzaWJsZVN1YnNldDogUmVhZG9ubHlTZXQ8dW5rbm93bj4pXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIHBvc3NpYmxlU3Vic2V0KVxuXHRcdFx0XHRpZiAoIXNvdXJjZVNldC5oYXMoaXRlbSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgV2hldGhlciB0aGUgaXRlbXMgb2YgdGhlIGZpcnN0IHNldCBvYmplY3QgZm9ybVxuXHRcdCAqIGEgc3VwZXJzZXQgKG5vdCBhIHByb3BlciBzdXBlcnNldCkgb2YgdGhlIGl0ZW1zIG9mIHRoZVxuXHRcdCAqIHNlY29uZCBzZXQuXG5cdFx0ICovXG5cdFx0c3RhdGljIGlzU3VwZXJzZXQoXG5cdFx0XHRzb3VyY2VTZXQ6IFJlYWRvbmx5U2V0PHVua25vd24+LFxuXHRcdFx0cG9zc2libGVTdXBlcnNldDogUmVhZG9ubHlTZXQ8dW5rbm93bj4pXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZVNldClcblx0XHRcdFx0aWYgKCFwb3NzaWJsZVN1cGVyc2V0LmhhcyhpdGVtKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgYXJlIG1pc3Npbmdcblx0XHQgKiBmcm9tIHRoZSBzZWNvbmQgc2V0IHRoYXQgZXhpc3QgaW4gdGhlIGZpcnN0IHNldC5cblx0XHQgKi9cblx0XHRzdGF0aWMgY29tcHV0ZVN1YnNldEZhY3Rvcihcblx0XHRcdGE6IHJlYWRvbmx5IHVua25vd25bXSxcblx0XHRcdGI6IHJlYWRvbmx5IHVua25vd25bXSlcblx0XHR7XG5cdFx0XHRsZXQgY291bnQgPSAwO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgYSlcblx0XHRcdFx0Y291bnQgKz0gYi5pbmNsdWRlcyhpdGVtKSA/IDAgOiAxO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgcmVjdXJzaXZlIHJlZHVjdGlvbiBvcGVyYXRpb24gb24gYW4gaW5pdGlhbCBvYmplY3Rcblx0XHQgKiB0aGF0IHJlcHJlc2VudHMgc29tZSBhYnN0cmFjdCBub2RlIG9mIGEgZ3JhcGguIFRoZSB0cmF2ZXJzYWxcblx0XHQgKiBhbGdvcml0aG0gdXNlZCBlbnN1cmVzIGFsbCBwcm92aWRlZCBub2RlcyBhcmUgb25seSB2aXNpdGVkXG5cdFx0ICogb25jZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgcmVkdWNlUmVjdXJzaXZlPFRSZXQsIFQ+KFxuXHRcdFx0aW5pdGlhbE9iamVjdDogVCxcblx0XHRcdGZvbGxvd0ZuOiAoZnJvbTogVCkgPT4gSXRlcmFibGU8VD4sXG5cdFx0XHRyZWR1Y2VGbjogKGN1cnJlbnQ6IFQsIG5lc3RlZFJlc3VsdHM6IHJlYWRvbmx5IFRSZXRbXSkgPT4gVFJldFxuXHRcdCk6IFRSZXRcblx0XHR7XG5cdFx0XHRjb25zdCB2aXNpdGVkID0gbmV3IFNldDxUPigpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByZWN1cnNlID0gKG9iamVjdDogVCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dmlzaXRlZC5hZGQob2JqZWN0KTtcblx0XHRcdFx0Y29uc3QgcmVkdWNlUmVzdWx0OiBUUmV0W10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgbmV4dCBvZiBmb2xsb3dGbihvYmplY3QpKVxuXHRcdFx0XHRcdGlmICghdmlzaXRlZC5oYXMobmV4dCkpXG5cdFx0XHRcdFx0XHRyZWR1Y2VSZXN1bHQucHVzaChyZWN1cnNlKG5leHQpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZWR1Y2VGbihvYmplY3QsIE9iamVjdC5mcmVlemUocmVkdWNlUmVzdWx0KSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVjdXJzZShpbml0aWFsT2JqZWN0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBwcm94eSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdCwgd2hvc2UgbWVtYmVyc1xuXHRcdCAqIGhhdmUgYmVlbiBwYXRjaGVkIHdpdGggdGhlIHNwZWNpZmllZCBwYXRjaCBvYmplY3QuXG5cdFx0ICovXG5cdFx0c3RhdGljIHBhdGNoPFQgZXh0ZW5kcyBvYmplY3Q+KHNvdXJjZTogVCwgcGF0Y2g6IFBhcnRpYWw8VD4pXG5cdFx0e1xuXHRcdFx0dHlwZSBLID0gcmVhZG9ubHkgKGtleW9mIFQpW107XG5cdFx0XHRjb25zdCBwYXRjaEtleXMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5rZXlzKHBhdGNoKSkgYXMgSztcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBQcm94eShzb3VyY2UsIHtcblx0XHRcdFx0Z2V0KHRhcmdldDogVCwga2V5OiBrZXlvZiBUKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdGNoS2V5cy5pbmNsdWRlcyhrZXkpID9cblx0XHRcdFx0XHRcdHBhdGNoW2tleV0gOlxuXHRcdFx0XHRcdFx0c291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTYWZlbHkgcGFyc2VzIGEgSlNPTiBvYmplY3QsIHNpbGVuY2luZyBhbnkgdGhyb3duIHBhcnNlIGV4Y2VwdGlvbnMuXG5cdFx0ICovXG5cdFx0c3RhdGljIHRyeVBhcnNlSnNvbihqc29uVGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHRyeVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShqc29uVGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSlcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogVGhlIGJhc2UgY2xhc3Mgb2YgYWxsIGRvbWFpbiBvYmplY3RzIGluIHRoZSBzeXN0ZW0uXG5cdCAqIChUaGUgc3lzdGVtIGlzIHNsb3dpbmcgYmVpbmcgbWlncmF0ZWQgc28gdGhhdCBtb3JlXG5cdCAqIGNsYXNzZXMgbWFrZSB1c2Ugb2YgdGhpcyBmZWF0dXJlKS5cblx0ICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdENsYXNzXG5cdHtcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cmVhZG9ubHkgaWQgPSBnZXROZXh0Q2xhc3NJZCgpO1xuXHRcdFxuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRhYnN0cmFjdCByZWFkb25seSBjbGFzczogQ2xhc3M7XG5cdH1cblx0XG5cdGxldCBuZXh0Q2xhc3NJZCA9IDA7XG5cdFxuXHQvKiogKi9cblx0ZnVuY3Rpb24gZ2V0TmV4dENsYXNzSWQoKVxuXHR7XG5cdFx0cmV0dXJuICgrK25leHRDbGFzc0lkKSAlIDIgKiogMzI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBIHVuaW9uIHR5cGUgYmV0d2VlbiBhbGwgZG9tYWluIG9iamVjdHMgaW4gdGhlIHN5c3RlbS5cblx0ICovXG5cdGV4cG9ydCB0eXBlIEFueUNsYXNzID0gXG5cdFx0RG9jdW1lbnQgfCBcblx0XHRTdGF0ZW1lbnQgfCBcblx0XHRSZWZlcmVuY2UgfFxuXHRcdFBocmFzZSB8XG5cdFx0VGVybTtcblx0XG5cdC8qKlxuXHQgKiBBIGNvbnN0IGVudW0gdG8gdW5pcXVlbHkgaWRlbnRpZnkgZWFjaCBkb21haW4gb2JqZWN0IGluIHRoZSBzeXN0ZW0uXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgZW51bSBDbGFzc1xuXHR7XG5cdFx0ZG9jdW1lbnQsXG5cdFx0c3RhdGVtZW50LFxuXHRcdHJlZmVyZW5jZSxcblx0XHRwaHJhc2UsXG5cdFx0dGVybVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogVGhlIHRvcC1sZXZlbCBvYmplY3QgdGhhdCBtYW5hZ2VzIFRydXRoIGRvY3VtZW50cy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQcm9ncmFtXG5cdHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFByb2dyYW0sIGludG8gd2hpY2ggRG9jdW1lbnRzIG1heVxuXHRcdCAqIGJlIGFkZGVkLCBhbmQgdmVyaWZpZWQuXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoKVxuXHRcdHtcblx0XHRcdHRoaXMuX3ZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFx0dGhpcy5yZWFkZXIgPSBUcnV0aC5jcmVhdGVEZWZhdWx0VXJpUmVhZGVyKCk7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBvcmRlcmluZyBvZiB0aGVzZSBpbnN0YW50YXRpb25zIGlzIHJlbGV2YW50LFxuXHRcdFx0Ly8gYmVjYXVzZSBpdCByZWZsZWN0cyB0aGUgb3JkZXIgaW4gd2hpY2ggZWFjaCBvZlxuXHRcdFx0Ly8gdGhlc2Ugc2VydmljZXMgYXJlIGdvaW5nIHRvIHByb2Nlc3MgaG9va3MuXG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VEb2N1bWVudENyZWF0ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnVudmVyaWZpZWREb2N1bWVudHMucHVzaChkYXRhLmRvY3VtZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlRG9jdW1lbnREZWxldGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaWR4ID0gdGhpcy51bnZlcmlmaWVkRG9jdW1lbnRzLmluZGV4T2YoZGF0YS5kb2N1bWVudCk7XG5cdFx0XHRcdGlmIChpZHggPiAtMSlcblx0XHRcdFx0XHR0aGlzLnVudmVyaWZpZWREb2N1bWVudHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5vbihDYXVzZURvY3VtZW50VXJpQ2hhbmdlLCAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlQWdlbnREZXRhY2gsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbY2F1c2UsIGF0dGFjaG1lbnRzXSBvZiB0aGlzLmNhdXNlcylcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHMpXG5cdFx0XHRcdFx0XHRpZiAoYXR0YWNobWVudC51cmkgJiYgYXR0YWNobWVudC51cmkgPT09IGRhdGEudXJpKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmNhdXNlcy5kZWxldGUoY2F1c2UsIGF0dGFjaG1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWdlbnRDYWNoZSA9IG5ldyBBZ2VudENhY2hlKHRoaXMpO1xuXHRcdFx0dGhpcy5ncmFwaCA9IG5ldyBIeXBlckdyYXBoKHRoaXMpO1xuXHRcdFx0dGhpcy5jeWNsZURldGVjdG9yID0gbmV3IEN5Y2xlRGV0ZWN0b3IodGhpcyk7XG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VSZXZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IGkgPSB0aGlzLnVudmVyaWZpZWRTdGF0ZW1lbnRzLmxlbmd0aDsgaS0tID4gMDspXG5cdFx0XHRcdFx0aWYgKHRoaXMudW52ZXJpZmllZFN0YXRlbWVudHNbaV0uaXNEaXNwb3NlZClcblx0XHRcdFx0XHRcdHRoaXMudW52ZXJpZmllZFN0YXRlbWVudHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBzdGF0ZW1lbnQgb2YgZGF0YS5wYXJlbnRzKVxuXHRcdFx0XHRcdGlmICghc3RhdGVtZW50LmlzQ3J1ZnQpXG5cdFx0XHRcdFx0XHR0aGlzLnVudmVyaWZpZWRTdGF0ZW1lbnRzLnB1c2goc3RhdGVtZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmZhdWx0cyA9IG5ldyBGYXVsdFNlcnZpY2UodGhpcyk7XG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VFZGl0Q29tcGxldGUsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3ZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IFVyaVJlYWRlciB1c2VkIGJ5IHRoZSBwcm9ncmFtLlxuXHRcdCAqIFRoaXMgcmVhZGVyIGlzIHVzZWQgdG8gbG9hZCB0aGUgY29udGVudHMgb2YgZmlsZXMgdGhhdCBcblx0XHQgKiBhcmUgcmVmZXJlbmNlZCB3aXRoaW4gdXJpLWNvbnRhaW5pbmcgc3RhdGVtZW50cyB3aXRoaW5cblx0XHQgKiBUcnV0aCBkb2N1bWVudHMuXG5cdFx0ICovXG5cdFx0c2V0UmVhZGVyKHJlYWRlcjogSVVyaVJlYWRlcilcblx0XHR7XG5cdFx0XHR0aGlzLnJlYWRlciA9IHJlYWRlcjtcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkZXI6IElVcmlSZWFkZXI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhIGRvY3VtZW50IHRvIHRoaXMgcHJvZ3JhbSB3aXRoIHRoZSBzcGVjaWZpZWQgc291cmNlVGV4dC5cblx0XHQgKiBUaGUgVVJJIGZvciB0aGUgZG9jdW1lbnQgaXMgYW4gYXV0by1nZW5lcmF0ZWQsIGF1dG8taW5jcmVtZW50aW5nXG5cdFx0ICogbnVtYmVyLlxuXHRcdCAqIFxuXHRcdCAqIEZvciBleGFtcGxlLCB0aGUgZmlyc3QgZG9jdW1lbnQgYWRkZWQgaW4gdGhpcyB3YXkgaXMgY29uc2lkZXJlZFxuXHRcdCAqIHRvIGhhdmUgdGhlIFVSSSBcIm1lbW9yeTovL21lbW9yeS8xLnRydXRoXCIsIHRoZSBzZWNvbmQgYmVpbmcgXG5cdFx0ICogXCJtZW1vcnk6Ly9tZW1vcnkvMi50cnV0aFwiLCBhbmQgc28gb24uXG5cdFx0ICovXG5cdFx0YXN5bmMgYWRkRG9jdW1lbnQoc291cmNlVGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IG1lbW9yeVVyaSA9IEtub3duVXJpLmNyZWF0ZU1lbW9yeVVyaSgrK3RoaXMubWVtb3J5VXJpQ291bnQpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IERvY3VtZW50Lm5ldyh0aGlzLCBtZW1vcnlVcmksIHNvdXJjZVRleHQsIGQgPT4gdGhpcy5zYXZlRG9jdW1lbnQoZCkpO1xuXHRcdH1cblx0XHRwcml2YXRlIG1lbW9yeVVyaUNvdW50ID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIGEgZG9jdW1lbnQgdG8gdGhpcyBwcm9ncmFtLCBieSBsb2FkaW5nIGl0IGZyb20gdGhlIHNwZWNpZmllZFxuXHRcdCAqIFVSSS4gSW4gdGhlIGNhc2Ugd2hlbiB0aGVyZSBoYXMgYWxyZWFkeSBiZWVuIGEgZG9jdW1lbnQgbG9hZGVkXG5cdFx0ICogZnJvbSB0aGUgVVJJIHNwZWNpZmllZCwgdGhpcyBwcmUtbG9hZGVkIGRvY3VtZW50IGlzIHJldHVybmVkLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBkb2N1bWVudFVyaSBUaGUgVVJJIHRoYXQgd2lsbCByZXByZXNlbnQgdGhlIHNvdXJjZSBcblx0XHQgKiBsb2NhdGlvbiBvZiB0aGUgbG9hZGVkIGRvY3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBzb3VyY2VUZXh0IFRoZSBzb3VyY2UgdGV4dCB0byBsb2FkIGludG8gdGhlIGRvY3VtZW50XG5cdFx0ICogYnkgZGVmYXVsdC4gSWYgb21pdHRlZCwgdGhlIHNvdXJjZSB0ZXh0IHdpbGwgYmUgbG9hZGVkIGZyb20gdGhlXG5cdFx0ICogdGhlIFVSSSBzcGVjaWZpZWQgaW4gdGhlIGBkb2N1bWVudFVyaWAgIGFyZ3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIFVzZSB0aGlzIGFyZ3VtZW50IHdoZW4gdGhlIHNvdXJjZSB0ZXh0IG9mIHRoZSBkb2N1bWVudCBiZWluZ1xuXHRcdCAqIGFkZGVkIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIGludG8gYSBzdHJpbmcgYnkgYW5vdGhlciBtZWFucyxcblx0XHQgKiBvciB3aGVuIG1vcmUgY29udHJvbCBvZiB0aGUgYWN0dWFsIGxvYWRlZCBjb250ZW50IGlzIHJlcXVpcmVkLlxuXHRcdCAqL1xuXHRcdGFzeW5jIGFkZERvY3VtZW50RnJvbVVyaShcblx0XHRcdGRvY3VtZW50VXJpOiBzdHJpbmcgfCBLbm93blVyaSxcblx0XHRcdHNvdXJjZVRleHQ/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpID0gdHlwZW9mIGRvY3VtZW50VXJpID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0S25vd25VcmkuZnJvbVN0cmluZyhkb2N1bWVudFVyaSkgOlxuXHRcdFx0XHRkb2N1bWVudFVyaTtcblx0XHRcdFxuXHRcdFx0aWYgKCF1cmkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkVXJpKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGV4aXN0aW5nRG9jID0gdGhpcy5nZXREb2N1bWVudEJ5VXJpKHVyaSk7XG5cdFx0XHRpZiAoZXhpc3RpbmdEb2MpXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RvYztcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJvbWlzZXMgPSB0aGlzLnF1ZXVlLmdldCh1cmkpO1xuXHRcdFx0aWYgKHByb21pc2VzKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2U8RG9jdW1lbnQgfCBFcnJvcj4ocmVzb2x2ZSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChyZXNvbHZlIGFzIGFueSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBUaGUgcHJvYmxlbSB3aXRoIHRoaXMgZGVzaWduIGlzIHRoYXQgSSBkb24ndCBrbm93IGlmIHRoZSBcblx0XHRcdC8vIHJlc29sdmUgZnVuY3Rpb24gaXMgZ29pbmcgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG5cdFx0XHQvLyBJZiBpdCBpcywgdGhpcyBjb2RlIHN0cnVjdHVyZSB3aWxsIHByb2JhYmx5IHdvcmsuXG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZTxEb2N1bWVudCB8IEVycm9yPihhc3luYyByZXNvbHZlID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMucXVldWUuc2V0KHVyaSwgW3Jlc29sdmVdKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzb3VyY2VUZXh0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBsb2FkZWRTb3VyY2VUZXh0ID0gYXdhaXQgKGFzeW5jICgpID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVhZFJlc3VsdCA9IGF3YWl0IHRoaXMucmVhZGVyLnRyeVJlYWQodXJpKTtcblx0XHRcdFx0XHRcdGlmIChyZWFkUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkUmVzdWx0O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVhZFJlc3VsdDtcblx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobG9hZGVkU291cmNlVGV4dCBpbnN0YW5jZW9mIEVycm9yKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGxvYWRlZFNvdXJjZVRleHQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0c291cmNlVGV4dCA9IGxvYWRlZFNvdXJjZVRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRvY09yRXJyb3IgPSBhd2FpdCBEb2N1bWVudC5uZXcoXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR1cmksXG5cdFx0XHRcdFx0c291cmNlVGV4dCxcblx0XHRcdFx0XHRkID0+IHRoaXMuc2F2ZURvY3VtZW50KGQpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHJlc29sdmVGbnMgPSB0aGlzLnF1ZXVlLmdldCh1cmkpO1xuXHRcdFx0XHRpZiAocmVzb2x2ZUZucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMucXVldWUuZGVsZXRlKHVyaSk7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCByZXNvbHZlRm4gb2YgcmVzb2x2ZUZucylcblx0XHRcdFx0XHRcdHJlc29sdmVGbihkb2NPckVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcXVldWUgPSBuZXcgTWFwPEtub3duVXJpLCAoKHJlc29sdmVkOiBEb2N1bWVudCB8IEVycm9yKSA9PiB2b2lkKVtdPigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBkb2N1bWVudCB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBkb2N1bWVudHMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBzYXZlRG9jdW1lbnQoZG9jOiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHR0aGlzLl9kb2N1bWVudHMucHVzaChkb2MpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgbG9hZGVkIGRvY3VtZW50IHdpdGggdGhlIHNwZWNpZmllZCBVUkkuXG5cdFx0ICovXG5cdFx0Z2V0RG9jdW1lbnRCeVVyaSh1cmk6IEtub3duVXJpKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZG9jIG9mIHRoaXMuX2RvY3VtZW50cylcblx0XHRcdFx0aWYgKGRvYy51cmkgPT09IHVyaSlcblx0XHRcdFx0XHRyZXR1cm4gZG9jO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHJlYWRvbmx5IGFycmF5IG9mIHRydXRoIGRvY3VtZW50c1xuXHRcdCAqIHRoYXQgaGF2ZSBiZWVuIGxvYWRlZCBpbnRvIHRoaXMgUHJvZ3JhbS5cblx0XHQgKi9cblx0XHRnZXQgZG9jdW1lbnRzKCk6IHJlYWRvbmx5IERvY3VtZW50W11cblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9jdW1lbnRzO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9kb2N1bWVudHM6IERvY3VtZW50W10gPSBbXTtcblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cmVhZG9ubHkgZ3JhcGg6IEh5cGVyR3JhcGg7XG5cdFx0XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdHJlYWRvbmx5IGN5Y2xlRGV0ZWN0b3I6IEN5Y2xlRGV0ZWN0b3I7XG5cdFx0XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgYWdlbnRDYWNoZTogQWdlbnRDYWNoZTtcblx0XHRcblx0XHQvKiogICovXG5cdFx0cmVhZG9ubHkgZmF1bHRzOiBGYXVsdFNlcnZpY2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IHZlcnNpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl92ZXJzaW9uO1xuXHRcdH1cblx0XHRwcml2YXRlIF92ZXJzaW9uOiBWZXJzaW9uU3RhbXA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvYmVzIHRoZSBwcm9ncmFtIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCB0aGUgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgYSBjYXVzZSBvZiB0aGUgc3BlY2lmaWVkXG5cdFx0ICogdHlwZSBpcyBicm9hZGNhc3RlZC4gRXNzZW50aWFsbHksIHRoaXMgbWV0aG9kIGFuc3dlcnMgdGhlIHF1ZXN0aW9uLCBcblx0XHQgKiBcIldobyBpcyBsaXN0ZW5pbmcgZm9yIENhdXNlcyBvZiB0eXBlIFg/XCIuXG5cdFx0ICogXG5cdFx0ICogSWYgbm8gYWdlbnRzIGhhdmUgYXR0YWNoZWQgdG8gdGhlIHNwZWNpZmllZCB0eXBlLCBhbiBlbXB0eSBhcnJheVxuXHRcdCAqIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdHByb2JlKGNhdXNlVHlwZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBzY29wZTogQXR0YWNobWVudFNjb3BlID0gdGhpcylcblx0XHR7XG5cdFx0XHRpZiAoc2NvcGUgaW5zdGFuY2VvZiBUeXBlKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVzdWx0czogeyB1cmk6IEtub3duVXJpIHwgbnVsbDsgc2NvcGU6IEF0dGFjaG1lbnRTY29wZTsgfVtdID0gW107XG5cdFx0XHRjb25zdCBwdXNoID0gKGNhOiBDYXVzZUF0dGFjaG1lbnQpID0+XG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7IHVyaTogY2EudXJpLCBzY29wZTogY2Euc2NvcGUgfSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2NhdXNlVHlwZUtleSwgYXR0YWNobWVudHNdIG9mIHRoaXMuY2F1c2VzKVxuXHRcdFx0XHRpZiAoY2F1c2VUeXBlID09PSBjYXVzZVR5cGVLZXkpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjYSBvZiBhdHRhY2htZW50cylcblx0XHRcdFx0XHRcdGlmIChzY29wZSA9PT0gY2Euc2NvcGUgfHwgXG5cdFx0XHRcdFx0XHRcdHNjb3BlIGluc3RhbmNlb2YgUHJvZ3JhbSAmJiBjYS5zY29wZSBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0XHRcdFx0XHRwdXNoKGNhKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdG9uPFQgZXh0ZW5kcyBDYXVzZTxhbnk+Pihcblx0XHRcdGNhdXNlVHlwZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVCxcblx0XHRcdGZuOiAoZGF0YTogVENhdXNlRGF0YTxUPikgPT4gVENhdXNlUmV0dXJuPFQ+LFxuXHRcdFx0c2NvcGU/OiBEb2N1bWVudCB8IFR5cGUpOiB2b2lkXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5mbyA9IGdldEhvbGRlckluZm8odGhpcyk7XG5cdFx0XHRjb25zdCB1c2luZ1Njb3BlOiBBdHRhY2htZW50U2NvcGUgPSBzY29wZSB8fCBpbmZvLnNjb3BlIHx8IHRoaXM7XG5cdFx0XHRjb25zdCBjYSA9IG5ldyBDYXVzZUF0dGFjaG1lbnQoaW5mby51cmksIGZuLCB1c2luZ1Njb3BlKTtcblx0XHRcdHRoaXMuY2F1c2VzLmFkZChjYXVzZVR5cGUsIGNhKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvZ2F0ZXMgdGhlIHNwZWNpZmllZCBDYXVzZSBvYmplY3QgdG8gYWxsIHN1YnNjcmliZXJzIHRoYXRcblx0XHQgKiBhcmUgbGlzdGVuaW5nIGZvciBjYXVzZXMgb2Ygb2JqZWN0J3MgdHlwZS4gXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGNhdXNlIEEgcmVmZXJlbmNlIHRvIHRoZSBDYXVzZSBpbnN0YW5jZSB0byBicm9hZGNhc3QuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGZpbHRlciBBbiBvcHRpb25hbCBhcnJheSBvZiBVcmkgaW5zdGFuY2VzIHRoYXRcblx0XHQgKiBzcGVjaWZ5IHRoZSBvcmlnaW4gZnJvbSB3aGVyZSBhbiBhZ2VudCB0aGF0IGlzIGF0dGFjaGVkXG5cdFx0ICogdG8gdGhlIGNhdXNlIG11c3QgbG9hZGVkIGluIG9yZGVyIHRvIGJlIGRlbGl2ZXJlZCB0aGVcblx0XHQgKiBjYXVzZSBpbnN0YW5jZS5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBbiBvYmplY3QgdGhhdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG5cdFx0ICogY2F1c2UgcmVzdWx0cyB0aGF0IHdlcmUgcmV0dXJuZWQsIGFuZCB0aGUgVVJJIG9mIHRoZSBcblx0XHQgKiBhZ2VudCB0aGF0IHByb2R1Y2VkIHRoZSByZXN1bHQuIEluIHRoZSBjYXNlIHdoZW4gdGhlXG5cdFx0ICogYWdlbnQgd2FzIGF0dGFjaGVkIHByb2dyYW1tYXRpY2FsbHksIHRoZSBVUkkgdmFsdWUgXG5cdFx0ICogd2lsbCBiZSBudWxsLlxuXHRcdCAqL1xuXHRcdGNhdXNlPFI+KGNhdXNlOiBDYXVzZTxSPiwgLi4uZmlsdGVyczogS25vd25VcmlbXSlcblx0XHR7XG5cdFx0XHRjb25zdCBjYXVzZVR5cGUgPSBjYXVzZS5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgQ2F1c2U7XG5cdFx0XHRjb25zdCBhdHRhY2htZW50c0FsbCA9IHRoaXMuY2F1c2VzLmdldChjYXVzZVR5cGUpIHx8IFtdO1xuXHRcdFx0Y29uc3QgYXR0YWNobWVudHMgPSBhdHRhY2htZW50c0FsbC5maWx0ZXIoYXR0YWNobWVudCA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZmlsdGVycy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBvdGhlclVyaSA9IGF0dGFjaG1lbnQudXJpO1xuXHRcdFx0XHRpZiAob3RoZXJVcmkgPT09IG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZmlsdGVycy5maW5kKHVyaSA9PiB1cmkgPT09IG90aGVyVXJpKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoYXR0YWNobWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlc3VsdDogeyBmcm9tOiBLbm93blVyaSB8IG51bGw7IHJldHVybmVkOiBSIH1bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJldHVybmVkOiBSID0gYXR0YWNobWVudC5jYWxsYmFjayhjYXVzZSk7XG5cdFx0XHRcdGlmIChyZXR1cm5lZCAhPT0gbnVsbCAmJiByZXR1cm5lZCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHsgZnJvbTogYXR0YWNobWVudC51cmksIHJldHVybmVkIH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjYXVzZXMgPSBuZXcgTXVsdGlNYXA8dHlwZW9mIENhdXNlLCBDYXVzZUF0dGFjaG1lbnQ+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXVnbWVudHMgdGhlIGdsb2JhbCBzY29wZSBvZiB0aGUgYWdlbnRzIGF0dGFjaGVkIHRvIHRoaXNcblx0XHQgKiBwcm9ncmFtIHdpdGggYSB2YXJpYWJsZSB3aG9zZSBuYW1lIGFuZCB2YWx1ZSBhcmUgc3BlY2lmaWVkXG5cdFx0ICogaW4gdGhlIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZC4gKE5vdGUgdGhhdCB0aGlzIG9ubHkgYWZmZWN0c1xuXHRcdCAqIGFnZW50cyB0aGF0IGFyZSBhdHRhY2hlZCAqYWZ0ZXIqIHRoaXMgY2FsbCBoYXMgYmVlbiBtYWRlLilcblx0XHQgKi9cblx0XHRhdWdtZW50KG5hbWU6IHN0cmluZywgdmFsdWU6IG9iamVjdClcblx0XHR7XG5cdFx0XHR0aGlzLmFnZW50Q2FjaGUuYXVnbWVudChuYW1lLCB2YWx1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGF0dGFjaChhZ2VudFVyaTogS25vd25VcmkpOiBQcm9taXNlPEVycm9yIHwgdm9pZD5cblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0ZGV0YWNoKGFnZW50VXJpOiBLbm93blVyaSlcblx0XHR7XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGUgcHJvZ3JhbSBmb3IgdGhlIHJvb3QtbGV2ZWwgdHlwZXMgdGhhdCBleGlzdCB3aXRoaW5cblx0XHQgKiB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcXVlcnkuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgdG9wLWxldmVsIHR5cGVzIHRoYXQgYXJlXG5cdFx0ICogZGVmaW5lZCB3aXRoaW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRxdWVyeShkb2N1bWVudDogRG9jdW1lbnQpOiByZWFkb25seSBUeXBlW107XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGUgcHJvZ3JhbSBmb3IgdGhlIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluXG5cdFx0ICogdGhlIHNwZWNpZmllZCBkb2N1bWVudCwgYXQgdGhlIHNwZWNpZmllZCB0eXBlIHBhdGguXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBxdWVyeS5cblx0XHQgKiBAcGFyYW0gdHlwZVBhdGggVGhlIHR5cGUgcGF0aCB3aXRoaW4gdGhlIGRvY3VtZW50IHRvIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZ1bGx5IGNvbnN0cnVjdGVkIFR5cGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0b1xuXHRcdCAqIHRoZSB0eXBlIGF0IHRoZSBVUkkgc3BlY2lmaWVkLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gbm8gdHlwZVxuXHRcdCAqIGNvdWxkIGJlIGZvdW5kLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KGRvY3VtZW50OiBEb2N1bWVudCwgLi4udHlwZVBhdGg6IHN0cmluZ1tdKTogVHlwZSB8IG51bGw7XG5cdFx0cXVlcnkoZG9jdW1lbnQ6IERvY3VtZW50LCAuLi50eXBlUGF0aDogc3RyaW5nW10pOlxuXHRcdFx0cmVhZG9ubHkgVHlwZVtdIHwgVHlwZSB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZVBhdGgubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ucGFzc2VkQXJyYXlDYW5ub3RCZUVtcHR5KFwidHlwZVBhdGhcIik7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlUGF0aC5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBUeXBlLmNvbnN0cnVjdFJvb3RzKGRvY3VtZW50KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcGhyYXNlID0gZG9jdW1lbnQucGhyYXNlLmZvcndhcmREZWVwKHR5cGVQYXRoKTtcblx0XHRcdHJldHVybiBUeXBlLmNvbnN0cnVjdChwaHJhc2UpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBCZWdpbiBpbnNwZWN0aW5nIGEgZG9jdW1lbnQgbG9hZGVkXG5cdFx0ICogaW50byB0aGlzIHByb2dyYW0sIGEgc3BlY2lmaWMgbG9jYXRpb24uXG5cdFx0ICovXG5cdFx0aW5zcGVjdChcblx0XHRcdGRvY3VtZW50OiBEb2N1bWVudCxcblx0XHRcdGxpbmU6IG51bWJlcixcblx0XHRcdG9mZnNldDogbnVtYmVyKTogUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHRcblx0XHR7XG5cdFx0XHRjb25zdCBzdGF0ZW1lbnQgPSBkb2N1bWVudC5yZWFkKGxpbmUpO1xuXHRcdFx0Y29uc3Qgem9uZSA9IHN0YXRlbWVudC5nZXRab25lKG9mZnNldCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHtcblx0XHRcdFx0bGluZSxcblx0XHRcdFx0b2Zmc2V0XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRzd2l0Y2ggKHpvbmUpXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgU3RhdGVtZW50Wm9uZS52b2lkOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQocG9zaXRpb24sIHpvbmUsIG51bGwsIHN0YXRlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSB0eXBlcyBpbiB0aGUgZGVjbGFyYXRpb24gc2lkZSBvZiB0aGUgcGFyZW50LlxuXHRcdFx0XHRjYXNlIFN0YXRlbWVudFpvbmUud2hpdGVzcGFjZTpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmdldFBhcmVudEZyb21Qb3NpdGlvbihsaW5lLCBvZmZzZXQpO1xuXHRcdFx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudClcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQocG9zaXRpb24sIHpvbmUsIHBhcmVudCwgc3RhdGVtZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0eXBlcyA9IHBhcmVudC5kZWNsYXJhdGlvbnNcblx0XHRcdFx0XHRcdC5tYXAoZGVjbCA9PiBkZWNsLmZhY3RvcigpKVxuXHRcdFx0XHRcdFx0LnJlZHVjZSgoc3BpbmVzLCBzKSA9PiBzcGluZXMuY29uY2F0KHMpLCBbXSlcblx0XHRcdFx0XHRcdC5tYXAoc3BpbmUgPT4gVHlwZS5jb25zdHJ1Y3Qoc3BpbmUpKVxuXHRcdFx0XHRcdFx0LmZpbHRlcigodHlwZSk6IHR5cGUgaXMgVHlwZSA9PiAhIXR5cGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQocG9zaXRpb24sIHpvbmUsIHR5cGVzLCBzdGF0ZW1lbnQsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGNhc2UgU3RhdGVtZW50Wm9uZS5wYXR0ZXJuOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gVE9ETzogVGhpcyBzaG91bGQgbm90IGJlIHJldHVybmluZyBhIFBhdHRlcm5MaXRlcmFsLFxuXHRcdFx0XHRcdC8vIGJ1dCByYXRoZXIgYSBmdWxseSBjb25zdHJ1Y3RlZCBJUGF0dGVybiBvYmplY3QuIFRoaXNcblx0XHRcdFx0XHQvLyBjb2RlIGlzIG9ubHkgaGVyZSBhcyBhIHNoaW0uXG5cdFx0XHRcdFx0Y29uc3QgcGF0dGVyblR5cGVzOiBUeXBlW10gPSBbXTtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KHBvc2l0aW9uLCB6b25lLCBwYXR0ZXJuVHlwZXMsIHN0YXRlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgdHlwZXMgcmVsYXRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2xhcmF0aW9uLlxuXHRcdFx0XHRjYXNlIFN0YXRlbWVudFpvbmUuZGVjbGFyYXRpb246XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkZWNsID0gc3RhdGVtZW50LmdldERlY2xhcmF0aW9uKG9mZnNldCk7XG5cdFx0XHRcdFx0aWYgKCFkZWNsKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHR5cGVzID0gZGVjbFxuXHRcdFx0XHRcdFx0LmZhY3RvcigpXG5cdFx0XHRcdFx0XHQubWFwKHNwaW5lID0+IFR5cGUuY29uc3RydWN0KHNwaW5lKSlcblx0XHRcdFx0XHRcdC5maWx0ZXIoKHR5cGUpOiB0eXBlIGlzIFR5cGUgPT4gISF0eXBlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KHBvc2l0aW9uLCB6b25lLCB0eXBlcywgc3RhdGVtZW50LCBkZWNsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBcblx0XHRcdFx0Y2FzZSBTdGF0ZW1lbnRab25lLmFubm90YXRpb246XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBhbm5vID0gc3RhdGVtZW50LmdldEFubm90YXRpb24ob2Zmc2V0KTtcblx0XHRcdFx0XHRpZiAoIWFubm8pXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3BpbmUgPSBzdGF0ZW1lbnQuZGVjbGFyYXRpb25zWzBdLmZhY3RvcigpWzBdO1xuXHRcdFx0XHRcdGxldCBiYXNlOiBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gVHlwZS5jb25zdHJ1Y3Qoc3BpbmUpO1xuXHRcdFx0XHRcdGlmICh0eXBlKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGFubm9UZXh0ID0gYW5uby5ib3VuZGFyeS5zdWJqZWN0LnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHRiYXNlID0gdHlwZS5iYXNlcy5maWx0ZXIoYiA9PiBiLm5hbWUgPT09IGFubm9UZXh0KTtcblx0XHRcdFx0XHRcdGJhc2UucHVzaCh0eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdChwb3NpdGlvbiwgem9uZSwgYmFzZSwgc3RhdGVtZW50LCBhbm5vKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFN0YXRlbWVudFpvbmUuYW5ub3RhdGlvblZvaWQ6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBhbm5vID0gc3RhdGVtZW50LmdldEFubm90YXRpb24ob2Zmc2V0KTtcblx0XHRcdFx0XHRjb25zdCBzcGluZSA9IHN0YXRlbWVudC5kZWNsYXJhdGlvbnNbMF0uZmFjdG9yKClbMF07XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IFR5cGUuY29uc3RydWN0KHNwaW5lKTtcblx0XHRcdFx0XHRjb25zdCBmb3VuZE9iamVjdCA9IHR5cGUgPyBbdHlwZV0gOiBudWxsO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQocG9zaXRpb24sIHpvbmUsIGZvdW5kT2JqZWN0LCBzdGF0ZW1lbnQsIGFubm8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQocG9zaXRpb24sIHpvbmUsIG51bGwsIHN0YXRlbWVudCwgbnVsbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgZnVsbCB2ZXJpZmljYXRpb24gb2YgYWxsIGRvY3VtZW50cyBsb2FkZWQgaW50byB0aGUgcHJvZ3JhbS5cblx0XHQgKiBUaGlzIFByb2dyYW0ncyAuZmF1bHRzIGZpZWxkIGlzIHBvcHVsYXRlZCB3aXRoIGFueSBmYXVsdHMgZ2VuZXJhdGVkIGFzXG5cdFx0ICogYSByZXN1bHQgb2YgdGhlIHZlcmlmaWNhdGlvbi4gSWYgbm8gZG9jdW1lbnRzIGxvYWRlZCBpbnRvIHRoaXMgcHJvZ3JhbVxuXHRcdCAqIGhhcyBiZWVuIGVkaXRlZCBzaW5jZSB0aGUgbGFzdCB2ZXJpZmljYXRpb24sIHZlcmlmaWNhdGlvbiBpcyBub3QgcmUtYXR0ZW1wdGVkLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSB2ZXJpZmljYXRpb24gcGFzc2VkLlxuXHRcdCAqL1xuXHRcdHZlcmlmeSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMubGFzdEZ1bGxWZXJpZnkgJiYgIXRoaXMudmVyc2lvbi5uZXdlclRoYW4odGhpcy5sYXN0RnVsbFZlcmlmeSkpXG5cdFx0XHRcdHJldHVybiB0aGlzLmxhc3RGdWxsVmVyaWZ5UmVzdWx0O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGRvYyBvZiB0aGlzLmRvY3VtZW50cylcblx0XHRcdFx0Zm9yIChjb25zdCB7IHN0YXRlbWVudCB9IG9mIGRvYy5lYWNoRGVzY2VuZGFudCgpKVxuXHRcdFx0XHRcdHRoaXMudmVyaWZ5QXNzb2NpYXRlZERlY2xhcmF0aW9ucyhzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmxhc3RGdWxsVmVyaWZ5ID0gdGhpcy52ZXJzaW9uO1xuXHRcdFx0cmV0dXJuIHRoaXMubGFzdEZ1bGxWZXJpZnlSZXN1bHQgPSB0aGlzLmZpbmFsaXplVmVyaWZpY2F0aW9uKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgdGhlIHZlcnNpb24gb2YgdGhpcyBwcm9ncmFtIHdoZW4gdGhlIGxhc3QgZnVsbCB2ZXJpZmljYXRpb24gb2NjdXJlZC4gKi9cblx0XHRwcml2YXRlIGxhc3RGdWxsVmVyaWZ5OiBWZXJzaW9uU3RhbXAgfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogU3RvcmVzIHRoZSByZXN1bHQgcHJvZHVjZWQgZnJvbSB0aGUgbGFzdCBmdWxsIHZlcmlmaWNhdGlvbi4gKi9cblx0XHRwcml2YXRlIGxhc3RGdWxsVmVyaWZ5UmVzdWx0ID0gdHJ1ZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyB2ZXJpZmljYXRpb24gb24gdGhlIHBhcnRzIG9mIHRoZSBkb2N1bWVudCB0aGF0IGhhdmVcblx0XHQgKiBub3QgYmVlbiB2ZXJpZmllZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgbWV0aG9kLiBPbmNlIHRoaXNcblx0XHQgKiBtZXRob2QgaGFzIGNvbXBsZXRlZCwgYW55IGRldGVjdGVkIGZhdWx0cyB3aWxsIGJlIGF2YWlsYWJsZVxuXHRcdCAqIGJ5IHVzaW5nIHRoZSBtZXRob2RzIGxvY2F0ZWQgaW4gdGhlIGAuZmF1bHRzYCBwcm9wZXJ0eSBvZiB0aGlzXG5cdFx0ICogaW5zdGFuY2UuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdmVyaWZpY2F0aW9uXG5cdFx0ICogY29tcGxldGVkIHdpdGhvdXQgZGV0ZWN0aW5nIGFueSBmYXVsdHMgaW4gdGhpcyBQcm9ncmFtLlxuXHRcdCAqL1xuXHRcdHJldmVyaWZ5KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGRvYyBvZiB0aGlzLnVudmVyaWZpZWREb2N1bWVudHMpXG5cdFx0XHRcdGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBkb2MuZWFjaERlc2NlbmRhbnQoKSlcblx0XHRcdFx0XHR0aGlzLnZlcmlmeUFzc29jaWF0ZWREZWNsYXJhdGlvbnMoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgdGhpcy51bnZlcmlmaWVkU3RhdGVtZW50cylcblx0XHRcdFx0dGhpcy52ZXJpZnlBc3NvY2lhdGVkRGVjbGFyYXRpb25zKHNtdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZpbmFsaXplVmVyaWZpY2F0aW9uKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgdmVyaWZ5QXNzb2NpYXRlZERlY2xhcmF0aW9ucyhzdGF0ZW1lbnQ6IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHRpZiAoIXN0YXRlbWVudC5pc0Rpc3Bvc2VkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGRlY2wgb2Ygc3RhdGVtZW50LmRlY2xhcmF0aW9ucylcblx0XHRcdFx0XHRkZWNsLmZhY3RvcigpLm1hcChzcGluZSA9PiBcblx0XHRcdFx0XHRcdFR5cGUuY29uc3RydWN0KHNwaW5lKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgZmluYWxpemVWZXJpZmljYXRpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuZmF1bHRzLnJlZnJlc2goKTtcblx0XHRcdHRoaXMudW52ZXJpZmllZERvY3VtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy51bnZlcmlmaWVkU3RhdGVtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmF1bHRzLmNvdW50ID09PSAwO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHVudmVyaWZpZWRTdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgdW52ZXJpZmllZERvY3VtZW50czogRG9jdW1lbnRbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWdlbnQgdGhhdCBob2xkcyB0aGUgcmVmZXJlbmNlXG5cdFx0ICogdG8gdGhpcyBQcm9ncmFtIGluc3RhbmNlLiBUaGUgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGluIHRoZVxuXHRcdCAqIGNhc2Ugd2hlbiB0aGUgaW5zdGFuY2UgaXMgbm90IGhlbGQgYnkgYW4gYWdlbnQuXG5cdFx0ICogXG5cdFx0ICogVGhpcyB2YWx1ZSBpcyBhcHBsaWVkIHRocm91Z2ggdGhlIE1pc2MucGF0Y2goKSBmdW5jdGlvbiwgd2hpY2hcblx0XHQgKiB1c2VzIGEgUHJveHkgb2JqZWN0IHRvIHByb3ZpZGUgXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaW5zdGFuY2VIb2xkZXI/OiB7XG5cdFx0XHR1cmk6IEtub3duVXJpO1xuXHRcdFx0c2NvcGU6IEF0dGFjaG1lbnRTY29wZTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3QgdGhhdCBob2xkcyBcblx0ICogdGhlIHNwZWNpZmllZCBQcm9ncmFtIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0SG9sZGVySW5mbyhwcm9ncmFtOiBQcm9ncmFtKVxuXHR7XG5cdFx0Y29uc3QgaWggPSBwcm9ncmFtLmluc3RhbmNlSG9sZGVyO1xuXHRcdFxuXHRcdHJldHVybiB7XG5cdFx0XHR1cmk6IGloID8gaWgudXJpIDogbnVsbCxcblx0XHRcdHNjb3BlOiA8QXR0YWNobWVudFNjb3BlPihpaCA/IGloLnNjb3BlIDogcHJvZ3JhbSlcblx0XHR9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXR0YWNobWVudFxuXHQgKiBvZiBhIGNhdXNlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0Y2xhc3MgQ2F1c2VBdHRhY2htZW50XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHVyaTogS25vd25VcmkgfCBudWxsLFxuXHRcdFx0cmVhZG9ubHkgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IGFueSxcblx0XHRcdHJlYWRvbmx5IHNjb3BlOiBBdHRhY2htZW50U2NvcGUpXG5cdFx0eyB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXNjcmliZXMgYSBwbGFjZSBpbiB0aGUgcHJvZ3JhbSB3aGVyZSBhIENhdXNlIGlzIGF0dGFjaGVkLlxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgQXR0YWNobWVudFNjb3BlID0gUHJvZ3JhbSB8IERvY3VtZW50IHwgVHlwZTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIGRldGFpbHMgYWJvdXQgYSBwcmVjaXNlIGxvY2F0aW9uIGluIGEgRG9jdW1lbnQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHRcblx0e1xuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgaW5zcGVjdGlvbiBwb2ludCB3aXRoaW4gYSBEb2N1bWVudC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcG9zaXRpb246IFBvc2l0aW9uLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgem9uZSBvZiB0aGUgc3RhdGVtZW50IGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHpvbmU6IFN0YXRlbWVudFpvbmUsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBjb21waWxhdGlvbiBvYmplY3QgdGhhdCBtb3N0IGNsb3NlbHkgcmVwcmVzZW50c1xuXHRcdFx0ICogd2hhdCB3YXMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi4gU3RvcmVzIG51bGwgaW4gdGhlXG5cdFx0XHQgKiBjYXNlIHdoZW4gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBjb250YWlucyBhbiBvYmplY3QgdGhhdFxuXHRcdFx0ICogaGFzIGJlZW4gbWFya2VkIGFzIGNydWZ0ICh0aGUgc3RhdGVtZW50IGFuZCBzcGFuIGZpZWxkc1xuXHRcdFx0ICogYXJlIHN0aWxsIHBvcHVsYXRlZCBpbiB0aGlzIGNhc2UpLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBmb3VuZE9iamVjdDogRG9jdW1lbnQgfCBUeXBlW10gfCBudWxsLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgU3RhdGVtZW50IGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHN0YXRlbWVudDogU3RhdGVtZW50LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgU3BhbiBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLCBvclxuXHRcdFx0ICogbnVsbCBpbiB0aGUgY2FzZSB3aGVuIG5vIFNwYW4gd2FzIGZvdW5kLCBzdWNoIGFzIGlmXG5cdFx0XHQgKiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIGlzIHdoaXRlc3BhY2Ugb3IgYSBjb21tZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzcGFuOiBTcGFuIHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZm91bmRPYmplY3QpICYmIGZvdW5kT2JqZWN0Lmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhpcy5mb3VuZE9iamVjdCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogTWFya3MgYSBzcGVjaWZpYyBsaW5lIGFuZCBvZmZzZXQgd2l0aGluIGEgVHJ1dGggZG9jdW1lbnQuXG5cdCAqL1xuXHRleHBvcnQgaW50ZXJmYWNlIFBvc2l0aW9uIFxuXHR7XG5cdFx0bGluZTogbnVtYmVyO1xuXHRcdG9mZnNldDogbnVtYmVyO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgY2FjaGUgdGhhdCBzdG9yZXMgYWdlbnQgYnVpbGQgZnVuY3Rpb24gbG9hZGVkIGJ5IGEgc2luZ2xlIHByb2dyYW0gaW5zdGFuY2UuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQWdlbnRDYWNoZVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtKVxuXHRcdHtcblx0XHRcdC8qXG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlVXJpUmVmZXJlbmNlQWRkLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnVyaS5leHQgPT09IFVyaUV4dGVuc2lvbi5qcylcblx0XHRcdFx0XHR0aGlzLmF0dGFjaEFnZW50KGRhdGEudXJpLCBkYXRhLnN0YXRlbWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVVyaVJlZmVyZW5jZVJlbW92ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZGF0YS51cmkuZXh0ID09PSBVcmlFeHRlbnNpb24uanMpXG5cdFx0XHRcdFx0dGhpcy5kZXRhY2hBZ2VudChkYXRhLnVyaSwgZGF0YS5zdGF0ZW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHQqL1xuXHRcdH1cblx0XHRcblx0XHQvKiogKiAvXG5cdFx0cHJpdmF0ZSBhc3luYyBhdHRhY2hBZ2VudCh1cmk6IEtub3duVXJpLCBzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXhpc3RpbmdDYWNoZVNldCA9IHRoaXMuY2FjaGUuZ2V0KHVyaSk7XG5cdFx0XHRjb25zdCByZWZlcmVuY2UgPSBzdGF0ZW1lbnQgfHwgdGhpcy5wcm9ncmFtO1xuXHRcdFx0XG5cdFx0XHRpZiAoZXhpc3RpbmdDYWNoZVNldClcblx0XHRcdHtcblx0XHRcdFx0ZXhpc3RpbmdDYWNoZVNldC5hZGQocmVmZXJlbmNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBzY29wZSA9IHN0YXRlbWVudCBpbnN0YW5jZW9mIFN0YXRlbWVudCA/XG5cdFx0XHRcdHN0YXRlbWVudC5kb2N1bWVudCA6XG5cdFx0XHRcdHRoaXMucHJvZ3JhbTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlUmF3ID0gYXdhaXQgVXJpUmVhZGVyLnRyeVJlYWQodXJpKTtcblx0XHRcdGlmIChzb3VyY2VSYXcgaW5zdGFuY2VvZiBFcnJvcilcblx0XHRcdFx0cmV0dXJuIHNvdXJjZVJhdztcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlID0gdGhpcy5tYXliZUFkanVzdFNvdXJjZU1hcCh1cmksIHNvdXJjZVJhdyk7XG5cdFx0XHRjb25zdCBwYXRjaGVkUHJvZ3JhbSA9IE1pc2MucGF0Y2godGhpcy5wcm9ncmFtLCB7XG5cdFx0XHRcdGluc3RhbmNlSG9sZGVyOiB7IHVyaSwgc2NvcGUgfVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhcmFtcyA9IFtcblx0XHRcdFx0XCJwcm9ncmFtXCIsXG5cdFx0XHRcdFwiVHJ1dGhcIixcblx0XHRcdFx0XCJyZXF1aXJlXCIsXG5cdFx0XHRcdC4uLnRoaXMuYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMua2V5cygpLFxuXHRcdFx0XHRzb3VyY2Vcblx0XHRcdF07XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFyZ3MgPSBbXG5cdFx0XHRcdHBhdGNoZWRQcm9ncmFtLFxuXHRcdFx0XHRUcnV0aCxcblx0XHRcdFx0QWdlbnRDYWNoZS5oaWphY2tlZFJlcXVpcmVGbixcblx0XHRcdFx0Li4udGhpcy5hZ2VudEZ1bmN0aW9uUGFyYW1ldGVycy52YWx1ZXMoKVxuXHRcdFx0XTtcblx0XHRcdFxuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGZuID0gT2JqZWN0LmZyZWV6ZShGdW5jdGlvbi5hcHBseShGdW5jdGlvbiwgcGFyYW1zKSk7XG5cdFx0XHRcdGF3YWl0IGZuLmFwcGx5KGZuLCBhcmdzIGFzIGFueSk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5yZXBvcnRVc2VyTGFuZEVycm9yKGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VBZ2VudEF0dGFjaCh1cmksIHNjb3BlKSk7XG5cdFx0XHRjb25zdCBzZXQgPSBuZXcgU2V0PFN0YXRlbWVudCB8IFByb2dyYW0+KFtyZWZlcmVuY2VdKTtcblx0XHRcdHRoaXMuY2FjaGUuc2V0KHVyaSwgc2V0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICogL1xuXHRcdHByaXZhdGUgZGV0YWNoQWdlbnQodXJpOiBLbm93blVyaSwgc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudWxsKVxuXHRcdHtcblx0XHRcdGNvbnN0IGV4aXN0aW5nQ2FjaGVTZXQgPSB0aGlzLmNhY2hlLmdldCh1cmkpO1xuXHRcdFx0aWYgKCFleGlzdGluZ0NhY2hlU2V0KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGV4aXN0aW5nQ2FjaGVTZXQuZGVsZXRlKHN0YXRlbWVudCB8fCB0aGlzLnByb2dyYW0pO1xuXHRcdFx0aWYgKGV4aXN0aW5nQ2FjaGVTZXQuc2l6ZSA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jYWNoZS5kZWxldGUodXJpKTtcblx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZUFnZW50RGV0YWNoKHVyaSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiAoQ2FsbGVkIGJ5IFByb2dyYW0pXG5cdFx0ICovXG5cdFx0YXVnbWVudChuYW1lOiBzdHJpbmcsIHZhbHVlOiBvYmplY3QpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMuaGFzKG5hbWUpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uY2F1c2VQYXJhbWV0ZXJOYW1lSW5Vc2UobmFtZSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMuc2V0KFxuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHR2YWx1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkanVzdHMgdGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZW1hcCBpbiB0aGUgc3BlY2lmaWVkIHNvdXJjZSBjb2RlIFxuXHRcdCAqIGZpbGUsIHRvIGFjY291bnQgZm9yIHRoZSBkaXNjcmVwZW5jaWVzIGludHJvZHVjZWQgYnkgd3JhcHBpbmcgSmF2YVNjcmlwdFxuXHRcdCAqIHNvdXJjZSBjb2RlIGluIGEgbmV3IEZ1bmN0aW9uKCkgY29uc3RydWN0b3IuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBtYXliZUFkanVzdFNvdXJjZU1hcChzb3VyY2VVcmk6IEtub3duVXJpLCBzb3VyY2VDb2RlOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZG8gYW55IG9mIHRoaXMgc291cmNlIG1hcCBtdXRhdGlvbiB3aXRob3V0IE5vZGUuSlNcblx0XHRcdC8vIGFjY2VzcyByaWdodCBub3cuIE1heWJlIHRoaXMgd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblx0XHRcdGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbGFzdExpbmVTdGFydCA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCBpID0gc291cmNlQ29kZS5sZW5ndGg7IGktLSA+IDE7KVxuXHRcdFx0XHRcdGlmIChzb3VyY2VDb2RlW2kgLSAxXSA9PT0gXCJcXG5cIilcblx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGxhc3RMaW5lU3RhcnQgPCAwKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlTWFwVXJsID0gW1wiLy9cIiwgXCIjXCIsIFwiIHNvdXJjZVwiLCBcIk1hcHBpbmdVUkw9XCJdLmpvaW4oXCJcIik7XG5cdFx0XHRpZiAoc291cmNlQ29kZS5zdWJzdHIobGFzdExpbmVTdGFydCwgc291cmNlTWFwVXJsLmxlbmd0aCkgIT09IHNvdXJjZU1hcFVybClcblx0XHRcdFx0cmV0dXJuIHNvdXJjZUNvZGU7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0YXJ0UG9zID0gbGFzdExpbmVTdGFydCArIHNvdXJjZU1hcFVybC5sZW5ndGg7XG5cdFx0XHRjb25zdCBlbmRpbmcgPSBcIjtiYXNlNjQsXCI7XG5cdFx0XHRjb25zdCBlbmRQb3MgPSBzb3VyY2VDb2RlLmluZGV4T2YoZW5kaW5nLCBzdGFydFBvcykgKyBlbmRpbmcubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHQvLyBVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGZvcm1hdC5cblx0XHRcdGlmIChlbmRQb3MgPCBlbmRpbmcubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlTWFwUmF3ID0gdGhpcy5mcm9tQmFzZTY0KHNvdXJjZUNvZGUuc2xpY2UoZW5kUG9zKSk7XG5cdFx0XHRcblx0XHRcdC8vIFRoZXJlJ3MgcHJvYmFibHkgc29tZSBlcnJvciBpbiB0aGUgc291cmNlIG1hcFxuXHRcdFx0aWYgKCFzb3VyY2VNYXBSYXcpXG5cdFx0XHRcdHJldHVybiBzb3VyY2VDb2RlO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgc291cmNlIG1hcCBpc24ndCBwYXJzaW5nIGFzIGEgSlNPTiBvYmplY3QgLi4uIHByb2JhYmx5IGJyb2tlbiBzb21laG93XG5cdFx0XHRjb25zdCBzb3VyY2VNYXA6IElTb3VyY2VNYXAgPSBNaXNjLnRyeVBhcnNlSnNvbihzb3VyY2VNYXBSYXcpO1xuXHRcdFx0aWYgKCFzb3VyY2VNYXApXG5cdFx0XHRcdHJldHVybiBzb3VyY2VDb2RlO1xuXHRcdFx0XG5cdFx0XHQvLyBVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIHZlcnNpb25cblx0XHRcdGlmICh0eXBlb2Ygc291cmNlTWFwLm1hcHBpbmdzICE9PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Ly8gUGxhY2luZyBhIDsgaW4gdGhlIFwibWFwcGluZ3NcIiBwcm9wZXJ0eSBvZiB0aGUgc291cmNlIG1hcCBvYmplY3Rcblx0XHRcdC8vIHNoaWZ0cyB0aGUgbGluZXMgZG93biBieSAxLiBJdCBuZWVkcyB0byBiZSArIDEsIGJlY2F1c2Ugd2Ugd3JhcFxuXHRcdFx0Ly8gdGhlIGNvZGUgaW4gb3VyIG93biBzZXRUaW1lb3V0KCkgYmxvY2suXG5cdFx0XHRjb25zdCBwcmVmaXggPSBcIjtcIi5yZXBlYXQodGhpcy5zb3VyY2VNYXBMaW5lT2Zmc2V0ICsgMSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhdGhNb2R1bGUgPSByZXF1aXJlKFwicGF0aFwiKSBhcyB0eXBlb2YgaW1wb3J0KFwicGF0aFwiKTtcblx0XHRcdFxuXHRcdFx0Ly8gU2hvdWxkIGFjdHVhbGx5IGJlIC50b1N0cmluZygpIHdpdGhvdXQgYSBmaWxlLlxuXHRcdFx0ZGVidWdnZXI7XG5cdFx0XHRjb25zdCBiYXNlUGF0aCA9IHNvdXJjZVVyaS50b1N0cmluZygpO1xuXHRcdFx0c291cmNlTWFwLm1hcHBpbmdzID0gcHJlZml4ICsgc291cmNlTWFwLm1hcHBpbmdzO1xuXHRcdFx0XG5cdFx0XHRpZiAoc291cmNlTWFwLnNvdXJjZXMgaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0c291cmNlTWFwLnNvdXJjZXMgPSBzb3VyY2VNYXAuc291cmNlcy5tYXAocyA9PiBcblx0XHRcdFx0XHRwYXRoTW9kdWxlLmpvaW4oYmFzZVBhdGgsIHMpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbmV3U291cmNlTWFwID0gdGhpcy50b0Jhc2U2NChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKTtcblx0XHRcdGNvbnN0IG5ld1NvdXJjZUNvZGUgPSBzb3VyY2VDb2RlLnNsaWNlKDAsIGxhc3RMaW5lU3RhcnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgc291cmNlIGNvZGUgaXMgd3JhcHBlZCBpbiBhIHNldFRpbWVvdXQgaW4gb3JkZXJcblx0XHRcdC8vIHRvIGdpdmUgYW55IGF0dGFjaGVkIGRlYnVnZ2VycyBhIGNoYW5jZSB0byBjb25uZWN0LlxuXHRcdFx0Y29uc3QgdmFyTmFtZSA9IFwiJCRfX1JFU09MVkVfRlVOQ1RJT05fXyQkXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG5ld1NvdXJjZUNvZGVEZWxheWVkID0gXG5cdFx0XHRcdGByZXR1cm4gbmV3IFByb21pc2UoJHt2YXJOYW1lfSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcXG5gICsgXG5cdFx0XHRcdG5ld1NvdXJjZUNvZGUgKyBcblx0XHRcdFx0YDsgJHt2YXJOYW1lfSgpOyB9LCAxKSlcXG5gO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBuZXdQcmVmaXggPSBzb3VyY2VDb2RlLnNsaWNlKGxhc3RMaW5lU3RhcnQsIGVuZFBvcyk7XG5cdFx0XHRyZXR1cm4gbmV3U291cmNlQ29kZURlbGF5ZWQgKyBuZXdQcmVmaXggKyBuZXdTb3VyY2VNYXA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVwb3J0VXNlckxhbmRFcnJvcihlOiBFcnJvcilcblx0XHR7XG5cdFx0XHQvLyBOT1RFOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSByZXBvcnRpbmcgdGhlIGVycm9yXG5cdFx0XHQvLyBzb21ld2hlcmUgd2hlcmUgaXQncyB2aXNpYmxlLlxuXHRcdFx0ZGVidWdnZXI7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHRvQmFzZTY0KHBsYWluOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0XHRidG9hKHBsYWluKSA6XG5cdFx0XHRcdEJ1ZmZlci5mcm9tKHBsYWluLCBcImFzY2lpXCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGZyb21CYXNlNjQoZW5jb2RlZDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0eXBlb2YgYXRvYiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdFx0YXRvYihlbmNvZGVkKSA6XG5cdFx0XHRcdEJ1ZmZlci5mcm9tKGVuY29kZWQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYXNjaWlcIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXF1aXJlKCkgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYW5cblx0XHQgKiBhZ2VudCBmb3IgbnVtZXJvdXMgKGFuZCBub24tb2J2aW91cykgcmVhc29ucy4gVGhpcyBmdW5jdGlvblxuXHRcdCAqIGlzIGZlZCBpbnRvIGFsbCBhZ2VudCBmdW5jdGlvbnMgdG8gcHJldmVudCBhbnkgb3RoZXJ3aXNlIGF2YWlsYWJsZVxuXHRcdCAqIHJlcXVpcmUoKSBmdW5jdGlvbiBmcm9tIGJlaW5nIGFjY2Vzc2VkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGhpamFja2VkUmVxdWlyZUZuID0gT2JqZWN0LmZyZWV6ZSgoc3BlY2lmaWVyOiBzdHJpbmcpID0+XG5cdFx0e1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcIlRoZSByZXF1aXJlKCkgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGNvbnRleHQuIFwiICtcblx0XHRcdFx0XCJNdWx0aS1maWxlIGFnZW50cyBzaG91bGQgYmUgYnVuZGxlZCB3aXRoIGEgYnVuZGxlciBcIiArIFxuXHRcdFx0XHRcInN1Y2ggYXMgUm9sbHVwSlMuXCIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbnVtYmVyIG9mIGxpbmVzIHRoYXQgYXJlIGludHJvZHVjZWQgYnkgdGhlIHNjcmlwdFxuXHRcdCAqIGVuZ2luZSB3aGVuIGEgY29kZSBibG9jayBpcyB3cmFwcGVkIGluIGEgbmV3IEZ1bmN0aW9uKClcblx0XHQgKiBibG9jaywgd2hpY2ggaXMgdGhlbiB0b1N0cmluZygpJ2QuIFRoaXMgaXMgdXNlZCBpbiBvcmRlciB0byBjYWxjdWxhdGVcblx0XHQgKiBzb3VyY2UgbWFwIGxpbmUgb2Zmc2V0cyAod2hpY2ggdmFyaWVzIGJ5IGVuZ2luZSkuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzb3VyY2VNYXBMaW5lT2Zmc2V0ID0gKCgpID0+XG5cdFx0e1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cdFx0XHRjb25zdCB0ZXN0Rm4gPSBuZXcgRnVuY3Rpb24oXCJhXCIsIFwiYlwiLCBcImNcIiwgXCI7XCIpO1xuXHRcdFx0Y29uc3QgbGluZUNvdW50ID0gdGVzdEZuLnRvU3RyaW5nKCkuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIGxpbmVDb3VudCAtIDI7IFxuXHRcdH0pKCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIHdob3NlIGtleXMgYXJlIGFnZW50IFVSSXMsIGFuZCB3aG9zZSB2YWx1ZXNcblx0XHQgKiBhcmUgYSBzZXQgb2YgU3RhdGVtZW50IGluc3RhbmNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgYWdlbnQsXG5cdFx0ICogb3IsIGluIHRoZSBjYXNlIHdoZW4gdGhlIGFnZW50IGlzIGFkZGVkIHRvIHRoZSBwcm9ncmFtXG5cdFx0ICogdGhyb3VnaCBhbm90aGVyIG1lYW5zIChzdWNoIGFzIHByb2dyYW1tYXRpY2FsbHkpLFxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBwcm9ncmFtIGlzIHN0b3JlZCBpbnN0ZWFkLlxuXHRcdCAqIFxuXHRcdCAqIFRlY2huaWNhbGx5IGFuIGFnZW50IHNob3VsZCBiZSBhdHRhY2hlZCBpbiBvbmx5IG9uZSBwbGFjZVxuXHRcdCAqIGluIHRoZSBwcm9ncmFtLCBob3dldmVyLCB0aGlzIG1heSBub3QgYWx3YXlzIGJlIHRoZSBjYXNlLFxuXHRcdCAqIGFuZCB0aGUgc3lzdGVtIG5lZWRzIHRvIGJlIGFibGUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW5cblx0XHQgKiBpdCBpc24ndC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGFycmF5IGlzIHVzZWQgdG8gcmVmZXJlbmNlIGNvdW50IC8gZ2FyYmFnZSBjb2xsZWN0XG5cdFx0ICogdGhlIGF0dGFjaGVkIGFnZW50cy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGNhY2hlID0gbmV3IE1hcDxLbm93blVyaSwgU2V0PFN0YXRlbWVudCB8IFByb2dyYW0+PigpO1xuXHR9XG5cdFxuXHRkZWNsYXJlIGZ1bmN0aW9uIGF0b2IoaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcblx0ZGVjbGFyZSBmdW5jdGlvbiBidG9hKGlucHV0OiBzdHJpbmcpOiBzdHJpbmc7XG5cdFxuXHQvKipcblx0ICogQSBzaW1wbGUgdHlwZSBkZWZpbml0aW9uIGZvciBhIFYzIHNvdXJjZSBtYXAgb2JqZWN0LlxuXHQgKi9cblx0aW50ZXJmYWNlIElTb3VyY2VNYXBcblx0e1xuXHRcdHZlcnNpb246IDM7XG5cdFx0ZmlsZT86IHN0cmluZztcblx0XHRzb3VyY2VSb290Pzogc3RyaW5nO1xuXHRcdHNvdXJjZXM/OiBzdHJpbmdbXTtcblx0XHRuYW1lcz86IHN0cmluZ1tdO1xuXHRcdG1hcHBpbmdzOiBzdHJpbmc7XG5cdFx0c291cmNlc0NvbnRlbnQ/OiBzdHJpbmdbXTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBDYXVzZXMgZGVmaW5lZCBib3RoIHdpdGhpblxuXHQgKiB0aGUgY29tcGlsZXIgY29yZSwgYW5kIGluIHVzZXIgY29kZS5cblx0ICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYXVzZTxSID0gdm9pZD5cblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIENhdXNlLCBpZiBhbnkuIEluIGEgY2F1c2UgY2FsbGJhY2sgZnVuY3Rpb24sXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSBleGlzdHMgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiByZXR1cm5lZFxuXHRcdCAqIGZyb20gb3RoZXIgY2F1c2UgYWlkcy5cblx0XHQgKi9cblx0XHRyZWFkb25seSByZXR1cm5zOiBSID0gbnVsbCE7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgKlJlc3VsdCogdHlwZSBwYXJhbWV0ZXIgb2YgYSBDYXVzZS5cblx0ICovXG5cdGV4cG9ydCB0eXBlIFRDYXVzZVJldHVybjxUPiA9IFQgZXh0ZW5kcyB7IHJldHVybnM6IGluZmVyIFIgfSA/IFIgOiBuZXZlcjtcblx0XG5cdC8qKlxuXHQgKiBNYXBzIGEgQ2F1c2UgdHlwZSBvdmVyIHRvIGl0J3MgY29ycmVzcG9uZGluZyBvYmplY3Rcblx0ICogdGhhdCBpcyBmZWQgaW50byBhbGwgY2F1c2UgY2FsbGJhY2sgZnVuY3Rpb25zLlxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgVENhdXNlRGF0YTxUPiA9IHtcblx0XHRbUCBpbiBrZXlvZiBUXTogUCBleHRlbmRzIFwicmV0dXJuc1wiID9cblx0XHRcdHJlYWRvbmx5IFRbUF1bXSA6IFxuXHRcdFx0VFtQXTtcblx0fTtcblx0XG5cdC8vIFxuXHQvLyBDYXVzZXNcblx0Ly8gXG5cdFxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlQWdlbnRBdHRhY2ggZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgVVJJIGZyb20gd2hlcmUgdGhlIGFnZW50IHdhcyBsb2FkZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHVyaTogS25vd25VcmksXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBzY29wZSBvZiB3aGVyZSB0aGUgYWdlbnRcblx0XHRcdCAqIGFwcGxpZXMuXG5cdFx0XHQgKiBcblx0XHRcdCAqIElmIHRoZSB2YWx1ZSBpcyBgaW5zdGFuY2VvZiBQcm9ncmFtYCwgdGhpcyBpbmRpY2F0ZXMgdGhhdFxuXHRcdFx0ICogdGhlIGFnZW50J3MgY2F1c2VzIGFyZSBzY29wZWQgdG8gYSBwYXJ0aWN1bGFyIHByb2dyYW0gKHdoaWNoXG5cdFx0XHQgKiBpcyBlZmZlY3RpdmVseSBcInVuc2NvcGVkXCIpLlxuXHRcdFx0ICogXG5cdFx0XHQgKiBJZiB0aGUgdmFsdWUgaXMgYGluc3RhbmNlb2YgRG9jdW1lbnRgLCB0aGlzIGluZGljYXRlcyB0aGF0XG5cdFx0XHQgKiB0aGUgYWdlbnQncyBjYXVzZXMgYXJlIHNjb3BlZCB0byB0aGUgY2F1c2VzIHRoYXQgY2FuXG5cdFx0XHQgKiBvcmlnaW5hdGUgZnJvbSBhIHNpbmdsZSBkb2N1bWVudC5cblx0XHRcdCAqIFxuXHRcdFx0ICogKE5vdCBpbXBsZW1lbnRlZCkuIElmIHRoZSB2YWx1ZSBpcyBgaW5zdGFuY2VvZiBUeXBlYCwgdGhpcyBcblx0XHRcdCAqIGluZGljYXRlcyB0aGF0IHRoZSBhZ2VudCdzIGNhdXNlcyBhcmUgc2NvcGVkIHRvIHRoZSBjYXVzZXNcblx0XHRcdCAqIHRoYXQgY2FuIG9yaWdpbmF0ZSBmcm9tIGEgc2luZ2xlIHR5cGUuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHNjb3BlOiBQcm9ncmFtIHwgRG9jdW1lbnQgfCBUeXBlKVxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG5cdFxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlQWdlbnREZXRhY2ggZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgdXJpOiBLbm93blVyaSkgeyBzdXBlcigpOyB9XG5cdH1cblx0XG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyBpbW1lZGlhdGVseSBhZnRlciBhIGRvY3VtZW50IGhhcyBiZWVuIGNyZWF0ZWQuICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZURvY3VtZW50Q3JlYXRlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHJlYWRvbmx5IGRvY3VtZW50OiBEb2N1bWVudCkgeyBzdXBlcigpOyB9XG5cdH1cblx0XG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyBpbW1lZGlhdGVseSBiZWZvcmUgYSBkb2N1bWVudCBpcyByZW1vdmVkIGZyb20gdGhlIHByb2dyYW0uICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZURvY3VtZW50RGVsZXRlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHJlYWRvbmx5IGRvY3VtZW50OiBEb2N1bWVudCkgeyBzdXBlcigpOyB9XG5cdH1cblx0XG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyB3aGVuIGEgZG9jdW1lbnQncyBmaWxlIG5hbWUgY2hhbmdlcy4gKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlRG9jdW1lbnRVcmlDaGFuZ2UgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXG5cdFx0XHRyZWFkb25seSBuZXdVcmk6IEtub3duVXJpKVxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG5cdFxuXHQvKiogQWJzdHJhY3QgY2F1c2UgY2xhc3MgZm9yIHRoZSByZXNvbHV0aW9uIGNhdXNlcyAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2F1c2VSZXNvbHZlIGV4dGVuZHMgQ2F1c2U8SVJlc29sdXRpb25SZXR1cm4+XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0sXG5cdFx0XHRyZWFkb25seSBzcGluZTogU3BpbmUpXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cblx0XG5cdC8qKiBPdXRwdXQgZm9yIHJlc29sdXRpb24gaG9va3MgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJUmVzb2x1dGlvblJldHVyblxuXHR7XG5cdFx0cmVhZG9ubHkgcmVzb2x2ZXM6IGJvb2xlYW47XG5cdH1cblx0XG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyBiZWZvcmUgdGhlIGNvbXBpbGVyIGlzIGFib3V0IHRvIHJlc29sdmUgYSB0ZXJtLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VCZWZvcmVSZXNvbHZlIGV4dGVuZHMgQ2F1c2VSZXNvbHZlIHsgfVxuXHRcblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIGFmdGVyIHRoZSBjb21waWxlciBoYXMgcmVzb2x2ZWQgYSB0ZXJtLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VBZnRlclJlc29sdmUgZXh0ZW5kcyBDYXVzZVJlc29sdmUgeyB9XG5cdFxuXHQvKiogQSBjYXVzZSB0aGF0IHJ1bnMgd2hlbiB0aGUgY29tcGlsZXIgaXMgdW5hYmxlIHRvIHJlc29sdmUgYSB0ZXJtLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VOb3RSZXNvbHZlZCBleHRlbmRzIENhdXNlUmVzb2x2ZSB7IH1cblx0XG5cdC8qKiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VJbnZhbGlkYXRlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnQgb2JqZWN0IGluIHdoaWNoIHRoZSBJbnZhbGlkYXRpb24gb2NjdXJlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHdob3NlIGRlc2NlbmRhbnRzIHNob3VsZCBiZSBpbnZhbGlkYXRlZC5cblx0XHRcdCAqIElmIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlIGVudGlyZSBkb2N1bWVudCBzaG91bGQgYmUgaW52YWxpZGF0ZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHBhcmVudHM6IHJlYWRvbmx5IFN0YXRlbWVudFtdLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBhcnJheSBvZiBpbmRleGVzIHdob3NlIGxlbmd0aCBpcyB0aGUgc2FtZSBhcyB0aGUgcGFyZW50cyBmaWVsZCxcblx0XHRcdCAqIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgZWFjaCBwYXJlbnQgd2l0aGluIHRoZSBkb2N1bWVudC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgaW5kZXhlczogcmVhZG9ubHkgbnVtYmVyW10pXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cblx0XG5cdC8qKiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VSZXZhbGlkYXRlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnQgb2JqZWN0IGluIHdoaWNoIHRoZSBSZXZhbGlkYXRpb24gd2lsbCBvY2N1ci5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHdob3NlIGRlc2NlbmRhbnRzIHNob3VsZCBiZSByZXZhbGlkYXRlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcGFyZW50czogcmVhZG9ubHkgU3RhdGVtZW50W10sXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGFycmF5IG9mIGluZGV4ZXMgd2hvc2UgbGVuZ3RoIGlzIHRoZSBzYW1lIGFzIHRoZSBwYXJlbnRzIGZpZWxkLFxuXHRcdFx0ICogdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiBlYWNoIHBhcmVudCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBpbmRleGVzOiByZWFkb25seSBudW1iZXJbXSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXHRcblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIHdoZW4gYSBkb2N1bWVudCBlZGl0IHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUVkaXRDb21wbGV0ZSBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3RvcihyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQpIHsgc3VwZXIoKTsgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogQSBob29rIHRoYXQgcnVucyB3aGVuIHRoZSBzZXQgb2YgZmF1bHRzIHRoYXQgYXJlIGRldGVjdGVkXG5cdCAqIHdpdGhpbiB0aGUgZG9jdW1lbnQgaGF2ZSBjaGFuZ2VkLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlRmF1bHRDaGFuZ2UgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBmYXVsdHNBZGRlZDogRmF1bHRbXSxcblx0XHRcdHJlYWRvbmx5IGZhdWx0c1JlbW92ZWQ6IEZhdWx0W10pXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKiBAaW50ZXJuYWwgKi9cblx0ZXhwb3J0IGNsYXNzIEV4Y2VwdGlvblxuXHR7XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG9iamVjdERpcnR5KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgY2FsbCB0aGlzIG1ldGhvZCBvciBhY2Nlc3MgdGhpcyBwcm9wZXJ0eSxcblx0XHRcdFx0YmVjYXVzZSB0aGUgZG9jdW1lbnQgaGFzIGNoYW5nZWQgc2luY2UgaXRcblx0XHRcdFx0d2FzIGNyZWF0ZWQuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkQXJndW1lbnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkludmFsaWQgYXJndW1lbnQuXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgcGFzc2VkQXJyYXlDYW5ub3RCZUVtcHR5KHBhcmFtTmFtZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkFycmF5IGNhbm5vdCBiZSBlbXB0eSBmb3IgcGFyYW1ldGVyOiBcIiArIHBhcmFtTmFtZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyB1bmtub3duU3RhdGUoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkFuIHVua25vd24gc3RhdGUgaGFzIGJlZW4gcmVhY2hlZCBpbiB0aGUgcHJvZ3JhbS5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkQ2FsbCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiQ2Fubm90IGNhbGwgdGhpcyBtZXRob2QgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHByb2dyYW0uXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgbm90SW1wbGVtZW50ZWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBhZ2VudE5vdFJlYWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdENhbm5vdCBpbnN0YW50aWF0ZSBhbiBhZ2VudCBvZiB0aGlzIHR5cGUsXG5cdFx0XHRcdGFkZGVkLiBTZWUgYWdlbnRzLmFkZC5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGFnZW50TWlzc2luZyhyYXdVcmk6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYENvdWxkIG5vdCBsb2FkIGFuIGFnZW50IGZyb20gdGhlIFVSSSAke3Jhd1VyaX1gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGFnZW50SW1wb3J0RXJyb3IoYWdlbnRVcmk6IHN0cmluZywgZXJyb3JUZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0QW4gZXJyb3Igb2NjdXJlZCB3aGlsZSB0cnlpbmcgdG8gZXZhbHVhdGUgdGhlIGFnZW50IGF0IFwiJHthZ2VudFVyaX1cIi5cblx0XHRcdFx0VGhlIGVycm9yIG1lc3NhZ2UgcmV0dXJuZWQgd2FzOiAke2Vycm9yVGV4dH1gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGFnZW50SW52YWxpZChyYXdVcmk6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRUaGUgY29kZSBmaWxlIGF0ICR7cmF3VXJpfSBkb2VzIG5vdCBleHBvcnQgYSBmdW5jdGlvbi4gQ29uc2lkZXIgbG9va2luZ1xuXHRcdFx0XHRhdCB0aGUgZG9jdW1lbnRpb24gYW5kIGV4YW1wbGVzIGZvciB0aGUgcHJvcGVyIHdheSB0byBzdHVjdHVyZSBhblxuXHRcdFx0XHRhZ2VudCBjb2RlIGZpbGUuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBub1JlbW90ZUFnZW50cygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0QWdlbnRzIGNhbm5vdCBiZSBsb2FkZWQgZnJvbSByZW1vdGUgVVJJcyBpbiB0aGlzIGNvbnRleHQuXG5cdFx0XHRcdChNb3N0IGxpa2VseSwgdGhpcyBjb2RlIGlzIHJ1bm5pbmcgaW4gTm9kZS5qcyB3aGVyZSB0aGUgbG9hZGluZ1xuXHRcdFx0XHRvZiByZW1vdGUgY29kZSBpcyBhIHNlY3VyaXR5IHJpc2spLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgY2F1c2VQYXJhbWV0ZXJOYW1lSW5Vc2UocGFyYW1OYW1lOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0Q2Fubm90IHVzZSB0aGUgbmFtZSBcIiR7cGFyYW1OYW1lfVwiIGFzIGEgcGFyYW1ldGVyXG5cdFx0XHRcdG5hbWUgYmVjYXVzZSBpdCdzIGFscmVhZHkgaW4gdXNlLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgZG91YmxlVHJhbnNhY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkNhbm5vdCBzdGFydCBhIG5ldyB0cmFuc2FjdGlvbiB3aGlsZSBhbm90aGVyIGlzIGV4ZWN1dGluZy5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkVXJpUmV0cmFjdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiVVJJIGNvbnRhaW5zIHRvbyBmZXcgcGF0aCBzZWdtZW50cyB0byBwZXJmb3JtIHRoaXMgcmV0cmFjdGlvbi5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkVXJpKHJhd1VyaT86IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJJbnZhbGlkIFVSSVwiICsgKHR5cGVvZiByYXdVcmkgPT09IFwic3RyaW5nXCIgPyBcIjogXCIgKyByYXdVcmkgOiBcIlwiKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyB1cmlOb3RTdXBwb3J0ZWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIlVSSXMgb2YgdGhpcyB0eXBlIGFyZSBub3Qgc3VwcG9ydGVkLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGNhbm5vdE1ha2VBYnNvbHV0ZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0Q2Fubm90IG1ha2UgdGhpcyBVUkkgYWJzb2x1dGUgYmVjYXVzZSBubyBcblx0XHRcdFx0cHJvY2VzcyBvciB3aW5kb3cgb2JqZWN0IGNvdWxkIGJlIGZvdW5kYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBhYnNvbHV0ZVVyaUV4cGVjdGVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFRoaXMgbWV0aG9kIGV4cGVjdHMgYW4gYWJzb2x1dGUgVVJJIHRvIGJlIHNwZWNpZmllZC5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG11c3RTcGVjaWZ5VmlhKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRNdXN0IHNwZWNpZnkgdGhlIFwidmlhXCIgYXJndW1lbnQgYmVjYXVzZSB0aGUgcGFyc2VkIFVSSSBcblx0XHRcdFx0d2FzIGZvdW5kIHRvIGJlIHJlbGF0aXZlYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyB2aWFDYW5ub3RCZVJlbGF0aXZlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFVSSSBpbnN0YW5jZXMgc3BlY2lmaWVkIGluIHRoZSBcInZpYVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIHJlbGF0aXZlYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkVHlwZVBhdGgoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdE9uZSBvciBtb3JlIG9mIHRoZSB0eXBlcyBpbiB0aGUgc3BlY2lmaWVkIHR5cGUgcGF0aCBhcmUgaW52YWxpZCxcblx0XHRcdFx0YmVjYXVzZSB0aGV5IGNvbnRhaW4gZWl0aGVyIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSwgb3Jcblx0XHRcdFx0aXMgYW4gZW1wdHkgc3RyaW5nLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZEV4dGVuc2lvbihyZXF1aXJlZEV4dGVuc2lvbjogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdFRoaXMgbWV0aG9kIHJlcXVpcmVzIFVSSXMgdGhhdCBoYXZlIHRoZSBcblx0XHRcdFx0XCIuJHtyZXF1aXJlZEV4dGVuc2lvbn1cIiBleHRlbnNpb24uYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkRG9jdW1lbnRSZWZlcmVuY2UoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdFRoaXMgZG9jdW1lbnQgY2Fubm90IGJlIGFkZGVkIGFzIGEgZGVwZW5kZW5jeVxuXHRcdFx0XHRvZiB0aGUgdGFyZ2V0IGRvY3VtZW50IGJlY2F1c2UgaXQncyBzdG9yYWdlIGxvY2F0aW9uXG5cdFx0XHRcdChtZW1vcnkgb3IgZGlzaykgZGlmZmVycyBmcm9tIHRoZSB0aGF0IG9mIHRoZSB0YXJnZXQuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyB1cmlBbHJlYWR5RXhpc3RzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgYXNzaWduIHRoaXMgVVJJIHRvIHRoaXMgZG9jdW1lbnQsIGJlY2F1c2Vcblx0XHRcdFx0YW5vdGhlciBkb2N1bWVudCBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgcHJvZ3JhbVxuXHRcdFx0XHR3aXRoIHRoZSBVcmkgc3BlY2lmaWVkLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgdXJpUHJvdG9jb2xzTXVzdE1hdGNoKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgYXNzaWduIHRoaXMgVVJJIHRvIHRoaXMgZG9jdW1lbnQsIGJlY2F1c2Vcblx0XHRcdFx0aXQncyBwcm90b2NvbCBkaWZmZXJzIGZyb20gdGhlIFVSSSBjdXJyZW50IGFzc2lnbmVkIFxuXHRcdFx0XHR0byB0aGlzIGRvY3VtZW50YCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBub25FbXB0eURvY3VtZW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJDYW5ub3QgY2FsbCB0aGlzIG1ldGhvZCBvbiBhIG5vbi1lbXB0eSBkb2N1bWVudC5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkV2hpbGVJbkVkaXRUcmFuc2FjdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFxuXHRcdFx0XHRgQ2Fubm90IGNhbGwgdGhpcyBtZXRob2QsIG9yIHJ1biB0aGlzIGhvb2sgd2hpbGUgYW4gZWRpdFxuXHRcdFx0XHR0cmFuc2FjdGlvbiBpcyB1bmRlcndheS5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHVuY2FjaGFibGVEb2N1bWVudCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0Q2Fubm90IGNhY2hlIHRoaXMgZG9jdW1lbnQgYmVjYXVzZSBpdCB3YXMgbm90IGxvYWRlZCBmcm9tIGEgZmlsZS5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGRvY3VtZW50QWxyZWFkeUxvYWRlZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0QSBkb2N1bWVudCB3aXRoIHRoaXMgVVJJIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5cblx0XHRcdFx0VXNlIERvY3VtZW50LmZyb21VcmkoKSBpbnN0ZWFkLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgZG9jdW1lbnROb3RMb2FkZWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIlRoaXMgZG9jdW1lbnQgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIHRoZSBjdXJyZW50IHByb2dyYW0uXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgc3RhdGVtZW50Tm90SW5Eb2N1bWVudCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiVGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aGluIHRoaXMgZG9jdW1lbnQuXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgY2Fubm90UmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0VGhpcyByZXNvdXJjZSBjYW5ub3QgYmUgcmVsb2FkZWQgYmVjYXVzZSBpdCBvbmx5IGV4aXN0cyBpbiBtZW1vcnkuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBvZmZzZXRSZXF1aXJlZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0T2Zmc2V0IGFyZ3VtZW50IGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlIGEgd2hpdGVzcGFjZS1vbmx5XG5cdFx0XHRcdHN0YXRlbWVudCB3YXMgcGFzc2VkLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgdW5zdXBwb3J0ZWRQbGF0Zm9ybSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiVGhpcyBjb2RlIGFwcGVhcnMgdG8gYmUgb3BlcmF0aW5nIGluIGFuIHVuc3VwcG9ydGVkIHBsYXRmb3JtLlwiKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBwcm9wZXIgZXJyb3Igb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IobXNnOiBzdHJpbmcpXG5cdHtcblx0XHRyZXR1cm4gbmV3IEVycm9yKG1zZy50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBsaXN0cyBhbGwgYXZhaWxibGUgcHJvdG9jb2xzXG5cdCAqIHN1cHBvcnRlZCBieSB0aGUgc3lzdGVtLiBUaGUgbGlzdCBjYW4gYmUgZW51bWVyYXRlZFxuXHQgKiB2aWEgVXJpLmVhY2hQcm90b2NvbCgpXG5cdCAqL1xuXHRleHBvcnQgZW51bSBVcmlQcm90b2NvbFxuXHR7XG5cdFx0bm9uZSA9IFwiXCIsXG5cdFx0dW5rbm93biA9IFwiP1wiLFxuXHRcdGZpbGUgPSBcImZpbGU6XCIsXG5cdFx0aHR0cHMgPSBcImh0dHBzOlwiLFxuXHRcdGh0dHAgPSBcImh0dHA6XCIsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW50ZXJuYWwgVVJJcyAod2hpY2ggYXJlIFVSSXMgdGhhdCByZWZlciB0byBhbiBpbi1tZW1vcnkgZG9jdW1lbnQpXG5cdFx0ICogYXJlIHNvdXJjZWQgZnJvbSB0aGUgZ29waGVyIHByb3RvY29sLiBZZXMsIHRoZSBnb3BoZXIgcHJvdG9jb2wuIFRoaXNcblx0XHQgKiBpcyBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgcHJvdG9jb2wgdGhhdCB3aWxsIHBhcnNlIHRocm91Z2ggdGhlIHN0YW5kYXJkXG5cdFx0ICogVVJMIGNvbnN0cnVjdG9yIGluIFY4LCBvdGhlciB0aGFuIHRoZSBzdGFuZGFyZCBwcm90b2NvbHMgKGh0dHAsIGh0dHBzKS5cblx0XHQgKiAoT3RoZXIgSmF2YVNjcmlwdCBlbmdpbmVzIHNlZW0gdG8gcGFyc2UgYWxsIHByb3RvY29scywgZXZlbiBtYWRlLXVwIFxuXHRcdCAqIG9uZXMpLlxuXHRcdCAqL1xuXHRcdG1lbW9yeSA9IFwibWVtb3J5OlwiXG5cdH1cblx0XG5cdGV4cG9ydCBuYW1lc3BhY2UgVXJpUHJvdG9jb2xcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgVXJpUHJvdG9jb2wgbWVtYmVyIGZyb20gdGhlIHNwZWNpZmllZCBzdHJpbmcuXG5cdFx0ICovXG5cdFx0ZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IFVyaVByb3RvY29sIHwgbnVsbFxuXHRcdHtcblx0XHRcdGNvbnN0IHZhbHMgPSBPYmplY3QudmFsdWVzKFVyaVByb3RvY29sKSBhcyBzdHJpbmdbXTtcblx0XHRcdGNvbnN0IGlkeCA9IHZhbHMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gaWR4IDwgMCA/IG51bGwgOiB2YWxzW2lkeF0gYXMgVXJpUHJvdG9jb2w7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQW4gaW50ZXJmYWNlIGZvciBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBVUkktcmVhZGluZyBmdW5jdGlvbmFsaXR5LlxuXHQgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJVXJpUmVhZGVyXG5cdHtcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byByZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gVVJJLlxuXHRcdCAqIElmIGFuIGVycm9yIGlzIGdlbmVyYXRlZCB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhIGZpbGUgXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiwgdGhlIGVycm9ycyBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHR0cnlSZWFkKHVyaTogS25vd25VcmkpOiBQcm9taXNlPHN0cmluZyB8IEVycm9yPjtcblx0fVxuXHRcblx0LyoqIEBpbnRlcm5hbCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFVyaVJlYWRlcigpOiBJVXJpUmVhZGVyXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHJ5UmVhZDogYXN5bmMgKHVyaTogS25vd25VcmkpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHVyaVRleHQgPSB1cmkudG9TdHJpbmcoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh1cmkucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmZpbGUpXG5cdFx0XHRcdFx0cmV0dXJuIGF3YWl0IHJlYWRGaWxlVXJpKHVyaVRleHQpO1xuXHRcdFx0XHRcblx0XHRcdFx0ZWxzZSBpZiAodXJpLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5odHRwIHx8XG5cdFx0XHRcdFx0dXJpLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5odHRwcylcblx0XHRcdFx0XHRyZXR1cm4gYXdhaXQgcmVhZFdlYlVyaSh1cmlUZXh0KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0XG5cdC8qKiAqL1xuXHRhc3luYyBmdW5jdGlvbiByZWFkRmlsZVVyaShwYXRoOiBzdHJpbmcsIG9wdHMgPSBcInV0ZjhcIilcblx0e1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmcgfCBFcnJvcj4ocmVzb2x2ZSA9PlxuXHRcdHtcblx0XHRcdHBhdGggPSBkZWNvZGVVUkkocGF0aCk7XG5cdFx0XHRGcy5tb2R1bGUucmVhZEZpbGUocGF0aCwgb3B0cywgKGVycm9yLCBkYXRhKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXNvbHZlKGVycm9yICYmIGVycm9yLmVycm5vID9cblx0XHRcdFx0XHRlcnJvciA6XG5cdFx0XHRcdFx0ZGF0YSB8fCBcIlwiKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHQvKiogKi9cblx0YXN5bmMgZnVuY3Rpb24gcmVhZFdlYlVyaSh1cmw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgRXJyb3I+XG5cdHtcblx0XHRpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0e1xuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMClcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBGZXRjaEVycm9yKFxuXHRcdFx0XHRcdHJlc3BvbnNlLnN0YXR1cyxcblx0XHRcdFx0XHRyZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKFwiVW5rbm93biBlcnJvci5cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0e1xuXHRcdFx0dHlwZSBIdHRwR2V0ID0gdHlwZW9mIGltcG9ydChcImh0dHBcIikuZ2V0O1xuXHRcdFx0dHlwZSBIdHRwc0dldCA9IHR5cGVvZiBpbXBvcnQoXCJodHRwc1wiKS5nZXQ7XG5cdFx0XHR0eXBlIEdldEZuID0gSHR0cEdldCB8IEh0dHBzR2V0O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBnZXRGbjogR2V0Rm4gPSBcblx0XHRcdFx0dXJsLnN0YXJ0c1dpdGgoXCJodHRwczpcIikgPyByZXF1aXJlKFwiaHR0cHNcIikuZ2V0IDpcblx0XHRcdFx0dXJsLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSA/IHJlcXVpcmUoXCJodHRwXCIpLmdldCA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChnZXRGbiA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRVcmkodXJsKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZyB8IEVycm9yPihyZXNvbHZlID0+XG5cdFx0XHR7XG5cdFx0XHRcdGdldEZuKHVybCwgcmVzcG9uc2UgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRhdGE6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmVzcG9uc2Uub24oXCJkYXRhXCIsIGNodW5rID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdGNodW5rIDpcblx0XHRcdFx0XHRcdFx0Y2h1bmsudG9TdHJpbmcoXCJ1dGY4XCIpKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXNwb25zZS5vbihcImVycm9yXCIsIGVycm9yID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShlcnJvcik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGRhdGEuam9pbihcIlwiKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0dGhyb3cgRXhjZXB0aW9uLnVuc3VwcG9ydGVkUGxhdGZvcm0oKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvclxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBzdGF0dXNDb2RlOiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSBzdGF0dXNUZXh0OiBzdHJpbmcpXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cblx0XG5cdGRlY2xhcmUgZnVuY3Rpb24gZmV0Y2goLi4uYXJnczogdW5rbm93bltdKTogYW55O1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIGxhbmd1YWdlIHN5bnRheCB0b2tlbnMuXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgZW51bSBTeW50YXhcblx0e1xuXHRcdHRhYiA9IFwiXFx0XCIsXG5cdFx0c3BhY2UgPSBcIiBcIixcblx0XHR0ZXJtaW5hbCA9IFwiXFxuXCIsXG5cdFx0Y29tYmluYXRvciA9IFwiLFwiLFxuXHRcdGpvaW50ID0gXCI6XCIsXG5cdFx0bGlzdCA9IFwiLi4uXCIsXG5cdFx0ZXNjYXBlQ2hhciA9IFwiXFxcXFwiLFxuXHRcdGNvbW1lbnQgPSBcIi8vXCIsXG5cdFx0XG5cdFx0Ly8gQ29uc3RhbnRzIHVzZWQgaW4gVVJJIHBhcnNpbmdcblx0XHRyZXRyYWN0aW5nVXJpUHJlZml4ID0gXCIuLi9cIixcblx0XHRyZWxhdGl2ZVVyaVByZWZpeCA9IFwiLi9cIixcblx0XHRodHRwUHJlZml4ID0gXCJodHRwOi8vXCIsXG5cdFx0aHR0cHNQcmVmaXggPSBcImh0dHBzOi8vXCIsXG5cdFx0dHJ1dGhFeHRlbnNpb24gPSBcIi50cnV0aFwiXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFVyaVN5bnRheFxuXHR7XG5cdFx0cmV0cmFjdCA9IFwiLi5cIixcblx0XHRjdXJyZW50ID0gXCIuXCIsXG5cdFx0Y29tcG9uZW50U2VwYXJhdG9yID0gXCIvXCIsXG5cdFx0dHlwZVNlcGFyYXRvciA9IFwiLy9cIixcblx0XHRwcm90b2NvbFNlcGFyYXRvciA9IFwiLy9cIixcblx0XHRpbmRleGVyU3RhcnQgPSBcIltcIixcblx0XHRpbmRleGVyRW5kID0gXCJdXCIsXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBIGNvbnN0YW50IGVudW1lcmF0aW9ucyB0aGF0IHN0b3JlcyB0aGUgdmFsaWQgZXh0ZW5zaW9uc1xuXHQgKiB0aGF0IG11c3QgYmUgcHJlc2VudCBpbiBhIHBhcnNhYmxlIFVSSS5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFVyaUV4dGVuc2lvblxuXHR7XG5cdFx0dW5rbm93biA9IFwiXCIsXG5cdFx0dHJ1dGggPSBcIi50cnV0aFwiLFxuXHRcdGpzID0gXCIudHJ1dGguanNcIixcblx0XHR3YXNtID0gXCIudHJ1dGgud2FzbVwiXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IHN0b3JlcyB0aGUgZXNjYXBlIHNlcXVlbmNlc1xuXHQgKiB0aGF0IG9ubHkgbWF0Y2ggYSBzaW5nbGUga2luZCBvZiBjaGFyYWN0ZXIuIFwiU2lnblwiIGluXG5cdCAqIHRoaXMgY2FzZSByZWZlcnMgdG8gdGhlIGZhY3QgdGhhdCB0aGVzZSBhcmUgZXNjYXBlXG5cdCAqIHNlcXVlbmNlcyB0aGF0IHJlZmVyIHRvIGFub3RoZXIgY2hhcmFjdGVyLlxuXHQgKi9cblx0ZXhwb3J0IGVudW0gUmVnZXhTeW50YXhTaWduXG5cdHtcblx0XHR0YWIgPSBcIlxcXFx0XCIsXG5cdFx0bGluZUZlZWQgPSBcIlxcXFxuXCIsXG5cdFx0Y2FycmlhZ2VSZXR1cm4gPSBcIlxcXFxyXCIsXG5cdFx0ZXNjYXBlZEZpbmFsaXplciA9IFwiXFxcXC9cIixcblx0XHRiYWNrc2xhc2ggPSBcIlxcXFxcXFxcXCJcblx0fVxuXHRcblx0LyoqICovXG5cdGV4cG9ydCBuYW1lc3BhY2UgUmVnZXhTeW50YXhTaWduXG5cdHtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIFJlZ2V4U3ludGF4U2lnbiBtZW1iZXIgZnJvbSB0aGVcblx0XHQgKiBzcGVjaWZpZWQgc2lnbiBsaXRlcmFsIChleDogXCJcXHRcIikgb3IgcmF3IHNpZ25hYmxlXG5cdFx0ICogY2hhcmFjdGVyIChleDogXCJcdFwiKS5cblx0XHQgKi9cblx0XHRleHBvcnQgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZTogc3RyaW5nKTogUmVnZXhTeW50YXhTaWduIHwgbnVsbFxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZS5sZW5ndGggPCAxIHx8IHZhbHVlLmxlbmd0aCA+IDIpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB2YWxzID0gT2JqZWN0LnZhbHVlcyhSZWdleFN5bnRheFNpZ24pIGFzIHN0cmluZ1tdO1xuXHRcdFx0Y29uc3QgaWR4ID0gdmFscy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdHJldHVybiBpZHggPCAwID8gbnVsbCA6IHZhbHNbaWR4XSBhcyBSZWdleFN5bnRheFNpZ247XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZSh2YWx1ZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHN3aXRjaCAodmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLnRhYjogcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KDkpO1xuXHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4U2lnbi5saW5lRmVlZDogcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KDEwKTtcblx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheFNpZ24uY2FycmlhZ2VSZXR1cm46IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCgxMyk7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLmVzY2FwZWRGaW5hbGl6ZXI6IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCg0Nyk7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLmJhY2tzbGFzaDogcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KDkyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBzdG9yZXMgdGhlIGVzY2FwZSBzZXF1ZW5jZXNcblx0ICogdGhhdCBjYW4gbWF0Y2ggbW9yZSB0aGFuIG9uZSBraW5kIG9mIGNoYXJhY3Rlci5cblx0ICovXG5cdGV4cG9ydCBlbnVtIFJlZ2V4U3ludGF4S25vd25TZXRcblx0e1xuXHRcdGRpZ2l0ID0gXCJcXFxcZFwiLFxuXHRcdGRpZ2l0Tm9uID0gXCJcXFxcRFwiLFxuXHRcdGFscGhhbnVtZXJpYyA9IFwiXFxcXHdcIixcblx0XHRhbHBoYW51bWVyaWNOb24gPSBcIlxcXFxXXCIsXG5cdFx0d2hpdGVzcGFjZSA9IFwiXFxcXHNcIixcblx0XHR3aGl0ZXNwYWNlTm9uID0gXCJcXFxcU1wiLFxuXHRcdHdpbGQgPSBcIi5cIixcblx0fVxuXHRcblx0LyoqICovXG5cdGV4cG9ydCBuYW1lc3BhY2UgUmVnZXhTeW50YXhLbm93blNldFxuXHR7XG5cdFx0Y29uc3QgdmFscyA9IE9iamVjdC52YWx1ZXMoUmVnZXhTeW50YXhLbm93blNldCkgYXMgc3RyaW5nW107XG5cdFx0XG5cdFx0ZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IFJlZ2V4U3ludGF4S25vd25TZXQgfCBudWxsXG5cdFx0e1xuXHRcdFx0Y29uc3QgaWR4ID0gdmFscy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdHJldHVybiBpZHggPCAwID8gbnVsbCA6IHZhbHNbaWR4XSBhcyBSZWdleFN5bnRheEtub3duU2V0O1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIHRoZSBkZWxpbWl0ZXJzIGF2YWlsYWJsZVxuXHQgKiBpbiB0aGUgc3lzdGVtJ3MgcmVndWxhciBleHByZXNzaW9uIGZsYXZvci5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFJlZ2V4U3ludGF4RGVsaW1pdGVyXG5cdHtcblx0XHRtYWluID0gXCIvXCIsXG5cdFx0dXRmMTZHcm91cFN0YXJ0ID0gXCJcXFxcdXtcIixcblx0XHR1dGYxNkdyb3VwRW5kID0gXCJ9XCIsXG5cdFx0Z3JvdXBTdGFydCA9IFwiKFwiLFxuXHRcdGdyb3VwRW5kID0gXCIpXCIsXG5cdFx0YWx0ZXJuYXRvciA9IFwifFwiLFxuXHRcdHNldFN0YXJ0ID0gXCJbXCIsXG5cdFx0c2V0RW5kID0gXCJdXCIsXG5cdFx0cXVhbnRpZmllclN0YXJ0ID0gXCJ7XCIsXG5cdFx0cXVhbnRpZmllckVuZCA9IFwifVwiLFxuXHRcdHF1YW50aWZpZXJTZXBhcmF0b3IgPSBcIixcIixcblx0XHRyYW5nZSA9IFwiLVwiLFxuXHR9XG5cdFxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBzdG9yZXMgbWlzY2VsbGFuZW91cyByZWd1bGFyXG5cdCAqIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgZG9uJ3QgZml0IGludG9cblx0ICogdGhlIG90aGVyIGVudW1lcmF0aW9ucy5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFJlZ2V4U3ludGF4TWlzY1xuXHR7XG5cdFx0c3RhciA9IFwiKlwiLFxuXHRcdHBsdXMgPSBcIitcIixcblx0XHRuZWdhdGUgPSBcIl5cIixcblx0XHRyZXN0cmFpbmVkID0gXCI/XCIsXG5cdFx0Ym91bmRhcnkgPSBcIlxcXFxiXCIsXG5cdFx0Ym91bmRhcnlOb24gPSBcIlxcXFxCXCIsXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IHN0b3JlcyB0aGUgZGVsaW1pdGVycyBhdmFpbGFibGVcblx0ICogaW4gdGhlIGluZml4IHN5bnRheC5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIEluZml4U3ludGF4XG5cdHtcblx0XHRzdGFydCA9IFwiPFwiLFxuXHRcdGVuZCA9IFwiPlwiLFxuXHRcdG5vbWluYWxTdGFydCA9IFwiPDxcIixcblx0XHRub21pbmFsRW5kID0gXCI+PlwiLFxuXHRcdHBhdHRlcm5TdGFydCA9IFwiPC9cIixcblx0XHRwYXR0ZXJuRW5kID0gXCIvPlwiXG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgbWFuYWdlcyB0aGUgZGlhZ25vc3RpY3MgdGhhdCBoYXZlIGJlZW4gXG5cdCAqIHJlcG9ydGVkIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcHJvZ3JhbS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGYXVsdFNlcnZpY2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHQvLyBMaXN0ZW4gZm9yIGludmFsaWRhdGlvbnMgYW5kIGNsZWFyIG91dCBhbnkgZmF1bHRzXG5cdFx0XHQvLyB0aGF0IGNvcnJlc3BvbmQgdG8gb2JqZWN0cyB0aGF0IGRvbid0IGV4aXN0IGluIHRoZVxuXHRcdFx0Ly8gZG9jdW1lbnQgYW55bW9yZS4gXG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VJbnZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnBhcmVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBzbXQuZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQoc210LCB0cnVlKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVTdGF0ZW1lbnRGYXVsdHMoc3RhdGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBkYXRhLmRvY3VtZW50LmVhY2hEZXNjZW5kYW50KCkpXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVTdGF0ZW1lbnRGYXVsdHMoc3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuaW5FZGl0VHJhbnNhY3Rpb24gPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VFZGl0Q29tcGxldGUsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuaW5FZGl0VHJhbnNhY3Rpb24gPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBpbkVkaXRUcmFuc2FjdGlvbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYWxsIGZhdWx0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZW1vdmVTdGF0ZW1lbnRGYXVsdHMoc3RhdGVtZW50OiBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0dGhpcy5iYWNrZ3JvdW5kTWFudWFsRnJhbWUucmVtb3ZlU291cmNlKHN0YXRlbWVudCk7XG5cdFx0XHR0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUucmVtb3ZlU291cmNlKHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiBzdGF0ZW1lbnQuYWxsU3BhbnMpXG5cdFx0XHRcdHRoaXMuYmFja2dyb3VuZEF1dG9GcmFtZS5yZW1vdmVTb3VyY2Uoc3Bhbik7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIHN0YXRlbWVudC5pbmZpeFNwYW5zKVxuXHRcdFx0XHR0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUucmVtb3ZlU291cmNlKGluZml4U3Bhbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhbGwgZmF1bHRzIHJldGFpbmVkIGJ5IHRoaXMgRmF1bHRTZXJ2aWNlLFxuXHRcdCAqIHNvcnRlZCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGV4aXN0IGluIHRoZSBwcm9ncmFtLCBvcHRpb25hbGx5IGZpbHRlcmVkXG5cdFx0ICogYnkgdGhlIGRvY3VtZW50IHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRlYWNoKGRvY3VtZW50PzogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0bGV0IGZhdWx0cyA9IFtcblx0XHRcdFx0Li4udGhpcy5mb3JlZ3JvdW5kQXV0b0ZyYW1lLmZhdWx0cy52YWx1ZXMoKSxcblx0XHRcdFx0Li4udGhpcy5mb3JlZ3JvdW5kTWFudWFsRnJhbWUuZmF1bHRzLnZhbHVlcygpXG5cdFx0XHRdXG5cdFx0XHRcdC5tYXAoZmF1bHRNYXAgPT4gWy4uLmZhdWx0TWFwLnZhbHVlcygpXSlcblx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcblx0XHRcdFxuXHRcdFx0aWYgKGRvY3VtZW50KVxuXHRcdFx0XHRmYXVsdHMgPSBmYXVsdHMuZmlsdGVyKHYgPT4gdi5kb2N1bWVudCA9PT0gZG9jdW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmF1bHRzLnNvcnQodGhpcy5jb21wYXJlRmF1bHRzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogQ29tcGFyZXMgdHdvIGZhdWx0IGluc3RhbmNlcywgYW5kIHJldHVybnMgYSBudW1iZXIgdGhhdCBpcyBzdWl0YWJsZVxuXHRcdCAqIGFzIGEgcmV0dXJuIHZhbHVlIGZvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2VkIHRvIEphdmFTY3JpcHQnc1xuXHRcdCAqIEFycmF5LnNvcnQoKSBtZXRob2QuXG5cdFx0ICogXG5cdFx0ICogUmV0dXJucyAwIGluIHRoZSBjYXNlIHdoZW4gdGhlIGZhdWx0cyBhcHBlYXIgdG8gYmUgZXF1aXZhbGVudC5cblx0XHQgKi9cblx0XHRjb21wYXJlRmF1bHRzKGE6IEZhdWx0LCBiOiBGYXVsdClcblx0XHR7XG5cdFx0XHRpZiAoYS5kb2N1bWVudCAhPT0gYi5kb2N1bWVudClcblx0XHRcdFx0cmV0dXJuIGEuZG9jdW1lbnQudXJpLnRvU3RyaW5nKCkgPCBiLmRvY3VtZW50LnVyaS50b1N0cmluZygpID8gLTEgOiAxO1xuXHRcdFx0XG5cdFx0XHRpZiAoYS5saW5lICE9PSBiLmxpbmUpXG5cdFx0XHRcdHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XG5cdFx0XHRcblx0XHRcdC8vIFdoZW4gdGhlIGZhdWx0cyBleGlzdCBvbiB0aGUgc2FtZSBsaW5lLCB0aGUgb3JkZXJpbmcgaXMgYmFzZWQgb24gXG5cdFx0XHQvLyB0aGUgc3RhcnRpbmcgb2Zmc2V0IG9mIHRoZSByZXBvcnRlZCBmYXVsdCdzIHJhbmdlLiBUaGlzIHNob3VsZCBjYXVzZVxuXHRcdFx0Ly8gU3RhdGVtZW50IGZhdWx0cyB0byBhbHdheXMgYmUgb3JkZXJlZCBiZWZvcmUgU3BhbiBhbmQgSW5maXhTcGFuXG5cdFx0XHQvLyBmYXVsdHMuXG5cdFx0XHRjb25zdCBvZmZzZXREZWx0YSA9IGEucmFuZ2VbMF0gLSBiLnJhbmdlWzBdO1xuXHRcdFx0aWYgKG9mZnNldERlbHRhICE9PSAwKVxuXHRcdFx0XHRyZXR1cm4gb2Zmc2V0RGVsdGE7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBmYXVsdHMgcmVwb3J0ZWQgb24gdGhlIHNhbWUgc3BhbiwgdGhlIG9yZGVyaW5nXG5cdFx0XHQvLyBpcyBiYXNlZCBvbiB0aGUgaW50ZXJuYWwgZmF1bHQgY29kZS4gSWYgdGhlIGZhdWx0cyBhcmUgdGhlIHNhbWUsIDAgaXNcblx0XHRcdC8vIHJldHVybmVkLCBhbmQgdGhlIGZhdWx0cyBhcmUgY29uc2lkZXJlZCB0byBiZSBlcXVpdmFsZW50LlxuXHRcdFx0cmV0dXJuIGEudHlwZS5jb2RlIC0gYi50eXBlLmNvZGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2Zcblx0XHQgKiB1bnJlY3RpZmllZCBmYXVsdHMgcmV0YWluZWQgYnkgdGhpcyBGYXVsdFNlcnZpY2UuXG5cdFx0ICovXG5cdFx0Z2V0IGNvdW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5mb3JlZ3JvdW5kQXV0b0ZyYW1lLmZhdWx0cy5zaXplICtcblx0XHRcdFx0dGhpcy5mb3JlZ3JvdW5kTWFudWFsRnJhbWUuZmF1bHRzLnNpemU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcG9ydHMgYSBmYXVsdC4gSWYgYSBzaW1pbGFyIEZhdWx0IG9uIHRoZSBzYW1lIGFyZWFcblx0XHQgKiBvZiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gcmVwb3J0ZWQsIHRoZSBtZXRob2Rcblx0XHQgKiBydW5zIHRoZSBGYXVsdFJlcG9ydGVkIGhvb2suXG5cdFx0ICovXG5cdFx0cmVwb3J0KGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHR0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUuYWRkRmF1bHQoZmF1bHQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBvcnRzIGEgZmF1bHQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiBhbiBlZGl0IHRyYW5zYWN0aW9uLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIHRvIGJlIHVzZWQgZm9yIGZhdWx0cyB0aGF0IGFyZSByZXBvcnRlZCBpblxuXHRcdCAqIGFzeW5jaHJvbm91cyBjYWxsYmFja3MsIHN1Y2ggYXMgbmV0d29yayBlcnJvcnMuXG5cdFx0ICovXG5cdFx0cmVwb3J0TWFudWFsKGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHR0aGlzLmJhY2tncm91bmRNYW51YWxGcmFtZS5hZGRGYXVsdChmYXVsdCk7XG5cdFx0XHR0aGlzLm1heWJlUXVldWVNYW51YWxSZWZyZXNoKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENsZWFycyBhIGZhdWx0IHRoYXQgd2FzIHByZXZpb3VzbHkgcmVwb3J0ZWQgb3V0c2lkZVxuXHRcdCAqIG9mIGFuIGVkaXQgdHJhbnNhY3Rpb24uIFxuXHRcdCAqL1xuXHRcdHJlc29sdmVNYW51YWwoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdHRoaXMuYmFja2dyb3VuZE1hbnVhbEZyYW1lLnJlbW92ZUZhdWx0KGZhdWx0KTtcblx0XHRcdHRoaXMubWF5YmVRdWV1ZU1hbnVhbFJlZnJlc2goKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVldWVzIHRoZSBjb3B5aW5nIG9mIHRoZSBiYWNrZ3JvdW5kIGZhdWx0IGJ1ZmZlciB0byB0aGUgXG5cdFx0ICogZm9yZWdyb3VuZC4gXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBtYXliZVF1ZXVlTWFudWFsUmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMubWFudWFsUmVmcmVzaFF1ZXVlZClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm1hbnVhbFJlZnJlc2hRdWV1ZWQgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubWFudWFsUmVmcmVzaFF1ZXVlZCA9IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCF0aGlzLmluRWRpdFRyYW5zYWN0aW9uKVxuXHRcdFx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdFx0fSxcblx0XHRcdDApO1xuXHRcdH1cblx0XHRwcml2YXRlIG1hbnVhbFJlZnJlc2hRdWV1ZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBGYXVsdCBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIHJlcG9ydGVkXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBzb3VyY2UuIElmIHRoZSBzb3VyY2UgaGFzIG5vIGZhdWx0cywgYW4gZW1wdHlcblx0XHQgKiBhcnJheSBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRpbnNwZWN0PFRTb3VyY2UgZXh0ZW5kcyBURmF1bHRTb3VyY2U+KHNvdXJjZTogVFNvdXJjZSk6IEZhdWx0PFRTb3VyY2U+W11cblx0XHR7XG5cdFx0XHRjb25zdCBvdXQ6IEZhdWx0PFRTb3VyY2U+W10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCByZXRhaW5lZEZhdWx0IG9mIHRoaXMuZWFjaCgpKVxuXHRcdFx0XHRpZiAocmV0YWluZWRGYXVsdC5zb3VyY2UgPT09IHNvdXJjZSlcblx0XHRcdFx0XHRvdXQucHVzaChyZXRhaW5lZEZhdWx0IGFzIEZhdWx0PFRTb3VyY2U+KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgRmF1bHQgb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiByZXBvcnRlZCB0aGF0XG5cdFx0ICogY29ycmVzcG9uZCB0byB0aGUgc3BlY2lmaWVkIFN0YXRlbWVudCwgb3IgYW55IFNwYW4gb3IgSW5maXhTcGFuXG5cdFx0ICogb2JqZWN0cyBjb250YWluZWQgd2l0aGluIGl0LlxuXHRcdCAqL1xuXHRcdGluc3BlY3REZWVwKHNvdXJjZTogU3RhdGVtZW50KTogRmF1bHRbXVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dDogRmF1bHRbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJldGFpbmVkRmF1bHQgb2YgdGhpcy5lYWNoKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlU291cmNlID0gcmV0YWluZWRGYXVsdC5zb3VyY2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocmVTb3VyY2UgPT09IHNvdXJjZSlcblx0XHRcdFx0XHRvdXQucHVzaChyZXRhaW5lZEZhdWx0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGVsc2UgaWYgKHJlU291cmNlIGluc3RhbmNlb2YgU3BhbiB8fCByZVNvdXJjZSBpbnN0YW5jZW9mIEluZml4U3Bhbilcblx0XHRcdFx0XHRpZiAocmVTb3VyY2Uuc3RhdGVtZW50ID09PSBzb3VyY2UpXG5cdFx0XHRcdFx0XHRvdXQucHVzaChyZXRhaW5lZEZhdWx0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogVXNlZCBpbnRlcm5hbGx5IHRvIGluZm9ybSB0aGUgRmF1bHRTZXJ2aWNlIHRoYXQgdHlwZS1sZXZlbCBmYXVsdFxuXHRcdCAqIGFuYWx5c2lzIGlzIGJlaW5nIGRvbmUgb24gdGhlIHByb3ZpZGVkIE5vZGUuIFRoaXMgaXMgbmVjZXNzYXJ5XG5cdFx0ICogYmVjYXVzZSB0eXBlLWxldmVsIGZhdWx0cyBkbyBub3QgbGl2ZSBiZXlvbmQgYSBzaW5nbGUgZWRpdCBmcmFtZSxcblx0XHQgKiBzbyB0aGUgRmF1bHRTZXJ2aWNlIG5lZWRzIHRvIGtub3cgd2hpY2ggTm9kZXMgd2VyZSBhbmFseXplZFxuXHRcdCAqIHNvIHRoYXQgbmV3bHkgcmVjdGlmaWVkIGZhdWx0cyBjYW4gYmUgY2xlYXJlZCBvdXQuXG5cdFx0ICogXG5cdFx0ICogV2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGFueSBmYXVsdHMgY29ycmVzcG9uZGluZyB0byB0aGVcblx0XHQgKiBzcGVjaWZpZWQgTm9kZSBhcmUgY2xlYXJlZCBvdXQsIGFuZCBhcmUgb25seSBhZGRlZCBiYWNrIGluIGlmXG5cdFx0ICogdGhleSB3ZXJlIHJlLWRldGVjdGVkIGR1cmluZyB0aGlzIGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICovXG5cdFx0aW5mb3JtKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210cyA9IG5vZGUuc3RhdGVtZW50cy5maWx0ZXIoc210ID0+ICFzbXQuaXNEaXNwb3NlZCk7XG5cdFx0XHRcblx0XHRcdC8vIENsZWFyIG91dCBhbnkgc3RhdGVtZW50LWxldmVsIGZhdWx0cyB0aGF0IHRvdWNoIHRoZSBub2RlXG5cdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzbXRzKVxuXHRcdFx0XHR0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUucmVtb3ZlU291cmNlKHNtdCk7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gQ2xlYXIgb3V0IGFueSBzcGFuLWxldmVsIGZhdWx0cyB0aGF0IHRvdWNoIHRoZSBub2RlXG5cdFx0XHRjb25zdCBzcGFucyA9IHNtdHNcblx0XHRcdFx0Lm1hcChzbXQgPT4gc210LnNwYW5zKVxuXHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpXG5cdFx0XHRcdHRoaXMuYmFja2dyb3VuZEF1dG9GcmFtZS5yZW1vdmVTb3VyY2Uoc3Bhbik7XG5cdFx0XHRcblx0XHRcdC8vIENsZWFyIG91dCBhbnkgaW5maXgtbGV2ZWwgZmF1bHRzIHRoYXQgdG91Y2ggdGhlIG5vZGVcblx0XHRcdGNvbnN0IGluZml4ZXMgPSBzbXRzXG5cdFx0XHRcdC5tYXAoc210ID0+IHNtdC5pbmZpeFNwYW5zIHx8IFtdKVxuXHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4IG9mIGluZml4ZXMpXG5cdFx0XHRcdHRoaXMuYmFja2dyb3VuZEF1dG9GcmFtZS5yZW1vdmVTb3VyY2UoaW5maXgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBCcm9hZGNhc3RzIGFueSBub3QteWV0LXJlcG9ydGVkIGZhdWx0cyB0byB0aGUgRmF1bHRTZXJ2aWNlLlxuXHRcdCAqL1xuXHRcdHJlZnJlc2goKVxuXHRcdHtcblx0XHRcdGNvbnN0IFthdXRvQWRkZWQsIGF1dG9SZW1vdmVkXSA9IHRoaXMucmVmcmVzaEZyYW1lU2V0KFxuXHRcdFx0XHR0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUsXG5cdFx0XHRcdHRoaXMuZm9yZWdyb3VuZEF1dG9GcmFtZSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IFttYW51YWxBZGRlZCwgbWFudWFsUmVtb3ZlZF0gPSB0aGlzLnJlZnJlc2hGcmFtZVNldChcblx0XHRcdFx0dGhpcy5iYWNrZ3JvdW5kTWFudWFsRnJhbWUsXG5cdFx0XHRcdHRoaXMuZm9yZWdyb3VuZE1hbnVhbEZyYW1lKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYXV0b0NoYW5nZWQgPSBhdXRvQWRkZWQubGVuZ3RoICsgYXV0b1JlbW92ZWQubGVuZ3RoID4gMDtcblx0XHRcdGlmIChhdXRvQ2hhbmdlZClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5mb3JlZ3JvdW5kQXV0b0ZyYW1lID0gdGhpcy5iYWNrZ3JvdW5kQXV0b0ZyYW1lO1xuXHRcdFx0XHR0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUgPSB0aGlzLmJhY2tncm91bmRBdXRvRnJhbWUuY2xvbmUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgbWFudWFsQ2hhbmdlZCA9IG1hbnVhbEFkZGVkLmxlbmd0aCArIG1hbnVhbFJlbW92ZWQubGVuZ3RoID4gMDtcblx0XHRcdGlmIChtYW51YWxDaGFuZ2VkKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmZvcmVncm91bmRNYW51YWxGcmFtZSA9IHRoaXMuYmFja2dyb3VuZE1hbnVhbEZyYW1lO1xuXHRcdFx0XHR0aGlzLmJhY2tncm91bmRNYW51YWxGcmFtZSA9IHRoaXMuYmFja2dyb3VuZE1hbnVhbEZyYW1lLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChhdXRvQ2hhbmdlZCB8fCBtYW51YWxDaGFuZ2VkKVxuXHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlRmF1bHRDaGFuZ2UoXG5cdFx0XHRcdFx0YXV0b0FkZGVkLmNvbmNhdChtYW51YWxBZGRlZCksXG5cdFx0XHRcdFx0YXV0b1JlbW92ZWQuY29uY2F0KG1hbnVhbFJlbW92ZWQpKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVmcmVzaEZyYW1lU2V0KGJnRnJhbWU6IEZhdWx0RnJhbWUsIGZnRnJhbWU6IEZhdWx0RnJhbWUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZmF1bHRzQWRkZWQ6IEZhdWx0W10gPSBbXTtcblx0XHRcdGNvbnN0IGZhdWx0c1JlbW92ZWQ6IEZhdWx0W10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBtYXAgb2YgYmdGcmFtZS5mYXVsdHMudmFsdWVzKCkpXG5cdFx0XHRcdGZvciAoY29uc3QgZmF1bHQgb2YgbWFwLnZhbHVlcygpKVxuXHRcdFx0XHRcdGlmICghZmdGcmFtZS5oYXNGYXVsdChmYXVsdCkpXG5cdFx0XHRcdFx0XHRmYXVsdHNBZGRlZC5wdXNoKGZhdWx0KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBtYXAgb2YgZmdGcmFtZS5mYXVsdHMudmFsdWVzKCkpXG5cdFx0XHRcdGZvciAoY29uc3QgZmF1bHQgb2YgbWFwLnZhbHVlcygpKVxuXHRcdFx0XHRcdGlmICghYmdGcmFtZS5oYXNGYXVsdChmYXVsdCkpXG5cdFx0XHRcdFx0XHRmYXVsdHNSZW1vdmVkLnB1c2goZmF1bHQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gW2ZhdWx0c0FkZGVkLCBmYXVsdHNSZW1vdmVkXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGZhdWx0cyB0aGF0IGFyZSBleHBvc2VkIHRvIHRoZSBvdXRzaWRlIHdoZW4gdGhlIFxuXHRcdCAqIEZhdWx0U2VydmljZSdzIGFjY2Vzc29yIG1ldGhvZHMgYXJlIHVzZWQuIFRoZXNlIGZhdWx0cyBhcmVcblx0XHQgKiByZXBvcnRlZCB3aXRoaW4gYW4gZWRpdCB0cmFuc2FjdGlvbiwgYW5kIGNsZWFyIGF1dG9tYXRpY2FsbHlcblx0XHQgKiB3aGVuIHRoZSBTdGF0ZW1lbnQgb3IgU3BhbiB0byB3aGljaCB0aGV5IGFyZSBjb25uZWN0ZWQgaXNcblx0XHQgKiBkaXNwb3NlZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIGZvcmVncm91bmRBdXRvRnJhbWUgPSBuZXcgRmF1bHRGcmFtZSgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIGJ1ZmZlciBvZiB0aGUgZmF1bHRzIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIGV4cG9zZWQgdG8gdGhlXG5cdFx0ICogb3V0c2lkZS4gVGhlc2UgZmF1bHRzIGNsZWFyIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgU3RhdGVtZW50IG9yXG5cdFx0ICogU3BhbiB0byB3aGljaCB0aGV5IGFyZSBjb25uZWN0ZWQgaXMgZGlzcG9zZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBiYWNrZ3JvdW5kQXV0b0ZyYW1lID0gbmV3IEZhdWx0RnJhbWUoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgZmF1bHRzIHRoYXQgYXJlIGV4cG9zZWQgdG8gdGhlIG91dHNpZGUgd2hlbiB0aGVcblx0XHQgKiBGYXVsdFNlcnZpY2UncyBhY2Nlc3NvciBtZXRob2RzIGFyZSB1c2VkLiBcblx0XHQgKi9cblx0XHRwcml2YXRlIGZvcmVncm91bmRNYW51YWxGcmFtZSA9IG5ldyBGYXVsdEZyYW1lKCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgYnVmZmVyIG9mIHRoZSBmYXVsdHMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgZXhwb3NlZCB0byB0aGVcblx0XHQgKiBvdXRzaWRlLCBhZnRlciBiZWluZyBjb3BpZWQgdG8gdGhlIGZvcmVncm91bmRNYW51YWxGcmFtZS5cblx0XHQgKiBUaGVzZSBmYXVsdHMgYXJlIHJlcG9ydGVkIG91dHNpZGUgb2YgYW4gZWRpdCB0cmFuc2FjcnRpb24sIGFuZCBtdXN0IFxuXHRcdCAqIGJlIGNsZWFyZWQgbWFudWFsbHkgKHZpYSByZXBvcnRNYW51YWwpLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYmFja2dyb3VuZE1hbnVhbEZyYW1lID0gbmV3IEZhdWx0RnJhbWUoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFN0b3JlcyBhIGJ1ZmZlciBvZiBmYXVsdHMuXG5cdCAqL1xuXHRjbGFzcyBGYXVsdEZyYW1lXG5cdHtcblx0XHQvKiogKi9cblx0XHRjbG9uZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgbmV3RnJhbWUgPSBuZXcgRmF1bHRGcmFtZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtmYXVsdFNvdXJjZSwgZXhpc3RpbmdNYXBdIG9mIHRoaXMuZmF1bHRzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXdNYXA6IFRGYXVsdE1hcCA9IG5ldyBNYXAoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgW2NvZGUsIGZhdWx0XSBvZiBleGlzdGluZ01hcClcblx0XHRcdFx0XHRuZXdNYXAuc2V0KGNvZGUsIGZhdWx0KTtcblx0XHRcdFx0XG5cdFx0XHRcdG5ld0ZyYW1lLmZhdWx0cy5zZXQoZmF1bHRTb3VyY2UsIG5ld01hcCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXdGcmFtZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkRmF1bHQoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdGNvbnN0IGZhdWx0c0ZvclNvdXJjZSA9IHRoaXMuZmF1bHRzLmdldChmYXVsdC5zb3VyY2UpO1xuXHRcdFx0aWYgKGZhdWx0c0ZvclNvdXJjZSlcblx0XHRcdHtcblx0XHRcdFx0ZmF1bHRzRm9yU291cmNlLnNldChmYXVsdC50eXBlLmNvZGUsIGZhdWx0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwOiBURmF1bHRNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdG1hcC5zZXQoZmF1bHQudHlwZS5jb2RlLCBmYXVsdCk7XG5cdFx0XHRcdHRoaXMuZmF1bHRzLnNldChmYXVsdC5zb3VyY2UsIG1hcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlbW92ZVNvdXJjZShzb3VyY2U6IFRGYXVsdFNvdXJjZSlcblx0XHR7XG5cdFx0XHR0aGlzLmZhdWx0cy5kZWxldGUoc291cmNlKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFN0YXRlbWVudClcblx0XHRcdFx0Zm9yIChjb25zdCBjcnVmdE9iamVjdCBvZiBzb3VyY2UuY3J1ZnRPYmplY3RzKVxuXHRcdFx0XHRcdHRoaXMuZmF1bHRzLmRlbGV0ZShjcnVmdE9iamVjdCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlbW92ZUZhdWx0KGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNGb3JTb3VyY2UgPSB0aGlzLmZhdWx0cy5nZXQoZmF1bHQuc291cmNlKTtcblx0XHRcdGlmIChmYXVsdHNGb3JTb3VyY2UpXG5cdFx0XHRcdGZhdWx0c0ZvclNvdXJjZS5kZWxldGUoZmF1bHQudHlwZS5jb2RlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzRmF1bHQoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdGNvbnN0IGZhdWx0c0ZvclNvdXJjZSA9IHRoaXMuZmF1bHRzLmdldChmYXVsdC5zb3VyY2UpO1xuXHRcdFx0cmV0dXJuIGZhdWx0c0ZvclNvdXJjZSA/XG5cdFx0XHRcdGZhdWx0c0ZvclNvdXJjZS5oYXMoZmF1bHQudHlwZS5jb2RlKSA6XG5cdFx0XHRcdGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBIGRvdWJseS1uZXN0ZWQgbWFwIG9mIGZhdWx0IHNvdXJjZXMsIGZhdWx0IGNvZGVzLCBhbmQgdGhlIGFjdHVhbCBmYXVsdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBmYXVsdHMgPSBuZXcgTWFwPFRGYXVsdFNvdXJjZSwgVEZhdWx0TWFwPigpO1xuXHR9XG5cdFxuXHR0eXBlIFRGYXVsdE1hcCA9IE1hcDxudW1iZXIsIEZhdWx0Pjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIHR5cGUgdGhhdCBkZXNjcmliZXMgdGhlIHBvc3NpYmxlIG9iamVjdHMgd2l0aGluIGEgZG9jdW1lbnRcblx0ICogdGhhdCBtYXkgYmUgcmVzcG9uc2libGUgZm9yIHRoZSBnZW5lcmF0aW9uIG9mIGEgZmF1bHQuXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBURmF1bHRTb3VyY2UgPSBTdGF0ZW1lbnQgfCBTcGFuIHwgSW5maXhTcGFuO1xuXHRcblx0LyoqIEBpbnRlcm5hbCAqL1xuXHRleHBvcnQgdHlwZSBTdGF0ZW1lbnRGYXVsdCA9IFJlYWRvbmx5PEZhdWx0PFN0YXRlbWVudD4+O1xuXHRcblx0LyoqIEBpbnRlcm5hbCAqL1xuXHRleHBvcnQgdHlwZSBTdGF0ZW1lbnRGYXVsdFR5cGUgPSBSZWFkb25seTxGYXVsdFR5cGU8U3RhdGVtZW50Pj47XG5cdFxuXHQvKiogQGludGVybmFsICovXG5cdGV4cG9ydCB0eXBlIFNwYW5GYXVsdCA9IFJlYWRvbmx5PEZhdWx0PFNwYW4+Pjtcblx0XG5cdC8qKiBAaW50ZXJuYWwgKi9cblx0ZXhwb3J0IHR5cGUgU3BhbkZhdWx0VHlwZSA9IFJlYWRvbmx5PEZhdWx0VHlwZTxTcGFuIHwgSW5maXhTcGFuPj47XG5cdFxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRmF1bHQ8VFNvdXJjZSA9IFRGYXVsdFNvdXJjZT5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqICovXG5cdFx0XHRyZWFkb25seSB0eXBlOiBGYXVsdFR5cGU8VFNvdXJjZT4sXG5cdFx0XHRcblx0XHRcdC8qKiBUaGUgZG9jdW1lbnQgb2JqZWN0IHRoYXQgY2F1c2VkIHRoZSBmYXVsdCB0byBiZSByZXBvcnRlZC4gKi9cblx0XHRcdHJlYWRvbmx5IHNvdXJjZTogVFNvdXJjZSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UgdGhhdCBjb250YWlucyBtb3JlIGluLWRlcHRoIGRldGFpbFxuXHRcdFx0ICogb2YgdGhlIGZhdWx0IHRoYXQgb2NjdXJlZCwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIG1lc3NhZ2UuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGFkZGl0aW9uYWxEZXRhaWw6IHN0cmluZyA9IFwiXCIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy5zb3VyY2U7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSArMSdzIGFyZSBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gZGVhbCB3aXRoIHRoZSBmYWN0IHRoYXRcblx0XHRcdC8vIG1vc3QgZWRpdG9ycyBhcmUgMS1iYXNlZCB3aGVyZWFzIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuXHRcdFx0Ly8gb2Ygc3RhdGVtZW50IHN0cmluZ3MgYXJlIDAtYmFzZWQuXG5cdFx0XHRcblx0XHRcdGlmIChzcmMgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFRoZSBUYWJzQW5kU3BhY2VzIGZhdWx0IGlzIHRoZSBvbmx5IGZhdWx0IHRoYXQgbmVlZHMgYVxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2Ugd2hlcmUgaXQgaGFzIGEgZGlmZmVyZW50IHJlcG9ydGluZyBsb2NhdGlvbi5cblx0XHRcdFx0dGhpcy5yYW5nZSA9IHR5cGUuY29kZSA9PT0gRmF1bHRzLlRhYnNBbmRTcGFjZXMuY29kZSA/XG5cdFx0XHRcdFx0WzEsIHNyYy5pbmRlbnQgKyAxXSA6XG5cdFx0XHRcdFx0W3NyYy5pbmRlbnQgKyAxLCBzcmMuc291cmNlVGV4dC5sZW5ndGggKyAxXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFNwYW4gfHwgc3JjIGluc3RhbmNlb2YgSW5maXhTcGFuKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnJhbmdlID0gW1xuXHRcdFx0XHRcdHNyYy5ib3VuZGFyeS5vZmZzZXRTdGFydCArIDEsXG5cdFx0XHRcdFx0c3JjLmJvdW5kYXJ5Lm9mZnNldEVuZCArIDFcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgdGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIGZhdWx0IGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sXG5cdFx0ICogc3VpdGFibGUgZm9yIG91dHB1dCBhcyBhbiBlcnJvciBtZXNzYWdlLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBhdm9pZFByb3RvY29scyA9IFtcblx0XHRcdFx0VXJpUHJvdG9jb2wubWVtb3J5LFxuXHRcdFx0XHRVcmlQcm90b2NvbC5ub25lLFxuXHRcdFx0XHRVcmlQcm90b2NvbC51bmtub3duXG5cdFx0XHRdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gYXZvaWRQcm90b2NvbHMuaW5jbHVkZXMoZG9jLnVyaS5wcm90b2NvbCkgP1xuXHRcdFx0XHRcIlwiIDogZG9jLnVyaS50b1N0cmluZygpICsgXCIgXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvbE51bXMgPSB0aGlzLnJhbmdlLmpvaW4oXCItXCIpO1xuXHRcdFx0Y29uc3QgY29sVGV4dCA9IGNvbE51bXMgPyBcIiwgQ29sIFwiICsgY29sTnVtcyA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBgJHt0aGlzLnR5cGUubWVzc2FnZX0gKCR7dXJpVGV4dH1MaW5lICR7dGhpcy5saW5lfSR7Y29sVGV4dH0pYDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnQgaW4gd2hpY2ggdGhpcyBGYXVsdCB3YXMgZGV0ZWN0ZWQuXG5cdFx0ICovXG5cdFx0Z2V0IGRvY3VtZW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZW1lbnQuZG9jdW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSByZWZlcmVuY2UgdG8gdGhlIFN0YXRlbWVudCBpbiB3aGljaCB0aGlzIEZhdWx0IHdhcyBkZXRlY3RlZC5cblx0XHQgKi9cblx0XHRnZXQgc3RhdGVtZW50KClcblx0XHR7XG5cdFx0XHRjb25zdCBzcmMgPSB0aGlzLnNvdXJjZTtcblx0XHRcdHJldHVybiBOb3QubnVsbChcblx0XHRcdFx0c3JjIGluc3RhbmNlb2YgU3RhdGVtZW50ID8gc3JjIDpcblx0XHRcdFx0c3JjIGluc3RhbmNlb2YgU3BhbiA/IHNyYy5zdGF0ZW1lbnQgOlxuXHRcdFx0XHRzcmMgaW5zdGFuY2VvZiBJbmZpeFNwYW4gPyBzcmMuc3RhdGVtZW50IDpcblx0XHRcdFx0bnVsbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIDEtYmFzZWQgbGluZSBudW1iZXIgb2YgdGhlIFN0YXRlbWVudCBpbiB3aGljaCB0aGlzIEZhdWx0IHdhcyBkZXRlY3RlZC5cblx0XHQgKi9cblx0XHRnZXQgbGluZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210ID0gdGhpcy5zdGF0ZW1lbnQ7XG5cdFx0XHRyZXR1cm4gc210LmRvY3VtZW50LmxpbmVOdW1iZXJPZihzbXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBjaGFyYWN0ZXIgb2Zmc2V0c1xuXHRcdCAqIHdpdGhpbiB0aGUgU3RhdGVtZW50IGluIHdoaWNoIHRoaXMgRmF1bHQgd2FzIGRldGVjdGVkLiBUaGUgY2hhcmFjdGVyXG5cdFx0ICogb2Zmc2V0cyBhcmUgMS1iYXNlZCAobm90IDAtYmFzZWQpIHRvIGNvbXBseSB3aXRoIHRoZSBiZWhhdmlvdXIgb2YgXG5cdFx0ICogbW9zdCB0ZXh0IGVkaXRvcnMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgcmFuZ2U6IFtudW1iZXIsIG51bWJlcl07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGYXVsdFR5cGU8VFNvdXJjZSA9IFRGYXVsdFNvdXJjZT5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBlcnJvciBjb2RlLCB1c2VmdWwgZm9yIHJlZmVyZW5jZSBwdXJwb3Nlcywgb3IgZGlzcGxheSBpbiBhIHVzZXIgaW50ZXJmYWNlLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBjb2RlOiBudW1iZXIsXG5cdFx0XHQvKipcblx0XHRcdCAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGZhdWx0LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBtZXNzYWdlOiBzdHJpbmcsXG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzZXZlcml0eTogRmF1bHRTZXZlcml0eSlcblx0XHR7XG5cdFx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIGZhdWx0IG9mIHRoaXMgdHlwZS5cblx0XHQgKi9cblx0XHRjcmVhdGUoc291cmNlOiBUU291cmNlKVxuXHRcdHtcblx0XHRcdHJldHVybiBuZXcgRmF1bHQ8VFNvdXJjZT4odGhpcywgc291cmNlKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUaGUgZm9sbG93aW5nIGRlZmluaXRpb25zIGFyZSBpbnRlbnRpb25hbGx5IGVxdWl2YWxlbnRcblx0ICogdG8gdGhlIHNldmVyaXR5IGNvZGVzIGZyb20gdGhlIG1vbmFjbyBlZGl0b3IuXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgZW51bSBGYXVsdFNldmVyaXR5XG5cdHtcblx0XHQvKiogVW51c2VkLiAqL1xuXHRcdGhpbnQgPSAxLFxuXHRcdFxuXHRcdC8qKiBVbnVzZWQuICovXG5cdFx0aW5mbyA9IDIsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBzZXZlcml0eSBvZiBhIGZhdWx0IGlzIFwid2FybmluZ1wiLCB3aGljaCBtZWFucyB0aGF0XG5cdFx0ICogdGhlIGFzc29jaWF0ZWQgb2JqZWN0IHdpbGwgc3RpbGwgYmUgcHJvY2Vzc2VkIGR1cmluZyB0eXBlIGFuYWx5c2lzLlxuXHRcdCAqL1xuXHRcdHdhcm5pbmcgPSA0LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgc2V2ZXJpdHkgb2YgYSBmYXVsdCBpcyBcImVycm9yXCIsIHdoaWNoIG1lYW5zIHRoYXRcblx0XHQgKiB0aGUgYXNzb2NpYXRlZCBvYmplY3Qgd2lsbCBiZSBpZ25vcmVkIGR1cmluZyB0eXBlIGFuYWx5c2lzLlxuXHRcdCAqL1xuXHRcdGVycm9yID0gOFxuXHR9XG5cdFxuXHQvKipcblx0ICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgZnJvemVuIGZhdWx0IGluc3RhbmNlcy5cblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUZhdWx0PFQ+KFxuXHRcdGNvZGU6IG51bWJlcixcblx0XHRtZXNzYWdlOiBzdHJpbmcsXG5cdFx0c2V2ZXJpdHkgPSBGYXVsdFNldmVyaXR5LmVycm9yKVxuXHR7XG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUobmV3IEZhdWx0VHlwZTxUPihjb2RlLCBtZXNzYWdlLCBzZXZlcml0eSkpO1xuXHR9XG5cdFxuXHRjb25zdCBxdWFudGlmaWVycyA9IFxuXHRcdGAoJHtSZWdleFN5bnRheE1pc2Muc3Rhcn0sIFxuXHRcdCR7UmVnZXhTeW50YXhNaXNjLnBsdXN9LFxuXHRcdCR7UmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclN0YXJ0fS4uJHtSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyRW5kfSlgO1xuXHRcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IEZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoKClcblx0XHR7XG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKEZhdWx0cykgYXMgRmF1bHRUeXBlPG9iamVjdD5bXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBmYXVsdFR5cGUgb2YgdmFsdWVzKVxuXHRcdFx0XHRpZiAoZmF1bHRUeXBlIGluc3RhbmNlb2YgRmF1bHRUeXBlKVxuXHRcdFx0XHRcdHlpZWxkIGZhdWx0VHlwZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBGYXVsdFR5cGUgaW5zdGFuY2Vcblx0XHQgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGZhdWx0IHdpdGggdGhlIHNwZWNpZmllZCBjb2RlLCBhc1xuXHRcdCAqIHdlbGwgYXMgdGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLiBJbiB0aGUgY2FzZSB3aGVuIHRoZVxuXHRcdCAqIGZhdWx0Q29kZSB3YXMgbm90IGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdG5hbWVPZihmYXVsdENvZGU6IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoRmF1bHRzKSBhcyBbc3RyaW5nLCBGYXVsdFR5cGU8b2JqZWN0Pl1bXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbbmFtZSwgdHlwZV0gb2YgZW50cmllcylcblx0XHRcdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBGYXVsdFR5cGUpXG5cdFx0XHRcdFx0aWYgKHR5cGUuY29kZSA9PT0gZmF1bHRDb2RlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0sXG5cdFx0XG5cdFx0Ly8jIFJlc291cmNlLXJlbGF0ZWQgZmF1bHRzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VW5yZXNvbHZlZFJlc291cmNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwLFxuXHRcdFx0XCJVUkkgcG9pbnRzIHRvIGEgcmVzb3VyY2UgdGhhdCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdENpcmN1bGFyUmVzb3VyY2VSZWZlcmVuY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDIsXG5cdFx0XHRcIlVSSSBwb2ludHMgdG8gYSByZXNvdXJjZSB0aGF0IHdvdWxkIGNhdXNlIGEgY2lyY3VsYXIgcmVmZXJlbmNlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbnNlY3VyZVJlc291cmNlUmVmZXJlbmNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTA0LFxuXHRcdFx0YERvY3VtZW50cyBsb2FkZWQgZnJvbSByZW1vdGUgbG9jYXRpb25zXG5cdFx0XHRjYW5ub3QgcmVmZXJlbmNlIGRvY3VtZW50cyBzdG9yZWQgbG9jYWxseS5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHREdXBsaWNhdGVSZWZlcmVuY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDYsXG5cdFx0XHRcIkRvY3VtZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVmZXJlbmNlZC5cIixcblx0XHRcdEZhdWx0U2V2ZXJpdHkuZXJyb3IpLFxuXHRcdFxuXHRcdC8vIyBUeXBlIHZlcmlmaWNhdGlvbiBmYXVsdHNcblx0XHRcblx0XHQvKiogKi9cblx0XHRVbnJlc29sdmVkQW5ub3RhdGlvbjogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQyMDEsXG5cdFx0XHRcIlVucmVzb2x2ZWQgYW5ub3RhdGlvbi5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Q2lyY3VsYXJUeXBlUmVmZXJlbmNlOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDIwMyxcblx0XHRcdFwiQ2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgZGV0ZWN0ZWQuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdENvbnRyYWN0VmlvbGF0aW9uOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0Ly8hIENIQU5HRSBUSElTIFRPIDIwNFxuXHRcdFx0MjA1LFxuXHRcdFx0XCJPdmVycmlkZGVuIHR5cGVzIG11c3QgZXhwbGljaXRseSBleHBhbmQgdGhlIHR5cGUgYXMgZGVmaW5lZCBpbiB0aGUgYmFzZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VHlwZUNhbm5vdEJlUmVmcmVzaGVkOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MjA2LFxuXHRcdFx0YFRoaXMgdHlwZSBjYW5ub3QgYmUgcmVmcmVzaGVkLCBiZWNhdXNlIG9uZSBvciBtb3JlIGJhc2Vcblx0XHRcdHR5cGVzIGFyZSBpbXBvc2luZyBhIHNwZWNpZmljIHR5cGUgY29udHJhY3Qgb24gaXQuIENvbnNpZGVyXG5cdFx0XHRvbWl0dGluZyB0aGUgJHtTeW50YXguam9pbnR9IG9wZXJhdG9yIGhlcmUuYCxcblx0XHRcdEZhdWx0U2V2ZXJpdHkud2FybmluZyksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SWdub3JlZEFubm90YXRpb246IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MjA3LFxuXHRcdFx0YFRoaXMgYW5ub3RhdGlvbiBpcyBpZ25vcmVkIGJlY2F1c2UgYW5vdGhlciBhbm5vdGF0aW9uXG5cdFx0XHRpbiB0aGlzIHN0YXRlbWVudCByZXNvbHZlcyB0byB0aGUgc2FtZSB0eXBlLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdElnbm9yZWRBbGlhczogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQyMDksXG5cdFx0XHRgQWxpYXNlcyAobWVhbmluZyBhbm5vdGF0aW9ucyB0aGF0IGFyZSBtYXRjaGVkIGJ5IHBhdHRlcm5zKVxuXHRcdFx0Y2FuJ3QgYmUgYWRkZWQgb250byB0eXBlcyB0aGF0IGhhdmUgYSBjb250cmFjdCBwdXQgaW4gcGxhY2Vcblx0XHRcdGJ5IGEgYmFzZSB0eXBlLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFR5cGVTZWxmUmVmZXJlbnRpYWw6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MjExLFxuXHRcdFx0XCJUeXBlcyBjYW5ub3QgYmUgc2VsZi1yZWZlcmVudGlhbFwiKSxcblx0XHRcblx0XHQvLyMgTGlzdC1yZWxhdGVkIGZhdWx0c1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEFub255bW91c0luTGlzdEludHJpbnNpYzogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDMwMCxcblx0XHRcdFwiVHlwZXMgY29udGFpbmVkIGRpcmVjdGx5IGJ5IExpc3QtaW50cmluc2ljIHR5cGVzIGNhbm5vdCBiZSBhbm9ueW1vdXMuXCIsXG5cdFx0XHRGYXVsdFNldmVyaXR5Lndhcm5pbmcpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdExpc3RDb250cmFjdFZpb2xhdGlvbjogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQzMDEsXG5cdFx0XHRcIlRoZSBjb250YWluaW5nIGxpc3QgY2Fubm90IGNvbnRhaW4gY2hpbGRyZW4gb2YgdGhpcyB0eXBlLlwiLFxuXHRcdFx0RmF1bHRTZXZlcml0eS53YXJuaW5nKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRMaXN0SW50cmluc2ljRXh0ZW5kaW5nTGlzdDogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQzMDMsXG5cdFx0XHRcIkxpc3QgaW50cmluc2ljIHR5cGVzIGNhbm5vdCBleHRlbmQgZnJvbSBvdGhlciBsaXN0cy5cIiksXG5cdFx0XG5cdFx0LyoqIChUaGlzIGlzIHRoZSBzYW1lIHRoaW5nIGFzIGEgbGlzdCBkaW1lbnNpb25hbGl0eSBjb25mbGljdCkgKi9cblx0XHRMaXN0RXh0cmluc2ljRXh0ZW5kaW5nTm9uTGlzdDogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQzMDUsXG5cdFx0XHRcIkxpc3RzIGNhbm5vdCBleHRlbmQgZnJvbSBub24tbGlzdHMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdExpc3REaW1lbnNpb25hbERpc2NyZXBhbmN5RmF1bHQ6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MzA3LFxuXHRcdFx0YEEgdW5pb24gY2Fubm90IGJlIGNyZWF0ZWQgYmV0d2VlbiB0aGVzZSB0d28gdHlwZXNcblx0XHRcdGJlY2F1c2UgdGhleSBhcmUgbGlzdHMgb2YgZGlmZmVyZW50IGRpbWVuc2lvbnMuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0TGlzdEFubm90YXRpb25Db25mbGljdDogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQzMDksXG5cdFx0XHRgQWxsIGZyYWdtZW50cyBvZiB0aGlzIGFubm90YXRpb24gbmVlZCB0byBoYXZlXG5cdFx0XHRhIGxpc3Qgb3BlcmF0b3IgKCR7U3ludGF4Lmxpc3R9KWApLFxuXHRcdFxuXHRcdC8vIyBQYXR0ZXJuLXJlbGF0ZWQgZmF1bHRzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybkludmFsaWQ6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MDAsXG5cdFx0XHRcIkludmFsaWQgcGF0dGVybi5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybldpdGhvdXRBbm5vdGF0aW9uOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDAyLFxuXHRcdFx0XCJQYXR0ZXJuIGhhcyBubyBhbm5vdGF0aW9ucy5cIixcblx0XHRcdEZhdWx0U2V2ZXJpdHkud2FybmluZyksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybkNhbk1hdGNoRW1wdHk6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MDQsXG5cdFx0XHRcIlBhdHRlcm5zIG11c3Qgbm90IGJlIGFibGUgdG8gbWF0Y2ggYW4gZW1wdHkgaW5wdXQuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5NYXRjaGluZ1R5cGVzQWxyZWFkeUV4aXN0czogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQwNixcblx0XHRcdGBBIHBhdHRlcm4gbWF0Y2hpbmcgdGhlc2UgdHlwZXMgaGFzIFxuXHRcdFx0YWxyZWFkeSBiZWVuIGRlZmluZWQgaW4gdGhpcyBzY29wZS5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuTWF0Y2hpbmdMaXN0OiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDQwNyxcblx0XHRcdFwiQSBwYXR0ZXJuIGNhbm5vdCBtYXRjaCBhIGxpc3QgdHlwZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybkNhbk1hdGNoV2hpdGVzcGFjZU9ubHk6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MjAsXG5cdFx0XHRcIlBhdHRlcm5zIG11c3Qgbm90IGJlIGFibGUgdG8gbWF0Y2ggYW4gaW5wdXQgXCIgK1xuXHRcdFx0XCJjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuQWNjZXB0c0xlYWRpbmdXaGl0ZXNwYWNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDIyLFxuXHRcdFx0XCJQYXR0ZXJucyBtdXN0IG5vdCBiZSBhYmxlIHRvIG1hdGNoIGFuIGlucHV0IFwiICtcblx0XHRcdFwiY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVyblJlcXVpcmVzTGVhZGluZ1doaXRlc3BhY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MjQsXG5cdFx0XHRcIlBhdHRlcm5zIG11c3Qgbm90IGJlIGFibGUgdG8gbWF0Y2ggYW4gaW5wdXQgXCIgK1xuXHRcdFx0XCJjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuQWNjZXB0c1RyYWlsaW5nV2hpdGVzcGFjZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQyNixcblx0XHRcdFwiUGF0dGVybnMgbXVzdCBub3QgYmUgYWJsZSB0byBtYXRjaCBhbiBpbnB1dCBcIiArXG5cdFx0XHRcImNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5SZXF1aXJlc1RyYWlsaW5nV2hpdGVzcGFjZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQyOCxcblx0XHRcdFwiUGF0dGVybnMgbXVzdCBub3QgYmUgYWJsZSB0byBtYXRjaCBhbiBpbnB1dCBcIiArXG5cdFx0XHRcImNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5Ob25Db3ZhcmlhbnQ6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0NDAsXG5cdFx0XHRcIlBhdHRlcm4gZG9lcyBub3QgbWF0Y2ggaXQncyBiYXNlIHR5cGVzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuUGFydGlhbFdpdGhDb21iaW5hdG9yOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDQyLFxuXHRcdFx0XCJQYXJ0aWFsIHBhdHRlcm5zIGNhbm5vdCBleHBsaWNpdGx5IG1hdGNoIHRoZSBjb21tYSBjaGFyYWN0ZXIuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5zRm9ybURpc2NyZXBhbnRVbmlvbjogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQ0OTksXG5cdFx0XHRcIkEgdW5pb24gY2Fubm90IGJlIGNyZWF0ZWQgYmV0d2VlbiB0aGVzZSB0eXBlcyBiZWNhdXNlIHRoZWlyIFwiICsgXG5cdFx0XHRcImFzc29jaWF0ZWQgcGF0dGVybnMgY29uZmxpY3Qgd2l0aCBlYWNoIG90aGVyLlwiKSxcblx0XHRcblx0XHQvLyMgSW5maXggcmVsYXRlZFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4SGFzUXVhbnRpZmllcjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdC8vLzAsXG5cdFx0XHQ1MDAsXG5cdFx0XHRgSW5maXhlcyBjYW5ub3QgaGF2ZSBxdWFudGlmaWVycyAke3F1YW50aWZpZXJzfSBhcHBsaWVkIHRvIHRoZW1gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeEhhc0R1cGxpY2F0ZVRlcm06IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy8wLFxuXHRcdFx0NTAxLFxuXHRcdFx0XCJJbmZpeGVzIGNhbm5vdCBoYXZlIGR1cGxpY2F0ZSB0ZXJtcy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhIYXNTZWxmUmVmZXJlbnRpYWxUeXBlOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDEwLFxuXHRcdFx0NTAzLFxuXHRcdFx0XCJJbmZpeGVzIGNhbm5vdCBiZSBzZWxmLXJlZmVyZW50aWFsLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeE5vbkNvbnZhcmlhbnQ6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MTIsXG5cdFx0XHQ1MDUsXG5cdFx0XHRcIkluZml4ZXMgbXVzdCBiZSBjb21wYXRpYmxlIHdpdGggdGhlaXIgYmFzZXMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4Q2Fubm90RGVmaW5lTmV3VHlwZXM6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MjIsXG5cdFx0XHQ1MDcsXG5cdFx0XHRgQSB0eXBlIHJlZmVyZW5jZWQgaW4gYW4gaW5maXggbXVzdCBiZSBjb250YWluZWRcblx0XHRcdGJ5IHRoZSBwYXR0ZXJuIHN0YXRlbWVudCBkaXJlY3RseSwgb3IgYmUgY29udGFpbmVkXG5cdFx0XHRieSBvbmUgb2YgaXQncyBtYXRjaGVkIGJhc2VzLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4UmVmZXJlbmNlZFR5cGVNdXN0SGF2ZVBhdHRlcm46IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MTQsXG5cdFx0XHQ1MDksXG5cdFx0XHRcIlR5cGVzIGFwcGxpZWQgdG8gYW4gaW5maXggbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBhc3NvY2lhdGVkIHBhdHRlcm4uXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4UmVmZXJlbmNlZFR5cGVDYW5ub3RCZVJlY3Vyc2l2ZTogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQxNixcblx0XHRcdDUxMSxcblx0XHRcdFwiVHlwZXMgYXBwbGllZCB0byBhbiBpbmZpeCBtdXN0IG5vdCBjcmVhdGUgYSByZWN1cnNpdmUgc3RydWN0dXJlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeENvbnRyYWN0VmlvbGF0aW9uOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDI0LFxuXHRcdFx0NTEzLFxuXHRcdFx0XCJJbmZpeCB0eXBlIGFubm90YXRpb25zIG11c3QgZXhwbGljaXRseSBleHBhbmQgdGhlIHR5cGUgYXMgZGVmaW5lZCBieSB0aGUgYmFzZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhQb3B1bGF0aW9uQ2hhaW5pbmc6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MjYsXG5cdFx0XHQ1MTUsXG5cdFx0XHRcIlBvcHVsYXRpb24gaW5maXhlcyBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBkZWNsYXJhdGlvbnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4VXNpbmdMaXN0T3BlcmF0b3I6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy8wLFxuXHRcdFx0NTE3LFxuXHRcdFx0YEluZml4IHRlcm1zIGNhbm5vdCBlbmQgd2l0aCB0aGUgbGlzdCBvcGVyYXRvciAoJHtTeW50YXgubGlzdH0pLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4UmVmZXJlbmNpbmdMaXN0OiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDI4LFxuXHRcdFx0NTE5LFxuXHRcdFx0XCJJbmZpeGVzIGNhbm5vdCByZWZlcmVuY2UgbGlzdCB0eXBlcy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UG9ydGFiaWxpdHlJbmZpeEhhc011bHRpcGxlRGVmaW5pdGlvbnM6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MTgsXG5cdFx0XHQ1MjEsXG5cdFx0XHRgUG9ydGFiaWxpdHkgaW5maXhlcyB3aXRoIGNvbXBhdGlibGUgdHlwZXMgY2Fubm90XG5cdFx0XHRiZSBzcGVjaWZpZWQgbW9yZSB0aGFuIG9uY2UuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UG9ydGFiaWxpdHlJbmZpeEhhc1VuaW9uOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDE4LFxuXHRcdFx0NTIzLFxuXHRcdFx0XCJQb3J0YWJpbGl0eSBpbmZpeGVzIHdpdGggdW5pb25lZCB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBvcHVsYXRpb25JbmZpeEhhc011bHRpcGxlRGVmaW5pdGlvbnM6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy8wLFxuXHRcdFx0NTI1LFxuXHRcdFx0YERlY2xhcmF0aW9ucyBpbiBhIHBvcHVsYXRpb24gaW5maXggY2Fubm90IGJlIFxuXHRcdFx0ZGVmaW5lZCB0d2ljZSBpbiB0aGUgc2FtZSBwYXR0ZXJuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Tm9taW5hbEluZml4TXVzdFN1YnR5cGU6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0Ly8vNDMwLFxuXHRcdFx0NTI3LFxuXHRcdFx0XCJQYXR0ZXJucyB3aXRoIG5vbWluYWwgaW5maXhlcyByZXF1aXJlIGFuIGlucHV0IHRoYXQgaXMgXCIgK1xuXHRcdFx0XCJhIHN1YnR5cGUgb2YgdGhlIHR5cGUgc3BlY2lmaWVkLCBub3QgdGhlIHR5cGUgaXRzZWxmLlwiKSxcblx0XHRcblx0XHQvLyMgUGFyc2UgZXJyb3JzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0U3RhdGVtZW50QmVnaW5zV2l0aENvbW1hOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NjAwLFxuXHRcdFx0XCJTdGF0ZW1lbnRzIGNhbm5vdCBiZWdpbiB3aXRoIGEgY29tbWEuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFN0YXRlbWVudEJlZ2luc1dpdGhFbGxpcHNpczogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDYwMixcblx0XHRcdFwiU3RhdGVtZW50cyBjYW5ub3QgYmVnaW4gd2l0aCBhbiBlbGxpcHNpcyAoLi4uKS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0U3RhdGVtZW50QmVnaW5zV2l0aEVzY2FwZWRTcGFjZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDYwNCxcblx0XHRcdFwiU3RhdGVtZW50cyBjYW5ub3QgYmVnaW4gd2l0aCBhbiBlc2NhcGUgY2hhcmFjdGVyIChcXFxcKSBcIiArIFxuXHRcdFx0XCJ0aGF0IGlzIGZvbGxvd2VkIGJ5IGEgdGFiIG9yIHNwYWNlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRTdGF0ZW1lbnRDb250YWluc09ubHlFc2NhcGVDaGFyYWN0ZXI6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ2MDYsXG5cdFx0XHRcIkEgc3RhdGVtZW50IGNhbm5vdCBjb25zaXN0IG9mIGEgc2luZ2xlIGVzY2FwZSBjaGFyYWN0ZXIgKFxcXFwpXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFN0YXRlbWVudEJlZ2luc1dpdGhJbnZhbGlkU2VxdWVuY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ2MDgsXG5cdFx0XHRcIkEgc3RhdGVtZW50IGNhbm5vdCBiZWdpbiB3aXRoIHRoZSBzZXF1ZW5jZXM6IC8qLCAvKywgb3IgLz9cIiksXG5cdFx0XG5cdFx0Ly8jIFBhcnNpbmcgRmF1bHRzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VGFic0FuZFNwYWNlczogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMDAsXG5cdFx0XHRcIlN0YXRlbWVudCBpbmRlbnQgY29udGFpbnMgYSBtaXh0dXJlIG9mIHRhYnMgYW5kIHNwYWNlcy5cIixcblx0XHRcdEZhdWx0U2V2ZXJpdHkud2FybmluZyksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0RHVwbGljYXRlRGVjbGFyYXRpb246IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MTAwMSxcblx0XHRcdFwiRHVwbGljYXRlZCBkZWNsYXJhdGlvbi5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VW50ZXJtaW5hdGVkQ2hhcmFjdGVyU2V0OiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwMixcblx0XHRcdGBVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIHNldC4gUGF0dGVybiBoYXMgYW4gb3BlbmluZ1xuXHRcdFx0XCIke1JlZ2V4U3ludGF4RGVsaW1pdGVyLnNldFN0YXJ0fVwiIGNoYXJhY3RlciB3aXRob3V0IGEgbWF0Y2hpbmdcblx0XHRcdFwiJHtSZWdleFN5bnRheERlbGltaXRlci5zZXRFbmR9XCIgY2hhcmFjdGVyLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFVudGVybWluYXRlZEdyb3VwOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwNCxcblx0XHRcdGBVbnRlcm1pbmF0ZWQgZ3JvdXAuIFBhdHRlcm4gaGFzIGFuIG9wZW5pbmdcblx0XHRcdFwiJHtSZWdleFN5bnRheERlbGltaXRlci5ncm91cFN0YXJ0fVwiIGNoYXJhY3RlciB3aXRob3V0IGEgbWF0Y2hpbmdcblx0XHRcdFwiJHtSZWdleFN5bnRheERlbGltaXRlci5ncm91cEVuZH1cIiBjaGFyYWN0ZXIuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0RHVwbGljYXRlUXVhbnRpZmllcjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMDYsXG5cdFx0XHRgTXVsdGlwbGUgY29uc2VjdXRpdmUgcXVhbnRpZmllcnMgJHtxdWFudGlmaWVyc30gYXJlIG5vdCBhbGxvd2VkLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFVudGVybWluYXRlZEluZml4OiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwOCxcblx0XHRcdGBVbnRlcm1pbmF0ZWQgaW5maXguIFBhdHRlcm4gaGFzIGFuIG9wZW5pbmcgJHtJbmZpeFN5bnRheC5zdGFydH0sXG5cdFx0XHQke0luZml4U3ludGF4Lm5vbWluYWxTdGFydH0sICR7SW5maXhTeW50YXgucGF0dGVyblN0YXJ0fSBkZWxpbWl0ZXIgd2l0aG91dFxuXHRcdFx0YSBtYXRjaGluZyBjbG9zaW5nIGRlbGltaXRlci5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRFbXB0eVBhdHRlcm46IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDEwLFxuXHRcdFx0XCJQYXR0ZXJuIGhhcyBubyBtYXRjaGFibGUgY29udGVudC5cIilcblx0fSk7XG5cdFxuXHQvLyBBZGRpdGlvbmFsIHNhZmV0eVxuXHRBcnJheS5mcm9tKEZhdWx0cy5lYWNoKCkpLmV2ZXJ5KE9iamVjdC5mcmVlemUpO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2hhaW4gb2YgU3ViamVjdHMgdGhhdCBmb3JtIGEgcGF0aCB0byBhIHBhcnRpY3VsYXJcblx0ICogbG9jYXRpb24gd2l0aGluIGEgRG9jdW1lbnQuXG5cdCAqIFxuXHQgKiBUaGUgbGlmZXRpbWUgb2YgYSBQaHJhc2UgaXMgcGlubmVkIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KVxuXHQgKiB0byB0aGUgbGlmZXRpbWUgb2YgYSBEb2N1bWVudC4gQSBEb2N1bWVudCBvYmplY3QgYXMgYVxuXHQgKiByZWZlcmVuY2UgdG8gYSByb290LWxldmVsIFBocmFzZSwgYW5kIFBocmFzZSBvYmplY3RzIGFyZVxuXHQgKiB0aGVuIHN0b3JlIHJlZmVyZW5jZXMgdG8gdGhlaXIgbmVzdGVkIFBocmFzZSBjaGlsZHJlbi5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQaHJhc2UgZXh0ZW5kcyBBYnN0cmFjdENsYXNzXG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBDcmVhdGVzIGEgbmV3IHJvb3QgcGhyYXNlLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBuZXcoY29udGFpbmluZ0RvY3VtZW50OiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IFBocmFzZShudWxsLCBjb250YWluaW5nRG9jdW1lbnQsIFRlcm0udm9pZCwgMCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEZpbmRzIG9yIGNyZWF0ZXMgYSBQaHJhc2Ugb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCBTcGluZS5cblx0XHQgKiBSZXR1cm5zIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgU3BpbmUgcGFzc2VzIHRocm91Z2hcblx0XHQgKiBzdGF0ZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBjcnVmdC5cblx0XHQgKi9cblx0XHRzdGF0aWMgZnJvbVNwaW5lKHNwaW5lOiBTcGluZSlcblx0XHR7XG5cdFx0XHRsZXQgY3VycmVudCA9IHNwaW5lLmRvY3VtZW50LnBocmFzZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB2ZXJ0IG9mIHNwaW5lLnZlcnRlYnJhZSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKCEodmVydCBpbnN0YW5jZW9mIFNwYW4pKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuZm9yd2FyZCh2ZXJ0LmJvdW5kYXJ5LnN1YmplY3QpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY3VycmVudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgZmlyc3QtbGV2ZWwgcGhyYXNlcyBvZiB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LFxuXHRcdCAqIHNraXBwaW5nIG92ZXIgdGhlIHBocmFzZXMgdGhhdCBkb24ndCBoYXZlIGFuIGFzc29jaWF0ZWQgbm9kZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgKnJvb3RzT2YoZG9jdW1lbnQ6IERvY3VtZW50KTogSXRlcmFibGVJdGVyYXRvcjxBc3NvY2lhdGVkUGhyYXNlPlxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgcGhyYXNlIG9mIGRvY3VtZW50LnBocmFzZS5mb3J3YXJkaW5ncy52YWx1ZXMoKSlcblx0XHRcdFx0aWYgKHBocmFzZS5hc3NvY2lhdGVkTm9kZSAhPT0gbnVsbClcblx0XHRcdFx0XHR5aWVsZCBwaHJhc2UgYXMgQXNzb2NpYXRlZFBocmFzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3Rvcihcblx0XHRcdHBhcmVudDogUGhyYXNlIHwgbnVsbCxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBEb2N1bWVudCB0aGF0IHVsdGltYXRlbHlcblx0XHRcdCAqIGNvbnRhaW5zIHRoaXMgUGhyYXNlLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBjb250YWluaW5nRG9jdW1lbnQ6IERvY3VtZW50LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIHN1YmplY3QgdGhhdCBleGlzdHMgYXQgdGhlIGVuZCBvZiB0aGlzIHBocmFzZS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgdGVybWluYWw6IFN1YmplY3QsXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgbnVtYmVyIG9mIHN1YmplY3RzIGluIHRoaXMgUGhyYXNlLiBUaGlzIHZhbHVlXG5cdFx0XHQgKiBpcyBlcXVpdmFsZW50IHRvIHRoZSBsZW5ndGggb2YgdGhpcyBQaHJhc2UncyBhbmNlc3RyeS4gXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGxlbmd0aDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnBhcmVudCA9IHBhcmVudCB8fCB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBjbGFzcyA9IENsYXNzLnBocmFzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIFBocmFzZSBvYmplY3QgdGhhdCBjb250YWlucyBleGFjdGx5IG9uZVxuXHRcdCAqIGxlc3MgdGVybSB0aGFuIHRoaXMgb25lIChmcm9tIHRoZSBlbmQpLiBJbiB0aGUgY2FzZSB3aGVuIHRoZSBQaHJhc2Vcblx0XHQgKiBpcyByb290LWxldmVsLCB0aGlzIGZpZWxkIHN0b3JlcyBhIHNlbGYtcmVmZXJlbmNlLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHBhcmVudDogUGhyYXNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHBocmFzZSB0aGF0IGlzIDEgc3ViamVjdCBzaG9ydGVyIHRoYW5cblx0XHQgKiB0aGlzIG9uZSAoY291bnRpbmcgZnJvbSB0aGUgZW5kKS5cblx0XHQgKi9cblx0XHRiYWNrKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQgfHwgdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgcGhyYXNlIHRoYXQgaXMgZXh0ZW5kZWQgYnkgdGhlIHN1YmplY3Qgc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdGZvcndhcmQoc3ViamVjdDogU3ViamVjdClcblx0XHR7XG5cdFx0XHRyZXR1cm4gTWlzYy5nZXQoXG5cdFx0XHRcdHRoaXMuZm9yd2FyZGluZ3MsXG5cdFx0XHRcdHN1YmplY3QsXG5cdFx0XHRcdCgpID0+IG5ldyBQaHJhc2UodGhpcywgdGhpcy5jb250YWluaW5nRG9jdW1lbnQsIHN1YmplY3QsIHRoaXMubGVuZ3RoICsgMSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBwaHJhc2UgdGhhdCBpcyBleHRlbmRlZCBieSB0aGUgYXJyYXkgb2Ygc3ViamVjdHMgc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdGZvcndhcmREZWVwKHBhdGg6IHJlYWRvbmx5IChzdHJpbmcgfCBTdWJqZWN0KVtdKVxuXHRcdHtcblx0XHRcdGxldCBjdXJyZW50OiBQaHJhc2UgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgcGF0aClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3ViamVjdCA9IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gVGVybS5mcm9tKGl0ZW0pIDogaXRlbTtcblx0XHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuZm9yd2FyZChzdWJqZWN0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGN1cnJlbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZm9yd2FyZGluZ3MgPSBuZXcgTWFwPFN1YmplY3QsIFBocmFzZT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN1YmplY3RzIHRoYXQgY29tcG9zZSB0aGlzIHBocmFzZS5cblx0XHQgKiBOb3RlIHRoYXQgaWYgb25seSB0aGUgbnVtYmVyIG9mIHN1YmplY3RzIGlzIHJlcXVpcmVkLCB0aGUgLmxlbmd0aFxuXHRcdCAqIGZpZWxkIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICovXG5cdFx0Z2V0IHN1YmplY3RzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3ViamVjdHMgP1xuXHRcdFx0XHR0aGlzLl9zdWJqZWN0cyA6XG5cdFx0XHRcdHRoaXMuX3N1YmplY3RzID0gdGhpcy5hbmNlc3RyeS5tYXAocGggPT4gcGgudGVybWluYWwpO1xuXHRcdH1cblx0XHRwcml2YXRlIF9zdWJqZWN0czogcmVhZG9ubHkgU3ViamVjdFtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSBvZiBQaHJhc2Ugb2JqZWN0cyB0aGF0IGZvcm0gYSBwYXRoIGxlYWRpbmcgdG8gdGhpcyBQaHJhc2UuXG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIHRoZSBzdWJqZWN0cyBvZiB0aGlzIFBocmFzZSB3ZXJlIHRvIHNlcmlhbGl6ZSB0byBzb21ldGhpbmdcblx0XHQgKiBsaWtlIEFBIC8gQkIgLyBDQywgdGhlbiB0aGlzIHByb3BlcnR5IHdvdWxkIHN0b3JlIGFuIGFycmF5IG9mIDMgUGhyYXNlcyxcblx0XHQgKiB3aGljaCB3b3VsZCBzZXJpYWxpemUgdG86XG5cdFx0ICogXG5cdFx0ICogQUFcblx0XHQgKiBBQSAvIEJCXG5cdFx0ICogQUEgLyBCQiAvIENDXG5cdFx0ICogXG5cdFx0ICogTm90ZSB0aGF0IGlmIG9ubHkgdGhlIGxlbmd0aCBvZiB0aGUgcGhyYXNlIGlzIHJlcXVpcmVkLCB0aGUgLmxlbmd0aFxuXHRcdCAqIGZpZWxkIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICovXG5cdFx0Z2V0IGFuY2VzdHJ5KCk6IFBocmFzZVtdXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2FuY2VzdHJ5ID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9hbmNlc3RyeSA9IFtdO1xuXHRcdFx0XHRsZXQgY3VycmVudDogUGhyYXNlID0gdGhpcztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZSBhbmNlc3RyeSBuZXZlciBpbmNsdWRlcyB0aGUgMC1sZW5ndGggcGhyYXNlXG5cdFx0XHRcdC8vIGF0dGFjaGVkIHRvIGEgZG9jdW1lbnQsIGFuZCBhbHdheXMgaW5jbHVkZXMgaXRzZWxmLlxuXHRcdFx0XHR3aGlsZSAoY3VycmVudC5sZW5ndGggPiAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5fYW5jZXN0cnkudW5zaGlmdChjdXJyZW50KTtcblx0XHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2FuY2VzdHJ5O1xuXHRcdH1cblx0XHRwcml2YXRlIF9hbmNlc3RyeTogKFBocmFzZVtdIHwgbnVsbCkgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQaHJhc2UsIHN1aXRhYmxlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHVyaSA9IHRoaXMuY29udGFpbmluZ0RvY3VtZW50LnVyaS50b1N0cmluZygpO1xuXHRcdFx0Y29uc3QgcGF0aCA9IHRoaXMuc3ViamVjdHMubWFwKHN1YiA9PiBzdWIudG9TdHJpbmcoKSkuam9pbihcIi9cIik7XG5cdFx0XHRyZXR1cm4gdXJpICsgXCIvL1wiICsgcGF0aDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogRm9yIHJlYXNvbnMgcmVsYXRlZCB0byBwZXJmb3JtYW5jZSBhbmQgYXJjaGl0ZWN0dXJhbCBzaW1wbGljaXR5LFxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBOb2RlIHRvIHdoaWNoIHRoaXMgUGhyYXNlIGlzIGFzc29jaWF0ZWQgaXNcblx0XHQgKiBzdG9yZWQgaGVyZS4gVGhpcyBpcyBzbyB0aGF0IHdlIGNhbiBhdm9pZCBtYW5hZ2luZyBhIHNlcGFyYXRlXG5cdFx0ICogaW5kZXggdG8gbWFuYWdlIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSB0d28gb2JqZWN0cy5cblx0XHQgKiBQaHJhc2VzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGVpciBhc3NvY2lhdGVkIE5vZGUsIGFuZCBzbyBpbiB0aGlzXG5cdFx0ICogY2FzZSwgdGhpcyBmaWVsZCBpcyBudWxsLlxuXHRcdCAqIFxuXHRcdCAqIFRoaXMgZmllbGQgc2hvdWxkIG9ubHkgYmUgYXNzaWduZWQgZnJvbSB3aXRoaW4gdGhlIE5vZGUgY2xhc3MuXG5cdFx0ICovXG5cdFx0YXNzb2NpYXRlZE5vZGU6IE5vZGUgfCBudWxsID0gbnVsbDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIHR5cGUgdGhhdCBkZXNjcmliZXMgYSBQaHJhc2Ugb2JqZWN0IHdpdGggYSBub24tbnVsbCAuYXNzb2NpYXRlZE5vZGUgZmllbGQuXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBBc3NvY2lhdGVkUGhyYXNlID0gUGhyYXNlICYgeyByZWFkb25seSBhc3NvY2lhdGVkTm9kZTogTm9kZTsgfTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdGNvbnN0IGhhc2hSZWdleCA9IG5ldyBSZWdFeHAoXCJbYS1mMC05XXtcIiArIEhhc2gubGVuZ3RoICsgXCJ9XCIsIFwiaVwiKTtcblx0XG5cdC8qKlxuXHQgKiBBIHJlZmVyZW5jZSB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGEgdW5pcXVlIHRlcm0gd2l0aGluIGEgZG9jdW1lbnQuXG5cdCAqIEEgdGVybSBtYXkgYmUgdGhlIG5hbWUgb2YgYSB0eXBlLCBzdWNoIGFzIFwiUHJvZHVjdFwiLCBvciBpdCBtYXkgYWxzb1xuXHQgKiBiZSBzb21lIHR5cGUgYWxpYXMgdG8gYmUgbWF0Y2hlZCBieSBhIHBhdHRlcm4sIHN1Y2ggYXMgXCIxMGNtXCIuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVGVybSBleHRlbmRzIEFic3RyYWN0Q2xhc3Ncblx0e1xuXHRcdC8qKlxuXHRcdCAqIEZpbmRzIG9yIGNyZWF0ZXMgYSBUZXJtIG9iamVjdCB3aG9zZSBpbm5lciB0ZXh0Q29udGVudCBpcyBlcXVhbFxuXHRcdCAqIHRvIHRoZSB0ZXh0Q29udGVudCB2YWx1ZSBzcGVjaWZpZWQuIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYWNxdWlyZVxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIGEgVGVybSwgaW5zdGVhZCBvZiB1c2luZyB0aGUgVGVybSBjb25zdHJ1Y3RvciAod2hpY2hcblx0XHQgKiBpcyBwcml2YXRlKSwgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXMgb25seSBldmVyIG9uZSBpbnN0YW5jZSBvZiBhIFRlcm1cblx0XHQgKiBmb3IgZWFjaCB1bmlxdWUgdGV4dENvbnRlbnQgdmFsdWUuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSB0ZXJtIG9iamVjdCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBzdHJpbmcgc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBmcm9tKHRleHRDb250ZW50OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWxGcm9tKHVuZXNjYXBlKHRleHRDb250ZW50KSwgZmFsc2UpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyBpbnRlcm5hbEZyb20odGV4dENvbnRlbnQ6IHN0cmluZywgZm9yY2VTaW5ndWxhcjogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRyZXR1cm4gTWlzYy5nZXQoXG5cdFx0XHRcdHRoaXMuY2FjaGUsXG5cdFx0XHRcdHRleHRDb250ZW50LFxuXHRcdFx0XHQoKSA9PiBuZXcgVGVybSh0ZXh0Q29udGVudCwgZm9yY2VTaW5ndWxhcikpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBjYWNoZSBvZiBhbGwgVGVybXMgY3JlYXRlZCBieSB0aGUgY29tcGlsZXIuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgVGVybT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gZW1wdHktc3RyaW5nIHRlcm0sIHdoaWNoIGlzIHVzZWQgYXMgYSBtYXJrZXIgdGVybVxuXHRcdCAqIHRvIHJlcHJlc2VudCB3aGF0IGlzIGV2ZW50dWFsbHkgcHJlc2VudGVkIGFzIGFuIGFub255bW91cyB0eXBlLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyByZWFkb25seSB2b2lkID0gVGVybS5mcm9tKFwiXCIpO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgY29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgaW5uZXIgY29udGVudCBvZiB0aGlzIFRlcm0uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHRleHRDb250ZW50OiBzdHJpbmcsXG5cdFx0XHRmb3JjZVNpbmd1bGFyOiBib29sZWFuKVxuXHRcdHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmhhc2ggPSB0aGlzLnRyeUV4dHJhY3RIYXNoKHRleHRDb250ZW50KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbGlzdFRvayA9IFN5bnRheC5saXN0O1xuXHRcdFx0Y29uc3QgdG9rTGVuID0gbGlzdFRvay5sZW5ndGg7XG5cdFx0XHRjb25zdCBpc0xpc3QgPSB0ZXh0Q29udGVudC5sZW5ndGggPiB0b2tMZW4gKyAxICYmIHRleHRDb250ZW50LnNsaWNlKC10b2tMZW4pID09PSBsaXN0VG9rO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnNpbmd1bGFyID0gaXNMaXN0ICYmICFmb3JjZVNpbmd1bGFyID9cblx0XHRcdFx0VGVybS5pbnRlcm5hbEZyb20odGV4dENvbnRlbnQuc2xpY2UoMCwgLXRva0xlbiksIHRydWUpIDpcblx0XHRcdFx0dGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgY2xhc3MgPSBDbGFzcy50ZXJtO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgdHJ5RXh0cmFjdEhhc2godGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlbGltID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbjtcblx0XHRcdGNvbnN0IGRlbGltRXNjID0gZXNjYXBlKGRlbGltKTtcblx0XHRcdGNvbnN0IGRlbGltTGVuID1cblx0XHRcdFx0dGV4dC5zdGFydHNXaXRoKGRlbGltKSA/IGRlbGltLmxlbmd0aCA6XG5cdFx0XHRcdHRleHQuc3RhcnRzV2l0aChkZWxpbUVzYykgPyBkZWxpbUVzYy5sZW5ndGggOlxuXHRcdFx0XHQtMTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaGFzaExlbiA9IEhhc2gubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGVsaW1MZW4gPCAwIHx8IHRleHQubGVuZ3RoIDwgZGVsaW1MZW4gKyBoYXNoTGVuICsgMSlcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGhhc2ggPSB0ZXh0LnN1YnN0cihkZWxpbUxlbiwgaGFzaExlbik7XG5cdFx0XHRpZiAoaGFzaC5sZW5ndGggIT09IGhhc2hMZW4gfHwgIWhhc2hSZWdleC50ZXN0KGhhc2gpKVxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgd2hldGhlciB0aGlzIGNvbXBvbmVudCByZXByZXNlbnRzIGEgcGF0dGVybi4gKi9cblx0XHRnZXQgaXNQYXR0ZXJuKCkgeyByZXR1cm4gdGhpcy5oYXNoICE9PSBcIlwiOyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBzaW5ndWxhciB2ZXJzaW9uIG9mIHRoaXMgVGVybS5cblx0XHQgKiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgdGVybSdzIHRleHRDb250ZW50IGlzXG5cdFx0ICogXCJTb21lVHlwZS4uLlwiLCB0aGlzIGZpZWxkIHJlZmVycyB0byB0aGUgVGVybSBvYmplY3Qgd2hvc2Vcblx0XHQgKiB0ZXh0Q29udGVudCBpcyBcIlNvbWVUeXBlXCIuXG5cdFx0ICogXG5cdFx0ICogSW4gdGhlIGNhc2Ugd2hlbiB0aGlzIFRlcm0gZG9lcyBub3QgY29uZm9ybSB0byB0aGUgbGlzdCBzeW50YXgsXG5cdFx0ICogdGhlIGZpZWxkIHN0b3JlcyBhIHNlbGYtcmVmZXJlbmNlIGJhY2sgdG8gdGhpcyBUZXJtIG9iamVjdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzaW5ndWxhcjogVGVybTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBUZXJtIGNvbmZvcm1zIHRvIHRoZSBsaXN0IHN5bnRheC5cblx0XHQgKi9cblx0XHRnZXQgaXNMaXN0KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zaW5ndWxhciAhPT0gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcGF0dGVybiBoYXNoLCBpbiB0aGUgY2FzZSB3aGVuIHRoaXMgVGVybVxuXHRcdCAqIHJlbGF0ZXMgdG8gYSBwYXR0ZXJuLiBTdG9yZXMgYW4gZW1wdHkgc3RyaW5nIGluIG90aGVyIGNhc2VzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgaGFzaDogc3RyaW5nID0gXCJcIjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIFRlcm0gdG8gaXQncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFxuXHRcdCAqIEBwYXJhbSBlc2NhcGUgSWYgdHJ1ZSwgcHJlc2VydmVzIGFueSBuZWNlc3Nhcnlcblx0XHQgKiBlc2NhcGluZyByZXF1aXJlZCB0byBlbnN1cmUgdGhlIHRlcm0gc3RyaW5nXG5cdFx0ICogaXMgaW4gYSBwYXJzYWJsZSBmb3JtYXQuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoZXNjYXBlID0gVGVybUVzY2FwZUtpbmQubm9uZSlcblx0XHR7XG5cdFx0XHRjb25zdCB2YWwgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0c3dpdGNoIChlc2NhcGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjYXNlIFRlcm1Fc2NhcGVLaW5kLm5vbmU6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFRlcm1Fc2NhcGVLaW5kLmRlY2xhcmF0aW9uOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIFJlZ2V4IGRlbGltaXRlcnMgYXJlIGVzY2FwZWQgaWYgYW5kIG9ubHkgaWYgXG5cdFx0XHRcdFx0XHQvLyB0aGV5J3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSB0ZXJtLlxuXHRcdFx0XHRcdFx0Y29uc3QgZGxtUmVnID0gbmV3IFJlZ0V4cChcIl5cIiArIFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW4pO1xuXHRcdFx0XHRcdFx0Y29uc3Qgam50UmVnUyA9IG5ldyBSZWdFeHAoU3ludGF4LmpvaW50ICsgU3ludGF4LnNwYWNlKTtcblx0XHRcdFx0XHRcdGNvbnN0IGpudFJlZ1QgPSBuZXcgUmVnRXhwKFN5bnRheC5qb2ludCArIFN5bnRheC50YWIpO1xuXHRcdFx0XHRcdFx0Y29uc3QgY21iUmVnID0gbmV3IFJlZ0V4cChTeW50YXguY29tYmluYXRvcik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnRleHRDb250ZW50XG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKGRsbVJlZywgU3ludGF4LmVzY2FwZUNoYXIgKyBSZWdleFN5bnRheERlbGltaXRlci5tYWluKVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZShqbnRSZWdTLCBTeW50YXguZXNjYXBlQ2hhciArIFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSlcblx0XHRcdFx0XHRcdFx0LnJlcGxhY2Uoam50UmVnVCwgU3ludGF4LmVzY2FwZUNoYXIgKyBTeW50YXguam9pbnQgKyBTeW50YXgudGFiKVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZShjbWJSZWcsIFN5bnRheC5lc2NhcGVDaGFyICsgU3ludGF4LmNvbWJpbmF0b3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFRlcm1Fc2NhcGVLaW5kLmFubm90YXRpb246XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVnID0gbmV3IFJlZ0V4cChTeW50YXguY29tYmluYXRvcik7XG5cdFx0XHRcdFx0XHRjb25zdCByZXAgPSBTeW50YXguZXNjYXBlQ2hhciArIFN5bnRheC5jb21iaW5hdG9yO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dENvbnRlbnQucmVwbGFjZShyZWcsIHJlcCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdmFsICsgKHRoaXMuaXNMaXN0ID8gU3ludGF4Lmxpc3QgOiBcIlwiKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IGRlc2NyaWJlcyB0aGUgdmFyaW91cyB3YXlzXG5cdCAqIHRvIGhhbmRsZSBlc2NhcGluZyB3aGVuIHNlcmlhbGl6aW5nIGEgVGVybS5cblx0ICogVGhpcyBlbnVtZXJhdGlvbiBpcyB1c2VkIHRvIGFkZHJlc3MgdGhlIGRpZmZlcmVuY2VzXG5cdCAqIGluIHRoZSB3YXkgdGVybXMgY2FuIGJlIHNlcmlhbGl6ZWQsIHdoaWNoIGNhbiBcblx0ICogZGVwZW5kIG9uIHdoZXRoZXIgdGhlIHRlcm0gaXMgYSBkZWNsYXJhdGlvbiBvclxuXHQgKiBhbiBhbm5vdGF0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gVGVybUVzY2FwZUtpbmRcblx0e1xuXHRcdG5vbmUgPSAwLFxuXHRcdGRlY2xhcmF0aW9uID0gMSxcblx0XHRhbm5vdGF0aW9uID0gMlxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogSW5maW5pdGUgaW5jcmVtZW50YWwgY291bnRlci5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBWZXJzaW9uU3RhbXBcblx0e1xuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBuZXh0KClcblx0XHR7XG5cdFx0XHRjb25zdCBjcmVhdGVTdGFtcCA9IChzdGFtcDogVFN0YW1wTnVtYmVyKSA9PlxuXHRcdFx0XHRuZXcgVmVyc2lvblN0YW1wKE9iamVjdC5mcmVlemUoc3RhbXApKTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLm5leHRTdGFtcCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVTdGFtcCh0aGlzLm5leHRTdGFtcCA9IEJpZ0ludCgxKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8xMDU3NFxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5uZXh0U3RhbXAgPT09IFwiYmlnaW50XCIpXG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW1wKCsrdGhpcy5uZXh0U3RhbXApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5uZXh0U3RhbXAgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMubmV4dFN0YW1wID0gWzFdO1xuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVTdGFtcCh0aGlzLm5leHRTdGFtcC5zbGljZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbnMgPSB0aGlzLm5leHRTdGFtcDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5zKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIFBvbHlmaWxsIGluZmluaXRlIG51bWJlciBjb3VudGVyIGZvciB1c2UgaW4gdGhlIFxuXHRcdFx0XHRcdC8vIGFic2VuY2Ugb2YgYSBuYXRpdmUgQmlnSW50IGltcGxlbWVudGF0aW9uLlxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBucy5sZW5ndGg7IGktLSA+IDA7KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChuc1tpXSA9PT0gOTk5Xzk5OV85OTlfOTk5KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRuc1tpXSA9IDA7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMClcblx0XHRcdFx0XHRcdFx0XHRucy51bnNoaWZ0KDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRuc1tpXSsrO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW1wKG5zLnNsaWNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgbmV4dFN0YW1wOiBUU3RhbXBOdW1iZXI7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RhbXA6IFRTdGFtcE51bWJlcikgeyB9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0bmV3ZXJUaGFuKG90aGVyU3RhbXA6IFZlcnNpb25TdGFtcClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFtcCA+IG90aGVyU3RhbXAuc3RhbXA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnN0YW1wKSA/XG5cdFx0XHRcdHRoaXMuc3RhbXAuam9pbihcIlwiKSA6XG5cdFx0XHRcdHRoaXMuc3RhbXAudG9TdHJpbmcoKTtcblx0XHR9XG5cdH1cblx0XG5cdHR5cGUgVFN0YW1wTnVtYmVyID0gYmlnaW50IHwgcmVhZG9ubHkgYmlnaW50W10gfCBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBBbHBoYWJldFJhbmdlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGZyb206IG51bWJlcixcblx0XHRcdHJlYWRvbmx5IHRvOiBudW1iZXIpXG5cdFx0eyB9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBBbHBoYWJldFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoLi4ucmFuZ2VzOiBBbHBoYWJldFJhbmdlW10pXG5cdFx0e1xuXHRcdFx0dGhpcy5yYW5nZXMgPSByYW5nZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgZGVmaW5lZCBpbiB0aGUgYWxwaGFiZXQuXG5cdFx0ICovXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8PSByYW5nZS50bzsgaSsrKVxuXHRcdFx0XHRcdHlpZWxkIFN0cmluZy5mcm9tQ29kZVBvaW50KGkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBkZWZpbmVkIHJhbmdlcyBpbiB0aGUgYWxwaGFiZXQsXG5cdFx0ICogZXhjbHVkaW5nIHRoZSB3aWxkY2FyZCByYW5nZS5cblx0XHQgKi9cblx0XHQqZWFjaFJhbmdlKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXNXaWxkY2FyZCgpKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCByYW5nZUlkeCA9IDA7IHJhbmdlSWR4IDwgdGhpcy5yYW5nZXMubGVuZ3RoIC0gMTspXG5cdFx0XHRcdFx0eWllbGQgdGhpcy5yYW5nZXNbcmFuZ2VJZHgrK107XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdHlpZWxkIHJhbmdlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoc3ltYm9sOiBzdHJpbmcgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKHN5bWJvbCA9PT0gQWxwaGFiZXQud2lsZGNhcmQpXG5cdFx0XHRcdHJldHVybiB0aGlzLmhhc1dpbGRjYXJkKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvZGUgPSB0b0NoYXJDb2RlKHN5bWJvbCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdGlmIChyYW5nZS5mcm9tID49IGNvZGUgJiYgcmFuZ2UudG8gPD0gY29kZSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXNXaWxkY2FyZCgpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgcm5nID0gdGhpcy5yYW5nZXM7XG5cdFx0XHRyZXR1cm4gcm5nLmxlbmd0aCA+IDAgJiYgcm5nW3JuZy5sZW5ndGggLSAxXSA9PT0gQWxwaGFiZXQud2lsZGNhcmRSYW5nZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QsIFxuXHRcdCAqIGZvciB0ZXN0aW5nIGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN5bWJvbHM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdHN5bWJvbHMucHVzaChyYW5nZS5mcm9tID09PSByYW5nZS50byA/XG5cdFx0XHRcdFx0U3RyaW5nLmZyb21Db2RlUG9pbnQocmFuZ2UuZnJvbSkgOlxuXHRcdFx0XHRcdFN0cmluZy5mcm9tQ29kZVBvaW50KHJhbmdlLmZyb20pICsgXCIgLSBcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KHJhbmdlLnRvKSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmhhc1dpbGRjYXJkKCkpXG5cdFx0XHRcdHN5bWJvbHMucHVzaChBbHBoYWJldC53aWxkY2FyZCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIltcIiArIHN5bWJvbHMuam9pbihcIiwgXCIpICsgXCJdXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcmFuZ2VzOiByZWFkb25seSBBbHBoYWJldFJhbmdlW10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBzcGVjaWFsIHRva2VuIHRoYXQgdGhlIHN5c3RlbSB1bmRlcnN0YW5kcyB0byBiZSB0aGVcblx0XHQgKiB3aWxkY2FyZCBjaGFyYWN0ZXIuIFRoZSBsZW5ndGggb2YgdGhlIHRva2VuIGlzIGxvbmdlciB0aGFuIGFueVxuXHRcdCAqIG90aGVyIHRva2VuIHRoYXQgY291bGQgb3RoZXJ3aXNlIGJlIGZvdW5kIGluIHRoZSBhbHBoYWJldC5cblx0XHQgKi9cblx0XHRzdGF0aWMgcmVhZG9ubHkgd2lsZGNhcmQgPSBcIigod2lsZCkpXCI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcmFuZ2UgdGhhdCByZXByZXNlbnRzIHRoZSB3aWxkY2FyZCBjaGFyYWN0ZXIuXG5cdFx0ICogVGhlIHJhbmdlIG9mIHRoZSB3aWxkY2FyZCBpcyBwb3NpdGl2ZSBpbmZpbml0eSBpbiBib3RoIGRpcmVjdGlvbnMsXG5cdFx0ICogdG8gZW5zdXJlIHRoYXQgaXQncyBhbHdheXMgc29ydGVkIGxhc3QgaW4gdGhlIHJhbmdlcyBhcnJheS5cblx0XHQgKi9cblx0XHRzdGF0aWMgcmVhZG9ubHkgd2lsZGNhcmRSYW5nZSA9IE9iamVjdC5mcmVlemUobmV3IEFscGhhYmV0UmFuZ2UoSW5maW5pdHksIEluZmluaXR5KSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBkaXNwb3NhYmxlIGNsYXNzIGZvciBlYXNpbHkgY3JlYXRpbmcgQWxwaGFiZXQgaW5zdGFuY2VzXG5cdCAqIChUaGlzIGRlc2lnbiBhdm9pZHMgaW50cm9kdWNpbmcgbXV0YWJpbGl0eSBpbnRvIHRoZSBBbHBoYWJldCBjbGFzcykuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQWxwaGFiZXRCdWlsZGVyXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3RvciguLi5vdGhlcnM6IChBbHBoYWJldCB8IEFscGhhYmV0UmFuZ2UgfCBzdHJpbmcgfCBudW1iZXIpW10pXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIG90aGVycylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBBbHBoYWJldClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHRoZVJhbmdlcyA9IEFycmF5LmZyb20oaXRlbS5lYWNoUmFuZ2UoKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCByYW5nZSBvZiB0aGVSYW5nZXMpXG5cdFx0XHRcdFx0XHR0aGlzLnJhbmdlcy5wdXNoKHJhbmdlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQWxwaGFiZXRSYW5nZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMucmFuZ2VzLnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgY29kZSA9IHRvQ2hhckNvZGUoaXRlbSk7XG5cdFx0XHRcdFx0dGhpcy5yYW5nZXMucHVzaChuZXcgQWxwaGFiZXRSYW5nZShjb2RlLCBjb2RlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhbiBlbnRyeSB0byB0aGUgYWxwaGFiZXQuXG5cdFx0ICogSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGVudHJ5IHJlZmVycyB0byBhXG5cdFx0ICogc2luZ2xlIGNoYXJhY3RlciwgcmF0aGVyIHRoYW4gYSByYW5nZSBvZiBjaGFyYWN0ZXJzLlxuXHRcdCAqL1xuXHRcdGFkZChmcm9tOiBzdHJpbmcgfCBudW1iZXIsIHRvPzogc3RyaW5nIHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRvQXNOdW0gPSB0byA9PT0gdW5kZWZpbmVkID8gZnJvbSA6IHRvO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnJhbmdlcy5wdXNoKG5ldyBBbHBoYWJldFJhbmdlKFxuXHRcdFx0XHR0b0NoYXJDb2RlKGZyb20pLFxuXHRcdFx0XHR0b0NoYXJDb2RlKHRvQXNOdW0pKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGRXaWxkKClcblx0XHR7XG5cdFx0XHR0aGlzLnJhbmdlcy5wdXNoKEFscGhhYmV0LndpbGRjYXJkUmFuZ2UpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIG9wdGltaXplZCBBbHBoYWJldCBpbnN0YW5jZXMgY29tcG9zZWQgXG5cdFx0ICogZnJvbSB0aGUgY2hhcmFjdGVycyBhbmQgcmFuZ2VzIGFwcGxpZWQgdG8gdGhpcyBBbHBoYWJldEJ1aWxkZXIuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGludmVydCBJbiB0cnVlLCBjYXVzZXMgdGhlIGVudHJpZXMgaW4gdGhlIGdlbmVyYXRlZFxuXHRcdCAqIEFscGhhYmV0IHRvIGJlIHJldmVyc2VkLCBzdWNoIHRoYXQgZXZlcnkgY2hhcmFjdGVyIG1hcmtlZFxuXHRcdCAqIGFzIGluY2x1ZGVkIGlzIGV4Y2x1ZGVkLCBhbmQgdmljZSB2ZXJzYS5cblx0XHQgKi9cblx0XHR0b0FscGhhYmV0KGludmVydD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucmFuZ2VzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIG5ldyBBbHBoYWJldCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByYW5nZXMgPSB0aGlzLnJhbmdlc1xuXHRcdFx0XHQuc2xpY2UoKVxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcblx0XHRcdFxuXHRcdFx0Ly8gUXVpY2sgb3B0aW1pemF0aW9uIG9mIHJhbmdlc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoIC0gMTsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB0aGlzUmFuZ2UgPSByYW5nZXNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoaSA8IHJhbmdlcy5sZW5ndGggLSAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dFJhbmdlID0gcmFuZ2VzW2kgKyAxXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBPbWl0XG5cdFx0XHRcdFx0aWYgKHRoaXNSYW5nZS50byA+PSBuZXh0UmFuZ2UudG8pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmFuZ2VzLnNwbGljZShpICsgMSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENvbmNhdFxuXHRcdFx0XHRcdGVsc2UgaWYgKHRoaXNSYW5nZS50byArIDEgPj0gbmV4dFJhbmdlLmZyb20pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmFuZ2VzLnNwbGljZShpICsgMSwgMSk7XG5cdFx0XHRcdFx0XHRyYW5nZXNbaV0gPSBuZXcgQWxwaGFiZXRSYW5nZSh0aGlzUmFuZ2UuZnJvbSwgbmV4dFJhbmdlLnRvKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTmV4dFxuXHRcdFx0XHRcdGVsc2UgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGludmVydClcblx0XHRcdHtcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVGhpcyBhbHBoYWJldCBpbnZlcnNpb24gYWxnb3JpdGhtIGhhcyB0byBkZWFsIHdpdGggNCBjYXNlcyxcblx0XHRcdFx0Ly8gZGVwZW5kaW5nIG9uIHRoZSBwYXR0ZXJuIG9mIHRoZSByYW5nZXMgYW5kIHRoZSBzcGFjZXMuXG5cdFx0XHRcdC8vIEFmdGVyIHRoZSByYW5nZXMgYXJlIHNvcnRlZCBhbmQgb3B0aW1pemVkLCB0aGUgcmFuZ2VzXG5cdFx0XHRcdC8vIGFycmF5IHJlcHJlc2VudHMgYSBsYXlvdXQgdGhhdCBhbHRlcm5hdGVzIGJldHdlZW4gcmFuZ2VzXG5cdFx0XHRcdC8vIGFuZCBzcGFjZXMuIFRoZXJlIGFyZSA0IGJhc2ljIGxheW91dHMgKFIgPSBSYW5nZSwgUyA9IFNwYWNlKTpcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gUlNSUyAtIFN0YXJ0cyB3aXRoIGEgcmFuZ2UsIGVuZHMgd2l0aCBhIHNwYWNlXG5cdFx0XHRcdC8vIFNSU1IgLSBTdGFydHMgd2l0aCBhIHNwYWNlLCBlbmRzIHdpdGggYSByYW5nZVxuXHRcdFx0XHQvLyBSU1JTUiAtIFN0YXJ0cyB3aXRoIGEgcmFuZ2UsIGVuZHMgd2l0aCBhIHJhbmdlXG5cdFx0XHRcdC8vIFNSU1JTIC0gU3RhcnRzIHdpdGggYSBzcGFjZSwgZW5kcyB3aXRoIGEgc3BhY2Vcblx0XHRcdFx0Ly8gXG5cdFx0XHRcdC8vIFRoZSBhbGdvcml0aG0gZGVhbCB3aXRoIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlXG5cdFx0XHRcdC8vIHNlcGFyYXRlbHksIHRvIG1ha2UgdGhlIGxvb3BpbmcgbGVzcyBjb21wbGljYXRlZC4gXG5cdFx0XHRcdC8vIFxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmFuZ2VzSW52OiBBbHBoYWJldFJhbmdlW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlc1plcm8gPSByYW5nZXNbMF0uZnJvbSA9PT0gMDtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlc01heCA9IGxhc3RSYW5nZS50byA9PT0gVW5pY29kZU1heDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtYXRjaGVzWmVybyAmJiBtYXRjaGVzTWF4ICYmIHJhbmdlcy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBBbHBoYWJldCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFtYXRjaGVzWmVybylcblx0XHRcdFx0XHRyYW5nZXNJbnYucHVzaChuZXcgQWxwaGFiZXRSYW5nZSgwLCByYW5nZXNbMF0uZnJvbSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZW5kQXQgPSBtYXRjaGVzTWF4ID9cblx0XHRcdFx0XHRsYXN0UmFuZ2UuZnJvbSA6XG5cdFx0XHRcdFx0VW5pY29kZU1heDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcHJldlJhbmdlRW5kID0gcmFuZ2VzW2ldLnRvO1xuXHRcdFx0XHRcdGNvbnN0IG5leHRSYW5nZVN0YXJ0ID0gaSA8IHJhbmdlcy5sZW5ndGggLSAxID8gXG5cdFx0XHRcdFx0XHRyYW5nZXNbaSArIDFdLmZyb20gOlxuXHRcdFx0XHRcdFx0VW5pY29kZU1heCArIDE7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmFuZ2VzSW52LnB1c2gobmV3IEFscGhhYmV0UmFuZ2UoXG5cdFx0XHRcdFx0XHRwcmV2UmFuZ2VFbmQgKyAxLFxuXHRcdFx0XHRcdFx0bmV4dFJhbmdlU3RhcnQgLSAxKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5leHRSYW5nZVN0YXJ0ID49IGVuZEF0KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmICghbWF0Y2hlc01heClcblx0XHRcdFx0XHRyYW5nZXNJbnYucHVzaChuZXcgQWxwaGFiZXRSYW5nZShsYXN0UmFuZ2UuZnJvbSwgVW5pY29kZU1heCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IEFscGhhYmV0KC4uLnJhbmdlcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcmFuZ2VzOiBBbHBoYWJldFJhbmdlW10gPSBbXTtcblx0fVxuXG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIHRvQ2hhckNvZGUoc3ltYm9sOiBzdHJpbmcgfCBudW1iZXIpXG5cdHtcblx0XHRyZXR1cm4gdHlwZW9mIHN5bWJvbCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRzeW1ib2wuY2hhckNvZGVBdCgwKSA6XG5cdFx0XHRzeW1ib2w7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUcmFuc2l0aW9uTWFwXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcih0cmFuc2l0aW9uTGl0ZXJhbD86IElUcmFuc2l0aW9uTGl0ZXJhbClcblx0XHR7XG5cdFx0XHRjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBUcmFuc2l0aW9uU3RhdGU+KCk7XG5cdFx0XHRcblx0XHRcdGlmICh0cmFuc2l0aW9uTGl0ZXJhbClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFRleHQsIHRzbE9iamVjdF0gb2YgT2JqZWN0LmVudHJpZXModHJhbnNpdGlvbkxpdGVyYWwpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhdGVJZCA9IHBhcnNlSW50KHN0YXRlSWRUZXh0LCAxMCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHN0YXRlSWQgIT09IHN0YXRlSWQpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCF0c2xPYmplY3QgfHwgdHlwZW9mIHRzbE9iamVjdCAhPT0gXCJvYmplY3RcIilcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0c2w6IElUcmFuc2l0aW9uU3RhdGVMaXRlcmFsID0gdHNsT2JqZWN0O1xuXHRcdFx0XHRcdHRyYW5zaXRpb25zLnNldChzdGF0ZUlkLCBuZXcgVHJhbnNpdGlvblN0YXRlKHRzbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkLCB0cmFuc2l0aW9uU3RhdGVdIG9mIHRoaXMudHJhbnNpdGlvbnMuZW50cmllcygpKVxuXHRcdFx0XHR5aWVsZCA8W251bWJlciwgVHJhbnNpdGlvblN0YXRlXT5bc3RhdGVJZCwgdHJhbnNpdGlvblN0YXRlXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y2xvbmUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IG5ldyBUcmFuc2l0aW9uTWFwKHt9KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy50cmFuc2l0aW9ucylcblx0XHRcdFx0b3V0LnRyYW5zaXRpb25zLnNldChrZXksIHZhbHVlLmNsb25lKCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHJhbnNpdGlvblN0YXRlID0gdGhpcy50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdGlmICghdHJhbnNpdGlvblN0YXRlKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChzeW1ib2wgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuICEhdHJhbnNpdGlvblN0YXRlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJhbnNpdGlvblN0YXRlLmhhcyhzeW1ib2wpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQoc3RhdGVJZDogbnVtYmVyKTogVHJhbnNpdGlvblN0YXRlIHwgdW5kZWZpbmVkO1xuXHRcdGdldChzdGF0ZUlkOiBudW1iZXIsIHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXHRcdGdldChzdGF0ZUlkOiBudW1iZXIsIHN5bWJvbD86IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCB0cmFuc2l0aW9uU3RhdGUgPSB0aGlzLnRyYW5zaXRpb25zLmdldChzdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0aWYgKCF0cmFuc2l0aW9uU3RhdGUpXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcblx0XHRcdGlmIChzeW1ib2wgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb25TdGF0ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRyYW5zaXRpb25TdGF0ZS5nZXQoc3ltYm9sKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWNxdWlyZShzdGF0ZUlkOiBudW1iZXIpOiBUcmFuc2l0aW9uU3RhdGU7XG5cdFx0YWNxdWlyZShzdGF0ZUlkOiBudW1iZXIsIHN5bWJvbDogc3RyaW5nKTogbnVtYmVyO1xuXHRcdGFjcXVpcmUoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHJhbnNpdGlvblN0YXRlID0gdGhpcy50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdGlmICghdHJhbnNpdGlvblN0YXRlKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHN5bWJvbCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvblN0YXRlO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdWJTdGF0ZUlkID0gdHJhbnNpdGlvblN0YXRlLmdldChzeW1ib2wpO1xuXHRcdFx0aWYgKHN1YlN0YXRlSWQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdWJTdGF0ZUlkO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqZWFjaFN0YXRlSWQoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVJZCBvZiB0aGlzLnRyYW5zaXRpb25zLmtleXMoKSlcblx0XHRcdFx0eWllbGQgc3RhdGVJZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QsIFxuXHRcdCAqIGZvciB0ZXN0aW5nIGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IFtcIntcIl07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3N0YXRlSWQsIHRTdGF0ZV0gb2YgdGhpcy50cmFuc2l0aW9ucylcblx0XHRcdFx0b3V0LnB1c2goXCJcXHRcIiArIHN0YXRlSWQgKyBcIjogXCIgKyB0U3RhdGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcblx0XHRcdG91dC5wdXNoKFwifVwiKTtcblx0XHRcdHJldHVybiBvdXQuam9pbihcIlxcblwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJvdGVjdGVkIHJlYWRvbmx5IHRyYW5zaXRpb25zOiBNYXA8bnVtYmVyLCBUcmFuc2l0aW9uU3RhdGU+O1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTXV0YWJsZVRyYW5zaXRpb25NYXAgZXh0ZW5kcyBUcmFuc2l0aW9uTWFwXG5cdHtcblx0XHQvKiogKi9cblx0XHRpbml0aWFsaXplKHNyY1N0YXRlSWQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zLnNldChzcmNTdGF0ZUlkLCBuZXcgVHJhbnNpdGlvblN0YXRlKCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzZXQoc3JjU3RhdGVJZDogbnVtYmVyLCBzeW1ib2w6IHN0cmluZywgZHN0U3RhdGVJZDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRTdGF0ZSA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlSWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRTdGF0ZSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdFN0YXRlID0gbmV3IFRyYW5zaXRpb25TdGF0ZSgpO1xuXHRcdFx0XHR0U3RhdGUuc2V0KHN5bWJvbCwgZHN0U3RhdGVJZCk7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlSWQsIHRTdGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRTdGF0ZS5zZXQoc3ltYm9sLCBkc3RTdGF0ZUlkKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBpbnRlcmZhY2UgSVRyYW5zaXRpb25MaXRlcmFsXG5cdHtcblx0XHRbc3RhdGVJZDogbnVtYmVyXTogSVRyYW5zaXRpb25TdGF0ZUxpdGVyYWw7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUcmFuc2l0aW9uU3RhdGVcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHNvdXJjZT86IElUcmFuc2l0aW9uU3RhdGVMaXRlcmFsKVxuXHRcdHtcblx0XHRcdHRoaXMuc3RhdGVNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcblx0XHRcdGlmIChzb3VyY2UpXG5cdFx0XHRcdGZvciAoY29uc3QgW3N5bWJvbCwgc3RhdGVJZF0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSlcblx0XHRcdFx0XHR0aGlzLnN0YXRlTWFwLnNldChzeW1ib2wsIHN0YXRlSWQpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRjbG9uZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2xvbmVkID0gbmV3IFRyYW5zaXRpb25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzeW1ib2wsIHN0YXRlSWRdIG9mIHRoaXMuc3RhdGVNYXApXG5cdFx0XHRcdGNsb25lZC5zdGF0ZU1hcC5zZXQoc3ltYm9sLCBzdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNsb25lZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzKHN5bWJvbDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXRlTWFwLmhhcyhzeW1ib2wpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQoc3ltYm9sOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVNYXAuZ2V0KHN5bWJvbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHNldChzeW1ib2w6IHN0cmluZywgc3RhdGVJZDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdHRoaXMuc3RhdGVNYXAuc2V0KHN5bWJvbCwgc3RhdGVJZCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoU3ltYm9sKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiB0aGlzLnN0YXRlTWFwLmtleXMoKSlcblx0XHRcdFx0eWllbGQgc3ltYm9sO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdCwgXG5cdFx0ICogZm9yIHRlc3RpbmcgYW5kIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzeW1ib2wsIHN0YXRlSWRdIG9mIHRoaXMuc3RhdGVNYXApXG5cdFx0XHRcdG91dC5wdXNoKFwieyBcIiArIHN5bWJvbCArIFwiOiBcIiArIHN0YXRlSWQgKyBcIiB9XCIpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0Lmxlbmd0aCA/IG91dC5qb2luKFwiLCBcIikgOiBcInt9XCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByb3RlY3RlZCByZWFkb25seSBzdGF0ZU1hcDogTWFwPHN0cmluZywgbnVtYmVyPjtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJVHJhbnNpdGlvblN0YXRlTGl0ZXJhbFxuXHR7XG5cdFx0W3N5bWJvbDogc3RyaW5nXTogbnVtYmVyO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgR3VpZGVcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKGZyb20/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdW10gfCBHdWlkZSlcblx0XHR7XG5cdFx0XHRpZiAoZnJvbSBpbnN0YW5jZW9mIEd1aWRlKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmhhc0RzdCA9IGZyb20uaGFzRHN0O1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiBmcm9tLmFycm93cylcblx0XHRcdFx0XHR0aGlzLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIilcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5hZGQoZnJvbSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChmcm9tKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiBmcm9tKVxuXHRcdFx0XHRcdHRoaXMuYXJyb3dzLnNldChzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y2xvbmUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNsb25lZCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiB0aGlzLmFycm93cylcblx0XHRcdFx0Y2xvbmVkLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjbG9uZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGhhcyhzdGF0ZUlkU3JjOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyb3dzLmhhcyhzdGF0ZUlkU3JjKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0KHN0YXRlSWRTcmM6IG51bWJlcilcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJvd3MuZ2V0KHN0YXRlSWRTcmMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGQoc3RhdGVJZFNyYzogbnVtYmVyLCBzdGF0ZUlkRHN0OiBudW1iZXIgfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pc0Zyb3plbilcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QgPT09IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYXJyb3dzLnNldChzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0aWYgKHN0YXRlSWREc3QgIT09IHN0YXRlSWREc3QpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMuaGFzRHN0ID09PSB0cnVlICYmIHR5cGVvZiBzdGF0ZUlkRHN0ICE9PSBcIm51bWJlclwiIHx8XG5cdFx0XHRcdFx0dGhpcy5oYXNEc3QgPT09IGZhbHNlICYmIHR5cGVvZiBzdGF0ZUlkRHN0ID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgbmVlZCB0byBiZSBrZXB0IGNvbnNpc3RlbnQgYWNyb3NzIHRoZSBpbnN0YW5jZS5cIik7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuaGFzRHN0ID0gc3RhdGVJZERzdCAhPT0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YXBwZW5kKG90aGVyOiBHdWlkZSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pc0Zyb3plbilcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QgPT09IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3NyYywgZHN0XSBvZiBvdGhlci5hcnJvd3MpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmhhc0RzdCA9IHR5cGVvZiBkc3QgPT09IFwibnVtYmVyXCI7XG5cdFx0XHRcdFx0dGhpcy5hcnJvd3Muc2V0KHNyYywgZHN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3RoZXIuaGFzRHN0ID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAob3RoZXIuc2l6ZSAhPT0gMClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3NyYywgZHN0XSBvZiBvdGhlci5hcnJvd3MpXG5cdFx0XHRcdFx0dGhpcy5hcnJvd3Muc2V0KHNyYywgZHN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Zmlyc3QoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IHRoaXMuYXJyb3dzLmdldCgwKTtcblx0XHRcdGlmIChvdXQgPT09IG51bGwgfHwgb3V0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqa2V5cygpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzcmMgb2YgdGhpcy5hcnJvd3Mua2V5cygpKVxuXHRcdFx0XHR5aWVsZCBzcmM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCp2YWx1ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmhhc0RzdCA9PT0gdHJ1ZSlcblx0XHRcdFx0Zm9yIChjb25zdCBkc3Qgb2YgdGhpcy5hcnJvd3MudmFsdWVzKCkpXG5cdFx0XHRcdFx0eWllbGQgTm90Lm51bGwoZHN0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVudHJpZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmhhc0RzdCA9PT0gZmFsc2UpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBlbnVtZXJhdGUgdGhlIGZ1bGwgZW50cmllcyBvZiB0aGlzIGluc3RhbmNlLlwiKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFNyYywgc3RhdGVJZERzdF0gb2YgdGhpcy5hcnJvd3MpXG5cdFx0XHRcdHlpZWxkIDxbbnVtYmVyLCBudW1iZXJdPltzdGF0ZUlkU3JjLCBOb3QubnVsbChzdGF0ZUlkRHN0KV07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5hcnJvd3Muc2l6ZTsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb250ZW50c1xuXHRcdCAqIG9mIHRoaXMgZ3VpZGUgbWF0Y2ggdGhlIGNvbnRlbnRzIG9mIHRoZSBndWlkZSBzcGVjaWZpZWQgaW4gdGhlXG5cdFx0ICogcGFyYW1ldGVyLlxuXHRcdCAqL1xuXHRcdGVxdWFscyhvdGhlcjogR3VpZGUpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzcmMsIGRzdF0gb2YgdGhpcy5hcnJvd3MpXG5cdFx0XHRcdGlmIChvdGhlci5hcnJvd3MuZ2V0KHNyYykgIT09IGRzdClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRmcmVlemUoKVxuXHRcdHtcblx0XHRcdHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCBcblx0XHQgKiBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxpdGVyYWw6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiB0aGlzLmFycm93cylcblx0XHRcdFx0XHRsaXRlcmFsLnB1c2goc3RhdGVJZFNyYyArIFwiOiBcIiArIHN0YXRlSWREc3QpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIFwieyBcIiArIGxpdGVyYWwuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXCJbXCIgKyBBcnJheS5mcm9tKHRoaXMuYXJyb3dzLmtleXMoKSkuam9pbihcIiwgXCIpICsgXCJdXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgaGFzRHN0OiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBpc0Zyb3plbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgYXJyb3dzID0gbmV3IE1hcDxudW1iZXIsIG51bWJlciB8IG51bGw+KCk7XG5cdH1cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGNvZGUgaXMgYSBUeXBlU2NyaXB0IGNvbnZlcnNpb24gb2YgYSBwb3J0aW9uIG9mIHRoZSB0aGUgUHl0aG9uXG4gKiBwcm9qZWN0IFwiZ3JlZW5lcnlcIiwgZnJvbSBHaXRIdWIgdXNlciBcInFudG1cIi4gXG4gKiBcbiAqIFRoZSBncmVlbmVyeSBwcm9qZWN0IGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3FudG0vZ3JlZW5lcnlcbiAqIFxuICogU3BlY2lmaWNhbGx5LCB0aGUgY29kZSBmcm9tIHdoZXJlIHRoaXMgY29kZSBkcmV3IGluc3BpcmF0aW9uIGlzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3FudG0vZ3JlZW5lcnkvYmxvYi9tYXN0ZXIvZ3JlZW5lcnkvZnNtLnB5XG4gKiBcbiAqIFBvc3NpYmx5IHJlbGV2YW50IGJsb2cgcG9zdDpcbiAqIGh0dHBzOi8vcW50bS5vcmcvYWxnb1xuICogXG4gKiBUaGUgb3JpZ2luYWwgTUlUIGxpY2Vuc2UgZnJvbSBncmVlbmVyeSBpcyBhcyBmb2xsb3dzOlxuICogXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgdG8gMjAxNyBieSBxbnRtXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIFxuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRVxuICogT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogT2JsaXZpb24gaXMgYSBTeW1ib2wgb2JqZWN0IHRoYXQgaXMgcmV0dXJuZWQgd2hpbGUgY2FsbGluZyBjcmF3bCgpIGlmIHRoZSBGc21cblx0ICogaXMgdHJhbnNpdGlvbmVkIHRvIHRoZSBvYmxpdmlvbiBzdGF0ZS4gRm9yIGV4YW1wbGUgd2hpbGUgY3Jhd2xpbmcgdHdvIEZzbXNcblx0ICogaW4gcGFyYWxsZWwgd2UgbWF5IHRyYW5zaXRpb24gdG8gdGhlIG9ibGl2aW9uIHN0YXRlIG9mIGJvdGggRnNtcyBhdCBvbmNlLlxuXHQgKiBUaGlzIHdhcnJhbnRzIGFuIG91dC1vZi1ib3VuZCBzaWduYWwgd2hpY2ggd2lsbCByZWR1Y2UgdGhlIGNvbXBsZXhpdHkgb2Zcblx0ICogdGhlIG5ldyBGc20ncyBtYXAuXG5cdCAqL1xuXHRjb25zdCBPYmxpdmlvbiA9IFN5bWJvbCgpO1xuXG5cblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIG9yIEZzbSBoYXMgYW4gYWxwaGFiZXQgYW5kIGEgc2V0IG9mIHN0YXRlcy4gQXQgYW55XG5cdCAqIGdpdmVuIG1vbWVudCwgdGhlIEZzbSBpcyBpbiBvbmUgc3RhdGUuIFdoZW4gcGFzc2VkIGEgc3ltYm9sIGZyb20gdGhlXG5cdCAqIGFscGhhYmV0LCB0aGUgRnNtIGp1bXBzIHRvIGFub3RoZXIgc3RhdGUgKG9yIHBvc3NpYmx5IHRoZSBzYW1lIHN0YXRlKS5cblx0ICogQSBUcmFuc2l0aW9uTWFwIGluZGljYXRlcyB3aGVyZSB0byBqdW1wLiBPbmUgc3RhdGUgaXMgbm9taW5hdGVkIGFzIHRoZVxuXHQgKiBpbml0aWFsIHN0YXRlLiBaZXJvIG9yIG1vcmUgc3RhdGVzIGFyZSBub21pbmF0ZWQgYXMgZmluYWwgc3RhdGVzLiBJZiwgYWZ0ZXJcblx0ICogY29uc3VtaW5nIGEgc3RyaW5nIG9mIHN5bWJvbHMsIHRoZSBGc20gaXMgaW4gYSBmaW5hbCBzdGF0ZSwgdGhlbiBpdCBpcyBzYWlkXG5cdCAqIHRvIFwiYWNjZXB0XCIgdGhlIHN0cmluZy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGc21cblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZSB0aGF0IGFjY2VwdFxuXHRcdCAqIG5vIGlucHV0cywgbm90IGV2ZW4gYW4gZW1wdHkgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBlbXB0eShhbHBoYWJldDogQWxwaGFiZXQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHNsOiBJVHJhbnNpdGlvblN0YXRlTGl0ZXJhbCA9IHt9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiBhbHBoYWJldClcblx0XHRcdFx0dHNsW3N5bWJvbF0gPSAwO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IEZzbShcblx0XHRcdFx0YWxwaGFiZXQsXG5cdFx0XHRcdG5ldyBTZXQoWzBdKSxcblx0XHRcdFx0MCxcblx0XHRcdFx0bmV3IFNldCgpLFxuXHRcdFx0XHRuZXcgVHJhbnNpdGlvbk1hcCh7IDA6IHRzbCB9KSk7XG5cdFx0fVxuXG5cblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBGc20gdGhhdCBtYXRjaGVzIG9ubHkgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBlcHNpbG9uKGFscGhhYmV0OiBBbHBoYWJldClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IEZzbShcblx0XHRcdFx0YWxwaGFiZXQsXG5cdFx0XHRcdG5ldyBTZXQoWzBdKSxcblx0XHRcdFx0MCxcblx0XHRcdFx0bmV3IFNldChbMF0pLFxuXHRcdFx0XHRuZXcgVHJhbnNpdGlvbk1hcCgpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGl0ZXJhYmxlIG9mIHN5bWJvbHMgdGhlIEZzbSBjYW4gYmUgZmVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBhbHBoYWJldDogQWxwaGFiZXQsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHNldCBvZiBwb3NzaWJsZSBzdGF0ZXMgZm9yIHRoZSBGc20uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHN0YXRlczogUmVhZG9ubHlTZXQ8bnVtYmVyPixcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgRnNtLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBpbml0aWFsOiBudW1iZXIsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHNldCBvZiBzdGF0ZXMgdGhhdCB0aGUgRnNtIGFjY2VwdHMuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGZpbmFsczogUmVhZG9ubHlTZXQ8bnVtYmVyPixcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNYXkgYmUgc3BhcnNlIChpLmUuIGl0IG1heSBvbWl0IHRyYW5zaXRpb25zKS4gXG5cdFx0XHQgKiBJbiB0aGUgY2FzZSBvZiBvbWl0dGVkIHRyYW5zaXRpb25zLCBhIG5vbi1maW5hbFxuXHRcdFx0ICogXCJvYmxpdmlvblwiIHN0YXRlIGlzIHNpbXVsYXRlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25NYXApXG5cdFx0eyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHByZXNlbnQgRnNtXG5cdFx0ICogYWNjZXB0cyB0aGUgc3VwcGxpZWQgYXJyYXkgb2Ygc3ltYm9scy4gRXF1aXZhbGVudGx5LCBjb25zaWRlciB0aGlzXG5cdFx0ICogRnNtIGluc3RhbmNlIGFzIGEgcG9zc2libHktaW5maW5pdGUgc2V0IG9mIHN0cmluZ3MgYW5kIHRlc3Qgd2hldGhlclxuXHRcdCAqIHRoZSBpbnB1dCBpcyBhIG1lbWJlciBvZiBpdC5cblx0XHQgKiBcblx0XHQgKiBJZiB0aGUgd2lsZGNhcmQgY2hhcmFjdGVyIGlzIHByZXNlbnQgaW4gdGhlIHNwZWNpZmllZCBhbHBoYWJldCwgdGhlblxuXHRcdCAqIGFueSBzeW1ib2wgbm90IGluIHRoZSBzcGVjaWZpZWQgYWxwaGFiZXQgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIFxuXHRcdCAqIHdpbGRjYXJkLlxuXHRcdCAqL1xuXHRcdGFjY2VwdHMoaW5wdXQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCB0aGlzSGFzV2lsZCA9IHRoaXMuYWxwaGFiZXQuaGFzV2lsZGNhcmQoKTtcblx0XHRcdGxldCBzdGF0ZUlkID0gdGhpcy5pbml0aWFsO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGNoYXIgb2YgaW5wdXQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN5bWJvbCA9IHRoaXNIYXNXaWxkICYmICF0aGlzLmFscGhhYmV0LmhhcyhjaGFyKSA/XG5cdFx0XHRcdFx0QWxwaGFiZXQud2lsZGNhcmQgOlxuXHRcdFx0XHRcdGNoYXI7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBNaXNzaW5nIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHRvIGRlYWQgc3RhdGVcblx0XHRcdFx0aWYgKCF0aGlzLnRyYW5zaXRpb25zLmhhcyhzdGF0ZUlkLCBzeW1ib2wpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG5ld1N0YXRlSWQgPSB0aGlzLnRyYW5zaXRpb25zLmdldChzdGF0ZUlkLCBzeW1ib2wpO1xuXHRcdFx0XHRpZiAobmV3U3RhdGVJZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigpO1xuXHRcdFx0XHRcblx0XHRcdFx0c3RhdGVJZCA9IG5ld1N0YXRlSWQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZpbmFscy5oYXMoc3RhdGVJZCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgcmVkdWNlZCB2ZXJzaW9uIG9mIHRoZSBGc20sIGRvd24gdG8gYSBtaW5pbWFsIGZpbml0ZVxuXHRcdCAqIHN0YXRlIG1hY2hpbmUgZXF1aXZhbGVudC5cblx0XHQgKiBcblx0XHQgKiAoQSByZXN1bHQgYnkgQnJ6b3pvd3NraSAoMTk2Mykgc2hvd3MgdGhhdCBhIG1pbmltYWwgZmluaXRlIHN0YXRlXG5cdFx0ICogbWFjaGluZSBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBjYW4gYmUgb2J0YWluZWQgYnkgcmV2ZXJzaW5nXG5cdFx0ICogdGhlIG9yaWdpbmFsIHR3aWNlLilcblx0XHQgKi9cblx0XHRyZWR1Y2UoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2UoKS5yZXZlcnNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbmNhdGVuYXRpb25cblx0XHQgKiBvZiB0aGUgc3BlY2lmaWVkIHNlcmllcyBvZiBmaW5pdGUgc3RhdGUgbWFjaGluZXMuXG5cdFx0ICovXG5cdFx0Y29uY2F0ZW5hdGUoLi4uZnNtczogRnNtW10pXG5cdFx0e1xuXHRcdFx0aWYgKGZzbXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZnNtcy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdHJldHVybiBmc21zWzBdO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRha2UgYSBzdGF0ZSBpbiB0aGUgbnVtYmVyZWQgRnNtIGFuZCByZXR1cm4gYSBzZXQgY29udGFpbmluZyBpdCxcblx0XHRcdCAqIHBsdXMgKGlmIGl0J3MgZmluYWwpIHRoZSBmaXJzdCBzdGF0ZSBmcm9tIHRoZSBuZXh0IEZzbSwgXG5cdFx0XHQgKiBwbHVzIChpZiB0aGF0J3MgZmluYWwpIHRoZSBmaXJzdCBzdGF0ZSBmcm9tIHRoZSBuZXh0IGJ1dCBvbmUgRnNtLCBcblx0XHRcdCAqIHBsdXMuLi5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgY29ubmVjdEFsbCA9IChpZHg6IG51bWJlciwgc3Vic3RhdGVJZDogbnVtYmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0cmVzdWx0LmFkZChpZHgsIHN1YnN0YXRlSWQpO1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IGkgPSBpZHg7XG5cdFx0XHRcdGxldCBpZCA9IHN1YnN0YXRlSWQ7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoaSA8IGZzbXMubGVuZ3RoIC0gMSAmJiBmc21zW2ldLmZpbmFscy5oYXMoaWQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGlkID0gZnNtc1tpXS5pbml0aWFsO1xuXHRcdFx0XHRcdHJlc3VsdC5hZGQoaSwgaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBVc2UgYSBzdXBlcnNldCBjb250YWluaW5nIHN0YXRlcyBmcm9tIGFsbCBGc21zIGF0IG9uY2UuXG5cdFx0XHQgKiBXZSBzdGFydCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IEZzbS4gSWYgdGhpcyBzdGF0ZSBpcyBmaW5hbCBpbiB0aGVcblx0XHRcdCAqIGZpcnN0IEZzbSwgdGhlbiB3ZSBhcmUgYWxzbyBhdCB0aGUgc3RhcnQgb2YgdGhlIHNlY29uZCBGc20uIEFuZCBzbyBvbi5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZnNtcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRpbml0aWFsLmFwcGVuZChjb25uZWN0QWxsKDAsIGZzbXNbMF0uaW5pdGlhbCkpO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIElmIHlvdSdyZSBpbiBhIGZpbmFsIHN0YXRlIG9mIHRoZSBmaW5hbCBGc20sIGl0J3MgZmluYWwuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGZpbmFsRm4gPSAoZ3VpZGU6IEd1aWRlKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtpLCBzdWJzdGF0ZUlkXSBvZiBndWlkZS5lbnRyaWVzKCkpXG5cdFx0XHRcdFx0aWYgKGkgPT09IGZzbXMubGVuZ3RoIC0gMSAmJiBmc21zW2ldLmZpbmFscy5oYXMoc3Vic3RhdGVJZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZm9sbG93Rm4gPSAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBbaSwgc3Vic3RhdGVJZF0gb2YgZ3VpZGUuZW50cmllcygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZnNtID0gZnNtc1tpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZnNtLnRyYW5zaXRpb25zLmhhcyhzdWJzdGF0ZUlkLCBzeW1ib2wpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0b3JlZFZhbHVlID0gZnNtLnRyYW5zaXRpb25zLmFjcXVpcmUoc3Vic3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0XHRcdG5leHQuYXBwZW5kKGNvbm5lY3RBbGwoaSwgc3RvcmVkVmFsdWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXh0LnNpemUgPT09IDAgP1xuXHRcdFx0XHRcdE9ibGl2aW9uIDpcblx0XHRcdFx0XHRuZXh0O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYWxwaGFiZXRzID0gZnNtcy5tYXAoZnNtID0+IGZzbS5hbHBoYWJldCk7XG5cdFx0XHRjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldEJ1aWxkZXIoLi4uYWxwaGFiZXRzKS50b0FscGhhYmV0KCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjcmF3bChhbHBoYWJldCwgaW5pdGlhbCwgZmluYWxGbiwgZm9sbG93Rm4pO1xuXHRcdH1cblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb25jYXRlbmF0ZSB0d28gZmluaXRlIHN0YXRlIG1hY2hpbmVzIHRvZ2V0aGVyLlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGFjY2VwdHMgXCIwKlwiIGFuZCBvdGhlciBhY2NlcHRzIFwiMSsoMHwxKVwiLFxuXHRcdCAqIHdpbGwgcmV0dXJuIGEgZmluaXRlIHN0YXRlIG1hY2hpbmUgYWNjZXB0aW5nIFwiMCoxKygwfDEpXCIuXG5cdFx0ICogQWNjb21wbGlzaGVkIGJ5IGVmZmVjdGl2ZWx5IGZvbGxvd2luZyBub24tZGV0ZXJtaW5pc3RpY2FsbHkuXG5cdFx0ICovXG5cdFx0YWRkKG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uY2F0ZW5hdGUodGhpcywgb3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgcHJlc2VudCBGc20gYWNjZXB0cyBYLCByZXR1cm5zIGFuIEZzbSBhY2NlcHRpbmcgWCpcblx0XHQgKiAoaS5lLiAwIG9yIG1vcmUgaW5zdGFuY2VzIG9mIFgpLiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgYXMgc2ltcGxlXG5cdFx0ICogYXMgbmFpdmVseSBjb25uZWN0aW5nIHRoZSBmaW5hbCBzdGF0ZXMgYmFjayB0byB0aGUgaW5pdGlhbCBzdGF0ZTogXG5cdFx0ICogc2VlIChiKmFiKSogZm9yIGV4YW1wbGUuXG5cdFx0ICovXG5cdFx0c3RhcigpXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZSh0aGlzLmluaXRpYWwpO1xuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdGNvbnN0IGZvbGxvd0ZuID0gKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic3RhdGVJZCBvZiBndWlkZS5rZXlzKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5oYXMoc3Vic3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHRcdG5leHQuYWRkKHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZShzdWJzdGF0ZUlkLCBzeW1ib2wpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJZiBvbmUgb2Ygb3VyIHN1YnN0YXRlcyBpcyBmaW5hbCwgdGhlbiB3ZSBjYW4gYWxzbyBjb25zaWRlclxuXHRcdFx0XHRcdC8vIHRyYW5zaXRpb25zIGZyb20gdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIG9yaWdpbmFsIEZzbS5cblx0XHRcdFx0XHRpZiAodGhpcy5maW5hbHMuaGFzKHN1YnN0YXRlSWQpICYmIHRoaXMudHJhbnNpdGlvbnMuaGFzKHRoaXMuaW5pdGlhbCwgc3ltYm9sKSlcblx0XHRcdFx0XHRcdG5leHQuYWRkKHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZSh0aGlzLmluaXRpYWwsIHN5bWJvbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dC5zaXplID09PSAwID9cblx0XHRcdFx0XHRPYmxpdmlvbiA6XG5cdFx0XHRcdFx0bmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic3RhdGVJZCBvZiBndWlkZS5rZXlzKCkpXG5cdFx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyhzdWJzdGF0ZUlkKSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNyYXdsKHRoaXMuYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKS5vcihGc20uZXBzaWxvbih0aGlzLmFscGhhYmV0KSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdpdmVuIGFuIEZzbSBhbmQgYSBtdWx0aXBsaWNhdGlvbiBmYWN0b3IsIHJldHVybiB0aGUgbXVsdGlwbGllZCBGc20uXG5cdFx0ICovXG5cdFx0bXVsdGlwbHkoZmFjdG9yOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKGZhY3RvciA8IDApXG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUoW1t0aGlzLmluaXRpYWwsIDBdXSk7XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3N1YnN0YXRlSWQsIGl0ZXJhdGlvbl0gb2YgZ3VpZGUuZW50cmllcygpKVxuXHRcdFx0XHRcdGlmICh0aGlzLmluaXRpYWwgPT09IHN1YnN0YXRlSWQpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5maW5hbHMuaGFzKHRoaXMuaW5pdGlhbCkgfHwgaXRlcmF0aW9uID09PSBmYWN0b3IpXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmb2xsb3dGbiA9IChndWlkZTogR3VpZGUsIHN5bWJvbDogc3RyaW5nKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdWJzdGF0ZUlkLCBpdGVyYXRpb25dIG9mIGd1aWRlLmVudHJpZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChpdGVyYXRpb24gPCBmYWN0b3IgJiYgdGhpcy50cmFuc2l0aW9ucy5oYXMoc3Vic3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBudW0gPSB0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUoc3Vic3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0XHRcdG5leHQuYWRkKG51bSwgaXRlcmF0aW9uKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyhudW0pKVxuXHRcdFx0XHRcdFx0XHRuZXh0LmFkZCh0aGlzLmluaXRpYWwsIGl0ZXJhdGlvbiArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5leHQuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gT2JsaXZpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBjcmF3bCh0aGlzLmFscGhhYmV0LCBpbml0aWFsLCBmaW5hbEZuLCBmb2xsb3dGbikucmVkdWNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBvYmplY3QgdGhhdCBwcmVzZW50cyB0aGUgdW5pb24gb2Zcblx0XHQgKiBhbGwgc3VwcGxpZWQgRnNtIGluc3RhbmNlcy5cblx0XHQgKi9cblx0XHR1bmlvbiguLi5mc21zOiBGc21bXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gY3Jhd2xQYXJhbGxlbChcblx0XHRcdFx0cHJlcGVuZEZzbSh0aGlzLCBmc21zKSwgXG5cdFx0XHRcdGFjY2VwdHMgPT4gYWNjZXB0cy5zb21lKHZhbCA9PiB2YWwpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgbG9naWNhbCBhbHRlcm5hdGlvbiBiZXR3ZWVuIHRoaXMgRnNtLCBhbmQgdGhlIEZzbVxuXHRcdCAqIGluc3RhbmNlIHN1cHBsaWVkIGluIHRoZSBhcmd1bWVudC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZpbml0ZSBzdGF0ZSBtYWNoaW5lIHdoaWNoIGFjY2VwdHMgYW55IHNlcXVlbmNlIG9mXG5cdFx0ICogc3ltYm9scyB0aGF0IGlzIGFjY2VwdGVkIGJ5IGVpdGhlciBzZWxmIG9yIG90aGVyLiBOb3RlIHRoYXQgdGhlIHNldFxuXHRcdCAqIG9mIHN0cmluZ3MgcmVjb2duaXNlZCBieSB0aGUgdHdvIEZzbXMgdW5kZXJnb2VzIGEgc2V0IHVuaW9uLlxuXHRcdCAqL1xuXHRcdG9yKG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudW5pb24ob3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGVcblx0XHQgKiBpbnRlcnNlY3Rpb24gb2YgYWxsIHN1cHBsaWVkIEZzbSBpbnN0YW5jZXMuXG5cdFx0ICovXG5cdFx0aW50ZXJzZWN0aW9uKC4uLmZzbXM6IEZzbVtdKVxuXHRcdHtcblx0XHRcdHJldHVybiBjcmF3bFBhcmFsbGVsKFxuXHRcdFx0XHRwcmVwZW5kRnNtKHRoaXMsIGZzbXMpLCBcblx0XHRcdFx0YWNjZXB0cyA9PiBhY2NlcHRzLmV2ZXJ5KHZhbCA9PiB2YWwpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVHJlYXQgdGhlIEZzbXMgYXMgc2V0cyBvZiBzdHJpbmdzIGFuZCByZXR1cm4gdGhlXG5cdFx0ICogaW50ZXJzZWN0aW9uIG9mIHRob3NlIHNldHMgaW4gdGhlIGZvcm0gb2YgYSBuZXcgRnNtLlxuXHRcdCAqL1xuXHRcdGFuZChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdGlvbihvdGhlcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb21wdXRlZFxuXHRcdCAqIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIGFsbCBzdXBwbGVkIEZzbSBpbnN0YW5jZXMuXG5cdFx0ICovXG5cdFx0c3ltbWV0cmljRGlmZmVyZW5jZSguLi5mc21zOiBGc21bXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gY3Jhd2xQYXJhbGxlbChcblx0XHRcdFx0cHJlcGVuZEZzbSh0aGlzLCBmc21zKSwgXG5cdFx0XHRcdGFjY2VwdHMgPT4gYWNjZXB0cy5maWx0ZXIodmFsID0+IHZhbCkubGVuZ3RoICUgMiA9PT0gMSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZXMgdGhhdCByZWNvZ25pc2VzIG9ubHkgdGhlIHN0cmluZ3Ncblx0XHQgKiByZWNvZ25pc2VkIGJ5IHRoaXMgRnNtLCBvciB0aGUgRnNtIGluc3RhbmNlIHN1cHBsaWVkIGluIHRoZSBcblx0XHQgKiBvdGhlciBhcmd1bWVudCwgYnV0IG5vdCBib3RoLlxuXHRcdCAqL1xuXHRcdHhvcihvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gaW5zdGFuY2UgdGhhdCByZWNvZ2l6ZXMgYWxsIGlucHV0cyB0aGF0XG5cdFx0ICogd291bGQgbm90IGJlIGFjY2VwdGVkIGJ5IHRoaXMgRnNtLlxuXHRcdCAqL1xuXHRcdG5vdCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZShbWzAsIHRoaXMuaW5pdGlhbF1dKTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmb2xsb3dGbiA9IChndWlkZTogR3VpZGUsIHN5bWJvbDogc3RyaW5nKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdGNvbnN0IGZpcnN0ID0gZ3VpZGUuZmlyc3QoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChmaXJzdCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25zLmhhcyhmaXJzdCwgc3ltYm9sKSlcblx0XHRcdFx0XHRcdG5leHQuYWRkKDAsIHRoaXMudHJhbnNpdGlvbnMuZ2V0KGZpcnN0LCBzeW1ib2wpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXh0O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmaW5hbEZuID0gKGd1aWRlOiBHdWlkZSkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZmlyc3QgPSBndWlkZS5maXJzdCgpO1xuXHRcdFx0XHRyZXR1cm4gIShmaXJzdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmluYWxzLmhhcyhmaXJzdCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNyYXdsKHRoaXMuYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBuZXcgRnNtIHN1Y2ggdGhhdCBmb3IgZXZlcnkgaW5wdXQgdGhhdCB0aGUgc3VwcGxpZWRcblx0XHQgKiBGc20gYWNjZXB0cywgdGhlIG5ldyBGc20gYWNjZXB0cyB0aGUgc2FtZSBpbnB1dCwgYnV0IHJldmVyc2VkLlxuXHRcdCAqL1xuXHRcdHJldmVyc2UoKVxuXHRcdHtcblx0XHRcdC8vIFN0YXJ0IGZyb20gYSBjb21wb3NpdGUgXCJzdGF0ZS1zZXRcIiBjb25zaXN0aW5nIG9mIGFsbCBmaW5hbCBzdGF0ZXMuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gZmluYWwgc3RhdGVzLCB0aGlzIHNldCBpcyBlbXB0eSBhbmQgd2UnbGwgZmluZCB0aGF0XG5cdFx0XHQvLyBubyBvdGhlciBzdGF0ZXMgZ2V0IGdlbmVyYXRlZC5cblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzdGF0ZUlkIG9mIHRoaXMuZmluYWxzKVxuXHRcdFx0XHRpbml0aWFsLmFkZChzdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0Ly8gRmluZCBldmVyeSBwb3NzaWJsZSB3YXkgdG8gcmVhY2ggdGhlIGN1cnJlbnQgc3RhdGUtc2V0XG5cdFx0XHQvLyB1c2luZyB0aGlzIHN5bWJvbC5cblx0XHRcdGNvbnN0IGZvbGxvd0ZuID0gKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgcHJldlN0YXRlSWQgb2YgdGhpcy50cmFuc2l0aW9ucy5lYWNoU3RhdGVJZCgpKVxuXHRcdFx0XHRcdGZvciAoY29uc3Qgc3RhdGVJZCBvZiBndWlkZS5rZXlzKCkpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5oYXMocHJldlN0YXRlSWQsIHN5bWJvbCkpXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25zLmdldChwcmV2U3RhdGVJZCwgc3ltYm9sKSA9PT0gc3RhdGVJZClcblx0XHRcdFx0XHRcdFx0XHRuZXh0LmFkZChwcmV2U3RhdGVJZCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dC5zaXplID09PSAwID9cblx0XHRcdFx0XHRPYmxpdmlvbiA6XG5cdFx0XHRcdFx0bmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+IGd1aWRlLmhhcyh0aGlzLmluaXRpYWwpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY3Jhd2wodGhpcy5hbHBoYWJldCwgaW5pdGlhbCwgZmluYWxGbiwgZm9sbG93Rm4pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgRnNtIGluc3RhbmNlXG5cdFx0ICogYWNjZXB0cyB0aGUgc2FtZSBzZXQgb2YgaW5wdXRzIGFzIHRoZSBGc20gaW5zdGFuY2Ugc3BlY2lmaWVkXG5cdFx0ICogaW4gdGhlIGFyZ3VtZW50LlxuXHRcdCAqL1xuXHRcdGVxdWl2YWxlbnQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy54b3Iob3RoZXIpLmlzRW1wdHkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIEZzbSBpbnN0YW5jZVxuXHRcdCAqIGRvZXMgbm90IGFjY2VwdCB0aGUgc2FtZSBzZXQgb2YgaW5wdXRzIGFzIHRoZSBGc20gaW5zdGFuY2Vcblx0XHQgKiBzcGVjaWZpZWQgaW4gdGhlIGFyZ3VtZW50LlxuXHRcdCAqL1xuXHRcdHVuZXF1aXZhbGVudChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiAhdGhpcy54b3Iob3RoZXIpLmlzRW1wdHkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gRnNtIGluc3RhbmNlIHdoaWNoIHJlY29nbmlzZXMgb25seSB0aGUgaW5wdXRzXG5cdFx0ICogcmVjb2duaXNlZCBieSB0aGUgZmlyc3QgRnNtIGluc3RhbmNlIGluIHRoZSBsaXN0LCBidXQgbm9uZSBvZiBcblx0XHQgKiB0aGUgb3RoZXJzLlxuXHRcdCAqL1xuXHRcdGRpZmZlcmVuY2UoLi4uZnNtczogRnNtW10pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGNyYXdsUGFyYWxsZWwoXG5cdFx0XHRcdHByZXBlbmRGc20odGhpcywgZnNtcyksIFxuXHRcdFx0XHRhY2NlcHRzID0+IGFjY2VwdHNbMF0gJiYgYWNjZXB0cy5zbGljZSgxKS5ldmVyeShhY2NlcHRzID0+ICFhY2NlcHRzKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgZmluYWwgc3RhdGVcblx0XHQgKiBjYW4gYmUgcmVhY2hlZCBmcm9tIHRoZSBzcGVjaWZpZWQgc3RhdGUuXG5cdFx0ICovXG5cdFx0aXNTdGF0ZUxpdmUoc3RhdGVJZDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJlYWNoYWJsZSA9IFtzdGF0ZUlkXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCByZWFjaGFibGUubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlSWQgPSByZWFjaGFibGVbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5maW5hbHMuaGFzKGN1cnJlbnRTdGF0ZUlkKSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25zLmhhcyhjdXJyZW50U3RhdGVJZCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uU3RhdGUgPSB0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUoY3VycmVudFN0YXRlSWQpO1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc3ltYm9sIG9mIHRyYW5zaXRpb25TdGF0ZS5lYWNoU3ltYm9sKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dCA9IHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZShjdXJyZW50U3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0XHRcdGlmICghcmVhY2hhYmxlLmluY2x1ZGVzKG5leHQpKVxuXHRcdFx0XHRcdFx0XHRyZWFjaGFibGUucHVzaChuZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBbiBGc20gaXMgZW1wdHkgaWYgaXQgcmVjb2duaXNlcyBubyBzdHJpbmdzLiBBbiBGc20gbWF5IGJlIGFyYml0cmFyaWx5XG5cdFx0ICogY29tcGxpY2F0ZWQgYW5kIGhhdmUgYXJiaXRyYXJpbHkgbWFueSBmaW5hbCBzdGF0ZXMgd2hpbGUgc3RpbGwgcmVjb2duaXNpbmdcblx0XHQgKiBubyBzdHJpbmdzIGJlY2F1c2UgdGhvc2UgZmluYWwgc3RhdGVzIG1heSBhbGwgYmUgaW5hY2Nlc3NpYmxlIGZyb20gdGhlXG5cdFx0ICogaW5pdGlhbCBzdGF0ZS4gRXF1YWxseSwgYW4gRnNtIG1heSBiZSBub24tZW1wdHkgZGVzcGl0ZSBoYXZpbmcgYW4gZW1wdHlcblx0XHQgKiBhbHBoYWJldCBpZiB0aGUgaW5pdGlhbCBzdGF0ZSBpcyBmaW5hbC5cblx0XHQgKi9cblx0XHRpc0VtcHR5KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gIXRoaXMuaXNTdGF0ZUxpdmUodGhpcy5pbml0aWFsKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGUgc3RyaW5ncyAobGlzdHMgb2Ygc3ltYm9scykgdGhhdCB0aGlzIEZzbSBhY2NlcHRzLiBTaW5jZSB0aGVyZSBtYXlcblx0XHQgKiBiZSBpbmZpbml0ZWx5IG1hbnkgb2YgdGhlc2Ugd2UgdXNlIGEgZ2VuZXJhdG9yIGluc3RlYWQgb2YgY29uc3RydWN0aW5nIGFcblx0XHQgKiBzdGF0aWMgbGlzdC4gU3RyaW5ncyB3aWxsIGJlIHNvcnRlZCBpbiBvcmRlciBvZiBsZW5ndGggYW5kIHRoZW4gbGV4aWNhbGx5LlxuXHRcdCAqIFRoaXMgcHJvY2VkdXJlIHVzZXMgYXJiaXRyYXJ5IGFtb3VudHMgb2YgbWVtb3J5IGJ1dCBpcyB2ZXJ5IGZhc3QuIFRoZXJlXG5cdFx0ICogbWF5IGJlIG1vcmUgZWZmaWNpZW50IHdheXMgdG8gZG8gdGhpcywgdGhhdCBJIGhhdmVuJ3QgaW52ZXN0aWdhdGVkIHlldC5cblx0XHQgKiBZb3UgY2FuIHVzZSB0aGlzIGluIGxpc3QgY29tcHJlaGVuc2lvbnMuXG5cdFx0ICovXG5cdFx0KmVhY2hTdHJpbmcoKVxuXHRcdHtcblx0XHRcdFwiTm90IGltcGxlbWVudGVkXCI7XG5cdFx0XHRkZWJ1Z2dlcjtcblx0XHRcdHlpZWxkIFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBhY3Qgb2YgbWVyZ2luZ1xuXHRcdCAqIHRoaXMgRnNtIGluc3RhbmNlIHdpdGggdGhlIEZzbSBpbnN0YW5jZSBzdXBwbGllZCBpbiB0aGUgYXJndW1lbnRcblx0XHQgKiB3b3VsZCByZXN1bHQgaW4gYW4gRnNtIGluc3RhbmNlIHRoYXQgYWNjZXB0cyBubyBpbnB1dHMuXG5cdFx0ICovXG5cdFx0aXNEaXNjcmVwYW50KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5kKG90aGVyKS5pc0VtcHR5KCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzZXQgb2YgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgdGhpcyBGc20gaW5zdGFuY2UgaXMgYSBzdWJzZXQgb2YgdGhlIGlucHV0cyBhY2NlcHRlZCBieSBcblx0XHQgKiBvdGhlciBGc20gaW5zdGFuY2Ugc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdGlzU3Vic2V0KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlmZmVyZW5jZShvdGhlcikuaXNFbXB0eSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IG9mIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IHRoaXMgRnNtIGluc3RhbmNlIGlzIGEgcHJvcGVyIHN1YnNldCBvZiB0aGUgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgb3RoZXIgRnNtIGluc3RhbmNlIHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRpc1Byb3BlclN1YnNldChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmRpZmZlcmVuY2Uob3RoZXIpLmlzRW1wdHkoKSAmJiB0aGlzLnVuZXF1aXZhbGVudChvdGhlcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzZXQgb2YgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgdGhpcyBGc20gaW5zdGFuY2UgaXMgYSBzdXBlcnNldCBvZiB0aGUgaW5wdXRzIGFjY2VwdGVkXG5cdFx0ICogYnkgb3RoZXIgRnNtIGluc3RhbmNlIHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRpc1N1cGVyc2V0KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG90aGVyLmRpZmZlcmVuY2UodGhpcykuaXNFbXB0eSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IG9mIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IHRoaXMgRnNtIGluc3RhbmNlIGlzIGEgcHJvcGVyIHN1cGVyc2V0IG9mIHRoZSBpbnB1dHNcblx0XHQgKiBhY2NlcHRlZCBieSBvdGhlciBGc20gaW5zdGFuY2Ugc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdGlzUHJvcGVyU3VwZXJzZXQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gb3RoZXIuZGlmZmVyZW5jZSh0aGlzKS5pc0VtcHR5KCkgJiYgb3RoZXIudW5lcXVpdmFsZW50KHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb21wdXRlIHRoZSBCcnpvem93c2tpIGRlcml2YXRpdmUgb2YgdGhpcyBGc20gd2l0aCByZXNwZWN0IHRvIHRoZSBpbnB1dFxuXHRcdCAqIHN0cmluZyBvZiBzeW1ib2xzLiA8aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJ6b3pvd3NraV9kZXJpdmF0aXZlPlxuXHRcdCAqIElmIGFueSBvZiB0aGUgc3ltYm9scyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIGFscGhhYmV0LCB0aGF0J3MgYSBLZXlFcnJvci5cblx0XHQgKiBJZiB5b3UgZmFsbCBpbnRvIG9ibGl2aW9uLCB0aGVuIHRoZSBkZXJpdmF0aXZlIGlzIGFuIEZzbSBhY2NlcHRpbmcgbm9cblx0XHQgKiBzdHJpbmdzLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZSB3aXRoIHRoZSBjb21wdXRlZCBjaGFyYWN0ZXJpc3RpY3MuXG5cdFx0ICovXG5cdFx0ZGVyaXZlKGlucHV0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0bGV0IHN0YXRlSWQ6IG51bWJlciA9IHRoaXMuaW5pdGlhbDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjaGFyIG9mIGlucHV0KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzeW1ib2wgPSAoKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICh0aGlzLmFscGhhYmV0LmhhcyhjaGFyKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuYWxwaGFiZXQuaGFzV2lsZGNhcmQpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihjaGFyKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIEFscGhhYmV0LndpbGRjYXJkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gY2hhcjtcblx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghdGhpcy50cmFuc2l0aW9ucy5oYXMoc3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHRyZXR1cm4gT2JsaXZpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGF0ZUlkID0gdGhpcy50cmFuc2l0aW9ucy5hY3F1aXJlKHN0YXRlSWQsIHN5bWJvbCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgRnNtKFxuXHRcdFx0XHR0aGlzLmFscGhhYmV0LFxuXHRcdFx0XHR0aGlzLnN0YXRlcyxcblx0XHRcdFx0c3RhdGVJZCxcblx0XHRcdFx0dGhpcy5maW5hbHMsXG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbnMuY2xvbmUoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCBcblx0XHQgKiBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcImFscGhhYmV0ID0gXCIgKyB0aGlzLmFscGhhYmV0LnRvU3RyaW5nKCksXG5cdFx0XHRcdFwic3RhdGVzID0gXCIgKyBBcnJheS5mcm9tKHRoaXMuc3RhdGVzKS5qb2luKCksXG5cdFx0XHRcdFwiaW5pdGFsID0gXCIgKyB0aGlzLmluaXRpYWwsXG5cdFx0XHRcdFwiZmluYWxzID0gXCIgKyBBcnJheS5mcm9tKHRoaXMuZmluYWxzKS5qb2luKCksXG5cdFx0XHRcdFwidHJhbnNpdGlvbnMgPSBcIiArIHRoaXMudHJhbnNpdGlvbnMudG9TdHJpbmcoKVxuXHRcdFx0XS5qb2luKFwiXFxuXCIpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHJlcGVuZCBhbiBGc20gaW5zdGFuY2UgdG8gYW4gRnNtIGFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gcHJlcGVuZEZzbShmc206IEZzbSwgZnNtczogRnNtW10pXG5cdHtcblx0XHRyZXR1cm4gW2ZzbV0uY29uY2F0KC4uLmZzbXMpO1xuXHR9XG5cblxuXHQvKipcblx0ICogQ3Jhd2wgc2V2ZXJhbCBGc21zIGluIHBhcmFsbGVsLCBtYXBwaW5nIHRoZSBzdGF0ZXMgb2YgYSBsYXJnZXIgbWV0YS1Gc20uXG5cdCAqIFRvIGRldGVybWluZSB3aGV0aGVyIGEgc3RhdGUgaW4gdGhlIGxhcmdlciBGc20gaXMgZmluYWwsIHBhc3MgYWxsIG9mIHRoZVxuXHQgKiBmaW5hbGl0eSBzdGF0dXNlcyAoZS5nLiBbdHJ1ZSwgZmFsc2UsIGZhbHNlXSB0byB0ZXN0Rm4uXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmF3bFBhcmFsbGVsKGZzbXM6IEZzbVtdLCB0ZXN0Rm46IChhY2NlcHRzOiBib29sZWFuW10pID0+IGJvb2xlYW4pXG5cdHtcblx0XHRjb25zdCBpbml0aWFsID0gbmV3IEd1aWRlKCk7XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBbaW5kZXgsIGZzbV0gb2YgZnNtcy5lbnRyaWVzKCkpXG5cdFx0XHRpbml0aWFsLmFkZChpbmRleCwgZnNtLmluaXRpYWwpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERlZGljYXRlZCBmdW5jdGlvbiBhY2NlcHRzIGEgXCJzdXBlcnNldFwiIGFuZCByZXR1cm5zIHRoZSBuZXh0IFwic3VwZXJzZXRcIlxuXHRcdCAqIG9idGFpbmVkIGJ5IGZvbGxvd2luZyB0aGlzIHRyYW5zaXRpb24gaW4gdGhlIG5ldyBGc20uXG5cdFx0ICovXG5cdFx0Y29uc3QgZm9sbG93Rm4gPSAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT5cblx0XHR7XG5cdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2luZGV4LCBmc21dIG9mIGZzbXMuZW50cmllcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdGF0ZUlkID0gZ3VpZGUuZ2V0KGluZGV4KTtcblx0XHRcdFx0aWYgKHN0YXRlSWQgPT09IG51bGwgfHwgc3RhdGVJZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc3Vic3RhdGVJZCA9IGZzbS50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcdGlmIChzdWJzdGF0ZUlkID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhbHBoYSA9IGZzbS5hbHBoYWJldDtcblx0XHRcdFx0Y29uc3QgYWN0dWFsU3ltYm9sID0gYWxwaGEuaGFzKHN5bWJvbCkgJiYgYWxwaGEuaGFzV2lsZGNhcmQoKSA/XG5cdFx0XHRcdFx0QWxwaGFiZXQud2lsZGNhcmQgOlxuXHRcdFx0XHRcdHN5bWJvbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdWJzdGF0ZUlkLmhhcyhhY3R1YWxTeW1ib2wpKVxuXHRcdFx0XHRcdG5leHQuYWRkKGluZGV4LCBmc20udHJhbnNpdGlvbnMuZ2V0KHN0YXRlSWQsIGFjdHVhbFN5bWJvbCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobmV4dC5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gT2JsaXZpb247XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXh0O1xuXHRcdH07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lIHRoZSBcImlzIGZpbmFsP1wiIGNvbmRpdGlvbiBvZiBlYWNoIHN1YnN0YXRlSWQsIHRoZW4gcGFzcyBpdCB0byB0aGVcblx0XHQgKiB0ZXN0IHRvIGRldGVybWluZSBmaW5hbGl0eSBvZiB0aGUgb3ZlcmFsbCBGc20uXG5cdFx0ICovXG5cdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgYWNjZXB0czogYm9vbGVhbltdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2lkeCwgZnNtXSBvZiBmc21zLmVudHJpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3Vic3RhdGVJZCA9IGd1aWRlLmdldChpZHgpO1xuXHRcdFx0XHRpZiAoc3Vic3RhdGVJZCAhPT0gbnVsbCAmJiBzdWJzdGF0ZUlkICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0YWNjZXB0cy5wdXNoKGd1aWRlLmhhcyhpZHgpICYmIGZzbS5maW5hbHMuaGFzKHN1YnN0YXRlSWQpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRlc3RGbihhY2NlcHRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdGNvbnN0IGFscGhhYmV0cyA9IGZzbXMubWFwKGZzbSA9PiBmc20uYWxwaGFiZXQpO1xuXHRcdGNvbnN0IGFscGhhYmV0ID0gbmV3IEFscGhhYmV0QnVpbGRlciguLi5hbHBoYWJldHMpLnRvQWxwaGFiZXQoKTtcblx0XHRyZXR1cm4gY3Jhd2woYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKS5yZWR1Y2UoKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEdpdmVuIHRoZSBhYm92ZSBjb25kaXRpb25zIGFuZCBpbnN0cnVjdGlvbnMsIGNyYXdsIGEgbmV3IHVua25vd24gRnNtLFxuXHQgKiBtYXBwaW5nIGl0cyBzdGF0ZXMsIGZpbmFsIHN0YXRlcyBhbmQgdHJhbnNpdGlvbnMuIFJldHVybiB0aGUgbmV3IEZzbS5cblx0ICovXG5cdGZ1bmN0aW9uIGNyYXdsKFxuXHRcdGFscGhhYmV0OiBBbHBoYWJldCxcblx0XHRpbml0aWFsOiBHdWlkZSxcblx0XHRmaW5hbEZuOiAoZ3VpZGU6IEd1aWRlKSA9PiBib29sZWFuLFxuXHRcdGZvbGxvd0ZuOiAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT4gR3VpZGUgfCB0eXBlb2YgT2JsaXZpb24pXG5cdHtcblx0XHRjb25zdCBkZWJ1Z0xpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGd1aWRlcyA9IFtpbml0aWFsXTtcblx0XHRjb25zdCBmaW5hbHMgPSBuZXcgU2V0PG51bWJlcj4oKTtcblx0XHRjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNdXRhYmxlVHJhbnNpdGlvbk1hcCgpO1xuXHRcdFxuXHRcdC8vIEl0ZXJhdGUgb3ZlciBhIGdyb3dpbmcgbGlzdFxuXHRcdGZvciAoY29uc3QgW2ksIGd1aWRlXSBvZiBndWlkZXMuZW50cmllcygpKVxuXHRcdHtcblx0XHRcdC8vIEFkZCB0byBmaW5hbHNcblx0XHRcdGlmIChmaW5hbEZuKGd1aWRlKSlcblx0XHRcdFx0ZmluYWxzLmFkZChpKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29tcHV0ZSB0cmFuc2l0aW9ucyBmb3IgdGhpcyBzdGF0ZVxuXHRcdFx0dHJhbnNpdGlvbnMuaW5pdGlhbGl6ZShpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzeW1ib2wgb2YgYWxwaGFiZXQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBmb2xsb3dGbihndWlkZSwgc3ltYm9sKTtcblx0XHRcdFx0aWYgKG5leHQgIT09IE9ibGl2aW9uKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGV0IG5leHRJZHggPSBndWlkZXMuZmluZEluZGV4KGd1aWRlID0+IGd1aWRlLmVxdWFscyhuZXh0KSk7XG5cdFx0XHRcdFx0aWYgKG5leHRJZHggPCAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG5leHRJZHggPSBndWlkZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Z3VpZGVzLnB1c2gobmV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRyYW5zaXRpb25zLnNldChpLCBzeW1ib2wsIG5leHRJZHgpO1xuXHRcdFx0XHRcdGRlYnVnTGluZXMucHVzaChuZXh0LnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBuZXcgRnNtKFxuXHRcdFx0YWxwaGFiZXQsXG5cdFx0XHRuZXcgU2V0KEFycmF5KGd1aWRlcy5sZW5ndGgpLmtleXMoKSksXG5cdFx0XHQwLFxuXHRcdFx0ZmluYWxzLFxuXHRcdFx0dHJhbnNpdGlvbnMpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFRyYW5zbGF0ZXMgUGF0dGVybiBpbnN0YW5jZXMgaW50byBhIGNvcnJlc3BvbmRpbmcgRnNtLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEZzbVRyYW5zbGF0b3Jcblx0e1xuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBleGVjKHVuaXRzOiBJdGVyYWJsZTxSZWdleFVuaXQ+KVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiB1bml0cylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleFNldClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyb3VwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JhcGhlbWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhTaWduKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsISBhcyBGc207XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHRyYW5zbGF0ZVNldChcblx0XHRcdHNldDogUmVnZXhTZXQsXG5cdFx0XHRhbHBoYTogQWxwaGFiZXRCdWlsZGVyIHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHRyYW5zbGF0ZUdyb3VwKFxuXHRcdFx0Z3JvdXA6IFJlZ2V4R3JvdXAsXG5cdFx0XHRhbHBoYTogQWxwaGFiZXRCdWlsZGVyIHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgYnVpbGRlciA9IGFscGhhIHx8IG5ldyBBbHBoYWJldEJ1aWxkZXIoKS5hZGRXaWxkKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIGNyZWF0ZUdyb3VwQWxwaGFiZXQoZ3JvdXA6IFJlZ2V4R3JvdXApXG5cdFx0e1xuXHRcdFx0Y29uc3QgYnVpbGRlciA9IG5ldyBBbHBoYWJldEJ1aWxkZXIoKTtcblx0XHRcdGJ1aWxkZXIuYWRkV2lsZCgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZ3JvdXAuY2FzZXMpXG5cdFx0XHR7XG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyB0cmFuc2xhdGVHcmFwaGVtZShcblx0XHRcdGdyYXBoZW1lOiBSZWdleEdyYXBoZW1lLFxuXHRcdFx0YWxwaGE6IEFscGhhYmV0QnVpbGRlciB8IG51bGwgPSBudWxsKVxuXHRcdHtcblx0XHRcdFxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyB0cmFuc2xhdGVTaWduKFxuXHRcdFx0c2lnbjogUmVnZXhTaWduLFxuXHRcdFx0YWxwaGE6IEFscGhhYmV0QnVpbGRlciB8IG51bGwgPSBudWxsKVxuXHRcdHtcblx0XHRcdFxuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCBtYW5hZ2VzIGEgc2luZ2xlIFRydXRoIGRvY3VtZW50IGxvYWRlZCBhcyBwYXJ0IG9mXG5cdCAqIGEgUHJvZ3JhbS5cblx0ICogXG5cdCAqIFRydXRoIGRvY3VtZW50cyBtYXkgYmUgbG9hZGVkIGZyb20gZmlsZXMsIG9yIHRoZXkgbWF5IGJlIGxvYWRlZFxuXHQgKiBmcm9tIGEgc3RyaW5nIG9mIFRydXRoIGNvbnRlbnQgZGlyZWN0bHkgKHNlZSB0aGUgYXNzb2NpYXRlZCBtZXRob2RzXG5cdCAqIGluIFRydXRoLlByb2dyYW0pLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIERvY3VtZW50IGV4dGVuZHMgQWJzdHJhY3RDbGFzc1xuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW50ZXJuYWwgY29uc3RydWN0b3IgZm9yIERvY3VtZW50IG9iamVjdHMuXG5cdFx0ICogRG9jdW1lbnQgb2JqZWN0cyBhcmUgY3JlYXRlZCB2aWEgYSBQcm9ncmFtIG9iamVjdC5cblx0XHQgKi9cblx0XHRzdGF0aWMgYXN5bmMgbmV3KFxuXHRcdFx0cHJvZ3JhbTogUHJvZ3JhbSxcblx0XHRcdGZyb21Vcmk6IEtub3duVXJpLFxuXHRcdFx0c291cmNlVGV4dDogc3RyaW5nLFxuXHRcdFx0c2F2ZUZuOiAoZG9jOiBEb2N1bWVudCkgPT4gdm9pZCk6IFByb21pc2U8RG9jdW1lbnQgfCBFcnJvcj5cblx0XHR7XG5cdFx0XHRjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQocHJvZ3JhbSwgZnJvbVVyaSk7XG5cdFx0XHRjb25zdCB1cmlTdGF0ZW1lbnRzOiBVcmlTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB0b3BMZXZlbFN0YXRlbWVudHM6IFN0YXRlbWVudFtdID0gW107XG5cdFx0XHRjb25zdCB0b3BMZXZlbFN0YXRlbWVudEluZGV4ZXM6IG51bWJlcltdID0gW107XG5cdFx0XHRsZXQgbWF4SW5kZW50ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0XHRsZXQgbGluZU51bWJlciA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50VGV4dCBvZiB0aGlzLnJlYWRMaW5lcyhzb3VyY2VUZXh0KSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc210ID0gbmV3IFN0YXRlbWVudChkb2MsIHN0YXRlbWVudFRleHQpXG5cdFx0XHRcdGRvYy5zdGF0ZW1lbnRzLnB1c2goc210KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzbXQudXJpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dXJpU3RhdGVtZW50cy5wdXNoKHNtdCBhcyBVcmlTdGF0ZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHNtdC5pbmRlbnQgPD0gbWF4SW5kZW50ICYmICFzbXQuaXNOb29wKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dG9wTGV2ZWxTdGF0ZW1lbnRzLnB1c2goc210KTtcblx0XHRcdFx0XHR0b3BMZXZlbFN0YXRlbWVudEluZGV4ZXMucHVzaCgrK2xpbmVOdW1iZXIpO1xuXHRcdFx0XHRcdG1heEluZGVudCA9IHNtdC5pbmRlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHNhdmVzIHRoZSBkb2N1bWVudCBpbiB0aGUgUHJvZ3JhbSBpbnN0YW5jZVxuXHRcdFx0Ly8gdGhhdCBpbnZva2VkIHRoaXMgbmV3IERvY3VtZW50LiBUaGlzIGlzIGEgYml0IHNwYWdldHRpLWlzaCwgYnV0IHRoZVxuXHRcdFx0Ly8gbmV3bHkgY3JlYXRlZCBkb2N1bWVudCBoYXMgdG8gYmUgaW4gdGhlIFByb2dyYW0ncyAuZG9jdW1lbnRzXG5cdFx0XHQvLyBhcnJheSwgb3IgdGhlIHVwZGF0aW5nIG9mIHJlZmVyZW5jZXMgd29uJ3Qgd29yay5cblx0XHRcdHNhdmVGbihkb2MpO1xuXHRcdFx0XG5cdFx0XHRpZiAodXJpU3RhdGVtZW50cy5sZW5ndGggPiAwKVxuXHRcdFx0XHRhd2FpdCBkb2MudXBkYXRlUmVmZXJlbmNlcyhbXSwgdXJpU3RhdGVtZW50cyk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0uY2F1c2UobmV3IENhdXNlUmV2YWxpZGF0ZShcblx0XHRcdFx0ZG9jLFxuXHRcdFx0XHR0b3BMZXZlbFN0YXRlbWVudHMsXG5cdFx0XHRcdHRvcExldmVsU3RhdGVtZW50SW5kZXhlc1xuXHRcdFx0KSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBkb2M7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IHlpZWxkcyBhbGwgc3RhdGVtZW50cyAodW5wYXJzZWQgbGluZXMpXG5cdFx0ICogb2YgdGhlIGdpdmVuIHNvdXJjZSB0ZXh0LiBcblx0XHQgKi9cblx0XHRwcml2YXRlIHN0YXRpYyAqcmVhZExpbmVzKHNvdXJjZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGxldCBjdXJzb3IgPSAtMTtcblx0XHRcdGxldCBzdGF0ZW1lbnRTdGFydCA9IDA7XG5cdFx0XHRjb25zdCBjaGFyID0gKCkgPT4gc291cmNlW2N1cnNvcl07XG5cdFx0XHRcblx0XHRcdGZvciAoOzspXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjdXJzb3IgPj0gc291cmNlLmxlbmd0aCAtIDEpXG5cdFx0XHRcdFx0cmV0dXJuIHlpZWxkIHNvdXJjZS5zbGljZShzdGF0ZW1lbnRTdGFydCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjdXJzb3IrKztcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaGFyKCkgPT09IFN5bnRheC50ZXJtaW5hbClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpZWxkIHNvdXJjZS5zbGljZShzdGF0ZW1lbnRTdGFydCwgY3Vyc29yKTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRTdGFydCA9IGN1cnNvciArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcm9ncmFtOiBQcm9ncmFtLCBzb3VyY2VVcmk6IEtub3duVXJpKVxuXHRcdHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdFx0dGhpcy5fdXJpID0gc291cmNlVXJpO1xuXHRcdFx0dGhpcy5waHJhc2UgPSBQaHJhc2UubmV3KHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cmVhZG9ubHkgY2xhc3MgPSBDbGFzcy5kb2N1bWVudDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBTdG9yZXMgdGhlIHJvb3QgcGhyYXNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY3VtZW50XG5cdFx0ICogKHdpdGggYW4gZW1wdHkgdGVybXMgYXJyYXkpLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHBocmFzZTogUGhyYXNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgVVJJIGZyb20gd2hlcmUgdGhpcyBkb2N1bWVudCB3YXMgbG9hZGVkLlxuXHRcdCAqL1xuXHRcdGdldCB1cmkoKTogS25vd25Vcmlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdXJpO1xuXHRcdH1cblx0XHRwcml2YXRlIF91cmk6IEtub3duVXJpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEEgcm9sbGluZyB2ZXJzaW9uIHN0YW1wIHRoYXQgaW5jcmVtZW50cyBhZnRlciBlYWNoIGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICovXG5cdFx0Z2V0IHZlcnNpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl92ZXJzaW9uO1xuXHRcdH1cblx0XHRwcml2YXRlIF92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgdGhlIERvY3VtZW50J3Mgc3RhdGVtZW50cyxcblx0XHQgKiBzb3J0ZWQgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcHBlYXIgaW4gdGhlIGZpbGUuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzdGF0ZW1lbnRzID0gbmV3IEFycmF5MUJhc2VkPFN0YXRlbWVudD4oKTtcblx0XHRcblx0XHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSBDb21waWxlciB0aGF0IG93bnMgdGhpcyBEb2N1bWVudC4gKi9cblx0XHRyZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhpcyBkb2N1bWVudCBmb3IgdGhlIHJvb3QtbGV2ZWwgdHlwZXMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHVyaSBUaGUgVVJJIG9mIHRoZSBkb2N1bWVudCB0byBxdWVyeS4gSWYgdGhlIFVSSSBjb250YWluc1xuXHRcdCAqIGEgdHlwZSBwYXRoLCBpdCBpcyBmYWN0b3JlZCBpbnRvIHRoZSBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHR5cGVQYXRoIFRoZSB0eXBlIHBhdGggd2l0aGluIHRoZSBkb2N1bWVudCB0byBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBmdWxseSBjb25zdHJ1Y3RlZCBUeXBlIGluc3RhbmNlIHRoYXQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiB0aGUgdHlwZSBhdCB0aGUgVVJJIHNwZWNpZmllZCwgb3IgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIG5vIHR5cGVcblx0XHQgKiBjb3VsZCBiZSBmb3VuZC5cblx0XHQgKi9cblx0XHRxdWVyeSguLi50eXBlUGF0aDogc3RyaW5nW10pOiBUeXBlIHwgbnVsbFxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnByb2dyYW0ucXVlcnkodGhpcywgLi4udHlwZVBhdGgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSByb290LWxldmVsIHR5cGVzIHRoYXQgYXJlIGRlZmluZWQgd2l0aGluIHRoaXMgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0IHR5cGVzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fdHlwZXMpXG5cdFx0XHRcdHJldHVybiB0aGlzLl90eXBlcztcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGVzID0gT2JqZWN0LmZyZWV6ZSh0aGlzLnByb2dyYW0ucXVlcnkodGhpcykpO1xuXHRcdH1cblx0XHRwcml2YXRlIF90eXBlczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBkb2N1bWVudCBoYXMgYVxuXHRcdCAqIHN0YXRlbWVudC1sZXZlbCBmYXVsdCBtYXRjaGluZyB0aGUgZmF1bHQgdHlwZSBzcGVjaWZpZWQsIG9uIHRoZSBzcGVjaWZpZWQgbGluZS5cblx0XHQgKi9cblx0XHRoYXNGYXVsdChcblx0XHRcdGZhdWx0VHlwZTogU3RhdGVtZW50RmF1bHRUeXBlLFxuXHRcdFx0bGluZTogbnVtYmVyKTogYm9vbGVhbjtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGRvY3VtZW50IGhhcyBhXG5cdFx0ICogdGVybS1sZXZlbCBmYXVsdCBtYXRjaGluZyB0aGUgZmF1bHQgdHlwZSBzcGVjaWZpZWQsIG9uIHRoZSBzcGVjaWZpZWQgbGluZSxcblx0XHQgKiBhbmQgYXQgdGhlIHNwZWNpZmllZCB0ZXJtIGluZGV4LlxuXHRcdCAqL1xuXHRcdGhhc0ZhdWx0KFxuXHRcdFx0ZmF1bHRUeXBlOiBTcGFuRmF1bHRUeXBlLFxuXHRcdFx0bGluZTogbnVtYmVyLFxuXHRcdFx0dGVybUluZGV4OiBudW1iZXIpOiBib29sZWFuO1xuXHRcdFxuXHRcdGhhc0ZhdWx0KGZhdWx0VHlwZTogUmVhZG9ubHk8RmF1bHRUeXBlPiwgbGluZTogbnVtYmVyLCB0ZXJtSW5kZXggPSAtMSlcblx0XHR7XG5cdFx0XHRjb25zdCBjb21wID0gdGVybUluZGV4IDwgMCA/XG5cdFx0XHRcdFtmYXVsdFR5cGUsIGxpbmVdIDpcblx0XHRcdFx0W2ZhdWx0VHlwZSwgbGluZSwgdGVybUluZGV4XTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29tcEZhdWx0ID0gdGhpcy5jcmVhdGVDb21wYXJpc29uRmF1bHQoY29tcCBhcyBUQ29tcGFyaXNvbkZhdWx0KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBmYXVsdCBvZiB0aGlzLnByb2dyYW0uZmF1bHRzLmVhY2godGhpcykpXG5cdFx0XHRcdGlmICh0aGlzLnByb2dyYW0uZmF1bHRzLmNvbXBhcmVGYXVsdHMoY29tcEZhdWx0LCBmYXVsdCkgPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRvY3VtZW50XG5cdFx0ICogaGFzIGF0IGxlYXN0IG9uZSBmYXVsdC5cblx0XHQgKi9cblx0XHRoYXNGYXVsdHMoKTogYm9vbGVhbjtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZG9jdW1lbnRcblx0XHQgKiBoYXMgZXhhY3RseSB0aGUgZmF1bHRzIHNwZWNpZmllZCAobm8gbW9yZSwgbm8gbGVzcykuXG5cdFx0ICovXG5cdFx0aGFzRmF1bHRzKC4uLmV4cGVjdGF0aW9uczogVENvbXBhcmlzb25GYXVsdFtdKTogYm9vbGVhblxuXHRcdGhhc0ZhdWx0cyguLi5leHBlY3RhdGlvbnM6IFRDb21wYXJpc29uRmF1bHRbXSlcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNSZXBvcnRlZCA9IEFycmF5LmZyb20odGhpcy5wcm9ncmFtLmZhdWx0cy5lYWNoKHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0aWYgKGV4cGVjdGF0aW9ucy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBmYXVsdHNSZXBvcnRlZC5sZW5ndGggPiAwO1xuXHRcdFx0XG5cdFx0XHRpZiAoZXhwZWN0YXRpb25zLmxlbmd0aCAhPT0gZmF1bHRzUmVwb3J0ZWQubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZhdWx0c0V4cGVjdGVkID0gZXhwZWN0YXRpb25zXG5cdFx0XHRcdC5tYXAoZXhwID0+IHRoaXMuY3JlYXRlQ29tcGFyaXNvbkZhdWx0KGV4cCkpXG5cdFx0XHRcdC5zb3J0KHRoaXMucHJvZ3JhbS5mYXVsdHMuY29tcGFyZUZhdWx0cyk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgZmF1bHRzUmVwb3J0ZWQubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmVwID0gZmF1bHRzUmVwb3J0ZWRbaV07XG5cdFx0XHRcdGNvbnN0IGV4cCA9IGZhdWx0c0V4cGVjdGVkW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMucHJvZ3JhbS5mYXVsdHMuY29tcGFyZUZhdWx0cyhyZXAsIGV4cCkgIT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjcmVhdGVDb21wYXJpc29uRmF1bHQoY29tcDogVENvbXBhcmlzb25GYXVsdClcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnJlYWQoY29tcFsxXSk7XG5cdFx0XHRcblx0XHRcdGlmIChjb21wLmxlbmd0aCA9PT0gMilcblx0XHRcdFx0cmV0dXJuIG5ldyBGYXVsdChjb21wWzBdLCBzbXQpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBuZnhMZW4gPSBzbXQuaW5maXhTcGFucy5sZW5ndGg7XG5cdFx0XHRjb25zdCBpZHggPSBjb21wWzJdO1xuXHRcdFx0Y29uc3Qgc3BhbiA9IFxuXHRcdFx0XHRuZnhMZW4gPiAwICYmIGlkeCA9PT0gMCA/IHNtdC5zcGFuc1swXSA6XG5cdFx0XHRcdG5meExlbiA+IDAgJiYgaWR4IDwgbmZ4TGVuICsgMSA/IHNtdC5pbmZpeFNwYW5zW2lkeCAtIDFdIDpcblx0XHRcdFx0c210LnNwYW5zW2lkeCAtIG5meExlbl07XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgRmF1bHQoY29tcFswXSwgc3Bhbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFN0YXRlbWVudCBvYmplY3RzIHRoYXQgcmVwcmVzZW50XG5cdFx0ICogYW5jZXN0cnkgb2YgdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQsIG9yIDEtYmFzZWQgbGluZSBudW1iZXIuIFxuXHRcdCAqIElmIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50IGlzIG5vdCBpbiB0aGlzIGRvY3VtZW50LCB0aGVcblx0XHQgKiByZXR1cm5lZCB2YWx1ZSBpcyBudWxsLlxuXHRcdCAqL1xuXHRcdGdldEFuY2VzdHJ5KHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNtdCA9IHRoaXMudG9TdGF0ZW1lbnQoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIHN0YXRlbWVudCBpcyByb290LWxldmVsLCBpdCBjYW4ndCBoYXZlIGFuIGFuY2VzdHJ5LlxuXHRcdFx0aWYgKHNtdC5pbmRlbnQgPT09IDApXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFxuXHRcdFx0bGV0IHBvcyA9IHRoaXMuc3RhdGVtZW50cy5wb3NPZihzbXQpO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9zIDwgMClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChwb3MgPCAyKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFuY2VzdHJ5ID0gW3NtdF07XG5cdFx0XHRsZXQgaW5kZW50VG9CZWF0ID0gc210LmluZGVudDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjdXJyZW50U3RhdGVtZW50IG9mIHRoaXMuc3RhdGVtZW50cy5lbnVtZXJhdGVCYWNrd2FyZChwb3MpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pc05vb3ApXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pbmRlbnQgPCBpbmRlbnRUb0JlYXQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhbmNlc3RyeS51bnNoaWZ0KGN1cnJlbnRTdGF0ZW1lbnQpO1xuXHRcdFx0XHRcdGluZGVudFRvQmVhdCA9IGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pbmRlbnQgPT09IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBhbmNlc3RyeS5zbGljZSgwLCAtMSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIHBhcmVudCBTdGF0ZW1lbnQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgU3RhdGVtZW50LiBcblx0XHQgKiBJZiB0aGUgc3RhdGVtZW50IGlzIHRvcCBsZXZlbCwgYSByZWZlcmVuY2UgdG8gdGhpcyBkb2N1bWVudCBvYmplY3Rcblx0XHQgKiBpcyByZXR1cm5lZC4gSWYgdGhlIHN0YXRlbWVudCBpcyBub3QgZm91bmQgaW4gdGhlIGRvY3VtZW50LCBvciB0aGVcblx0XHQgKiBzcGVjaWZpZWQgc3RhdGVtZW50IGlzIGEgbm8tb3AsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudWxsLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBzdGF0ZW1lbnQgQSBzdGF0ZW1lbnQgb2JqZWN0LCBvciBhIDEtYmFzZWQgbGluZSBudW1iZXJcblx0XHQgKiBvZiBhIHN0YXRlbWVudCB3aXRoaW4gdGhpcyBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRnZXRQYXJlbnQoc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210ID0gdGhpcy50b1N0YXRlbWVudChzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBzdGF0ZW1lbnQgaXMgcm9vdC1sZXZlbCwgaXQgY2FuJ3QgaGF2ZSBhIHBhcmVudC5cblx0XHRcdGlmIChzbXQuaW5kZW50ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0bGV0IHBvcyA9IHRoaXMuc3RhdGVtZW50cy5wb3NPZihzbXQpO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9zIDwgMClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cblx0XHRcdGlmIChwb3MgPCAyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5kZW50VG9CZWF0ID0gc210LmluZGVudDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjdXJyZW50U3RhdGVtZW50IG9mIHRoaXMuc3RhdGVtZW50cy5lbnVtZXJhdGVCYWNrd2FyZChwb3MpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pc05vb3ApXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pbmRlbnQgPCBpbmRlbnRUb0JlYXQpXG5cdFx0XHRcdFx0cmV0dXJuIGN1cnJlbnRTdGF0ZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIElmIGEgcGFyZW50IHN0YXRlbWVudCB3YXNuJ3QgZm91bmQsIHRoZW4gdGhlXG5cdFx0XHQvLyBpbnB1dCBzdGF0ZW1lbnQgaXMgdG9wLWxldmVsLCBhbmQgYSByZWZlcmVuY2Vcblx0XHRcdC8vIHRvIHRoaXMgRG9jdW1lbnQgb2JqZWN0IGlzIHJldHVybmVkLlxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBTdGF0ZW1lbnQgdGhhdCB3b3VsZCBhY3QgYXMgdGhlIHBhcmVudCBpZiBhIHN0YXRlbWVudCB3aGVyZSB0byBiZVxuXHRcdCAqIGluc2VydGVkIGF0IHRoZSBzcGVjaWZpZWQgdmlydHVhbCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuIElmIGFuIGluc2VydGVkIHN0YXRlbWVudFxuXHRcdCAqIHdvdWxkIGJlIHRvcC1sZXZlbCwgYSByZWZlcmVuY2UgdG8gdGhpcyBkb2N1bWVudCBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0Z2V0UGFyZW50RnJvbVBvc2l0aW9uKGxpbmVOdW1iZXI6IG51bWJlciwgbGluZU9mZnNldDogbnVtYmVyKTogU3RhdGVtZW50IHwgdGhpc1xuXHRcdHtcblx0XHRcdGlmIChsaW5lTnVtYmVyID09PSAxIHx8IFxuXHRcdFx0XHRsaW5lTnVtYmVyID09PSAwIHx8XG5cdFx0XHRcdGxpbmVPZmZzZXQgPCAxIHx8IFxuXHRcdFx0XHR0aGlzLnN0YXRlbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgdGhpcy5zdGF0ZW1lbnRzLmVudW1lcmF0ZUJhY2t3YXJkKGxpbmVOdW1iZXIpKVxuXHRcdFx0XHRpZiAoIXNtdC5pc05vb3AgJiYgc210LmluZGVudCA8IGxpbmVPZmZzZXQpXG5cdFx0XHRcdFx0cmV0dXJuIHNtdDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBzaWJsaW5nIFN0YXRlbWVudCBvYmplY3RzIG9mIHRoZSAgc3BlY2lmaWVkIFN0YXRlbWVudC4gXG5cdFx0ICogSWYgdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQgaXMgYSBuby1vcCwgdGhlIHJldHVybmVkIHZhbHVlIGlzIG51bGwuXG5cdFx0ICogQHRocm93cyBBbiBlcnJvciBpbiB0aGUgY2FzZSB3aGVuIHRoZSBzdGF0ZW1lbnQgaXMgbm90IGZvdW5kIGluIFxuXHRcdCAqIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRnZXRTaWJsaW5ncyhzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnRvU3RhdGVtZW50KHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGlmIChzbXQuaXNOb29wKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHNtdC5pbmRlbnQgPT09IDApXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KHNtdCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJlbnQgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJlbnQgPT09IHRoaXMpXG5cdFx0XHRcdHJldHVybiBwYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4ocGFyZW50IGFzIFN0YXRlbWVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBjaGlsZCBTdGF0ZW1lbnQgb2JqZWN0cyBvZiB0aGUgc3BlY2lmaWVkXG5cdFx0ICogU3RhdGVtZW50LiBJZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciBvbWl0dGVkLCB0aGVcblx0XHQgKiBkb2N1bWVudCdzIHRvcC1sZXZlbCBzdGF0ZW1lbnRzIGFyZSByZXR1cm5lZC4gXG5cdFx0ICogXG5cdFx0ICogQHRocm93cyBBbiBlcnJvciBpbiB0aGUgY2FzZSB3aGVuIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBzdGF0ZW1lbnQgaXMgbm90IGZvdW5kIGluIHRoZSBkb2N1bWVudC4gXG5cdFx0ICovXG5cdFx0Z2V0Q2hpbGRyZW4oc3RhdGVtZW50PzogU3RhdGVtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IGNoaWxkcmVuOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0bGV0IHBvcyA9IDE7XG5cdFx0XHRcblx0XHRcdC8vIFN0b3JlcyB0aGUgaW5kZW50IHZhbHVlIHRoYXQgY2F1c2VzIHRoZSBsb29wXG5cdFx0XHQvLyB0byB0ZXJtaW5hdGUgd2hlbiByZWFjaGVkLlxuXHRcdFx0bGV0IHN0b3BJbmRlbnQgPSAtMTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIHRoZSBpbmRlbnQgdmFsdWUgdGhlIGluZGljYXRlcyB0aGUgbWF4aW11bVxuXHRcdFx0Ly8gdmFsdWUgYXQgd2hpY2ggYSBzdGF0ZW1lbnQgaXMgc3RpbGwgY29uc2lkZXJlZCB0byBiZVxuXHRcdFx0Ly8gYSBjaGlsZC4gVGhpcyB2YWx1ZSBjYW4gcmV0cmFjdCBhcyB0aGUgYWxnb3JpdGhtIGlzXG5cdFx0XHQvLyBvcGVyYXRpbmcgdG8gZGVhbCB3aXRoIGJpemFycmUgKGJ1dCB2YWxpZCkgaW5kZW50YXRpb24uXG5cdFx0XHRsZXQgbWF4SW5kZW50ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0XHRcblx0XHRcdGlmIChzdGF0ZW1lbnQpXG5cdFx0XHR7XG5cdFx0XHRcdHBvcyA9IHRoaXMuc3RhdGVtZW50cy5wb3NPZihzdGF0ZW1lbnQpO1xuXHRcdFx0XHRpZiAocG9zIDwgMClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uc3RhdGVtZW50Tm90SW5Eb2N1bWVudCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0c3RvcEluZGVudCA9IHN0YXRlbWVudC5pbmRlbnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTdGFydCB0aGUgaXRlcmF0aW9uIDEgcG9zaXRpb24gYWZ0ZXIgdGhlIHN0YXRlbWVudFxuXHRcdFx0XHQvLyBzcGVjaWZpZWQsIHNvIHRoYXQgd2UncmUgYWx3YXlzIHBhc3NpbmcgdGhyb3VnaFxuXHRcdFx0XHQvLyBwb3RlbnRpYWwgY2hpbGRyZW4uXG5cdFx0XHRcdHBvcysrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiB0aGlzLnN0YXRlbWVudHMuZW51bWVyYXRlRm9yd2FyZChwb3MpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYmFjayB1cCB0aGUgaW5kZW50YXRpb24gb2YgY2hpbGQgc3RhdGVtZW50cywgXG5cdFx0XHRcdC8vIGluIG9yZGVyIHRvIGRlYWwgd2l0aCBiaXphcnJlIChidXQgdmFsaWQpIGluZGVudGF0aW9uLlxuXHRcdFx0XHRpZiAoc210LmluZGVudCA8IG1heEluZGVudClcblx0XHRcdFx0XHRtYXhJbmRlbnQgPSBzbXQuaW5kZW50O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNtdC5pbmRlbnQgPD0gc3RvcEluZGVudClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzbXQuaW5kZW50IDw9IG1heEluZGVudClcblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHNtdCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjaGlsZHJlbjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0YXRlbWVudCwgb3IgdGhlIHN0YXRlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGhhcyBhbnlcblx0XHQgKiBkZXNjZW5kYW50cy4gSWYgdGhlIGFyZ3VtZW50IGlzIG51bGwsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhXG5cdFx0ICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBkb2N1bWVudCBoYXMgYW55IG5vbi1ub29wXG5cdFx0ICogc3RhdGVtZW50cy5cblx0XHQgKi9cblx0XHRoYXNEZXNjZW5kYW50cyhzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0aWYgKHN0YXRlbWVudCA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgdGhpcy5zdGF0ZW1lbnRzLmVudW1lcmF0ZUZvcndhcmQoKSlcblx0XHRcdFx0XHRpZiAoIXNtdC5pc05vb3ApXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc210ID0gc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50ID9cblx0XHRcdFx0XHRzdGF0ZW1lbnQgOiBcblx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHMuZ2V0KHN0YXRlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgaWR4ID0gc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50ID9cblx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHMucG9zT2Yoc3RhdGVtZW50KSA6XG5cdFx0XHRcdFx0c3RhdGVtZW50O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBjdXJyZW50U3RhdGVtZW50IG9mIHRoaXMuc3RhdGVtZW50cy5lbnVtZXJhdGVGb3J3YXJkKGlkeCArIDEpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaXNOb29wKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50ID4gc210LmluZGVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSAxLWJhc2VkIGxpbmUgbnVtYmVyIG9mIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50IGluXG5cdFx0ICogdGhlIGRvY3VtZW50LCByZWx5aW5nIG9uIGNhY2hpbmcgd2hlbiBhdmFpbGFibGUuIElmIHRoZSBzdGF0ZW1lbnRcblx0XHQgKiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZG9jdW1lbnQsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyAtMS5cblx0XHQgKi9cblx0XHRsaW5lTnVtYmVyT2Yoc3RhdGVtZW50OiBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50cy5wb3NPZihzdGF0ZW1lbnQpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSBjb250ZW50XG5cdFx0ICogd3JpdHRlbiBpbiB0aGUgY29tbWVudHMgZGlyZWN0bHkgYWJvdmUgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0YXRlbWVudC4gV2hpdGVzcGFjZSBsaW5lcyBhcmUgaWdub3JlZC4gSWYgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0YXRlbWVudCBpcyBhIG5vLW9wLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRnZXROb3RlcyhzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnRvU3RhdGVtZW50KHN0YXRlbWVudCk7XG5cdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBsaW5lTnVtID0gdGhpcy5saW5lTnVtYmVyT2Yoc210KTtcblx0XHRcdGlmIChsaW5lTnVtIDwgMSlcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb21tZW50TGluZXM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRjb25zdCByZXF1aXJlZEluZGVudCA9IHNtdC5pbmRlbnQ7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgY3VycmVudFN0YXRlbWVudCBvZiB0aGlzLnN0YXRlbWVudHMuZW51bWVyYXRlQmFja3dhcmQobGluZU51bSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmlzV2hpdGVzcGFjZSlcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNvbW1lbnRUZXh0ID0gY3VycmVudFN0YXRlbWVudC5nZXRDb21tZW50VGV4dCgpO1xuXHRcdFx0XHRpZiAoY29tbWVudFRleHQgPT09IG51bGwpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pbmRlbnQgIT09IHJlcXVpcmVkSW5kZW50KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29tbWVudExpbmVzLnB1c2goY29tbWVudFRleHQpO1xuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdHJldHVybiBjb21tZW50TGluZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVudW1lcmF0ZXMgdGhyb3VnaCBlYWNoIHN0YXRlbWVudCB0aGF0IGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgXG5cdFx0ICogc3BlY2lmaWVkIHN0YXRlbWVudC4gSWYgdGhlIHBhcmFtZXRlcnMgYXJlIG51bGwgb3Igb21pdHRlZCwgYWxsIFxuXHRcdCAqIHN0YXRlbWVudHMgaW4gdGhpcyBEb2N1bWVudCBhcmUgeWllbGRlZC5cblx0XHQgKiBcblx0XHQgKiBUaGUgbWV0aG9kIHlpZWxkcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgeWllbGRlZCBzdGF0ZW1lbnQsXG5cdFx0ICogYXMgd2VsbCBhcyBhIG51bWVyaWMgbGV2ZWwgdmFsdWUgdGhhdCBzcGVjaWZpZXMgdGhlIGRpZmZlcmVuY2UgaW4gXG5cdFx0ICogdGhlIG51bWJlciBvZiBuZXN0aW5nIGxldmVscyBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgaW5pdGlhbFN0YXRlbWVudFxuXHRcdCAqIGFuZCB0aGUgeWllbGRlZCBzdGF0ZW1lbnQuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGluaXRpYWxTdGF0ZW1lbnQgQSByZWZlcmVuY2UgdG8gdGhlIHN0YXRlbWVudCBvYmplY3Rcblx0XHQgKiBmcm9tIHdoZXJlIHRoZSBlbnVtZXJhdGlvbiBzaG91bGQgYmVnaW4uXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGluY2x1ZGVJbml0aWFsIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Jcblx0XHQgKiBub3QgdGhlIHNwZWNpZmllZCBpbml0aWFsU3RhdGVtZW50IHNob3VsZCBhbHNvIGJlIHJldHVybmVkXG5cdFx0ICogYXMgYW4gZWxlbWVudCBpbiB0aGUgZW51bWVyYXRpb24uIElmIHRydWUsIGluaXRpYWxTdGF0ZW1lbnRcblx0XHQgKiBtdXN0IGJlIG5vbi1udWxsLlxuXHRcdCAqL1xuXHRcdCplYWNoRGVzY2VuZGFudChcblx0XHRcdGluaXRpYWxTdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCwgXG5cdFx0XHRpbmNsdWRlSW5pdGlhbD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0aWYgKGluY2x1ZGVJbml0aWFsKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIWluaXRpYWxTdGF0ZW1lbnQpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRBcmd1bWVudCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQgeyBzdGF0ZW1lbnQ6IGluaXRpYWxTdGF0ZW1lbnQsIGxldmVsOiAwIH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGluaXRpYWxDaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oaW5pdGlhbFN0YXRlbWVudCk7XG5cdFx0XHRpZiAoIWluaXRpYWxDaGlsZHJlbilcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGluaXRpYWwgbGV2ZWwgaXMgMCBpZiB0aGUgc3BlY2lmaWVkIGluaXRpYWxTdGF0ZW1lbnQgaXNcblx0XHRcdC8vIG51bGwsIGJlY2F1c2UgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGVudW1lcmF0aW9uIHN0YXJ0c1xuXHRcdFx0Ly8gYXQgdGhlIHJvb3Qgb2YgdGhlIGRvY3VtZW50LlxuXHRcdFx0bGV0IGxldmVsID0gaW5pdGlhbFN0YXRlbWVudCA/IDEgOiAwO1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiAqcmVjdXJzZShzdGF0ZW1lbnQ6IFN0YXRlbWVudCk6IEl0ZXJhYmxlSXRlcmF0b3I8e1xuXHRcdFx0XHRzdGF0ZW1lbnQ6IFN0YXRlbWVudDtcblx0XHRcdFx0bGV2ZWw6IG51bWJlcjtcblx0XHRcdH0+XG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkIHsgc3RhdGVtZW50LCBsZXZlbCB9O1xuXHRcdFx0XHRcblx0XHRcdFx0bGV2ZWwrKztcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgY2hpbGRTdGF0ZW1lbnQgb2Ygc2VsZi5nZXRDaGlsZHJlbihzdGF0ZW1lbnQpIHx8IFtdKVxuXHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlKGNoaWxkU3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldmVsLS07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIGluaXRpYWxDaGlsZHJlbilcblx0XHRcdFx0eWllbGQgKnJlY3Vyc2Uoc3RhdGVtZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRW51bWVyYXRlcyB0aHJvdWdoIGVhY2ggc3RhdGVtZW50IGluIHRoZSBkb2N1bWVudCxcblx0XHQgKiBpbmNsdWRpbmcgY29tbWVudHMgYW5kIHdoaXRlc3BhY2Utb25seSBsaW5lcywgc3RhcnRpbmdcblx0XHQgKiBhdCB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudCBvciBudW1lcmljIHBvc2l0aW9uLlxuXHRcdCAqIFxuXHRcdCAqIEB5aWVsZHMgVGhlIHN0YXRlbWVudHMgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcHBlYXJcblx0XHQgKiBpbiB0aGUgZG9jdW1lbnQsIGV4Y2x1ZGluZyB3aGl0ZXNwYWNlLW9ubHkgc3RhdGVtZW50cy5cblx0XHQgKi9cblx0XHQqZWFjaFN0YXRlbWVudChzdGF0ZW1lbnQ/OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3RhcnRQb3MgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCFzdGF0ZW1lbnQpXG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50KVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnN0YXRlbWVudHMucG9zT2Yoc3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBzdGF0ZW1lbnQ7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiB0aGlzLnN0YXRlbWVudHMuZW51bWVyYXRlRm9yd2FyZChzdGFydFBvcykpXG5cdFx0XHRcdHlpZWxkIHNtdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgdGhlIFN0YXRlbWVudCBhdCB0aGUgZ2l2ZW4gMS1iYXNlZCBsaW5lIG51bWJlci5cblx0XHQgKiBOZWdhdGl2ZSBudW1iZXJzIHJlYWQgU3RhdGVtZW50IHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZChsaW5lTnVtYmVyOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50cy5nZXQobGluZU51bWJlcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNvbnZlcnRzIGEgc3RhdGVtZW50IG9yIGl0J3MgaW5kZXhcblx0XHQgKiB3aXRoaW4gdGhpcyBkb2N1bWVudCB0byBhIHN0YXRlbWVudCBvYmplY3QuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB0b1N0YXRlbWVudChzdGF0ZW1lbnRPckluZGV4OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHN0YXRlbWVudE9ySW5kZXggaW5zdGFuY2VvZiBTdGF0ZW1lbnQgPyBcblx0XHRcdFx0c3RhdGVtZW50T3JJbmRleCA6XG5cdFx0XHRcdHRoaXMucmVhZChzdGF0ZW1lbnRPckluZGV4KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIFN0YXJ0cyBhbiBlZGl0IHRyYW5zYWN0aW9uIGluIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdFx0ICogRWRpdCB0cmFuc2FjdGlvbnMgYXJlIHVzZWQgdG8gc3luY2hyb25pemUgY2hhbmdlcyBtYWRlIGluXG5cdFx0ICogYW4gdW5kZXJseWluZyBmaWxlLCB0eXBpY2FsbHkgZG9uZSBieSBhIHVzZXIgaW4gYSB0ZXh0IGVkaXRpbmdcblx0XHQgKiBlbnZpcm9ubWVudC4gU3lzdGVtLWluaXRpYXRlZCBjaGFuZ2VzIHN1Y2ggYXMgYXV0b21hdGVkXG5cdFx0ICogZml4ZXMsIHJlZmFjdG9ycywgb3IgcmVuYW1lcyBkbyBub3QgZ28gdGhyb3VnaCB0aGlzIHBhdGh3YXkuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGVkaXRGbiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaW4gd2hpY2ggdG8gcGVyZm9ybVxuXHRcdCAqIGRvY3VtZW50IG11dGF0aW9uIG9wZXJhdGlvbnMuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYW55IGV4dGVybmFsIGRvY3VtZW50XG5cdFx0ICogcmVmZXJlbmNlcyBhZGRlZCBkdXJpbmcgdGhlIGVkaXQgb3BlcmF0aW9uIGhhdmUgYmVlbiByZXNvbHZlZC5cblx0XHQgKiBJZiBubyBzdWNoIHJlZmVyZW5jZXMgd2VyZSBhZGRlZCwgYSBwcm9taXNlIGlzIHJldHVybmVkIHRoYXRcblx0XHQgKiByZXNvbHZlcyBpbW1lZGlhdGVseS5cblx0XHQgKi9cblx0XHRhc3luYyBlZGl0KGVkaXRGbjogKG11dGF0b3I6IElEb2N1bWVudE11dGF0b3IpID0+IHZvaWQpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaW5FZGl0KVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uZG91YmxlVHJhbnNhY3Rpb24oKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5pbkVkaXQgPSB0cnVlO1xuXHRcdFx0Y29uc3QgY2FsbHM6IFRDYWxsVHlwZVtdID0gW107XG5cdFx0XHRsZXQgaGFzRGVsZXRlID0gZmFsc2U7XG5cdFx0XHRsZXQgaGFzSW5zZXJ0ID0gZmFsc2U7XG5cdFx0XHRsZXQgaGFzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGVkaXRGbih7XG5cdFx0XHRcdGRlbGV0ZTogKHBvcyA9IC0xLCBjb3VudCA9IDEpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY291bnQgPiAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNhbGxzLnB1c2gobmV3IERlbGV0ZUNhbGwocG9zLCBjb3VudCkpO1xuXHRcdFx0XHRcdFx0aGFzRGVsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydDogKHRleHQ6IHN0cmluZywgcG9zID0gLTEpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjYWxscy5wdXNoKG5ldyBJbnNlcnRDYWxsKG5ldyBTdGF0ZW1lbnQodGhpcywgdGV4dCksIHBvcykpO1xuXHRcdFx0XHRcdGhhc0luc2VydCA9IHRydWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwZGF0ZTogKHRleHQ6IHN0cmluZywgcG9zID0gLTEpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy5yZWFkKHBvcykuc291cmNlVGV4dCAhPT0gdGV4dClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjYWxscy5wdXNoKG5ldyBVcGRhdGVDYWxsKG5ldyBTdGF0ZW1lbnQodGhpcywgdGV4dCksIHBvcykpO1xuXHRcdFx0XHRcdFx0aGFzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2FsbHMubGVuZ3RoID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmluRWRpdCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlbGV0ZWRVcmlTbXRzOiBVcmlTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0Y29uc3QgYWRkZWRVcmlTbXRzOiBVcmlTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBCZWdpbiB0aGUgYWxnb3JpdGhtIHRoYXQgZGV0ZXJtaW5lcyB0aGUgY2hhbmdlc2V0LFxuXHRcdFx0Ly8gYW5kIHJ1bnMgdGhlIGFwcHJvcHJpYXRlIGludmFsaWRhdGlvbiBhbmQgcmV2YWxpZGF0aW9uXG5cdFx0XHQvLyBob29rcy4gVGhpcyBpcyB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSB3ZSBuZWVkIHRvXG5cdFx0XHQvLyBwZXJmb3JtIGZpbmFsaXphdGlvbiBhdCB0aGUgYm90dG9tIChhbmQgdGhlcmUgYXJlIGVhcmx5XG5cdFx0XHQvLyByZXR1cm4gcG9pbnRzIHRocm91Z2hvdXQgdGhlIGFsZ29yaXRobS5cblx0XHRcdCgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBoYXNNaXhlZCA9XG5cdFx0XHRcdFx0aGFzSW5zZXJ0ICYmIGhhc1VwZGF0ZSB8fFxuXHRcdFx0XHRcdGhhc0luc2VydCAmJiBoYXNEZWxldGUgfHxcblx0XHRcdFx0XHRoYXNVcGRhdGUgJiYgaGFzRGVsZXRlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZG9EZWxldGUgPSAoY2FsbDogRGVsZXRlQ2FsbCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHNtdHMgPSB0aGlzLnN0YXRlbWVudHMuc3BsaWNlKGNhbGwucG9zLCBjYWxsLmNvdW50KTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzbXRzKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNtdC5kaXNwb3NlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChzbXQudXJpKVxuXHRcdFx0XHRcdFx0XHRkZWxldGVkVXJpU210cy5wdXNoKHNtdCBhcyBVcmlTdGF0ZW1lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gc210cztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRvSW5zZXJ0ID0gKGNhbGw6IEluc2VydENhbGwpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHMuc3BsaWNlKGNhbGwucG9zLCAwLCBjYWxsLnNtdCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNhbGwuc210LnVyaSlcblx0XHRcdFx0XHRcdGFkZGVkVXJpU210cy5wdXNoKGNhbGwuc210IGFzIFVyaVN0YXRlbWVudCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkb1VwZGF0ZSA9IChjYWxsOiBVcGRhdGVDYWxsKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmcgPSB0aGlzLnN0YXRlbWVudHMuZ2V0KGNhbGwucG9zKTtcblx0XHRcdFx0XHRpZiAoZXhpc3RpbmcudXJpKVxuXHRcdFx0XHRcdFx0ZGVsZXRlZFVyaVNtdHMucHVzaChleGlzdGluZyBhcyBVcmlTdGF0ZW1lbnQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMuc3RhdGVtZW50cy5zZXQoY2FsbC5wb3MsIGNhbGwuc210KTtcblx0XHRcdFx0XHRpZiAoY2FsbC5zbXQudXJpKVxuXHRcdFx0XHRcdFx0YWRkZWRVcmlTbXRzLnB1c2goY2FsbC5zbXQgYXMgVXJpU3RhdGVtZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRleGlzdGluZy5kaXNwb3NlKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWhhc01peGVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gVGhpcyBoYW5kbGVzIHRoZSBmaXJzdCBvcHRpbWl6YXRpb24sIHdoaWNoIGlzIHRoZSBjYXNlIHdoZXJlXG5cdFx0XHRcdFx0Ly8gdGhlIG9ubHkga2luZHMgb2YgbXV0YXRpb25zIHdoZXJlIHVwZGF0ZXMsIGFuZCBubyBzdHJ1Y3R1cmFsXG5cdFx0XHRcdFx0Ly8gY2hhbmdlcyBvY2N1cmVkLiBUaGlzIGhhbmRsZXMgdHlwaWNhbCBcInVzZXIgaXMgdHlwaW5nXCIgY2FzZXMuXG5cdFx0XHRcdFx0Ly8gTW9zdCBlZGl0cyB3aWxsIGJlIGNhdWdodCBoZXJlLlxuXHRcdFx0XHRcdGlmIChoYXNVcGRhdGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gU29ydCB0aGUgdXBkYXRlIGNhbGxzIGJ5IHRoZWlyIGluZGV4LCBhbmQgcHJ1bmUgdXBkYXRlc1xuXHRcdFx0XHRcdFx0Ly8gdGhhdCB3b3VsZCBiZSBvdmVycmlkZGVuIGluIGEgZm9sbG93aW5nIGNhbGwuXG5cdFx0XHRcdFx0XHRjb25zdCB1cGRhdGVDYWxsc1R5cGVkID0gY2FsbHMgYXMgVXBkYXRlQ2FsbFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgdXBkYXRlQ2FsbHMgPSB1cGRhdGVDYWxsc1R5cGVkXG5cdFx0XHRcdFx0XHRcdC5zb3J0KChhLCBiKSA9PiBhLnBvcyAtIGIucG9zKVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKChjYWxsLCBpKSA9PiBpID49IGNhbGxzLmxlbmd0aCAtIDEgfHwgY2FsbC5wb3MgIT09IGNhbGxzW2kgKyAxXS5wb3MpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBvbGRTdGF0ZW1lbnRzID0gdXBkYXRlQ2FsbHMubWFwKGMgPT4gdGhpcy5zdGF0ZW1lbnRzLmdldChjLnBvcykpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3U3RhdGVtZW50cyA9IHVwZGF0ZUNhbGxzLm1hcChjID0+IGMuc210KTtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ZXMgPSBPYmplY3QuZnJlZXplKHVwZGF0ZUNhbGxzLm1hcChjID0+IGMucG9zKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IG5vU3RydWN0dXJhbENoYW5nZXMgPSBvbGRTdGF0ZW1lbnRzLmV2ZXJ5KChvbGRTbXQsIGlkeCkgPT5cblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmV3U210ID0gbmV3U3RhdGVtZW50c1tpZHhdO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2xkU210LmluZGVudCA9PT0gbmV3U210LmluZGVudCB8fFxuXHRcdFx0XHRcdFx0XHRcdG9sZFNtdC5pc05vb3AgJiYgbmV3U210LmlzTm9vcDtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobm9TdHJ1Y3R1cmFsQ2hhbmdlcylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaGFzT3BTdGF0ZW1lbnRzID1cblx0XHRcdFx0XHRcdFx0XHRvbGRTdGF0ZW1lbnRzLnNvbWUoc210ID0+ICFzbXQuaXNOb29wKSB8fFxuXHRcdFx0XHRcdFx0XHRcdG5ld1N0YXRlbWVudHMuc29tZShzbXQgPT4gIXNtdC5pc05vb3ApO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGhhc09wU3RhdGVtZW50cylcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdC8vIFRlbGwgc3Vic2NyaWJlcnMgdG8gYmxvdyBhd2F5IGFsbCB0aGUgb2xkIHN0YXRlbWVudHMuXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZUludmFsaWRhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0b2xkU3RhdGVtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRcdGluZGV4ZXMpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gUnVuIHRoZSBhY3R1YWwgbXV0YXRpb25zXG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgdXBkYXRlQ2FsbCBvZiB1cGRhdGVDYWxscylcblx0XHRcdFx0XHRcdFx0XHRkb1VwZGF0ZSh1cGRhdGVDYWxsKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChoYXNPcFN0YXRlbWVudHMpXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHQvLyBUZWxsIHN1YnNjcmliZXJzIHdoYXQgY2hhbmdlZFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VSZXZhbGlkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcywgXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdTdGF0ZW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW5kZXhlcykpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGlzIGhhbmRsZXMgdGhlIHNlY29uZCBvcHRpbWl6YXRpb24sIHdoaWNoIGlzIHRoZSBjYXNlIHdoZXJlXG5cdFx0XHRcdFx0Ly8gb25seSBkZWxldGVzIG9jY3VyZWQsIGFuZCBub25lIG9mIHRoZSBkZWxldGVkIHN0YXRlbWVudHMgaGF2ZSBhbnlcblx0XHRcdFx0XHQvLyBkZXNjZW5kYW50cy4gVGhpcyB3aWxsIGhhbmRsZSB0aGUgbWFqb3JpdHkgb2YgXCJkZWxldGUgYSBsaW5lXCIgY2FzZXMuXG5cdFx0XHRcdFx0aWYgKGhhc0RlbGV0ZSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWxldGVDYWxscyA9IGNhbGxzIGFzIERlbGV0ZUNhbGxbXTtcblx0XHRcdFx0XHRcdGNvbnN0IGRlYWRTdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVhZEluZGV4ZXM6IG51bWJlcltdID0gW107XG5cdFx0XHRcdFx0XHRsZXQgaGFzT3BTdGF0ZW1lbnRzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvckNhbGxzOlxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBkZWxldGVDYWxsIG9mIGRlbGV0ZUNhbGxzKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IGRlbGV0ZUNhbGwuY291bnQ7KVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGVhZFNtdCA9IHRoaXMuc3RhdGVtZW50cy5nZXQoZGVsZXRlQ2FsbC5wb3MgKyBpKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5oYXNEZXNjZW5kYW50cyhkZWFkU210KSlcblx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWFkU3RhdGVtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgZm9yQ2FsbHM7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdGRlYWRTdGF0ZW1lbnRzLnB1c2goZGVhZFNtdCk7XG5cdFx0XHRcdFx0XHRcdFx0ZGVhZEluZGV4ZXMucHVzaChpKTtcblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWRlYWRTbXQuaXNOb29wKVxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzT3BTdGF0ZW1lbnRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoZGVhZFN0YXRlbWVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gVGVsbCBzdWJzY3JpYmVycyB0byBibG93IGF3YXkgYWxsIHRoZSBvbGQgc3RhdGVtZW50cy5cblx0XHRcdFx0XHRcdFx0Ly8gQW4gZWRpdCB0cmFuc2FjdGlvbiBjYW4gYmUgYXZvaWRlZCBjb21wbGV0ZWx5IGluIHRoZSBjYXNlXG5cdFx0XHRcdFx0XHRcdC8vIHdoZW4gdGhlIG9ubHkgc3RhdGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZCB3ZXJlIG5vb3BzLlxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzT3BTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VJbnZhbGlkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdGRlYWRTdGF0ZW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVhZEluZGV4ZXMpKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFJ1biB0aGUgYWN0dWFsIG11dGF0aW9uc1xuXHRcdFx0XHRcdFx0XHRkZWxldGVDYWxscy5mb3JFYWNoKGRvRGVsZXRlKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFJ1biBhbiBlbXB0eSByZXZhbGlkYXRpb24gaG9vaywgdG8gY29tcGx5IHdpdGggdGhlXG5cdFx0XHRcdFx0XHRcdC8vIHJ1bGUgdGhhdCBmb3IgZXZlcnkgaW52YWxpZGF0aW9uIGhvb2ssIHRoZXJlIGlzIGFsd2F5cyBhXG5cdFx0XHRcdFx0XHRcdC8vIGNvcnJlc3BvbmRpbmcgcmV2YWxpZGF0aW9uIGhvb2suXG5cdFx0XHRcdFx0XHRcdGlmIChoYXNPcFN0YXRlbWVudHMpXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZVJldmFsaWRhdGUodGhpcywgW10sIFtdKSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRoaXMgaGFuZGxlcyB0aGUgdGhpcmQgb3B0aW1pemF0aW9uLCB3aGljaCBpcyB0aGUgY2FzZVxuXHRcdFx0XHRcdC8vIHdoZXJlIHRoZXJlIGFyZSBvbmx5IG5vb3Agc3RhdGVtZW50cyBiZWluZyBpbnNlcnRlZFxuXHRcdFx0XHRcdC8vIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdFx0XHRcdGlmIChoYXNJbnNlcnQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgaW5zZXJ0Q2FsbHMgPSBjYWxscyBhcyBJbnNlcnRDYWxsW107XG5cdFx0XHRcdFx0XHRpZiAoaW5zZXJ0Q2FsbHMuZXZlcnkoY2FsbCA9PiBjYWxsLnNtdC5pc05vb3ApKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpbnNlcnRDYWxscy5mb3JFYWNoKGRvSW5zZXJ0KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgdGhlIGNoZWNrcyB0byBzZWUgaWYgd2UgY2FuIGdldCBhd2F5IHdpdGhcblx0XHRcdFx0Ly8gcGVyZm9ybWluZyBzaW1wbGlzdGljIHVwZGF0ZXMgaGF2ZSBmYWlsZWQuIFNvIHdlIG5lZWRcblx0XHRcdFx0Ly8gdG8gcmVzb3J0IHRvIGludmFsaWRhdGluZyBhbmQgcmV2YWxpZGF0aW5nIGxhcmdlciBzd2F0aHMgXG5cdFx0XHRcdC8vIG9mIHN0YXRlbWVudHMuXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTdG9yZXMgYW4gYXJyYXkgb2Ygc3RhdGVtZW50cyB3aG9zZSBkZXNjZW5kYW50IHN0YXRlbWVudHNcblx0XHRcdFx0Ly8gc2hvdWxkIGJlIGludmFsaWRhdGVkLiBcblx0XHRcdFx0Y29uc3QgaW52YWxpZGF0ZWRQYXJlbnRzID0gbmV3IE1hcDxudW1iZXIsIFN0YXRlbWVudD4oKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFN0b3JlcyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZW50aXJlIGRvY3VtZW50XG5cdFx0XHRcdC8vIG5lZWRzIHRvIGJlIGludmFsaWRhdGVkLlxuXHRcdFx0XHRsZXQgbXVzdEludmFsaWRhdGVEb2MgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZSBmaXJzdCBzdGVwIGlzIHRvIGdvIHRocm91Z2ggYWxsIHRoZSBzdGF0ZW1lbnRzLCBhbmQgY29tcHV0ZSB0aGUgXG5cdFx0XHRcdC8vIHNldCBvZiBwYXJlbnQgc3RhdGVtZW50cyBmcm9tIHdoZXJlIGludmFsaWRhdGlvbiBzaG91bGQgb3JpZ2luYXRlLlxuXHRcdFx0XHQvLyBJbiB0aGUgbWFqb3JpdHkgb2YgY2FzZXMsIHRoaXMgd2lsbCBvbmx5IGJlIG9uZSBzaW5nbGUgc3RhdGVtZW50IG9iamVjdC5cblx0XHRcdFx0Zm9yIChjb25zdCBjYWxsIG9mIGNhbGxzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNhbGwgaW5zdGFuY2VvZiBEZWxldGVDYWxsKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlbGV0ZWRTdGF0ZW1lbnQgPSB0aGlzLnN0YXRlbWVudHMuZ2V0KGNhbGwucG9zKTtcblx0XHRcdFx0XHRcdGlmIChkZWxldGVkU3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KGNhbGwucG9zKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIFN0YXRlbWVudClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aW52YWxpZGF0ZWRQYXJlbnRzLnNldChjYWxsLnBvcywgcGFyZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRtdXN0SW52YWxpZGF0ZURvYyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoY2FsbCBpbnN0YW5jZW9mIEluc2VydENhbGwpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChjYWxsLnNtdC5pc05vb3ApXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChjYWxsIGluc3RhbmNlb2YgVXBkYXRlQ2FsbClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgb2xkU3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzLmdldChjYWxsLnBvcyk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAob2xkU3RhdGVtZW50LmlzTm9vcCAmJiBjYWxsLnNtdC5pc05vb3ApXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50RnJvbVBvc2l0aW9uKFxuXHRcdFx0XHRcdFx0XHRjYWxsLnBvcyxcblx0XHRcdFx0XHRcdFx0Y2FsbC5zbXQuaW5kZW50KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIFN0YXRlbWVudClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aW52YWxpZGF0ZWRQYXJlbnRzLnNldChjYWxsLnBvcywgcGFyZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHBhcmVudCA9PT0gdGhpcylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bXVzdEludmFsaWRhdGVEb2MgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFsdGhvdWdoIHVuY2xlYXIgaG93IHRoaXMgY291bGQgaGFwcGVuLCBpZiB0aGVyZVxuXHRcdFx0XHQvLyBhcmUgbm8gaW52YWxpZGF0ZWQgcGFyZW50cywgd2UgY2FuIHNhZmVseSByZXR1cm4uXG5cdFx0XHRcdGlmICghbXVzdEludmFsaWRhdGVEb2MgJiYgaW52YWxpZGF0ZWRQYXJlbnRzLnNpemUgPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gUHJ1bmUgYW55IHJlZHVuZGFudCBwYXJlbnRzLiBBIHBhcmVudCBpcyByZWR1bmRhbnRcblx0XHRcdFx0Ly8gd2hlbiBpdCdzIGEgZGVzY2VuZGFudCBvZiBhbm90aGVyIHBhcmVudCBpbiB0aGUgXG5cdFx0XHRcdC8vIGludmFsaWRhdGlvbiBhcnJheS4gVGhlIGFsZ29yaXRobSBiZWxvdyBjb21wYXJlcyB0aGVcblx0XHRcdFx0Ly8gc3RhdGVtZW50IGFuY2VzdHJpZXMgb2YgZWFjaCBwb3NzaWJsZSBwYWlycyBvZiBpbnZhbGlkYXRlZFxuXHRcdFx0XHQvLyBwYXJlbnRzLCBhbmQgc3BsaWNlcyBpbnZhbGlkYXRlZCBwYXJlbnRzIG91dCBvZiB0aGUgXG5cdFx0XHRcdC8vIGFycmF5IGluIHRoZSBjYXNlIHdoZW4gdGhlIHBhcmVudCBpcyBwYXJlbnRlZCBieSBzb21lXG5cdFx0XHRcdC8vIG90aGVyIGludmFsaWRhdGVkIHBhcmVudCBpbiB0aGUgaW52YWxpZGF0ZWRQYXJlbnRzIGFycmF5LlxuXHRcdFx0XHRjb25zdCBpbnZhbGlkYXRlZEFuY2VzdHJpZXM6IFN0YXRlbWVudFtdW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgbGluZSBvZiBpbnZhbGlkYXRlZFBhcmVudHMua2V5cygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnkgPSB0aGlzLmdldEFuY2VzdHJ5KGxpbmUpO1xuXHRcdFx0XHRcdGlmIChhbmNlc3RyeSlcblx0XHRcdFx0XHRcdGludmFsaWRhdGVkQW5jZXN0cmllcy5wdXNoKGFuY2VzdHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGludmFsaWRhdGVkQW5jZXN0cmllcy5sZW5ndGggPiAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGludmFsaWRhdGVkQW5jZXN0cmllcy5sZW5ndGg7IGktLTspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlBID0gaW52YWxpZGF0ZWRBbmNlc3RyaWVzW2ldO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBuID0gaTsgbi0tOylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlCID0gaW52YWxpZGF0ZWRBbmNlc3RyaWVzW25dO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGFuY2VzdHJ5QS5sZW5ndGggPT09IGFuY2VzdHJ5Qi5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjb25zdCBhTGVzc0IgPSBhbmNlc3RyeUEubGVuZ3RoIDwgYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlTaG9ydCA9IGFMZXNzQiA/IGFuY2VzdHJ5QSA6IGFuY2VzdHJ5Qjtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlMb25nID0gYUxlc3NCID8gYW5jZXN0cnlCIDogYW5jZXN0cnlBO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGFuY2VzdHJ5U2hvcnQuZXZlcnkoKHNtdCwgaWR4KSA9PiBzbXQgPT09IGFuY2VzdHJ5TG9uZ1tpZHhdKSlcblx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkYXRlZEFuY2VzdHJpZXMuc3BsaWNlKGFMZXNzQiA/IG4gOiBpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHBhcmVudHMgPSBtdXN0SW52YWxpZGF0ZURvYyA/IFtdIDogQXJyYXkuZnJvbShpbnZhbGlkYXRlZFBhcmVudHMudmFsdWVzKCkpO1xuXHRcdFx0XHRjb25zdCBpbmRleGVzID0gbXVzdEludmFsaWRhdGVEb2MgPyBbXSA6IEFycmF5LmZyb20oaW52YWxpZGF0ZWRQYXJlbnRzLmtleXMoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBOb3RpZnkgb2JzZXJ2ZXJzIG9mIHRoZSBJbnZhbGlkYXRlIGhvb2sgdG8gaW52YWxpZGF0ZSB0aGVcblx0XHRcdFx0Ly8gZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCBzZXQgb2YgcGFyZW50IHN0YXRlbWVudHMuXG5cdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VJbnZhbGlkYXRlKHRoaXMsIHBhcmVudHMsIGluZGV4ZXMpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRlbGV0ZWRTdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gUGVyZm9ybSB0aGUgZG9jdW1lbnQgbXV0YXRpb25zLlxuXHRcdFx0XHRmb3IgKGNvbnN0IGNhbGwgb2YgY2FsbHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY2FsbCBpbnN0YW5jZW9mIERlbGV0ZUNhbGwpXG5cdFx0XHRcdFx0XHRkZWxldGVkU3RhdGVtZW50cy5wdXNoKC4uLmRvRGVsZXRlKGNhbGwpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbHNlIGlmIChjYWxsIGluc3RhbmNlb2YgSW5zZXJ0Q2FsbClcblx0XHRcdFx0XHRcdGRvSW5zZXJ0KGNhbGwpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGVsc2UgaWYgKGNhbGwgaW5zdGFuY2VvZiBVcGRhdGVDYWxsKVxuXHRcdFx0XHRcdFx0ZG9VcGRhdGUoY2FsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgZGVsZXRlZCBzdGF0ZW1lbnRzIGZyb20gdGhlIGludmFsaWRhdGVkUGFyZW50cyBtYXBcblx0XHRcdFx0Zm9yIChjb25zdCBkZWxldGVkU3RhdGVtZW50IG9mIGRlbGV0ZWRTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgW2F0LCBwYXJlbnRTdGF0ZW1lbnRdIG9mIGludmFsaWRhdGVkUGFyZW50cylcblx0XHRcdFx0XHRcdGlmIChkZWxldGVkU3RhdGVtZW50ID09PSBwYXJlbnRTdGF0ZW1lbnQpXG5cdFx0XHRcdFx0XHRcdGludmFsaWRhdGVkUGFyZW50cy5kZWxldGUoYXQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTm90aWZ5IG9ic2VydmVycyBvZiB0aGUgUmV2YWxpZGF0ZSBob29rIHRvIHVwZGF0ZSB0aGVcblx0XHRcdFx0Ly8gZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCBzZXQgb2YgcGFyZW50IHN0YXRlbWVudHMuXG5cdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VSZXZhbGlkYXRlKFxuXHRcdFx0XHRcdHRoaXMsIFxuXHRcdFx0XHRcdEFycmF5LmZyb20oaW52YWxpZGF0ZWRQYXJlbnRzLnZhbHVlcygpKSxcblx0XHRcdFx0XHRBcnJheS5mcm9tKGludmFsaWRhdGVkUGFyZW50cy5rZXlzKCkpXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Ly8gUGVyZm9ybSBhIGRlYnVnLXRpbWUgY2hlY2sgdG8gYmUgc3VyZSB0aGF0IHRoZXJlIGFyZVxuXHRcdFx0Ly8gbm8gZGlzcG9zZWQgc3RhdGVtZW50cyBsZWZ0IGhhbmdpbmcgYXJvdW5kIGluIHRoZSBkb2N1bWVudFxuXHRcdFx0Ly8gYWZ0ZXIgdGhlIGVkaXQgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cblx0XHRcdGlmIChcIkRFQlVHXCIpXG5cdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIHRoaXMuc3RhdGVtZW50cy5lbnVtZXJhdGVGb3J3YXJkKCkpXG5cdFx0XHRcdFx0aWYgKHNtdC5pc0Rpc3Bvc2VkKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBDbGVhbiBvdXQgYW55IHR5cGUgY2FjaGVcblx0XHRcdHRoaXMuX3R5cGVzID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gVGVsbCBzdWJzY3JpYmVycyB0aGF0IHRoZSBlZGl0IHRyYW5zYWN0aW9uIGNvbXBsZXRlZC5cblx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VFZGl0Q29tcGxldGUodGhpcykpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcdHRoaXMuaW5FZGl0ID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChhZGRlZFVyaVNtdHMubGVuZ3RoICsgZGVsZXRlZFVyaVNtdHMubGVuZ3RoID4gMClcblx0XHRcdFx0YXdhaXQgdGhpcy51cGRhdGVSZWZlcmVuY2VzKGRlbGV0ZWRVcmlTbXRzLCBhZGRlZFVyaVNtdHMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBFeGVjdXRlcyBhIGNvbXBsZXRlIGVkaXQgdHJhbnNhY3Rpb24sIGFwcGx5aW5nIHRoZSBzZXJpZXNcblx0XHQgKiBvZiBlZGl0cyBzcGVjaWZpZWQgaW4gdGhlIGBlZGl0c2AgcGFyYW1ldGVyLiBcblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhbnkgZXh0ZXJuYWwgZG9jdW1lbnRcblx0XHQgKiByZWZlcmVuY2VzIGFkZGVkIGR1cmluZyB0aGUgZWRpdCBvcGVyYXRpb24gaGF2ZSBiZWVuIHJlc29sdmVkLlxuXHRcdCAqIElmIG5vIHN1Y2ggcmVmZXJlbmNlcyB3ZXJlIGFkZGVkLCBhIHByb21pc2UgaXMgcmV0dXJuZWQgdGhhdFxuXHRcdCAqIHJlc29sdmVzIGltbWVkaWF0ZWx5LlxuXHRcdCAqL1xuXHRcdGFzeW5jIGVkaXRBdG9taWMoZWRpdHM6IElEb2N1bWVudEVkaXRbXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5lZGl0KHN0YXRlbWVudHMgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBlZGl0SW5mbyBvZiBlZGl0cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghZWRpdEluZm8ucmFuZ2UpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gcmFuZ2UgaW5jbHVkZWQuXCIpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0TGluZSA9IGVkaXRJbmZvLnJhbmdlLnN0YXJ0TGluZU51bWJlcjtcblx0XHRcdFx0XHRjb25zdCBlbmRMaW5lID0gZWRpdEluZm8ucmFuZ2UuZW5kTGluZU51bWJlcjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBzdGFydENoYXIgPSBlZGl0SW5mby5yYW5nZS5zdGFydENvbHVtbjtcblx0XHRcdFx0XHRjb25zdCBlbmRDaGFyID0gZWRpdEluZm8ucmFuZ2UuZW5kQ29sdW1uO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0TGluZVRleHQgPSB0aGlzLnJlYWQoc3RhcnRMaW5lKS5zb3VyY2VUZXh0O1xuXHRcdFx0XHRcdGNvbnN0IGVuZExpbmVUZXh0ID0gdGhpcy5yZWFkKGVuZExpbmUpLnNvdXJjZVRleHQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgcHJlZml4U2VnbWVudCA9IHN0YXJ0TGluZVRleHQuc2xpY2UoMCwgc3RhcnRDaGFyKTtcblx0XHRcdFx0XHRjb25zdCBzdWZmaXhTZWdtZW50ID0gZW5kTGluZVRleHQuc2xpY2UoZW5kQ2hhcik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudHMgPSBlZGl0SW5mby50ZXh0LnNwbGl0KFwiXFxuXCIpO1xuXHRcdFx0XHRcdGNvbnN0IHBhc3RDb3VudCA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuXHRcdFx0XHRcdGNvbnN0IHByZXNlbnRDb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBkZWx0YUNvdW50ID0gcHJlc2VudENvdW50IC0gcGFzdENvdW50O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIERldGVjdCB0aGUgcHVyZSB1cGRhdGUgY2FzZXNcblx0XHRcdFx0XHRpZiAoZGVsdGFDb3VudCA9PT0gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAocGFzdENvdW50ID09PSAxKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLnVwZGF0ZShcblx0XHRcdFx0XHRcdFx0XHRwcmVmaXhTZWdtZW50ICsgZWRpdEluZm8udGV4dCArIHN1ZmZpeFNlZ21lbnQsIFxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0TGluZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLnVwZGF0ZShwcmVmaXhTZWdtZW50ICsgc2VnbWVudHNbMF0sIHN0YXJ0TGluZSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKylcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMudXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4U2VnbWVudCArIHNlZ21lbnRzW2ldICsgc3VmZml4U2VnbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0TGluZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMudXBkYXRlKHNlZ21lbnRzLnNsaWNlKC0xKVswXSArIHN1ZmZpeFNlZ21lbnQsIGVuZExpbmUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gRGV0ZWN0IHRoZSBwdXJlIGRlbGV0ZSBjYXNlc1xuXHRcdFx0XHRcdGlmIChkZWx0YUNvdW50IDwgMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWxldGVDb3VudCA9IGRlbHRhQ291bnQgKiAtMTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gRGV0ZWN0IGEgZGVsZXRlIHJhbmdpbmcgZnJvbSB0aGUgZW5kIG9mIFxuXHRcdFx0XHRcdFx0Ly8gb25lIGxpbmUsIHRvIHRoZSBlbmQgb2YgYSBzdWNjZXNzaXZlIGxpbmVcblx0XHRcdFx0XHRcdGlmIChzdGFydENoYXIgPT09IHN0YXJ0TGluZVRleHQubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHRpZiAoZW5kQ2hhciA9PT0gZW5kTGluZVRleHQubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGVtZW50cy5kZWxldGUoc3RhcnRMaW5lICsgMSwgZGVsZXRlQ291bnQpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIERldGVjdCBhIGRlbGV0ZSByYW5naW5nIGZyb20gdGhlIHN0YXJ0IG9mXG5cdFx0XHRcdFx0XHQvLyBvbmUgbGluZSB0byB0aGUgc3RhcnQgb2YgYSBzdWNjZXNzaXZlIGxpbmVcblx0XHRcdFx0XHRcdGlmIChzdGFydENoYXIgKyBlbmRDaGFyID09PSAwKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLmRlbGV0ZShzdGFydExpbmUsIGRlbGV0ZUNvdW50KTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIERldGVjdCB0aGUgcHVyZSBpbnNlcnQgY2FzZXNcblx0XHRcdFx0XHRpZiAoZGVsdGFDb3VudCA+IDApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gQ3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUsIGFuZCB0aGUgZmlyc3QgbGluZSBvZiB0aGUgXG5cdFx0XHRcdFx0XHQvLyBpbnNlcnRlZCBjb250ZW50IGlzIGVtcHR5IChtb3N0IGxpa2VseSwgZW50ZXIgd2FzIHByZXNzZWQpXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRDaGFyID09PSBzdGFydExpbmVUZXh0Lmxlbmd0aCAmJiBzZWdtZW50c1swXSA9PT0gXCJcIilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7ICsraSA8IHNlZ21lbnRzLmxlbmd0aDspXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGVtZW50cy5pbnNlcnQoc2VnbWVudHNbaV0sIHN0YXJ0TGluZSArIGkpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEN1cnNvciBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lLCBhbmQgdGhlXG5cdFx0XHRcdFx0XHQvLyBsYXN0IGxpbmUgb2YgdGhlIGluc2VydGVkIGNvbnRlbnQgaXMgZW1wdHkuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRDaGFyID09PSAwICYmIHNlZ21lbnRzLnNsaWNlKC0xKVswXSA9PT0gXCJcIilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBzZWdtZW50cy5sZW5ndGggLSAxOylcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLmluc2VydChzZWdtZW50c1tpXSwgc3RhcnRMaW5lICsgaSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyB0aGUgXCJmYWxsYmFja1wiIGJlaGF2aW9yIC0tIHNpbXBseSBkZWxldGUgZXZlcnl0aGluZ1xuXHRcdFx0XHRcdC8vIHRoYXQgaXMgb2xkLCBhbmQgaW5zZXJ0IGV2ZXJ5dGhpbmcgdGhhdCBpcyBuZXcuXG5cdFx0XHRcdFx0Y29uc3QgZGVsZXRlQ291bnQgPSBlbmRMaW5lIC0gc3RhcnRMaW5lICsgMTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRzLmRlbGV0ZShzdGFydExpbmUsIGRlbGV0ZUNvdW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBpbnNlcnRMaW5lcyA9IHNlZ21lbnRzLnNsaWNlKCk7XG5cdFx0XHRcdFx0aW5zZXJ0TGluZXNbMF0gPSBwcmVmaXhTZWdtZW50ICsgaW5zZXJ0TGluZXNbMF07XG5cdFx0XHRcdFx0aW5zZXJ0TGluZXNbaW5zZXJ0TGluZXMubGVuZ3RoIC0gMV0gKz0gc3VmZml4U2VnbWVudDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IGluc2VydExpbmVzLmxlbmd0aDspXG5cdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLmluc2VydChpbnNlcnRMaW5lc1tpXSwgc3RhcnRMaW5lICsgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBIHN0YXRlIHZhcmlhYmxlIHRoYXQgc3RvcmVzIHdoZXRoZXIgYW5cblx0XHQgKiBlZGl0IHRyYW5zYWN0aW9uIGlzIGN1cnJlbnRseSB1bmRlcndheS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGluRWRpdCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYXN5bmMgdXBkYXRlUmVmZXJlbmNlcyhcblx0XHRcdGRlbGV0ZWQ6IFVyaVN0YXRlbWVudFtdLFxuXHRcdFx0YWRkZWQ6IFVyaVN0YXRlbWVudFtdKVxuXHRcdHtcblx0XHRcdC8vIFRoaXMgYWxnb3JpdGhtIGFsd2F5cyBwZXJmb3JtcyBhbGwgZGVsZXRlcyBiZWZvcmUgYWRkcy5cblx0XHRcdC8vIEZvciB0aGlzIHJlYXNvbiwgaWYgYSBVUkkgaXMgYm90aCBpbiB0aGUgbGlzdCBvZiBkZWxldGVkIFVSSXNcblx0XHRcdC8vIGFzIHdlbGwgYXMgdGhlIGxpc3Qgb2YgYWRkZWQgVVJJcywgaXQgbWVhbnMgdGhhdCB0aGUgVVJJXG5cdFx0XHQvLyBzdGFydGVkIGluIHRoZSBkb2N1bWVudCwgYW5kIGlzIGN1cnJlbnRseSBzdGlsbCB0aGVyZS5cblx0XHRcdFxuXHRcdFx0Y29uc3QgcmF3UmVmc0V4aXN0aW5nID0gdGhpcy5yZWZlcmVuY2VzUmF3LnNsaWNlKCk7XG5cdFx0XHRjb25zdCByYXdSZWZzVG9BZGQ6IFJlZmVyZW5jZVtdID0gW107XG5cdFx0XHRjb25zdCByYXdSZWZzVG9EZWxldGU6IFJlZmVyZW5jZVtdID0gW107XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBmYXVsdHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksXG5cdFx0XHQvLyBzbyB0aGF0IHRoZXkgY2FuIGFsbCBiZSByZXBvcnRlZCBhdCBvbmNlIGF0IHRoZSBlbmQuXG5cdFx0XHQvLyBUaGlzIGlzIGJlY2F1c2UgdGhpcyBtZXRob2QgaXMgYXN5bmMsIGFuZCBpdCdzIGltcG9ydGFudFxuXHRcdFx0Ly8gdGhhdCBhbGwgdGhlIGZhdWx0cyBhcmUgcmVwb3J0ZWQgaW4gdGhlIHNhbWUgdHVybiBvZlxuXHRcdFx0Ly8gdGhlIGV2ZW50IGxvb3AuXG5cdFx0XHRjb25zdCBmYXVsdHM6IFN0YXRlbWVudEZhdWx0W10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gRGVsZXRlIG9sZCBVUkkgc3RhdGVtZW50cyBmcm9tIHRoZSBhcnJheS5cblx0XHRcdGZvciAoY29uc3QgZGVsIG9mIGRlbGV0ZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGlkeCA9IHJhd1JlZnNFeGlzdGluZy5maW5kSW5kZXgodiA9PiB2LnN0YXRlbWVudCA9PT0gZGVsKTtcblx0XHRcdFx0aWYgKGlkeCA+IC0xKVxuXHRcdFx0XHRcdHJhd1JlZnNUb0RlbGV0ZS5wdXNoKHJhd1JlZnNFeGlzdGluZy5zcGxpY2UoaWR4LCAxKVswXSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChcIkRFQlVHXCIpXG5cdFx0XHRcdGlmIChkZWxldGVkLmxlbmd0aCAhPT0gcmF3UmVmc1RvRGVsZXRlLmxlbmd0aClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdC8vIFBvcHVsYXRlIGFkZGVkUmVmZXJlbmNlcyBhcnJheS4gVGhpcyBsb29wIGJsaW5kbHkgYXR0ZW1wdHMgdG8gbG9hZFxuXHRcdFx0Ly8gYWxsIHJlZmVyZW5jZWQgZG9jdW1lbnRzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlcmUncyBnb2luZyB0byBiZVxuXHRcdFx0Ly8gc29tZSBmYXVsdCBnZW5lcmF0ZWQgYXMgYSByZXN1bHQgb2YgYXR0ZW1wdGluZyB0byBlc3RhYmxpc2ggYSByZWZlcmVuY2Vcblx0XHRcdC8vIHRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGZvciBhd2FpdCAoY29uc3Qgc210IG9mIGFkZGVkKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgcmVmRG9jOiBEb2N1bWVudCB8IEVycm9yIHwgbnVsbCA9IG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBCYWlsIGlmIGEgZG9jdW1lbnQgbG9hZGVkIGZyb20gSFRUUCBpcyB0cnlpbmcgdG8gcmVmZXJlbmNlXG5cdFx0XHRcdC8vIGEgZG9jdW1lbnQgbG9jYXRlZCBvbiB0aGUgZmlsZSBzeXN0ZW0uXG5cdFx0XHRcdGNvbnN0IGlzVG9GaWxlID0gc210LnVyaS5wcm90b2NvbCA9PT0gVXJpUHJvdG9jb2wuZmlsZTtcblx0XHRcdFx0Y29uc3QgdGhpc1Byb3RvID0gdGhpcy51cmkucHJvdG9jb2w7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaXNUb0ZpbGUgJiYgKHRoaXNQcm90byA9PT0gVXJpUHJvdG9jb2wuaHR0cCB8fCB0aGlzUHJvdG8gPT09IFVyaVByb3RvY29sLmh0dHBzKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZhdWx0cy5wdXNoKEZhdWx0cy5JbnNlY3VyZVJlc291cmNlUmVmZXJlbmNlLmNyZWF0ZShzbXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZWZEb2MgPSB0aGlzLnByb2dyYW0uZ2V0RG9jdW1lbnRCeVVyaShzbXQudXJpKTtcblx0XHRcdFx0XHRpZiAoIXJlZkRvYylcblx0XHRcdFx0XHRcdHJlZkRvYyA9IGF3YWl0IHRoaXMucHJvZ3JhbS5hZGREb2N1bWVudEZyb21Vcmkoc210LnVyaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoaXMgaXMgY2hlYXRpbmcgYSBiaXQuIEl0J3MgdW5jbGVhciBob3cgdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gZXJyb3Jcblx0XHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgb3Igd2hhdCB0byBkbyBpZiBpdCBkaWQuXG5cdFx0XHRcdGlmIChyZWZEb2MgaW5zdGFuY2VvZiBFcnJvcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlZkRvYyA9IG51bGw7XG5cdFx0XHRcdFx0ZmF1bHRzLnB1c2goRmF1bHRzLlVucmVzb2x2ZWRSZXNvdXJjZS5jcmVhdGUoc210KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJhd1JlZnNUb0FkZC5wdXNoKG5ldyBSZWZlcmVuY2Uoc210LCByZWZEb2MpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKFwiREVCVUdcIilcblx0XHRcdFx0aWYgKGFkZGVkLmxlbmd0aCAhPT0gcmF3UmVmc1RvQWRkLmxlbmd0aClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHRvUmVmZXJlbmNlVHVwbGVzID0gKHJlZnM6IFJlZmVyZW5jZVtdKSA9PlxuXHRcdFx0XHRyZWZzLm1hcCh2ID0+IFt0aGlzLmxpbmVOdW1iZXJPZih2LnN0YXRlbWVudCksIHZdIGFzIFtudW1iZXIsIFJlZmVyZW5jZV0pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByYXdSZWZzUHJvcG9zZWQgPSBbXG5cdFx0XHRcdC4uLnRvUmVmZXJlbmNlVHVwbGVzKHJhd1JlZnNFeGlzdGluZyksXG5cdFx0XHRcdC4uLnRvUmVmZXJlbmNlVHVwbGVzKHJhd1JlZnNUb0FkZClcblx0XHRcdF1cblx0XHRcdFx0LnNvcnQoKFtudW1BXSwgW251bUJdKSA9PiBudW1CIC0gbnVtQSlcblx0XHRcdFx0Lm1hcCgoW251bSwgcmVmXSkgPT4gcmVmKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVhbFJlZnM6IFJlZmVyZW5jZVtdID0gW107XG5cdFx0XHRjb25zdCByYXdSZWZEb2N1bWVudHMgPSByYXdSZWZzUHJvcG9zZWQubWFwKHYgPT4gdi50YXJnZXQpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtpZHgsIGRvY10gb2YgcmF3UmVmRG9jdW1lbnRzLmVudHJpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFkb2MpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocmF3UmVmRG9jdW1lbnRzLmluZGV4T2YoZG9jKSAhPT0gaWR4KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgc210ID0gcmF3UmVmc1Byb3Bvc2VkW2lkeF0uc3RhdGVtZW50O1xuXHRcdFx0XHRcdGZhdWx0cy5wdXNoKEZhdWx0cy5EdXBsaWNhdGVSZWZlcmVuY2UuY3JlYXRlKHNtdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlYWxSZWZzLnB1c2gocmF3UmVmc1Byb3Bvc2VkW2lkeF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlYWxSZWZzRGVsZXRlZCA9IHRoaXMucmVmZXJlbmNlc1JlYWwuZmlsdGVyKHYgPT4gIXJlYWxSZWZzLmluY2x1ZGVzKHYpKTtcblx0XHRcdGNvbnN0IHJlYWxSZWZzQWRkZWQgPSByZWFsUmVmcy5maWx0ZXIodiA9PiAhdGhpcy5yZWZlcmVuY2VzUmVhbC5pbmNsdWRlcyh2KSk7XG5cdFx0XHRcblx0XHRcdHRoaXMucmVmZXJlbmNlc1Jhdy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy5yZWZlcmVuY2VzUmF3LnB1c2goLi4ucmF3UmVmc1Byb3Bvc2VkKTtcblx0XHRcdHRoaXMucmVmZXJlbmNlc1JlYWwubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMucmVmZXJlbmNlc1JlYWwucHVzaCguLi5yZWFsUmVmcyk7XG5cdFx0XHRcblx0XHRcdHRoaXMuX2RlcGVuZGVuY2llcy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy5fZGVwZW5kZW5jaWVzLnB1c2goLi4ucmVhbFJlZnNcblx0XHRcdFx0Lm1hcCh2ID0+IHYudGFyZ2V0KVxuXHRcdFx0XHQuZmlsdGVyKCh2KTogdiBpcyBEb2N1bWVudCA9PiAhIXYpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCByZWYgb2YgcmVhbFJlZnNBZGRlZClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZGVwZW5kZW50cyA9IHJlZi50YXJnZXQ/Ll9kZXBlbmRlbnRzO1xuXHRcdFx0XHRpZiAoZGVwZW5kZW50cyAmJiAhZGVwZW5kZW50cy5pbmNsdWRlcyh0aGlzKSlcblx0XHRcdFx0XHRkZXBlbmRlbnRzLnB1c2godGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmVmIG9mIHJlYWxSZWZzRGVsZXRlZClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZGVwZW5kZW50cyA9IHJlZi50YXJnZXQ/Ll9kZXBlbmRlbnRzO1xuXHRcdFx0XHRpZiAoZGVwZW5kZW50cylcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZGVwZW5kZW50cy5sZW5ndGg7IGktLSA+IDA7KVxuXHRcdFx0XHRcdFx0aWYgKGRlcGVuZGVudHNbaV0gPT09IHRoaXMpXG5cdFx0XHRcdFx0XHRcdGRlcGVuZGVudHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRsZXQgaGFzQ2lyY3VsYXJGYXVsdHMgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCByZWZEZWxldGVkIG9mIHJlYWxSZWZzRGVsZXRlZClcblx0XHRcdFx0aWYgKHRoaXMucHJvZ3JhbS5jeWNsZURldGVjdG9yLmRpZERlbGV0ZShyZWZEZWxldGVkLnN0YXRlbWVudCkpXG5cdFx0XHRcdFx0aGFzQ2lyY3VsYXJGYXVsdHMgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJlZkFkZGVkIG9mIHJlYWxSZWZzQWRkZWQpXG5cdFx0XHRcdGlmICh0aGlzLnByb2dyYW0uY3ljbGVEZXRlY3Rvci5kaWRBZGQocmVmQWRkZWQuc3RhdGVtZW50KSlcblx0XHRcdFx0XHRoYXNDaXJjdWxhckZhdWx0cyA9IHRydWU7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZmF1bHQgb2YgZmF1bHRzKVxuXHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChmYXVsdCk7XG5cdFx0XHRcblx0XHRcdGlmIChmYXVsdHMubGVuZ3RoIHx8IGhhc0NpcmN1bGFyRmF1bHRzKVxuXHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlZnJlc2goKTtcblx0XHRcdFxuXHRcdFx0Ly8gVE9ETzogQnJvYWRjYXN0IHRoZSBhZGRlZCBhbmQgcmVtb3ZlZCBkZXBlbmRlbmNpZXMgdG8gZXh0ZXJuYWxcblx0XHRcdC8vIG9ic2VydmVycyAob3V0c2lkZSB0aGUgY29tcGlsZXIpLiBNYWtlIHN1cmUgdG8gYnJvYWRjYXN0IG9ubHkgdGhlXG5cdFx0XHQvLyBjaGFuZ2UgaW4gZGVwZW5kZW5jaWVzLCBub3QgdGhlIGNoYW5nZSBpbiByZWZlcmVuY2VzICh3aGljaCBhcmUgZGlmZmVyZW50KVxuXHRcdFx0Ly8gSW1wbGVtZW50aW5nIHRoaXMgd2lsbCByZXF1aXJlIGEgcmUtd29ya2luZyBvZiB0aGUgY2F1c2Ugc3lzdGVtLlxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiAoTm90IGltcGxlbWVudGVkKVxuXHRcdCAqIFxuXHRcdCAqIFVwZGF0ZXMgdGhpcyBkb2N1bWVudCdzIHNvdXJjZVVyaSB3aXRoIHRoZSBuZXcgVVJJIHNwZWNpZmllZC5cblx0XHQgKiBUaGUgdmFsdWUgc3BlY2lmaWVkIG1heSBiZSBhIHJlbGF0aXZlIFVSSSwgaW4gd2hpY2ggY2FzZSwgdGhlIGZpbmFsXG5cdFx0ICogVVJJIHdpbGwgYmUgbWFkZSByZWxhdGl2ZSB0byB0aGlzIGRvY3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIEB0aHJvd3MgQW4gZXJyb3IgaW4gdGhlIGNhc2Ugd2hlbiBhIGRvY3VtZW50IGhhcyBiZWVuIGxvYWRlZFxuXHRcdCAqIGludG8gdGhlIFByb2dyYW0gdGhhdCBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCB0aGUgVVJJIHNwZWNpZmllZCxcblx0XHQgKiBvciB3aGVuIHRoZSB2YWx1ZSBzcGVjaWZpZWQgY291bGQgbm90IGJlIHBhcnNlZC5cblx0XHQgKi9cblx0XHR1cGRhdGVVcmkobmV3VmFsdWU6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCBuZXdVcmkgPSBLbm93blVyaS5mcm9tU3RyaW5nKG5ld1ZhbHVlLCB0aGlzLl91cmkpO1xuXHRcdFx0aWYgKG5ld1VyaSA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRVcmkobmV3VmFsdWUpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBleGlzdGluZyA9IHRoaXMucHJvZ3JhbS5nZXREb2N1bWVudEJ5VXJpKG5ld1VyaSk7XG5cdFx0XHRpZiAoZXhpc3RpbmcpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51cmlBbHJlYWR5RXhpc3RzKCk7XG5cdFx0XHRcblx0XHRcdGlmIChuZXdVcmkucHJvdG9jb2wgIT09IHRoaXMuX3VyaS5wcm90b2NvbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVyaVByb3RvY29sc011c3RNYXRjaCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB3YXNVcmkgPSB0aGlzLl91cmk7XG5cdFx0XHR0aGlzLl91cmkgPSBuZXdVcmk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZG9jIG9mIHRoaXMucHJvZ3JhbS5kb2N1bWVudHMpXG5cdFx0XHRcdGRvYy5kaWRVcGRhdGVVcmkodGhpcywgd2FzVXJpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBkaWRVcGRhdGVVcmkoYWZmZWN0ZWREb2M6IERvY3VtZW50LCB3YXM6IEtub3duVXJpKVxuXHRcdHtcblx0XHRcdGNvbnN0IG5ld2x5QnJva2VuUmF3OiBSZWZlcmVuY2VbXSA9IFtdO1xuXHRcdFx0Y29uc3QgbmV3bHlUYXJnZXRlZFJhdzogUmVmZXJlbmNlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCByZWYgb2YgdGhpcy5yZWZlcmVuY2VzUmF3KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocmVmLnN0YXRlbWVudC51cmkgPT09IHdhcylcblx0XHRcdFx0XHRuZXdseUJyb2tlblJhdy5wdXNoKHJlZik7XG5cdFx0XHRcdFxuXHRcdFx0XHRlbHNlIGlmIChyZWYuc3RhdGVtZW50LnVyaSA9PT0gYWZmZWN0ZWREb2MuX3VyaSlcblx0XHRcdFx0XHRuZXdseVRhcmdldGVkUmF3LnB1c2gocmVmKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG5ld2x5QnJva2VuUmF3Lmxlbmd0aCArIG5ld2x5VGFyZ2V0ZWRSYXcubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIFJlZmVyZW5jZSBvYmplY3RzIHRoYXQgYXJlIGhhdmluZyBzb21lIGltcGFjdCBcblx0XHQgKiBvbiB0aGlzIGRvY3VtZW50J3MgcmVsYXRpb25zaGlwIHN0cnVjdHVyZS4gXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSByZWZlcmVuY2VzUmVhbDogUmVmZXJlbmNlW10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gYXJyYXkgb2YgUmVmZXJlbmNlIG9iamVjdHMsIHdoZXJlIGVhY2ggaXRlbSB0aGUgYXJyYXlcblx0XHQgKiBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBVUkktY29udGFpbmluZyBTdGF0ZW1lbnQgb2JqZWN0cy4gXG5cdFx0ICogU3RhdGVtZW50IG9iamVjdHMgbWF5IG5vdCBhY3R1YWxseSBiZSBhZmZlY3RpbmcgdGhlIGRvY3VtZW50J3Ncblx0XHQgKiByZWxhdGlvbnNoaXAgc3RydWN0dXJlLCBzdWNoIGFzIGluIHRoZSBjYXNlIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlXG5cdFx0ICogc3RhdGVtZW50cyB3aXRoaW4gdGhpcyBkb2N1bWVudCBhbGwgcmVmZXJlbmNpbmcgdGhlIHNhbWUgZG9jdW1lbnQsIFxuXHRcdCAqIChvbmx5IG9uZSBzdGF0ZW1lbnQgd291bGQgYmUgYWZmZWN0aW5nIGluIHRoaXMgY2FzZSksIG9yIHdoZW4gdGhlXG5cdFx0ICogcmVmZXJlbmNlZCBkb2N1bWVudCBpcyB1bmF2YWlsYWJsZSBmb3Igc29tZSByZWFzb24uXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSByZWZlcmVuY2VzUmF3OiBSZWZlcmVuY2VbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgb3RoZXIgZG9jdW1lbnRzIHRoYXQgdGhpcyBkb2N1bWVudCBoYXNcblx0XHQgKiBhcyBhIGRlcGVuZGVuY3kuXG5cdFx0ICogXG5cdFx0ICogQmVjYXVzZSBjaXJjdWxhciBkb2N1bWVudCByZWxhdGlvbnNoaXBzIGFyZSBzdG9yYWJsZSBhdCB0aGUgRG9jdW1lbnRcblx0XHQgKiBsZXZlbCwgcGVyZm9ybWluZyBhIGRlZXAgdHJhdmVyc2FsIG9uIHRoZXNlIGRlcGVuZGVuY2llcyBpcyBjb25zaWRlcmVkIGFuXG5cdFx0ICogdW5zYWZlIG9wZXJhdGlvbiwgZHVlIHRvIHRoZSBwb3NzaWJpbGl0eSBvZiBnZW5lcmF0aW5nIGEgc3RhY2sgb3ZlcmZsb3cuXG5cdFx0ICogXG5cdFx0ICogVG8gcGVyZm9ybSBhIGRlZXAgdHJhdmVyc2FsIG9uIGRvY3VtZW50IGRlcGVuZGVuY2llcywgY29uc2lkZXJpbmdcblx0XHQgKiB1c2luZyB0aGUgLnRyYXZlcnNlRGVwZW5kZW5jaWVzKCkgbWV0aG9kLlxuXHRcdCAqL1xuXHRcdGdldCBkZXBlbmRlbmNpZXMoKTogcmVhZG9ubHkgRG9jdW1lbnRbXVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9kZXBlbmRlbmNpZXM7XG5cdFx0fVxuXHRcdHByaXZhdGUgcmVhZG9ubHkgX2RlcGVuZGVuY2llczogRG9jdW1lbnRbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgb3RoZXIgZG9jdW1lbnRzIHRoYXQgZGVwZW5kIG9uIHRoaXNcblx0XHQgKiBkb2N1bWVudC5cblx0XHQgKiBcblx0XHQgKiBCZWNhdXNlIGNpcmN1bGFyIGRvY3VtZW50IHJlbGF0aW9uc2hpcHMgYXJlIHN0b3JhYmxlIGF0IHRoZSBEb2N1bWVudFxuXHRcdCAqIGxldmVsLCBwZXJmb3JtaW5nIGEgZGVlcCB0cmF2ZXJzYWwgb24gdGhlc2UgZGVwZW5kZW50cyBpcyBjb25zaWRlcmVkIGFuXG5cdFx0ICogdW5zYWZlIG9wZXJhdGlvbiwgZHVlIHRvIHRoZSBwb3NzaWJpbGl0eSBvZiBnZW5lcmF0aW5nIGEgc3RhY2sgb3ZlcmZsb3cuXG5cdFx0ICovXG5cdFx0Z2V0IGRlcGVuZGVudHMoKTogcmVhZG9ubHkgRG9jdW1lbnRbXVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9kZXBlbmRlbnRzO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9kZXBlbmRlbnRzOiBEb2N1bWVudFtdID0gW107XG5cdFx0XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdGdldFN0YXRlbWVudENhdXNpbmdEZXBlbmRlbmN5KGRlcGVuZGVuY3k6IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgcmVmIG9mIHRoaXMucmVmZXJlbmNlc1JlYWwpXG5cdFx0XHRcdGlmIChyZWYudGFyZ2V0ID09PSBkZXBlbmRlbmN5KVxuXHRcdFx0XHRcdHJldHVybiByZWYuc3RhdGVtZW50O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb24gdGhpcyBEb2N1bWVudCdzIGRlcGVuZGVuY3kgc3RydWN0dXJlLlxuXHRcdCAqIFRoZSB0cmF2ZXJzYWwgcGF0dGVybiBhdm9pZHMgZm9sbG93aW5nIGluZmluaXRlIGxvb3BzIGR1ZSB0byBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5cdFx0ICovXG5cdFx0KnRyYXZlcnNlRGVwZW5kZW5jaWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8RG9jdW1lbnQ+XG5cdFx0e1xuXHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0XHRjb25zdCB5aWVsZGVkOiBEb2N1bWVudFtdID0gW107XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uKiByZWN1cnNlKGRvYzogRG9jdW1lbnQpOiBJdGVyYWJsZUl0ZXJhdG9yPERvY3VtZW50PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZG9jID09PSBzZWxmKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgheWllbGRlZC5pbmNsdWRlcyhkb2MpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWllbGRlZC5wdXNoKGRvYyk7XG5cdFx0XHRcdFx0eWllbGQgZG9jO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZG9jLl9kZXBlbmRlbmNpZXMpXG5cdFx0XHRcdFx0eWllbGQqIHJlY3Vyc2UoZGVwZW5kZW5jeSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgdGhpcy5fZGVwZW5kZW5jaWVzKVxuXHRcdFx0XHR5aWVsZCogcmVjdXJzZShkZXBlbmRlbmN5KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBEb2N1bWVudC5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhrZWVwT3JpZ2luYWxGb3JtYXR0aW5nPzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0aWYgKGtlZXBPcmlnaW5hbEZvcm1hdHRpbmcpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHRoaXMuc3RhdGVtZW50cy5lbnVtZXJhdGVGb3J3YXJkKCkpXG5cdFx0XHRcdFx0bGluZXMucHVzaChzdGF0ZW1lbnQuc291cmNlVGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGZvciAoY29uc3QgeyBzdGF0ZW1lbnQsIGxldmVsIH0gb2YgdGhpcy5lYWNoRGVzY2VuZGFudCgpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBpbmRlbnQgPSBTeW50YXgudGFiLnJlcGVhdChsZXZlbCk7XG5cdFx0XHRcdGxpbmVzLnB1c2goaW5kZW50ICsgc3RhdGVtZW50LnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGFuIGludGVyZmFjZSBmb3IgY3JlYXRpbmcgYVxuXHQgKiBiYXRjaCBvZiBkb2N1bWVudCBtdXRhdGlvbiBvcGVyYXRpb25zLlxuXHQgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJRG9jdW1lbnRNdXRhdG9yXG5cdHtcblx0XHQvKipcblx0XHQgKiBJbnNlcnRzIGEgc3RhdGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIHJldHVybnMgdGhlIGluc2VydGVkIFN0YXRlbWVudFxuXHRcdCAqIG9iamVjdC4gTmVnYXRpdmUgbnVtYmVycyBpbnNlcnQgc3RhdGVtZW50cyBzdGFydGluZyBmcm9tIHRoZSBlbmQgb2YgdGhlXG5cdFx0ICogZG9jdW1lbnQuIFRoZSBzdGF0ZW1lbnRUZXh0IGFyZ3VtZW50IGlzIGV4cGVjdGVkIHRvIGJlIG9uZSBzaW5nbGUgbGluZSBvZiB0ZXh0LlxuXHRcdCAqL1xuXHRcdGluc2VydChzdGF0ZW1lbnRUZXh0OiBzdHJpbmcsIGF0OiBudW1iZXIpOiB2b2lkO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIGEgc3RhdGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIHJldHVybnMgdGhlIHJlcGxhY2VkXG5cdFx0ICogU3RhdGVtZW50IG9iamVjdC4gTmVnYXRpdmUgbnVtYmVycyBpbnNlcnQgc3RhdGVtZW50cyBzdGFydGluZyBmcm9tXG5cdFx0ICogdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuIFRoZSBzdGF0ZW1lbnRUZXh0IGFyZ3VtZW50IGlzIGV4cGVjdGVkIHRvXG5cdFx0ICogYmUgb25lIHNpbmdsZSBsaW5lIG9mIHRleHQuXG5cdFx0ICovXG5cdFx0dXBkYXRlKHN0YXRlbWVudFRleHQ6IHN0cmluZywgYXQ6IG51bWJlcik6IHZvaWQ7XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIERlbGV0ZXMgYSBzdGF0ZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgcmV0dXJucyB0aGUgZGVsZXRlZFxuXHRcdCAqIFN0YXRlbWVudCBvYmplY3QuIE5lZ2F0aXZlIG51bWJlcnMgZGVsZXRlIFN0YXRlbWVudCBvYmplY3RzXG5cdFx0ICogc3RhcnRpbmcgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRkZWxldGUoYXQ6IG51bWJlciwgY291bnQ/OiBudW1iZXIpOiB2b2lkO1xuXHR9XG5cdFxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgaW50ZXJmYWNlIElEb2N1bWVudEVkaXRcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHJhbmdlIGluIHRoZSBkb2N1bWVudCB0aGF0IHJlcHJlc2VudHMgdGhlXG5cdFx0ICogY29udGVudCB0aGF0IHNob3VsZCBiZSByZXBsYWNlZC5cblx0XHQgKi9cblx0XHRyZWFkb25seSByYW5nZTogSURvY3VtZW50RWRpdFJhbmdlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbmV3IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdGV4dDogc3RyaW5nO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyBhIHRleHQgcmFuZ2Ugd2l0aGluIHRoZSBsb2FkZWQgZG9jdW1lbnQuXG5cdCAqIFRoaXMgaW50ZXJmYWNlIGlzIGV4cGxpY2l0bHkgZGVzaWduZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBNb25hY29cblx0ICogdGV4dCBlZGl0b3IgQVBJIChhbmQgbWF5YmUgb3RoZXJzKSB0byBzaW1wbGlmeSBpbnRlZ3JhdGlvbnMuXG5cdCAqL1xuXHRleHBvcnQgaW50ZXJmYWNlIElEb2N1bWVudEVkaXRSYW5nZVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSAxLWJhc2VkIGxpbmUgbnVtYmVyIG9uIHdoaWNoIHRoZSByYW5nZSBzdGFydHMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgc3RhcnRMaW5lTnVtYmVyOiBudW1iZXI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSAwLWJhc2VkIGNvbHVtbiBvbiB3aGljaCB0aGUgcmFuZ2Ugc3RhcnRzIGluIGxpbmVcblx0XHQgKiBgc3RhcnRMaW5lTnVtYmVyYC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzdGFydENvbHVtbjogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgMS1iYXNlZCBsaW5lIG51bWJlciBvbiB3aGljaCB0aGUgcmFuZ2UgZW5kcy5cblx0XHQgKi9cblx0XHRyZWFkb25seSBlbmRMaW5lTnVtYmVyOiBudW1iZXI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSAwLWJhc2VkIGNvbHVtbiBvbiB3aGljaCB0aGUgcmFuZ2UgZW5kcyBpbiBsaW5lXG5cdFx0ICogYGVuZExpbmVOdW1iZXJgLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGVuZENvbHVtbjogbnVtYmVyO1xuXHR9XG5cdFxuXHQvKiogQGludGVybmFsICovXG5cdGV4cG9ydCBjbGFzcyBJbnNlcnRDYWxsIFxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBzbXQ6IFN0YXRlbWVudCxcblx0XHRcdHJlYWRvbmx5IHBvczogbnVtYmVyKVxuXHRcdHsgfVxuXHR9XG5cdFxuXHQvKiogQGludGVybmFsICovXG5cdGV4cG9ydCBjbGFzcyBVcGRhdGVDYWxsXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHNtdDogU3RhdGVtZW50LFxuXHRcdFx0cmVhZG9ubHkgcG9zOiBudW1iZXIpXG5cdFx0eyB9XG5cdH1cblx0XG5cdC8qKiBAaW50ZXJuYWwgKi9cblx0ZXhwb3J0IGNsYXNzIERlbGV0ZUNhbGxcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgcG9zOiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSBjb3VudDogbnVtYmVyKVxuXHRcdHsgfVxuXHR9XG5cdFxuXHQvKiogQGludGVybmFsICovXG5cdGV4cG9ydCB0eXBlIFRDYWxsVHlwZSA9IEluc2VydENhbGwgfCBVcGRhdGVDYWxsIHwgRGVsZXRlQ2FsbDtcblx0XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSB0eXBlIHRoYXQgZGVzY3JpYmVzIGEgU3RhdGVtZW50IG9iamVjdCB3aXRoIGEgbm9uLW51bGwgLnVyaSBmaWVsZC5cblx0ICovXG5cdGV4cG9ydCB0eXBlIFVyaVN0YXRlbWVudCA9IFN0YXRlbWVudCAmIHsgcmVhZG9ubHkgdXJpOiBLbm93blVyaTsgfTtcblx0XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBjbGFzcyB0aGF0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHJlZmVyZW5jZSBlc3RhYmxpc2hlZCBieVxuXHQgKiBvbmUgZG9jdW1lbnQgKHZpYSBhIFN0YXRlbWVudCkgdG8gYW5vdGhlciBkb2N1bWVudC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBSZWZlcmVuY2UgZXh0ZW5kcyBBYnN0cmFjdENsYXNzXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHN0YXRlbWVudDogVXJpU3RhdGVtZW50LFxuXHRcdFx0cmVhZG9ubHkgdGFyZ2V0OiBEb2N1bWVudCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdHJlYWRvbmx5IGNsYXNzID0gQ2xhc3MucmVmZXJlbmNlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQW4gYWxpYXMgZm9yIGEgdHVwbGUgdXNlZCB0byBjb25zdHJ1Y3QgZmF1bHRzIHRoYXQgYXJlIHVzZWQgYnkgYSBEb2N1bWVudCdzXG5cdCAqIC5oYXNGYXVsdHMgbWV0aG9kIGluIG9yZGVyIHRvIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgcGFydGljdWxhciBmYXVsdC5cblx0ICogXG5cdCAqIFRoZSBzY2hlbWEgb2YgdGhlIHR1cGxlIGlzIFtGYXVsdCB0eXBlLCBsaW5lIG51bWJlclxuXHQgKiBcblx0ICogSW4gdGhlIGNhc2Ugd2hlbiB0aGUgZmF1bHQgdHlwZSBpcyBhbiBJbmZpeFNwYW4sIFxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgVENvbXBhcmlzb25GYXVsdCA9IFxuXHRcdFtTdGF0ZW1lbnRGYXVsdFR5cGUsIG51bWJlcl0gfCBcblx0XHRbU3BhbkZhdWx0VHlwZSwgbnVtYmVyLCBudW1iZXJdO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIGNsYXNzIHRoYXQgZGV0ZWN0cyBjaXJjdWxhciByZWxhdGlvbnNoaXBzIGJldHdlZW5cblx0ICogaW50ZXItcmVmZXJlbmNpbmcgZG9jdW1lbnRzLCBhbmQgaGFuZGxlcyB0aGUgcmVwb3J0aW5nXG5cdCAqIGFuZCByZXNvbHV0aW9uIG9mIHRoZSBuZWNlc3NhcnkgZmF1bHRzIHdoZW4gY2lyY3VsYXJcblx0ICogcmVsYXRpb25zaGlwcyBhcmUgZGV0ZWN0ZWQgYW5kIHJlc29sdmVkLlxuXHQgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgb3duZWQgYnkgYSBQcm9ncmFtIGluc3RhbmNlLFxuXHQgKiBhbmQgZWFjaCBQcm9ncmFtIG93bnMgZXhhY3RseSBvbmUgQ3ljbGVEZXRlY3Rvci5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDeWNsZURldGVjdG9yXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZm9ybXMgdGhlIEN5Y2xlRGV0ZWN0b3IgdGhhdCBhIHJlZmVyZW50aWFsbHktc2lnbmlmaWNhbnQgXG5cdFx0ICogc3RhdGVtZW50IChtZWFuaW5nIHRoYXQgaXQgd2FzIGhhdmluZyBhbiBlZmZlY3Qgb24gdGhlIGdyYXBoXG5cdFx0ICogb2YgIGNvbm5lY3RlZCBkb2N1bWVudHMpIHdhcyBkZWxldGVkIGZyb20gYSBkb2N1bWVudC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIGZhdWx0cyB3ZXJlXG5cdFx0ICogcmVwb3J0ZWQgdG8gdGhlIEZhdWx0U2VydmljZS5cblx0XHQgKi9cblx0XHRkaWREZWxldGUoc3RhdGVtZW50OiBVcmlTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0bGV0IGhhc0ZhdWx0cyA9IGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5jeWNsZXMubGVuZ3RoOyBpLS0gPiAwOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZmF1bHRzID0gdGhpcy5jeWNsZXNbaV07XG5cdFx0XHRcdGlmIChmYXVsdHMubWFwKHYgPT4gdi5zdGF0ZW1lbnQpLmluY2x1ZGVzKHN0YXRlbWVudCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN5Y2xlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBmYXVsdCBvZiBmYXVsdHMpXG5cdFx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlc29sdmVNYW51YWwoZmF1bHQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGhhc0ZhdWx0cyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGhhc0ZhdWx0cztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5mb3JtcyB0aGUgQ3ljbGVEZXRlY3RvciB0aGF0IGEgcmVmZXJlbnRpYWxseS1zaWduaWZpY2FudCBcblx0XHQgKiBzdGF0ZW1lbnQgKG1lYW5pbmcgdGhhdCBpdCB3YXMgaGF2aW5nIGFuIGVmZmVjdCBvbiB0aGUgZ3JhcGhcblx0XHQgKiBvZiAgY29ubmVjdGVkIGRvY3VtZW50cykgd2FzIGFkZGVkIHRvIGEgZG9jdW1lbnQuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBmYXVsdHMgd2VyZVxuXHRcdCAqIHJlcG9ydGVkIHRvIHRoZSBGYXVsdFNlcnZpY2UuXG5cdFx0ICovXG5cdFx0ZGlkQWRkKHN0YXRlbWVudDogVXJpU3RhdGVtZW50KVxuXHRcdHtcblx0XHRcdGxldCBoYXNGYXVsdHMgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHN0YXJ0aW5nRG9jdW1lbnQgPSBzdGF0ZW1lbnQuZG9jdW1lbnQ7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBhbGdvcml0aG0gdHJhY2tzIHRoZSBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gdmlzaXRlZCxcblx0XHRcdC8vIGFuZCB0ZXJtaW5hdGVzIHRoZSB0cmF2ZXJzYWwgd2hlbiB2aXNpdGVkIGRvY3VtZW50cyBhcmVcblx0XHRcdC8vIGRpc2NvdmVyZWQuIFRoaXMgaXMgdG8gcHJldmVudCBzdGFjayBvdmVyZmxvd3MuXG5cdFx0XHRjb25zdCB2aXNpdGVkOiBEb2N1bWVudFtdID0gW107XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBvdXRwdXQgb2YgdGhlIHJlY3Vyc2UgZnVuY3Rpb24gYmVsb3cgaXMgYSBzZXJpZXMgb2YgZG9jdW1lbnRcblx0XHRcdC8vIHBhaXJzLCB3aGVyZSB0aGUgZmlyc3QgZG9jdW1lbnQgY29udGFpbnMgdGhlIHN0YXRlbWVudCB0aGF0IGlzXG5cdFx0XHQvLyByZXNwb25zaWJsZSBmb3IgdGhlIGludHJvZHVjdGlvbiBvZiB0aGUgcmVmZXJlbmNlLCBhbmQgdGhlIHNlY29uZFxuXHRcdFx0Ly8gZG9jdW1lbnQgaXMgdGhlIG9uZSBiZWluZyB0YXJnZXR0ZWQgYnkgc2FpZCByZWZlcmVuY2UuIFxuXHRcdFx0Y29uc3QgZGlzY292ZXJlZERvY1BhaXJzOiBbRG9jdW1lbnQsIERvY3VtZW50XVtdW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gV2hpbGUgdGhlIHJlY3Vyc2UgZnVuY3Rpb24gaXMgb3BlcmF0aW5nLCBpdCBrZWVwcyB0cmFjayBvZiBhIHN0YWNrXG5cdFx0XHQvLyBvZiBwYWlycyAocm91Z2hseSBjb3JyZXNwb25kaW5nIHRvIHRoZSBjYWxsIHN0YWNrIG9mIHRoZSByZWN1cnNlXG5cdFx0XHQvLyBmdW5jdGlvbikuIFRoZSBzdGFjayBpcyB0aGVuIGNvcGllZCB0byB0aGUgZGlzY292ZXJlZERvY1BhaXJzXG5cdFx0XHQvLyBhcnJheSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBzdGFjayBpcyBmb3VuZCB0byBiZSBhIGNpcmN1bGFyIHJlbGF0aW9uc2hpcC5cblx0XHRcdGNvbnN0IHN0YWNrUGFpcnM6IFtEb2N1bWVudCwgRG9jdW1lbnRdW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVjdXJzZSA9IChzcmNEb2M6IERvY3VtZW50LCBkc3REb2M6IERvY3VtZW50KSA9PlxuXHRcdFx0e1xuXHRcdFx0XHQvLyBEb24ndCBmb2xsb3cgcHJldmlvdXNseSB2aXNpdGVkIGRlc3RpbmF0aW9uIGRvY3VtZW50cy5cblx0XHRcdFx0aWYgKHZpc2l0ZWQuaW5jbHVkZXMoZHN0RG9jKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBGb3VuZCBhIGN5Y2xlLCBhZGQgYW55IG5ldyBjeWNsaWNhbCBjb250cmlidXRvcnNcblx0XHRcdFx0Ly8gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3RhY2sgdG8gdGhlIGFycmF5LlxuXHRcdFx0XHRpZiAoZHN0RG9jID09PSBzdGFydGluZ0RvY3VtZW50KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcGFpciA9IHN0YWNrUGFpcnMuc2xpY2UoKTtcblx0XHRcdFx0XHRwYWlyLnB1c2goW3NyY0RvYywgZHN0RG9jXSk7XG5cdFx0XHRcdFx0ZGlzY292ZXJlZERvY1BhaXJzLnB1c2gocGFpcik7XG5cdFx0XHRcdFx0dmlzaXRlZC5wdXNoKGRzdERvYyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFja1BhaXJzLnB1c2goW3NyY0RvYywgZHN0RG9jXSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGRlcGVuZGVuY3lEb2Mgb2YgZHN0RG9jLmRlcGVuZGVuY2llcylcblx0XHRcdFx0XHRyZWN1cnNlKGRzdERvYywgZGVwZW5kZW5jeURvYyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFja1BhaXJzLnBvcCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIHN0YXJ0aW5nRG9jdW1lbnQuZGVwZW5kZW5jaWVzKVxuXHRcdFx0XHRyZWN1cnNlKHN0YXRlbWVudC5kb2N1bWVudCwgZGVwZW5kZW5jeSk7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBkaXNjb3ZlcmVkRG9jUGFpcnMgYXJyYXkgaXMgY29udmVydGVkIGludG8gYSBwcm9wZXIgY3ljbGUsXG5cdFx0XHQvLyAoYW4gYXJyYXkgb2YgZmF1bHRzKSwgYmVmb3JlIGJlaW5nIHN0b3JlZC5cblx0XHRcdGZvciAoY29uc3QgY3ljbGVQYWlyIG9mIGRpc2NvdmVyZWREb2NQYWlycylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZmF1bHRzOiBGYXVsdDxTdGF0ZW1lbnQ+W10gPSBbXTtcblx0XHRcdFx0Zm9yIChjb25zdCBbc3JjRG9jLCBkc3REb2NdIG9mIGN5Y2xlUGFpcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHNtdCA9IHNyY0RvYy5nZXRTdGF0ZW1lbnRDYXVzaW5nRGVwZW5kZW5jeShkc3REb2MpO1xuXHRcdFx0XHRcdGlmIChzbXQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgZmF1bHQgPSBGYXVsdHMuQ2lyY3VsYXJSZXNvdXJjZVJlZmVyZW5jZS5jcmVhdGUoc210KTtcblx0XHRcdFx0XHRcdGZhdWx0cy5wdXNoKGZhdWx0KTtcblx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5mYXVsdHMucmVwb3J0TWFudWFsKGZhdWx0KTtcblx0XHRcdFx0XHRcdGhhc0ZhdWx0cyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmN5Y2xlcy5wdXNoKGZhdWx0cyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBoYXNGYXVsdHM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgYXJyYXkgb2YgY3ljbGVzIHRoYXQgd2VyZSBkaXNjb3ZlcmVkIGluIHRoZSBwcm9ncmFtLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgY3ljbGVzOiBDeWNsZVtdID0gW107XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBIFwiY3ljbGVcIiBpcyBkZWZpbmVkIGFzIGFuIGFycmF5IG9mIFN0YXRlbWVudEZhdWx0cywgdGhhdCBsb29zZWx5XG5cdCAqIGZvcm0gYSBjb25uZWN0ZWQgc2VyaWVzIG9mIGludGVyLXJlZmVyZW5jaW5nIGRvY3VtZW50cyB3aGVuXG5cdCAqIGNvbnNpZGVyaW5nIHRoZSBmYXVsdCdzIGFzc29jaWF0ZWQgc3RhdGVtZW50IGFuZCB0aGlzIHN0YXRlbWVudCdzXG5cdCAqIGNvbnRhaW5pbmcgZG9jdW1lbnQuXG5cdCAqIFxuXHQgKiBUaGUgc2VyaWVzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IGZvcm0gYSBzaW1wbGUgbGluZWFyIGNoYWluLiBUaGVyZVxuXHQgKiBtYXkgYmUgbWFueSBwb3NzaWJsZSBwYXRod2F5cyBmb3JtaW5nIHRoZSBjaXJjdWxhciByZWxhdGlvbnNoaXAuXG5cdCAqIEZvciBleGFtcGxlLCBpZiB3ZSBjb25zaWRlciBhIHVwd2FyZC1wb2ludGluZyBkaWFtb25kLXNoYXBlZCBcblx0ICogZGVwZW5kZW5jeSBwYXR0ZXJuLCBhbmQgdGhlbiB3ZSBmdXJ0aGVyIHN1cHBvc2UgdGhhdCB0aGUgdG9wXG5cdCAqIG5vZGUgb2YgdGhlIGRpYW1vbmQgaXMgY29ubmVjdGVkIHRvIHRoZSBib3R0b20gbm9kZSwgdGhpcyB3b3VsZFxuXHQgKiBmb3JtIGEgY2lyY3VsYXIgcmVsYXRpb25zaGlwIHdpdGggbXVsdGlwbGUgcGF0aHdheXMuIFxuXHQgKiBcblx0ICogQWRkaXRpb25hbGx5LCBpdCdzIHBvc3NpYmxlIHRoYXQgc29tZSBkb2N1bWVudCByZWxhdGlvbnNoaXBcblx0ICogc3RydWN0dXJlcyBjb3VsZCBhY3R1YWxseSBwcmVzZW50IGEgc2l0YXRpb24gd2hlcmUgdGhlcmUgYXJlIGFuXG5cdCAqIGluZmluaXRlIG51bWJlciBvZiB1bmlxdWUgcGF0aHdheXMgdG8gdHJhdmVyc2UgZnJvbSBhIHN0YXJ0aW5nXG5cdCAqIGRvY3VtZW50IGJhY2sgdG8gaXRzZWxmLiBUaGlzIHdvdWxkIG9jY3VyIGluIHRoZSBjYXNlIHdoZW4gd2UgXG5cdCAqIGhhdmUgYSBzaW1wbGUgY2lyY3VsYXIgcmVsYXRpb25zaGlwIHRoYXQgaXMgYWxzbyBqb2luZWQgdG8gYW5vdGhlclxuXHQgKiBuZXN0ZWQgY2lyY3VsYXIgcmVsYXRpb25zaGlwLCB3aGljaCBmb3JtcyBhIGtpbmQgb2Ygd2hpcmxwb29sLlxuXHQgKiBcblx0ICogRm9yIHRoaXMgcmVhc29uLCBhIGN5Y2xlIGlzIHN0b3JlZCBhcyBzaW1wbHkgYWxsIHRoZSBmYXVsdHMgdGhhdFxuXHQgKiBjb21wb3NlIHRoZSBjeWNsZSBpdHNlbGYsIGFuZCB0aGUgc3BlY2lmaWMgcGF0aHdheXMgdGhhdCBtYXlcblx0ICogYmUgY29udHJpYnV0aW5nIGFyZW4ndCBhdmFpbGFibGUuIENvbnZlbmllbnRseSwgU3RhdGVtZW50RmF1bHRcblx0ICogb2JqZWN0cyBzdG9yZSBhIFN0YXRlbWVudCBvYmplY3QsIGFuZCBTdGF0ZW1lbnQgb2JqZWN0cyBzdG9yZVxuXHQgKiBhIERvY3VtZW50LCBhbmQgc28gZnJvbSBhbiBhcnJheSBvZiBGYXVsdCBvYmplY3RzLCB0aGUgc3lzdGVtXG5cdCAqIGlzIGFibGUgdG8gZGlzY292ZXIgdGhlIGluZm9ybWF0aW9uIGl0IG5lZWRzLlxuXHQgKi9cblx0dHlwZSBDeWNsZSA9IFN0YXRlbWVudEZhdWx0W107XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogU3RvcmVzIHRoZSBvcHRpb25zIGZvciB0aGUgbGluZSBwYXJzZXIuXG5cdCAqL1xuXHRleHBvcnQgaW50ZXJmYWNlIElMaW5lUGFyc2VyT3B0aW9uc1xuXHR7XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIGEgZnVsbCBVUkkgdGhhdCB0aGUgcGFyc2luZyBjYW4gdXNlIHRvIHJlc29sdmVcblx0XHQgKiByZWxhdGl2ZSBVUklzIGRpc2NvdmVyZWQgZHVyaW5nIHRoZSBwYXJzaW5nIHByb2Nlc3MuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgYXNzdW1lZFVyaTogS25vd25Vcmk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgcGF0dGVybnMgc2hvdWxkIGJlXG5cdFx0ICogcGFyc2VkIGFzIHBhdHRlcm5zICh0cnVlKSwgb3IgYXMgcmVndWxhciB0eXBlcyAoZmFsc2UpLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHJlYWRQYXR0ZXJuczogYm9vbGVhbjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBVUklzIHNob3VsZCBiZVxuXHRcdCAqIHBhcnNlZCBhcyBVUklzICh0cnVlKSwgb3IgYXMgcmVndWxhciB0eXBlcyAoZmFsc2UpLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHJlYWRVcmlzOiBib29sZWFuO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUGFyc2VzIGEgc2luZ2xlIGxpbmUgb2YgVHJ1dGggY29kZSwgYW5kIHJldHVybnNcblx0ICogYSBMaW5lIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIHdoYXQgd2FzIHJlYWQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTGluZVBhcnNlclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgeWllbGRzIGFsbCBzdGF0ZW1lbnRzICh1bnBhcnNlZCBsaW5lcylcblx0XHQgKiBvZiB0aGUgZ2l2ZW4gc291cmNlIHRleHQuIFxuXHRcdCAqL1xuXHRcdHN0YXRpYyAqcmVhZChzb3VyY2VUZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKHNvdXJjZVRleHQubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGxldCBjdXJzb3IgPSAwO1xuXHRcdFx0bGV0IHN0YXRlbWVudFN0YXJ0ID0gMDtcblx0XHRcdFxuXHRcdFx0Zm9yICg7IGN1cnNvciA8IHNvdXJjZVRleHQubGVuZ3RoOyBjdXJzb3IrKylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHNvdXJjZVRleHRbY3Vyc29yXSA9PT0gU3ludGF4LnRlcm1pbmFsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWllbGQgc291cmNlVGV4dC5zbGljZShzdGF0ZW1lbnRTdGFydCwgY3Vyc29yKTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRTdGFydCA9IGN1cnNvciArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHN0YXRlbWVudFN0YXJ0IDwgY3Vyc29yKVxuXHRcdFx0XHR5aWVsZCBzb3VyY2VUZXh0LnNsaWNlKHN0YXRlbWVudFN0YXJ0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTWFpbiBlbnRyeSBwb2ludCBmb3IgcGFyc2luZyBhIHNpbmdsZSBsaW5lIGFuZCBwcm9kdWNpbmcgYVxuXHRcdCAqIFJhd1N0YXRlbWVudCBvYmplY3QuXG5cdFx0ICogXG5cdFx0ICogVGhlIHBhcnNpbmcgYWxnb3JpdGhtIGlzIHNvbWUga2luZCBvZiBxdWFzaS1yZWN1c2l2ZSBkZXNjZW50IHdpdGhcblx0XHQgKiBsb29raGVhZHMgYW5kIGJhY2t0cmFja2luZyBpbiBzb21lIHBsYWNlcyB0byBtYWtlIHRoZSBsb2dpYyBlYXNpZXJcblx0XHQgKiB0byBmb2xsb3cuIFRlY2huaWNhbGx5LCBpdCdzIHByb2JhYmx5IHNvbWUgbWFzaC11cCBvZiBMTChrKSAmIExBTFIuXG5cdFx0ICogTWF5YmUgaWYgSSBibGV3IDQgeWVhcnMgb2YgbXkgbGlmZSBpbiBzb21lIHNpbGx5IENvbXAgU2NpIHByb2dyYW1cblx0XHQgKiBpbnN0ZWFkIG9mIGRyb3BwaW5nIG91dCBvZiBoaWdoIHNjaG9vbCBJIGNvdWxkIHNheSBmb3Igc3VyZS5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gbGluZVRleHQgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgbGluZSB0byBwYXJzZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgcGFyc2UobGluZVRleHQ6IHN0cmluZywgb3B0aW9uczogSUxpbmVQYXJzZXJPcHRpb25zKVxuXHRcdHtcblx0XHRcdGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZVRleHQpO1xuXHRcdFx0Y29uc3Qgc291cmNlVGV4dCA9IGxpbmVUZXh0O1xuXHRcdFx0Y29uc3QgaW5kZW50ID0gcGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRjb25zdCBkZWNsYXJhdGlvbkVudHJpZXM6IEJvdW5kYXJ5PFN1YmplY3Q+W10gPSBbXTtcblx0XHRcdGNvbnN0IGFubm90YXRpb25FbnRyaWVzOiBCb3VuZGFyeTxUZXJtPltdID0gW107XG5cdFx0XHRjb25zdCBlc2MgPSBTeW50YXguZXNjYXBlQ2hhcjtcblx0XHRcdGxldCBmbGFncyA9IExpbmVGbGFncy5ub25lO1xuXHRcdFx0bGV0IGpvaW50UG9zaXRpb24gPSAtMTtcblx0XHRcdGxldCBzdW0gPSBcIlwiO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFVuaXZlcnNhbCBmdW5jdGlvbiBmb3IgcXVpY2tseSBwcm9kdWNpbmcgYSBSYXdTdGF0ZW1lbnRcblx0XHRcdCAqIGluc3RhbmNlIHVzaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIGNvbnN0cnVjdGVkIGxvY2FsIHZhcmlhYmxlcy5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgcmV0ID0gKGZhdWx0OiBTdGF0ZW1lbnRGYXVsdFR5cGUgfCBudWxsID0gbnVsbCkgPT4gbmV3IExpbmUoXG5cdFx0XHRcdHNvdXJjZVRleHQsXG5cdFx0XHRcdGluZGVudCxcblx0XHRcdFx0bmV3IEJvdW5kYXJ5R3JvdXAoZGVjbGFyYXRpb25FbnRyaWVzKSxcblx0XHRcdFx0bmV3IEJvdW5kYXJ5R3JvdXAoYW5ub3RhdGlvbkVudHJpZXMpLFxuXHRcdFx0XHRzdW0sXG5cdFx0XHRcdGpvaW50UG9zaXRpb24sXG5cdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHRmYXVsdCk7XG5cdFx0XHRcblx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZW4gdGhlIGxpbmUgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsXG5cdFx0XHQvLyB0aGlzIGNvbmRpdGlvbiB3aWxsIHBhc3MsIGJ5cGFzc2luZyB0aGUgZW50aXJlIHBhcnNpbmcgcHJvY2Vzc1xuXHRcdFx0Ly8gYW5kIHJldHVybmluZyBhbiAoYmFzaWNhbGx5KSBmcmVzaCBSYXdTdGF0ZW1lbnQgb2JqZWN0LlxuXHRcdFx0aWYgKCFwYXJzZXIubW9yZSgpKVxuXHRcdFx0e1xuXHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNXaGl0ZXNwYWNlO1xuXHRcdFx0XHRyZXR1cm4gcmV0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChTeW50YXguY29tbWVudCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIXBhcnNlci5tb3JlKCkgfHwgcGFyc2VyLnJlYWQoU3ludGF4LnNwYWNlKSB8fCBwYXJzZXIucmVhZChTeW50YXgudGFiKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNDb21tZW50O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdW5wYXJzYWJsZUZhdWx0VHlwZSA9ICgoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5jb21iaW5hdG9yKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50QmVnaW5zV2l0aENvbW1hO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChTeW50YXgubGlzdCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlN0YXRlbWVudEJlZ2luc1dpdGhFbGxpcHNpcztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoZXNjICsgU3ludGF4LnNwYWNlKSB8fCBwYXJzZXIucmVhZChlc2MgKyBTeW50YXgudGFiKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50QmVnaW5zV2l0aEVzY2FwZWRTcGFjZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWRUaGVuVGVybWluYWwoZXNjKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50Q29udGFpbnNPbmx5RXNjYXBlQ2hhcmFjdGVyO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHVucGFyc2FibGVGYXVsdFR5cGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNDcnVmdDtcblx0XHRcdFx0XHRyZXR1cm4gcmV0KHVucGFyc2FibGVGYXVsdFR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFya0JlZm9yZVVyaSA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgdXJpID0gbWF5YmVSZWFkVXJpKCk7XG5cdFx0XHRcdGlmICh1cmkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaGFzVXJpO1xuXHRcdFx0XHRcdGRlY2xhcmF0aW9uRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdG1hcmtCZWZvcmVVcmksXG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHR1cmkpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdGhlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBtYXJrQmVmb3JlUGF0dGVybiA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgcGF0dGVybiA9IG1heWJlUmVhZFBhdHRlcm4oKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpc0ZhdWx0KHBhdHRlcm4pKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZmxhZ3MgfD0gTGluZUZsYWdzLmlzQ3J1ZnQ7XG5cdFx0XHRcdFx0cmV0dXJuIHJldChwYXR0ZXJuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhdHRlcm4pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaGFzUGF0dGVybjtcblx0XHRcdFx0XHRmbGFncyB8PSBwYXR0ZXJuLmlzVG90YWwgP1xuXHRcdFx0XHRcdFx0TGluZUZsYWdzLmhhc1RvdGFsUGF0dGVybiA6XG5cdFx0XHRcdFx0XHRMaW5lRmxhZ3MuaGFzUGFydGlhbFBhdHRlcm47XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZGVjbGFyYXRpb25FbnRyaWVzLnB1c2gobmV3IEJvdW5kYXJ5KFxuXHRcdFx0XHRcdFx0bWFya0JlZm9yZVBhdHRlcm4sXG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHRwYXR0ZXJuKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIHRoZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBib3VuZHNFbnRyeSBvZiByZWFkRGVjbGFyYXRpb25zKFtdKSlcblx0XHRcdFx0XHRkZWNsYXJhdGlvbkVudHJpZXMucHVzaChib3VuZHNFbnRyeSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdGhlbigpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiB0aGVuKClcblx0XHRcdHtcblx0XHRcdFx0am9pbnRQb3NpdGlvbiA9IG1heWJlUmVhZEpvaW50KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCByZWFkUmVzdWx0ID0gcmVhZEFubm90YXRpb25zKFtdKTtcblx0XHRcdFx0c3VtID0gcmVhZFJlc3VsdC5yYXcudHJpbSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBib3VuZHNFbnRyeSBvZiByZWFkUmVzdWx0LmFubm90YXRpb25zKVxuXHRcdFx0XHRcdGFubm90YXRpb25FbnRyaWVzLnB1c2goYm91bmRzRW50cnkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGpvaW50UG9zaXRpb24gPiAtMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRMZW4gPSBkZWNsYXJhdGlvbkVudHJpZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnN0IGFMZW4gPSByZWFkUmVzdWx0LmFubm90YXRpb25zLmxlbmd0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZExlbiA9PT0gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkZWNsYXJhdGlvbkVudHJpZXMudW5zaGlmdChuZXcgQm91bmRhcnkoXG5cdFx0XHRcdFx0XHRcdGpvaW50UG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdGpvaW50UG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdFRlcm0udm9pZCkpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoYUxlbiA9PT0gMClcblx0XHRcdFx0XHRcdFx0ZmxhZ3MgfD0gTGluZUZsYWdzLmlzVmFjdW91cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoYUxlbiA9PT0gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNSZWZyZXNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJldCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWRzIHRoZSBmb2xsb3dpbmcgc2VyaWVzIG9mIGRlY2xhcmF0aW9ucywgd2hpY2ggbWF5IGJlXG5cdFx0XHQgKiBlaXRoZXIgZGlyZWN0bHkgY29udGFpbmVkIGJ5IGEgc3RhdGVtZW50LCBvciBpbnNpZGUgYW4gaW5maXguXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHJlYWREZWNsYXJhdGlvbnMocXVpdFRva2Vuczogc3RyaW5nW10pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGVudHJpZXM6IEJvdW5kYXJ5PFRlcm0+W10gPSBbXTtcblx0XHRcdFx0Y29uc3QgdW50aWwgPSBxdWl0VG9rZW5zLmNvbmNhdChTeW50YXguam9pbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCByZWFkUmVzdWx0ID0gbWF5YmVSZWFkVGVybSh1bnRpbCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHJlYWRSZXN1bHQgIT09IG51bGwpXG5cdFx0XHRcdFx0XHRlbnRyaWVzLnB1c2gobmV3IEJvdW5kYXJ5PFRlcm0+KFxuXHRcdFx0XHRcdFx0XHRyZWFkUmVzdWx0LmF0LCBcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0XHRyZWFkUmVzdWx0LnRlcm0pKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGUgZm9sbG93aW5nIGNvbWJpbmF0b3IgbXVzdCBiZSBlYXRlbiBiZWZvcmVcblx0XHRcdFx0XHQvLyBtb3Zpbmcgb24gdG8gYW5vdGhlciBkZWNsYXJhdGlvbi4gSWYgdGhpcyBmYWlscyxcblx0XHRcdFx0XHQvLyBpdCdzIGJlY2F1c2UgdGhlIHBhcnNlIHN0cmVhbSBoYXMgZW5kZWQuXG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChTeW50YXguY29tYmluYXRvcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGVla0pvaW50KCkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGVudHJpZXM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCB0aGUgam9pbnQgdG9rZW4gZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdFx0ICogQ29uc3VtZXMgYWxsIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UuXG5cdFx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBqb2ludFxuXHRcdFx0ICogdG9rZW4gd2FzIHJlYWQuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZEpvaW50KClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFya0JlZm9yZVdzID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0Y29uc3QgbWFya0FmdGVyV3MgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGxldCBmb3VuZEpvaW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChTeW50YXguam9pbnQgKyBTeW50YXguc3BhY2UpIHx8XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWQoU3ludGF4LmpvaW50ICsgU3ludGF4LnRhYikgfHxcblx0XHRcdFx0XHRwYXJzZXIucmVhZFRoZW5UZXJtaW5hbChTeW50YXguam9pbnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm91bmRKb2ludFBvc2l0aW9uID0gbWFya0FmdGVyV3M7XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFya0JlZm9yZVdzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZm91bmRKb2ludFBvc2l0aW9uO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBqb2ludFxuXHRcdFx0ICogaXMgdGhlIG5leHQgbG9naWNhbCB0b2tlbiB0byBiZSBjb25zdW1lZC4gVHJ1ZSBpcyByZXR1cm5lZFxuXHRcdFx0ICogaW4gdGhlIGNhc2Ugd2hlbiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgc2l0IGJldHdlZW4gdGhlXG5cdFx0XHQgKiBjdXJzb3IgYW5kIHRoZSBqb2ludCBvcGVyYXRvci5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcGVla0pvaW50KClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaW5uZXJQZWVrSm9pbnQgPSAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlci5wZWVrKFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSkgfHxcblx0XHRcdFx0XHRcdHBhcnNlci5wZWVrKFN5bnRheC5qb2ludCArIFN5bnRheC50YWIpIHx8XG5cdFx0XHRcdFx0XHRwYXJzZXIucGVla1RoZW5UZXJtaW5hbChTeW50YXguam9pbnQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGlubmVyUGVla0pvaW50KCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXBhcnNlci5wZWVrKFN5bnRheC5zcGFjZSkgJiYgIXBhcnNlci5wZWVrKFN5bnRheC50YWIpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRjb25zdCBhdEpvaW50ID0gaW5uZXJQZWVrSm9pbnQoKTtcblx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBhdEpvaW50O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZWFkQW5ub3RhdGlvbnMocXVpdFRva2Vuczogc3RyaW5nW10pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGFubm90YXRpb25zOiBCb3VuZGFyeTxUZXJtPltdID0gW107XG5cdFx0XHRcdGxldCByYXcgPSBcIlwiO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCByZWFkUmVzdWx0ID0gbWF5YmVSZWFkVGVybShxdWl0VG9rZW5zKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVhZFJlc3VsdCAhPT0gbnVsbClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhbm5vdGF0aW9ucy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0cmVhZFJlc3VsdC5hdCwgXG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0cmVhZFJlc3VsdC50ZXJtKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJhdyArPSByZWFkUmVzdWx0LnJhdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5leHQgdG9rZW4gaXMgbm90IGEgY29tYmluYXRvciwgXG5cdFx0XHRcdFx0Ly8gdGhlIHBhcnNlIHN0cmVhbSBoYXMgZW5kZWQuXG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChTeW50YXguY29tYmluYXRvcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRhbm5vdGF0aW9ucyxcblx0XHRcdFx0XHRyYXdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGFuZCByZXR1cm4gYSB0ZXJtIGZyb20gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkVGVybShxdWl0VG9rZW5zOiBzdHJpbmdbXSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdW50aWwgPSBxdWl0VG9rZW5zXG5cdFx0XHRcdFx0LmNvbmNhdChTeW50YXguY29tYmluYXRvcilcblx0XHRcdFx0XHQuZmlsdGVyKHRvayA9PiB0b2sgIT09IFN5bnRheC5qb2ludCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBzaG91bGRRdWl0T25Kb2ludCA9IHF1aXRUb2tlbnMuaW5jbHVkZXMoU3ludGF4LmpvaW50KTtcblx0XHRcdFx0Y29uc3QgYXQgPSBwYXJzZXIucG9zaXRpb24gKyBwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0bGV0IHRva2VuID0gXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHVudGlsLnNvbWUodG9rID0+IHBhcnNlci5wZWVrKHRvaykpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNob3VsZFF1aXRPbkpvaW50ICYmIHBlZWtKb2ludCgpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZzEgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gVGhlIG9ubHkgb3BlcmF0b3JzIHRoYXQgY2FuIGJlIG1lYW5pbmdmdWxseSBlc2NhcGVkIGF0XG5cdFx0XHRcdFx0XHQvLyB0aGUgdGVybSBsZXZlbCBhcmUgdGhlIGpvaW50LCB0aGUgY29tYmluYXRvciwgYW5kIHRoZVxuXHRcdFx0XHRcdFx0Ly8gcGF0dGVybiBkZWxpbWl0ZXIuIE90aGVyIG9jY3VyZW5jZXMgb2YgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHRcdC8vIGFwcGVuZCB0aGlzIGNoYXJhY3RlciB0byB0aGUgdGVybS5cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGcxID09PSBlc2MpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGcyID0gcGFyc2VyLnJlYWRHcmFwaGVtZSgpO1xuXHRcdFx0XHRcdFx0XHR0b2tlbiArPSBnMjtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRva2VuICs9IGcxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCB0b2tlblRyaW1tZWQgPSB0b2tlbi50cmltKCk7XG5cdFx0XHRcdGlmICghdG9rZW5UcmltbWVkLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0YXQsXG5cdFx0XHRcdFx0dGVybTogVGVybS5mcm9tKHRva2VuVHJpbW1lZCksXG5cdFx0XHRcdFx0cmF3OiB0b2tlblxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgYSBVUkkgc3RhcnRpbmcgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdCAqIG9mIHRoZSBjdXJzb3IuIFRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIGlzIG5vdCBjaGFuZ2VkXG5cdFx0XHQgKiBpbiB0aGUgY2FzZSB3aGVuIGEgdmFsaWQgVVJJIHdhcyBub3QgcmVhZC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkVXJpKClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFvcHRpb25zLnJlYWRVcmlzKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IHByZWZpeCA9IFxuXHRcdFx0XHRcdHBhcnNlci5yZWFkKFN5bnRheC5odHRwUHJlZml4KSB8fFxuXHRcdFx0XHRcdHBhcnNlci5yZWFkKFN5bnRheC5odHRwc1ByZWZpeCkgfHxcblx0XHRcdFx0XHRwYXJzZXIucmVhZChTeW50YXgucmV0cmFjdGluZ1VyaVByZWZpeCkgfHxcblx0XHRcdFx0XHRwYXJzZXIucmVhZChTeW50YXgucmVsYXRpdmVVcmlQcmVmaXgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHByZWZpeCA9PT0gXCJcIilcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IG1heWJlVXJpQ29udGVudCA9IHBhcnNlci5yZWFkVW50aWwoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtYXliZVVyaUNvbnRlbnQuZW5kc1dpdGgoU3ludGF4LnRydXRoRXh0ZW5zaW9uKSlcblx0XHRcdFx0XHRyZXR1cm4gS25vd25VcmkuZnJvbVN0cmluZyhwcmVmaXggKyBtYXliZVVyaUNvbnRlbnQsIG9wdGlvbnMuYXNzdW1lZFVyaSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgcGF0dGVybiBmcm9tIHRoZSBzdGVhbS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUGF0dGVybihuZXN0ZWQgPSBmYWxzZSk6IFBhdHRlcm4gfCBTdGF0ZW1lbnRGYXVsdFR5cGUgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghbmVzdGVkICYmICFwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci5tYWluKSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghb3B0aW9ucy5yZWFkUGF0dGVybnMpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgc3RhcnRpbmcgc2VxdWVuY2VzLiBUaGV5J3JlIGludmFsaWRcblx0XHRcdFx0Ly8gcmVnZXggc3ludGF4LCBhbmQgd2UgbWF5IHVzZSB0aGVtIGluIHRoZSBmdXR1cmUgdG8gcGFja1xuXHRcdFx0XHQvLyBpbiBvdGhlciBsYW5ndWFnZSBmZWF0dXJlcy5cblx0XHRcdFx0aWYgKHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4TWlzYy5wbHVzKSB8fFxuXHRcdFx0XHRcdHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4TWlzYy5zdGFyKSB8fFxuXHRcdFx0XHRcdHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkKSlcblx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlN0YXRlbWVudEJlZ2luc1dpdGhJbnZhbGlkU2VxdWVuY2U7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUeXBlU2NyaXB0IGlzbid0IHBlcmZlY3QuXG5cdFx0XHRcdGNvbnN0IHVuaXRzID0gbmVzdGVkID9cblx0XHRcdFx0XHRyZWFkUmVnZXhVbml0cyh0cnVlKSA6XG5cdFx0XHRcdFx0cmVhZFJlZ2V4VW5pdHMoZmFsc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGlzRmF1bHQodW5pdHMpKVxuXHRcdFx0XHRcdHJldHVybiB1bml0cztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFJpZ2h0LXRyaW0gYW55IHRyYWlsaW5nIHdoaXRlc3BhY2Vcblx0XHRcdFx0d2hpbGUgKHVuaXRzLmxlbmd0aClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGxhc3QgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIShsYXN0IGluc3RhbmNlb2YgUmVnZXhHcmFwaGVtZSkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobGFzdC5ncmFwaGVtZSAhPT0gU3ludGF4LnNwYWNlICYmIGxhc3QuZ3JhcGhlbWUgIT09IFN5bnRheC50YWIpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR1bml0cy5wb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHVuaXRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLkVtcHR5UGF0dGVybjtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGxhc3QgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcblx0XHRcdFx0Y29uc3QgaXNUb3RhbCA9IFxuXHRcdFx0XHRcdGxhc3QgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lICYmXG5cdFx0XHRcdFx0bGFzdC5xdWFudGlmaWVyID09PSBudWxsICYmXG5cdFx0XHRcdFx0bGFzdC5ncmFwaGVtZSA9PT0gUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbjtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gcG9wIG9mZiB0aGUgXG5cdFx0XHRcdGlmIChpc1RvdGFsKVxuXHRcdFx0XHRcdHVuaXRzLnBvcCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTm93IHJlYWQgdGhlIGFubm90YXRpb25zLCBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBQYXR0ZXJuJ3MgaGFzaFxuXHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBmb3VuZEpvaW50UG9zaXRpb24gPSBtYXliZVJlYWRKb2ludCgpO1xuXHRcdFx0XHRpZiAoZm91bmRKb2ludFBvc2l0aW9uIDwgMClcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhdHRlcm4oT2JqZWN0LmZyZWV6ZSh1bml0cyksIGlzVG90YWwsIFwiXCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYW5ub3MgPSByZWFkQW5ub3RhdGlvbnMoW10pLmFubm90YXRpb25zO1xuXHRcdFx0XHRjb25zdCBhbm5vc0FycmF5Sm9pbmVkID0gQXJyYXkuZnJvbShhbm5vcy52YWx1ZXMoKSlcblx0XHRcdFx0XHQubWFwKHYgPT4gdi5zdWJqZWN0LnRvU3RyaW5nKCkpXG5cdFx0XHRcdFx0LmpvaW4oU3ludGF4LnRlcm1pbmFsKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGhhc2ggPSBIYXNoLmNhbGN1bGF0ZShhbm5vc0FycmF5Sm9pbmVkKTtcblx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgUGF0dGVybihPYmplY3QuZnJlZXplKHVuaXRzKSwgaXNUb3RhbCwgaGFzaCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHJlYWRSZWdleFVuaXRzKG5lc3RlZDogdHJ1ZSk6IFN0YXRlbWVudEZhdWx0VHlwZSB8IChSZWdleFVuaXQpW107XG5cdFx0XHRmdW5jdGlvbiByZWFkUmVnZXhVbml0cyhuZXN0ZWQ6IGZhbHNlKTogU3RhdGVtZW50RmF1bHRUeXBlIHwgKFJlZ2V4VW5pdCB8IEluZml4KVtdO1xuXHRcdFx0ZnVuY3Rpb24gcmVhZFJlZ2V4VW5pdHMobmVzdGVkOiBib29sZWFuKTogU3RhdGVtZW50RmF1bHRUeXBlIHwgKFJlZ2V4VW5pdCB8IEluZml4KVtdXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHVuaXRzOiAoUmVnZXhVbml0IHwgSW5maXgpW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgc2V0T3JHcm91cCA9IG1heWJlUmVhZFJlZ2V4U2V0KCkgfHwgbWF5YmVSZWFkUmVnZXhHcm91cCgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpc0ZhdWx0KHNldE9yR3JvdXApKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHNldE9yR3JvdXA7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNldE9yR3JvdXAgIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRcdFx0aWYgKGlzRmF1bHQocXVhbnRpZmllcikpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBxdWFudGlmaWVyO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR1bml0cy5wdXNoKGFwcGVuZFF1YW50aWZpZXIoc2V0T3JHcm91cCwgcXVhbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChuZXN0ZWQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IpKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kKSlcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBJbmZpeGVzIGFyZSBub3Qgc3VwcG9ydGVkIGFueXdoZXJlIG90aGVyIFxuXHRcdFx0XHRcdFx0Ly8gdGhhbiBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSBwYXR0ZXJuLlxuXHRcdFx0XHRcdFx0Y29uc3QgaW5maXggPSBtYXliZVJlYWRJbmZpeCgpO1xuXHRcdFx0XHRcdFx0aWYgKGlzRmF1bHQoaW5maXgpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW5maXg7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChpbmZpeCAhPT0gbnVsbClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRcdFx0XHRpZiAocXVhbnRpZmllciAhPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLkluZml4SGFzUXVhbnRpZmllcjtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHVuaXRzLnB1c2goaW5maXgpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHBlZWtKb2ludCgpKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZ3JhcGhlbWUgPSBtYXliZVJlYWRSZWdleEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0aWYgKCFncmFwaGVtZSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBncmFwaGVtZSByZWFkIGlzIGluIHRoZSBSZWdleFN5bnRheEtub3duU2V0XG5cdFx0XHRcdFx0Ly8gZW51bWVyYXRpb24sIHdlIG5lZWQgdG8gY29udmVydCB0aGUgZ3JhcGhlbWUgdG8gYVxuXHRcdFx0XHRcdC8vIFJlZ2V4U2V0IGluc3RhbmNlLCBhbmQgcHVzaCB0aGF0IG9uIHRvIHRoZSB1bml0cyBhcnJheVxuXHRcdFx0XHRcdC8vIGluc3RlYWQuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgcmVnZXhLbm93blNldCA9ICgoKSA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChncmFwaGVtZS5jaGFyYWN0ZXIgPT09IFJlZ2V4U3ludGF4S25vd25TZXQud2lsZCAmJiAhZ3JhcGhlbWUuZXNjYXBlZClcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFJlZ2V4U3ludGF4S25vd25TZXQud2lsZDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGdyYXBoZW1lLmVzY2FwZWQpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNoYXJhY3RlcldpdGhFc2NhcGUgPSBlc2MgKyBncmFwaGVtZS5jaGFyYWN0ZXI7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGtub3duU2V0ID0gUmVnZXhTeW50YXhLbm93blNldC5yZXNvbHZlKGNoYXJhY3RlcldpdGhFc2NhcGUpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGtub3duU2V0ICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBrbm93blNldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBxdWFudGlmaWVyID0gbWF5YmVSZWFkUmVnZXhRdWFudGlmaWVyKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGlzRmF1bHQocXVhbnRpZmllcikpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcXVhbnRpZmllcjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVnZXhLbm93blNldCAhPT0gbnVsbClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR1bml0cy5wdXNoKG5ldyBSZWdleFNldChbcmVnZXhLbm93blNldF0sIFtdLCBbXSwgW10sIGZhbHNlLCBxdWFudGlmaWVyKSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGdyYXBoZW1lLnVuaWNvZGVCbG9ja05hbWUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgdWJuID0gZ3JhcGhlbWUudW5pY29kZUJsb2NrTmFtZTtcblx0XHRcdFx0XHRcdHVuaXRzLnB1c2gobmV3IFJlZ2V4U2V0KFtdLCBbXSwgW3Vibl0sIFtdLCBmYWxzZSwgcXVhbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChncmFwaGVtZS5lc2NhcGVkKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHNpZ24gPSBSZWdleFN5bnRheFNpZ24ucmVzb2x2ZShlc2MgKyBncmFwaGVtZS5jaGFyYWN0ZXIpO1xuXHRcdFx0XHRcdFx0aWYgKHNpZ24gIT09IG51bGwpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHVuaXRzLnB1c2gobmV3IFJlZ2V4U2lnbihzaWduLCBxdWFudGlmaWVyKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGlzIHBvaW50IGlzIHJlYWNoZWQsIGl0J3MgYmVjYXVzZSB0aGVyZSB3YXMgYSB1bm5lY2Nlc2FyaWx5XG5cdFx0XHRcdFx0XHQvLyBlc2NhcGVkIGNoYXJhY3RlciBmb3VuZCBpbiB0aGUgcGFyc2Ugc3RyZWFtLCBzdWNoIGFzIFwiXFxhXCIuIEluXG5cdFx0XHRcdFx0XHQvLyB0aGlzIGNhc2UsIHRoZSByYXcgY2hhcmFjdGVyIGNhbiBqdXN0IGJlIGFkZGVkIGFzIGEgcmVnZXggdW5pdC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dW5pdHMucHVzaChuZXcgUmVnZXhHcmFwaGVtZShcblx0XHRcdFx0XHRcdGdyYXBoZW1lLmNoYXJhY3Rlcixcblx0XHRcdFx0XHRcdHF1YW50aWZpZXIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHVuaXRzO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgYSBjaGFyYWN0ZXIgc2V0IGZyb20gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqIEV4YW1wbGU6IFthLXowLTldXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFJlZ2V4U2V0KCk6IFJlZ2V4U2V0IHwgU3RhdGVtZW50RmF1bHRUeXBlIHwgbnVsbFxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLnNldFN0YXJ0KSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHJuZyA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLnJhbmdlO1xuXHRcdFx0XHRjb25zdCBrbm93bnM6IFJlZ2V4U3ludGF4S25vd25TZXRbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCByYW5nZXM6IFJlZ2V4Q2hhclJhbmdlW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgYmxvY2tzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBzaW5nbGVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBpc05lZ2F0ZWQgPSAhIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4TWlzYy5uZWdhdGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IGNsb3NlZCA9IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFN0b3JlcyBhbGwgR3JhcGhlbWVzIHJlYWQuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRjb25zdCBncmFwaGVtZXM6IChHcmFwaGVtZSB8IG51bGwpW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBTdG9yZXMgYm9vbGVhbnMgdGhhdCBhbGlnbiB3aXRoIHRoZSBpdGVtcyBpbiBcInF1ZXVlXCIsXG5cdFx0XHRcdCAqIHRoYXQgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIHF1ZXVlZCBHcmFwaGVtZVxuXHRcdFx0XHQgKiBjYW4gcGFydGljaXBhdGUgaW4gYSByYW5nZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGNvbnN0IHJhbmdhYmxlUXVldWU6IGJvb2xlYW5bXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICg7Oylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGcgPSBtYXliZVJlYWRSZWdleEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGcgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWcuZXNjYXBlZCAmJiBnLmNoYXJhY3RlciA9PT0gUmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGcudW5pY29kZUJsb2NrTmFtZSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRibG9ja3MucHVzaChnLnVuaWNvZGVCbG9ja05hbWUpO1xuXHRcdFx0XHRcdFx0cmFuZ2FibGVRdWV1ZS5wdXNoKGZhbHNlKTtcblx0XHRcdFx0XHRcdGdyYXBoZW1lcy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGdGdWxsID0gZy5lc2NhcGVkID8gZXNjICsgZy5jaGFyYWN0ZXIgOiBnLmNoYXJhY3Rlcjtcblx0XHRcdFx0XHRjb25zdCBrbm93biA9IFJlZ2V4U3ludGF4S25vd25TZXQucmVzb2x2ZShnRnVsbCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGtub3duICE9PSBudWxsKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGtub3ducy5wdXNoKGtub3duKTtcblx0XHRcdFx0XHRcdHJhbmdhYmxlUXVldWUucHVzaChmYWxzZSk7XG5cdFx0XHRcdFx0XHRncmFwaGVtZXMucHVzaChudWxsKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRncmFwaGVtZXMucHVzaChnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyYW5nYWJsZVF1ZXVlLnB1c2goXG5cdFx0XHRcdFx0XHRnLmNoYXJhY3Rlci5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0XHRnLmNoYXJhY3RlciAhPT0gUmVnZXhTeW50YXhNaXNjLmJvdW5kYXJ5ICYmXG5cdFx0XHRcdFx0XHRnLmNoYXJhY3RlciAhPT0gUmVnZXhTeW50YXhNaXNjLmJvdW5kYXJ5Tm9uKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZy51bmljb2RlQmxvY2tOYW1lKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbGVuID0gZ3JhcGhlbWVzLmxlbmd0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobGVuIDwgMylcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG1heWJlUm5nID0gZ3JhcGhlbWVzW2xlbiAtIDJdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXliZVJuZyAhPT0gbnVsbCAmJiBtYXliZVJuZy5jaGFyYWN0ZXIgIT09IHJuZylcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghcmFuZ2FibGVRdWV1ZVtsZW4gLSAzXSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG1heWJlRnJvbSA9IGdyYXBoZW1lc1tsZW4gLSAzXTtcblx0XHRcdFx0XHRpZiAobWF5YmVGcm9tID09PSBudWxsKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gUGVlbCBiYWNrIHN5bWJvbCBxdWV1ZSwgYW5kIGFkZCBhIHJhbmdlXG5cdFx0XHRcdFx0Ly8gdG8gdGhlIGFscGhhYmV0IGJ1aWxkZXIgaWYgdGhlIHF1ZXVlIGdldHMgaW50b1xuXHRcdFx0XHRcdC8vIGEgc3RhdGUgd2hlcmUgaXQncyBlbmRpbmcgd2l0aCBzb21ldGhpbmdcblx0XHRcdFx0XHQvLyBsb29raW5nIGxpa2U6ID8tP1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGZyb20gPSBtYXliZUZyb20uY2hhcmFjdGVyLmNvZGVQb2ludEF0KDApIHx8IDA7XG5cdFx0XHRcdFx0Y29uc3QgdG8gPSBnLmNoYXJhY3Rlci5jb2RlUG9pbnRBdCgwKSB8fCAwO1xuXHRcdFx0XHRcdHJhbmdlcy5wdXNoKG5ldyBSZWdleENoYXJSYW5nZShmcm9tLCB0bykpO1xuXHRcdFx0XHRcdGdyYXBoZW1lcy5sZW5ndGggLT0gMztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFjbG9zZWQpXG5cdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5VbnRlcm1pbmF0ZWRDaGFyYWN0ZXJTZXQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGcgb2YgZ3JhcGhlbWVzKVxuXHRcdFx0XHRcdGlmIChnICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0c2luZ2xlcy5wdXNoKGcuY2hhcmFjdGVyKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHF1YW50aWZpZXIgPSBtYXliZVJlYWRSZWdleFF1YW50aWZpZXIoKTtcblx0XHRcdFx0aWYgKGlzRmF1bHQocXVhbnRpZmllcikpXG5cdFx0XHRcdFx0cmV0dXJuIHF1YW50aWZpZXI7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4U2V0KFxuXHRcdFx0XHRcdGtub3ducyxcblx0XHRcdFx0XHRyYW5nZXMsXG5cdFx0XHRcdFx0YmxvY2tzLFxuXHRcdFx0XHRcdHNpbmdsZXMsXG5cdFx0XHRcdFx0aXNOZWdhdGVkLFxuXHRcdFx0XHRcdHF1YW50aWZpZXIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgYW4gYWx0ZXJuYXRpb24gZ3JvdXAgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdFx0ICogRXhhbXBsZTogKEF8QnxDKVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRSZWdleEdyb3VwKCk6IFJlZ2V4R3JvdXAgfCBTdGF0ZW1lbnRGYXVsdFR5cGUgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghcGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBTdGFydCkpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjYXNlczogKHJlYWRvbmx5IFJlZ2V4VW5pdFtdKVtdID0gW107XG5cdFx0XHRcdGxldCBjbG9zZWQgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHN1YlVuaXRzID0gcmVhZFJlZ2V4VW5pdHModHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKGlzRmF1bHQoc3ViVW5pdHMpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN1YlVuaXRzO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBjYWxsIHRvIG1heWJlUmVhZFBhdHRlcm4gY2F1c2VzIHRoZSBjdXJzb3Jcblx0XHRcdFx0XHQvLyB0byByZWFjaCB0aGUgZW5kIG9mIHRlIHBhcnNlIHN0cmVhbSwgdGhlIGV4cHJlc3Npb25cblx0XHRcdFx0XHQvLyBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgd291bGQgbWVhbiB0aGUgaW5wdXQgbG9va3Ncblx0XHRcdFx0XHQvLyBzb21ldGhpbmcgbGlrZTogLyhhYXxiYlxuXHRcdFx0XHRcdGlmICghcGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuVW50ZXJtaW5hdGVkR3JvdXA7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQSBudWxsIHN1YlBhdHRlcm4gY291bGQgY29tZSBiYWNrIGluIHRoZSBjYXNlIHdoZW4gc29tZVxuXHRcdFx0XHRcdC8vIGJpemFycmUgc3ludGF4IGlzIGZvdW5kIGluIHRoZSBwYXR0ZXJuIHN1Y2ggYXM6IChhfHxiKVxuXHRcdFx0XHRcdGlmIChzdWJVbml0cyA9PT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2VzLnB1c2goT2JqZWN0LmZyZWV6ZShzdWJVbml0cykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWNsb3NlZClcblx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlVudGVybWluYXRlZEdyb3VwO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRpZiAoaXNGYXVsdChxdWFudGlmaWVyKSlcblx0XHRcdFx0XHRyZXR1cm4gcXVhbnRpZmllcjtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnZXhHcm91cChPYmplY3QuZnJlZXplKGNhc2VzKSwgcXVhbnRpZmllcik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBhIHBhdHRlcm4gcXVhbnRpZmllciBmcm9tIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0XHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZXMsIHdoaWNoIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBKYXZhU2NyaXB0XG5cdFx0XHQgKiByZWd1bGFyIGV4cHJlc3Npb24gZmxhdm9yIChhbmQgb3RoZXJzPykgY2Fubm90IHBhcnNlIGFuIGV4cHJlc3Npb25cblx0XHRcdCAqIHdpdGggdHdvIGNvbnNlY3V0aXZlIHF1YW50aWZpZXJzLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRSZWdleFF1YW50aWZpZXIoKTogUmVnZXhRdWFudGlmaWVyIHwgU3RhdGVtZW50RmF1bHRUeXBlIHwgbnVsbFxuXHRcdFx0e1xuXHRcdFx0XHQvKiogKi9cblx0XHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUXVhbnRpZmllcigpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2Muc3RhcikpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcigwLCBJbmZpbml0eSwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2MucGx1cykpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcigxLCBJbmZpbml0eSwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2MucmVzdHJhaW5lZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcigwLCAxLCBmYWxzZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyU3RhcnQpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbWluID0gbWF5YmVSZWFkSW50ZWdlcigpO1xuXHRcdFx0XHRcdGlmIChtaW4gIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcXVhbnRFbmQgPSBSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyRW5kO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyB7Mn1cblx0XHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChxdWFudEVuZCkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgUmVnZXhRdWFudGlmaWVyKG1pbiwgbWluLCBpc1Jlc3RyYWluZWQoKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIHsyLH0gb3IgezIsM30gb3IgezIsPz8/XG5cdFx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclNlcGFyYXRvcikpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChxdWFudEVuZCkpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFF1YW50aWZpZXIobWluLCBJbmZpbml0eSwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF4ID0gbWF5YmVSZWFkSW50ZWdlcigpO1xuXHRcdFx0XHRcdFx0XHRpZiAobWF4ICE9PSBudWxsICYmIHBhcnNlci5yZWFkKHF1YW50RW5kKSlcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcihtaW4sIG1heCwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvKiogKi9cblx0XHRcdFx0ZnVuY3Rpb24gaXNSZXN0cmFpbmVkKClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiAhIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFF1YW50aWZpZXIoKTtcblx0XHRcdFx0aWYgKHF1YW50aWZpZXIpXG5cdFx0XHRcdFx0aWYgKG1heWJlUmVhZFF1YW50aWZpZXIoKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuRHVwbGljYXRlUXVhbnRpZmllcjtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBxdWFudGlmaWVyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRJbnRlZ2VyKClcblx0XHRcdHtcblx0XHRcdFx0bGV0IGludGVnZXJUZXh0ID0gXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMTYgJiYgcGFyc2VyLm1vcmUoKTsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZGlnaXQgPSAoKCkgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBkaWdpdCA9IDA7IGRpZ2l0IDw9IDk7IGRpZ2l0KyspXG5cdFx0XHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChkaWdpdC50b1N0cmluZygpKSlcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZGlnaXQudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWRpZ2l0KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aW50ZWdlclRleHQgKz0gZGlnaXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBpbnRlZ2VyVGV4dC5sZW5ndGggPiAwID9cblx0XHRcdFx0XHRwYXJzZUludChpbnRlZ2VyVGV4dCwgMTApIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRJbmZpeCgpOiBJbmZpeCB8IFN0YXRlbWVudEZhdWx0VHlwZSB8IG51bGxcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgbGhzRW50cmllczogQm91bmRhcnk8VGVybT5bXSA9IFtdO1xuXHRcdFx0XHRjb25zdCByaHNFbnRyaWVzOiBCb3VuZGFyeTxUZXJtPltdID0gW107XG5cdFx0XHRcdGNvbnN0IGluZml4U3RhcnQgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGxldCBpbmZpeEZsYWdzOiBJbmZpeEZsYWdzID0gSW5maXhGbGFncy5ub25lO1xuXHRcdFx0XHRsZXQgcXVpdFRva2VuID0gSW5maXhTeW50YXguZW5kO1xuXHRcdFx0XHRsZXQgaGFzSm9pbnQgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChJbmZpeFN5bnRheC5ub21pbmFsU3RhcnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW5maXhGbGFncyB8PSBJbmZpeEZsYWdzLm5vbWluYWw7XG5cdFx0XHRcdFx0cXVpdFRva2VuID0gSW5maXhTeW50YXgubm9taW5hbEVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChwYXJzZXIucmVhZChJbmZpeFN5bnRheC5wYXR0ZXJuU3RhcnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW5maXhGbGFncyB8PSBJbmZpeEZsYWdzLnBhdHRlcm47XG5cdFx0XHRcdFx0cXVpdFRva2VuID0gSW5maXhTeW50YXgucGF0dGVybkVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChwYXJzZXIucmVhZChJbmZpeFN5bnRheC5zdGFydCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbmZpeEZsYWdzIHw9IEluZml4RmxhZ3MucG9wdWxhdGlvbjtcblx0XHRcdFx0XHRxdWl0VG9rZW4gPSBJbmZpeFN5bnRheC5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5qb2ludCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbmZpeEZsYWdzIHw9IEluZml4RmxhZ3MucG9ydGFiaWxpdHk7XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBib3VuZHNFbnRyeSBvZiByZWFkQW5ub3RhdGlvbnMoW3F1aXRUb2tlbl0pLmFubm90YXRpb25zKVxuXHRcdFx0XHRcdFx0cmhzRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0Ym91bmRzRW50cnkub2Zmc2V0U3RhcnQsXG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0Ym91bmRzRW50cnkuc3ViamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3QgYm91bmRzRW50cnkgb2YgcmVhZERlY2xhcmF0aW9ucyhbcXVpdFRva2VuXSkpXG5cdFx0XHRcdFx0XHRsaHNFbnRyaWVzLnB1c2goYm91bmRzRW50cnkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXliZVJlYWRKb2ludCgpID4gLTEpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aGFzSm9pbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgYm91bmRzRW50cnkgb2YgcmVhZEFubm90YXRpb25zKFtxdWl0VG9rZW5dKS5hbm5vdGF0aW9ucylcblx0XHRcdFx0XHRcdFx0cmhzRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0XHRib3VuZHNFbnRyeS5vZmZzZXRTdGFydCxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0Ym91bmRzRW50cnkuc3ViamVjdCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXZvaWQgcHJvZHVjaW5nIGFuIGluZml4IGluIHdlaXJkIGNhc2VzIHN1Y2ggYXM6XG5cdFx0XHRcdC8vIDwgOiA+ICA8LyAgLz4gIDw8Oj4+XG5cdFx0XHRcdGlmIChsaHNFbnRyaWVzLmxlbmd0aCArIHJoc0VudHJpZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGhhc0pvaW50KVxuXHRcdFx0XHRcdGluZml4RmxhZ3MgfD0gSW5maXhGbGFncy5oYXNKb2ludDtcblx0XHRcdFx0XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChxdWl0VG9rZW4pKVxuXHRcdFx0XHRcdHJldHVybiBGYXVsdHMuVW50ZXJtaW5hdGVkSW5maXg7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IEluZml4KFxuXHRcdFx0XHRcdGluZml4U3RhcnQsXG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uLFxuXHRcdFx0XHRcdG5ldyBCb3VuZGFyeUdyb3VwKGxoc0VudHJpZXMpLFxuXHRcdFx0XHRcdG5ldyBCb3VuZGFyeUdyb3VwKHJoc0VudHJpZXMpLFxuXHRcdFx0XHRcdGluZml4RmxhZ3MpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgb25lIHNpbmdsZSBzeW1ib2wgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLFxuXHRcdFx0ICogd2hpbGUgcmVzcGVjdGluZyB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMsIGFuZCBlc2NhcGVkXG5cdFx0XHQgKiBjaGFyYWN0ZXJzLlxuXHRcdFx0ICogXG5cdFx0XHQgKiBAcmV0dXJucyBUaGUgcmVhZCBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgY2FzZSB3aGVuXG5cdFx0XHQgKiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGluIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFJlZ2V4R3JhcGhlbWUoKTogR3JhcGhlbWUgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghcGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIudXRmMTZHcm91cFN0YXJ0KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRlbGltID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIudXRmMTZHcm91cEVuZDtcblx0XHRcdFx0XHRjb25zdCB1bmljb2RlUmVmID0gcGFyc2VyLnJlYWRVbnRpbChkZWxpbSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSByZWFkVW50aWwgbWV0aG9kIHN0b3BwZWQgYmVjYXVzZSBpdFxuXHRcdFx0XHRcdC8vIGFjdHVhbGx5IGhpdCB0aGUgZGVsaW1pdGVyLCBhbmQgbm90IGJlY2F1c2UgaXQgcmFuIG91dFxuXHRcdFx0XHRcdC8vIG9mIGNoYXJhY3RlcnMuXG5cdFx0XHRcdFx0aWYgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cGFyc2VyLnJlYWQoZGVsaW0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoVW5pY29kZUJsb2Nrcy5oYXModW5pY29kZVJlZi50b0xvd2VyQ2FzZSgpKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBHcmFwaGVtZShcIlwiLCB1bmljb2RlUmVmLCB0cnVlKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3QgbGVuID0gdW5pY29kZVJlZi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpZiAobGVuID49IDEgJiYgbGVuIDw9IDUpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG51bSA9IHBhcnNlSW50KHVuaWNvZGVSZWYsIDE2KTtcblx0XHRcdFx0XHRcdFx0aWYgKG51bSA9PT0gbnVtKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBHcmFwaGVtZShjaGFyLCBcIlwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBTb21ldGhpbmcgY2FtZSBpbiB0aGF0IGxvb2tlZCBsaWtlIGEgdW5pY29kZSBlc2NhcGVcblx0XHRcdFx0XHQvLyBzZXF1ZW5jZSwgYnV0IHR1cm5lZCBvdXQgbm90IHRvIGJlLCBsaWtlOiBcXHVcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoZXNjKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJzZSBzdHJlYW0gZW5kcyB3aXRoIGEgYmFja3NsYXNoLCB3ZSBqdXN0XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBhY3R1YWwgYmFja3NsYXNoIGNoYXJhY3RlciBhcyBhIGNoYXJhY3Rlci5cblx0XHRcdFx0XHQvLyBUaGlzIGNvdmVycyByaWRpY3Vsb3VzIGJ1dCBwb3NzaWJsZSBjYXNlcyB3aGVyZSBhXG5cdFx0XHRcdFx0Ly8gYW4gdW5hbm5vdGF0ZWQgdHlwZSBpcyBuYW1lZCBzb21ldGhpbmcgbGlrZSBcIlRoaW5nXFxcIi5cblx0XHRcdFx0XHRpZiAoIXBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEdyYXBoZW1lKGVzYywgXCJcIiwgZmFsc2UpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGcgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0Y29uc3QgZGVjb2RlZCA9IFJlZ2V4U3ludGF4U2lnbi51bmVzY2FwZShlc2MgKyBnKSB8fCBnO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JhcGhlbWUoZGVjb2RlZCwgXCJcIiwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgR3JhcGhlbWUocGFyc2VyLnJlYWRHcmFwaGVtZSgpLCBcIlwiLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0ZnVuY3Rpb24gaXNGYXVsdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0YXRlbWVudEZhdWx0VHlwZVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBGYXVsdFR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgY29uc3RydWN0b3IoKSB7IH1cblx0fVxuXHRcblx0LyoqICovXG5cdGNsYXNzIEdyYXBoZW1lXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBjaGFyYWN0ZXIgZm91bmQgaW4gdGhlIHBhcnNlIHN0cmVhbSBpblxuXHRcdFx0ICogdGhlaXIgdW5lc2NhcGVkIGZvcm1hdC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG5cdFx0XHQgKiB3aGVuIHRoZSBmaWVsZCBpcyByZWZlcnJpbmcgdG8gYSB1bmljb2RlIGNoYXJhY3Rlcixcblx0XHRcdCAqIHRoZSBmaWVsZCB3b3VsZCBzdG9yZSBcIvCfkIdcIiAuLi4gbm90IFwiXFx1MUY0MDdcIi5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgY2hhcmFjdGVyOiBzdHJpbmcsXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgbmFtZSBvZiB0aGUgdW5pY29kZSBibG9jayBzcGVjaWZpZWQsXG5cdFx0XHQgKiBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGdyYXBoZW1lIGRvZXMgbm90IHJlZmVyXG5cdFx0XHQgKiB0byBhIHVuaWNvZGUgYmxvY2suXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHVuaWNvZGVCbG9ja05hbWU6IHN0cmluZyxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhlIGRpc2NvdmVyZWQgZ3JhcGhlbWUgd2FzXG5cdFx0XHQgKiBlc2NhcGVkIGluIHRoZSBwYXJzZSBzdHJlYW0uIE5vdGUgdGhhdCBpZiB0aGVcblx0XHRcdCAqIGdyYXBoZW1lIHJlZmVycyB0byBhIHNwZWNpYWwgY2hhcmFjdGVyLCBzdWNoXG5cdFx0XHQgKiBhcyBcIlxcZFwiIGZvciBhbGwgZGlnaXRzLCB0aGlzIHdpbGwgYmUgdHJ1ZS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgZXNjYXBlZDogYm9vbGVhbilcblx0XHR7IH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFNsaWdodGx5IGF3a3dhcmQgaGFjayBmdW5jdGlvbiB0byBhdHRhY2ggYSBQYXR0ZXJuUXVhbnRpZmllclxuXHQgKiB0byBhbiBhbHJlYWR5IGV4aXN0aW5nIFBhdHRlcm5Vbml0ICh3aXRob3V0IHJlc29ydGluZyB0byBtYWtpbmdcblx0ICogcXVhbnRpZmllciBhIG11dGFibGUgcHJvcGVydHkuXG5cdCAqL1xuXHRmdW5jdGlvbiBhcHBlbmRRdWFudGlmaWVyKHVuaXQ6IFJlZ2V4VW5pdCwgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbCA9IG51bGwpXG5cdHtcblx0XHRpZiAocXVhbnRpZmllciA9PT0gbnVsbClcblx0XHRcdHJldHVybiB1bml0O1xuXHRcdFxuXHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhTZXQpXG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2V4U2V0KFxuXHRcdFx0XHR1bml0Lmtub3ducyxcblx0XHRcdFx0dW5pdC5yYW5nZXMsXG5cdFx0XHRcdHVuaXQudW5pY29kZUJsb2Nrcyxcblx0XHRcdFx0dW5pdC5zaW5nbGVzLFxuXHRcdFx0XHR1bml0LmlzTmVnYXRlZCxcblx0XHRcdFx0cXVhbnRpZmllcik7XG5cdFx0XG5cdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyb3VwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWdleEdyb3VwKHVuaXQuY2FzZXMsIHF1YW50aWZpZXIpO1xuXHRcdFxuXHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcmFwaGVtZSlcblx0XHRcdHJldHVybiBuZXcgUmVnZXhHcmFwaGVtZSh1bml0LmdyYXBoZW1lLCBxdWFudGlmaWVyKTtcblx0XHRcblx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFBsYWNlaG9sZGVyIG9iamVjdCB0byBtYXJrIHRoZSBwb3NpdGlvbiBvZlxuXHQgKiBhbiBhbm9ueW1vdXMgdHlwZSB3aXRoaW4gYSBzdGF0ZW1lbnQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQW5vblxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogTm8tb3AgcHJvcGVydHkgdXNlZCBmb3IgZGVidWdnaW5nXG5cdFx0ICogcHVycG9zZXMsIGFuZCBhbHNvIHRvIGRvZGdlIHN0cnVjdHVyYWxcblx0XHQgKiB0eXBlIGNvbXBhdGliaWxpdHkgYnVncyBpbiBUeXBlU2NyaXB0LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlkID0gKytuZXh0SWQ7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQW5vbiBvYmplY3Qgd2hpY2ggbWF5IGJlIHVzZWQgdG9cblx0XHQgKiB1bmlxdWVseSBpZGVudGlmeSBpdC5cblx0XHQgKiBcblx0XHQgKiBFYWNoIEFub24gb2JqZWN0IHNlcmlhbGl6ZXMgZGlmZmVyZW50bHksIG90aGVyd2lzZSwgcHJvYmxlbXMgd291bGQgYXJpc2Vcblx0XHQgKiB3aGVuIHRyeWluZyB0byByZWZlcmVuY2UgYW55IG9mIGl0J3MgY29udGFpbmVkIHR5cGVzIChFeC4gV2hhdCBzcGVjaWZpY1xuXHRcdCAqIHR5cGUgaXMgYmVpbmcgcmVmZXJlZCB0byBpbiBcIl9fQU5PTl9fXCIgaW4gdGhlIHR5cGUgVVJJIFwiQS9CL19fQU5PTl9fL0NcIj9cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGBfX0FOT04ke3RoaXMuaWR9X19gO1xuXHRcdH1cblx0fVxuXHRcblx0bGV0IG5leHRJZCA9IDA7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogU3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgbGluZSwgYWZ0ZXIgYmVpbmcgcGFyc2VkLlxuXHQgKiBBIExpbmUgaXMgZGlmZmVyZW50IGZyb20gYSBTdGF0ZW1lbnQgaW4gdGhhdCBpdCBoYXMgbm9cblx0ICogcmVsYXRpb25zaGlwIHRvIGEgRG9jdW1lbnQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTGluZVxuXHR7XG5cdFx0LyoqKiAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgc291cmNlVGV4dDogc3RyaW5nLFxuXHRcdFx0cmVhZG9ubHkgaW5kZW50OiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSBkZWNsYXJhdGlvbnM6IEJvdW5kYXJ5R3JvdXA8U3ViamVjdD4sXG5cdFx0XHRyZWFkb25seSBhbm5vdGF0aW9uczogQm91bmRhcnlHcm91cDxUZXJtPixcblx0XHRcdHJlYWRvbmx5IHN1bTogc3RyaW5nLFxuXHRcdFx0cmVhZG9ubHkgam9pbnRQb3NpdGlvbjogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgZmxhZ3M6IExpbmVGbGFncyxcblx0XHRcdHJlYWRvbmx5IGZhdWx0VHlwZTogU3RhdGVtZW50RmF1bHRUeXBlIHwgbnVsbClcblx0XHR7IH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEEgYml0IGZpZWxkIGVudW1lcmF0aW9uIHVzZWQgdG8gZWZmaWNpZW50bHkgc3RvcmVcblx0ICogbWV0YSBkYXRhIGFib3V0IGEgTGluZSAob3IgYSBTdGF0ZW1lbnQpIG9iamVjdC5cblx0ICovXG5cdGV4cG9ydCBlbnVtIExpbmVGbGFnc1xuXHR7XG5cdFx0bm9uZSA9IDAsXG5cdFx0aXNSZWZyZXNoID0gMSxcblx0XHRpc1ZhY3VvdXMgPSAyLFxuXHRcdGlzQ29tbWVudCA9IDQsXG5cdFx0aXNXaGl0ZXNwYWNlID0gOCxcblx0XHRpc0Rpc3Bvc2VkID0gMTYsXG5cdFx0aXNDcnVmdCA9IDMyLFxuXHRcdGhhc1VyaSA9IDY0LFxuXHRcdGhhc1RvdGFsUGF0dGVybiA9IDEyOCxcblx0XHRoYXNQYXJ0aWFsUGF0dGVybiA9IDI1Nixcblx0XHRoYXNQYXR0ZXJuID0gNTEyXG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIG1hcmtpbmcgb2JqZWN0IHRoYXQgc3Rha2VzIG91dCBhIHN0YXJ0aW5nIGFuZCBlbmRpbmdcblx0ICogY2hhcmFjdGVyIG9mZnNldCB3aXRoaW4gYSBzdGF0ZW1lbnQsIHNpZ25pZnlpbmcgdGhlXG5cdCAqIGJvdW5kYXJ5IG9mIGEgcGFydGljdWxhciBzdWJqZWN0LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEJvdW5kYXJ5PFRTdWJqZWN0IGV4dGVuZHMgU3ViamVjdD5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgb2Zmc2V0U3RhcnQ6IG51bWJlcixcblx0XHRcdHJlYWRvbmx5IG9mZnNldEVuZDogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgc3ViamVjdDogVFN1YmplY3QpXG5cdFx0eyB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHcm91cHMgdG9nZXRoZXIgYSBzZXJpZXMgb2YgcmVsYXRlZCBCb3VuZGFyeSBvYmplY3RzLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEJvdW5kYXJ5R3JvdXA8VFN1YmplY3QgZXh0ZW5kcyBTdWJqZWN0PlxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoYm91bmRhcmllczogQm91bmRhcnk8VFN1YmplY3Q+W10pXG5cdFx0e1xuXHRcdFx0dGhpcy5lbnRyaWVzID0gT2JqZWN0LmZyZWV6ZShib3VuZGFyaWVzLnNsaWNlKCkuc29ydCgoZW50cnlBLCBlbnRyeUIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBlbnRyeUEub2Zmc2V0U3RhcnQgLSBlbnRyeUIub2Zmc2V0U3RhcnQ7XG5cdFx0XHR9KSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCpbU3ltYm9sLml0ZXJhdG9yXSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMpXG5cdFx0XHRcdHlpZWxkIGVudHJ5O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3ViamVjdCBpbiB0aGUgYm91bmRhcnkgZ3JvdXAuXG5cdFx0ICovXG5cdFx0KmVhY2hTdWJqZWN0KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcylcblx0XHRcdFx0eWllbGQgZW50cnkuc3ViamVjdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc3ViamVjdCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCwgb3IgbnVsbCBpbiB0aGUgY2FzZVxuXHRcdCAqIHdoZW4gbm8gc3ViamVjdCBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG5cdFx0ICovXG5cdFx0aW5zcGVjdChvZmZzZXQ6IG51bWJlcik6IFRTdWJqZWN0IHwgbnVsbFxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKVxuXHRcdFx0XHRpZiAob2Zmc2V0ID49IGVudHJ5Lm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBlbnRyeS5vZmZzZXRFbmQpXG5cdFx0XHRcdFx0cmV0dXJuIGVudHJ5LnN1YmplY3Q7XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBmaXJzdCBzdWJqZWN0IGluIHRoZSBib3VuZGFyeSBncm91cCwgb3IgbnVsbCBpbiB0aGVcblx0XHQgKiBjYXNlIHdoZW4gdGhlIGJvdW5kYXJ5IGdyb3VwIGNvbnRhaW5zIG5vIHN1YmplY3RzLlxuXHRcdCAqL1xuXHRcdGZpcnN0KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpXG5cdFx0XHRcdHJldHVybiBlbnRyeTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBHZXRzIHRoZSBudW1iZXIgb2YgZW50cmllcyBkZWZpbmVkIGluIHRoZSBib3VuZHMuICovXG5cdFx0Z2V0IGxlbmd0aCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZW50cmllcy5sZW5ndGg7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZW50cmllczogcmVhZG9ubHkgQm91bmRhcnk8VFN1YmplY3Q+W107XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHNpbmdsZSBsaW5lIHdpdGhpbiBhIFRydXRoIGRvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFN0YXRlbWVudCBleHRlbmRzIEFic3RyYWN0Q2xhc3Ncblx0e1xuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRyZWFkb25seSBjbGFzcyA9IENsYXNzLnN0YXRlbWVudDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBMb2dpY2FsIGNsb2NrIHZhbHVlIHVzZWQgdG8gbWFrZSBjaHJvbm9sb2dpY2FsIFxuXHRcdCAqIGNyZWF0aW9uLXRpbWUgY29tcGFyaXNvbnMgYmV0d2VlbiBTdGF0ZW1lbnRzLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHN0YW1wID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihkb2N1bWVudDogRG9jdW1lbnQsIHRleHQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBsaW5lID0gTGluZVBhcnNlci5wYXJzZSh0ZXh0LCB7XG5cdFx0XHRcdHJlYWRQYXR0ZXJuczogdHJ1ZSxcblx0XHRcdFx0cmVhZFVyaXM6IHRydWUsXG5cdFx0XHRcdGFzc3VtZWRVcmk6IGRvY3VtZW50LnVyaVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcblx0XHRcdHRoaXMuc291cmNlVGV4dCA9IGxpbmUuc291cmNlVGV4dDtcblx0XHRcdHRoaXMuc3VtID0gbGluZS5zdW07XG5cdFx0XHR0aGlzLmluZGVudCA9IGxpbmUuaW5kZW50O1xuXHRcdFx0dGhpcy5mbGFncyA9IGxpbmUuZmxhZ3M7XG5cdFx0XHR0aGlzLmpvaW50UG9zaXRpb24gPSBsaW5lLmpvaW50UG9zaXRpb247XG5cdFx0XHRcblx0XHRcdHRoaXMuYWxsRGVjbGFyYXRpb25zID0gT2JqZWN0LmZyZWV6ZShBcnJheS5mcm9tKGxpbmUuZGVjbGFyYXRpb25zKVxuXHRcdFx0XHQubWFwKGJvdW5kYXJ5ID0+IG5ldyBTcGFuKHRoaXMsIGJvdW5kYXJ5KSkpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFsbEFubm90YXRpb25zID0gT2JqZWN0LmZyZWV6ZShBcnJheS5mcm9tKGxpbmUuYW5ub3RhdGlvbnMpXG5cdFx0XHRcdC5tYXAoYm91bmRhcnkgPT4gbmV3IFNwYW4odGhpcywgYm91bmRhcnkpKSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZhdWx0czogRmF1bHRbXSA9IFtdO1xuXHRcdFx0Y29uc3QgY3J1ZnRPYmplY3RzID0gbmV3IFNldDxTdGF0ZW1lbnQgfCBTcGFuIHwgSW5maXhTcGFuPigpO1xuXHRcdFx0XG5cdFx0XHRpZiAobGluZS5mYXVsdFR5cGUgIT09IG51bGwpXG5cdFx0XHRcdGZhdWx0cy5wdXNoKG5ldyBGYXVsdChsaW5lLmZhdWx0VHlwZSwgdGhpcykpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0IG9mIHRoaXMuZWFjaFBhcnNlRmF1bHQoKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGZhdWx0LnR5cGUuc2V2ZXJpdHkgPT09IEZhdWx0U2V2ZXJpdHkuZXJyb3IpXG5cdFx0XHRcdFx0Y3J1ZnRPYmplY3RzLmFkZChmYXVsdC5zb3VyY2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0ZmF1bHRzLnB1c2goZmF1bHQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0IG9mIGZhdWx0cylcblx0XHRcdFx0Ly8gQ2hlY2sgbmVlZGVkIHRvIHN1cHBvcnQgdGhlIHVuaXQgdGVzdHMsIHRoZSBmZWVkXG5cdFx0XHRcdC8vIGZha2UgZG9jdW1lbnQgb2JqZWN0cyBpbnRvIHRoZSBzdGF0ZW1lbnQgY29uc3RydWN0b3IuXG5cdFx0XHRcdGlmIChkb2N1bWVudC5wcm9ncmFtICYmIGRvY3VtZW50LnByb2dyYW0uZmF1bHRzKVxuXHRcdFx0XHRcdGRvY3VtZW50LnByb2dyYW0uZmF1bHRzLnJlcG9ydChmYXVsdCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuY3J1ZnRPYmplY3RzID0gY3J1ZnRPYmplY3RzO1xuXHRcdFx0dGhpcy5mYXVsdHMgPSBPYmplY3QuZnJlZXplKGZhdWx0cyk7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvZ3JhbVN0YW1wID0gZG9jdW1lbnQucHJvZ3JhbSA/XG5cdFx0XHRcdGRvY3VtZW50LnByb2dyYW0udmVyc2lvbiA6XG5cdFx0XHRcdFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0fVxuXHRcdFxuXHRcdHJlYWRvbmx5IHByb2dyYW1TdGFtcDogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgKmVhY2hQYXJzZUZhdWx0KCk6IEl0ZXJhYmxlSXRlcmF0b3I8UmVhZG9ubHk8RmF1bHQ8VEZhdWx0U291cmNlPj4+XG5cdFx0e1xuXHRcdFx0Ly8gQ2hlY2sgZm9yIHRhYnMgYW5kIHNwYWNlcyBtaXh0dXJlXG5cdFx0XHRpZiAodGhpcy5pbmRlbnQgPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgaGFzVGFicyA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgaGFzU3BhY2VzID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHRoaXMuaW5kZW50Oylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGNociA9IHRoaXMuc291cmNlVGV4dFtpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY2hyID09PSBTeW50YXgudGFiKVxuXHRcdFx0XHRcdFx0aGFzVGFicyA9IHRydWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNociA9PT0gU3ludGF4LnNwYWNlKVxuXHRcdFx0XHRcdFx0aGFzU3BhY2VzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGhhc1RhYnMgJiYgaGFzU3BhY2VzKVxuXHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuVGFic0FuZFNwYWNlcywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmFsbERlY2xhcmF0aW9ucy5sZW5ndGggPiAxKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdWJqZWN0czogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbERlY2xhcmF0aW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN1YlRleHQgPSBzcGFuLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0aWYgKHN1YmplY3RzLmluY2x1ZGVzKHN1YlRleHQpKVxuXHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5EdXBsaWNhdGVEZWNsYXJhdGlvbiwgc3Bhbik7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c3ViamVjdHMucHVzaChzdWJUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5hbGxBbm5vdGF0aW9ucy5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBUaGlzIHBlcmZvcm1zIGFuIGV4cGVkaWVudCBjaGVjayBmb3IgXCJMaXN0SW50cmluc2ljRXh0ZW5kaW5nTGlzdFwiLFxuXHRcdFx0XHQvLyBob3dldmVyLCBmdWxsIHR5cGUgYW5hbHlzaXMgaXMgcmVxdWlyZWQgdG8gY292ZXIgYWxsIGNhc2VzIHdoZXJlXG5cdFx0XHRcdC8vIHRoaXMgZmF1bHQgbWF5IGJlIHJlcG9ydGVkLlxuXHRcdFx0XHRjb25zdCBnZXRMaXN0U3BhbnMgPSAoc3BhbnM6IHJlYWRvbmx5IFNwYW5bXSkgPT4gc3BhbnMuZmlsdGVyKHNwYW4gPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN1YiA9IHNwYW4uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdFx0XHRyZXR1cm4gc3ViIGluc3RhbmNlb2YgVGVybSAmJiBzdWIuaXNMaXN0O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGxoc0xpc3RTcGFucyA9IGdldExpc3RTcGFucyh0aGlzLmFsbERlY2xhcmF0aW9ucyk7XG5cdFx0XHRcdGNvbnN0IHJoc0xpc3RTcGFucyA9IGdldExpc3RTcGFucyh0aGlzLmFsbEFubm90YXRpb25zKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChsaHNMaXN0U3BhbnMubGVuZ3RoID4gMCAmJiByaHNMaXN0U3BhbnMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgcmhzTGlzdFNwYW5zKVxuXHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5MaXN0SW50cmluc2ljRXh0ZW5kaW5nTGlzdCwgc3Bhbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhdHRlcm4gPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuYWxsRGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGhwID0gTGluZUZsYWdzLmhhc1BhdHRlcm47XG5cdFx0XHRcdGlmICgodGhpcy5mbGFncyAmIGhwKSAhPT0gaHApXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBzdWJqZWN0ID0gdGhpcy5hbGxEZWNsYXJhdGlvbnNbMF0uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdFx0cmV0dXJuIHN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuID9cblx0XHRcdFx0XHRzdWJqZWN0IDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhdHRlcm4gPT09IG51bGwpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWYgKCFwYXR0ZXJuLmlzVmFsaWQpXG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuUGF0dGVybkludmFsaWQsIHRoaXMpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmFsbEFubm90YXRpb25zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5QYXR0ZXJuV2l0aG91dEFubm90YXRpb24sIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGF0dGVybi50ZXN0KFwiXCIpKVxuXHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLlBhdHRlcm5DYW5NYXRjaEVtcHR5LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFwYXR0ZXJuLmlzVG90YWwpXG5cdFx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiBwYXR0ZXJuLmVhY2hVbml0KCkpXG5cdFx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lKVxuXHRcdFx0XHRcdFx0aWYgKHVuaXQuZ3JhcGhlbWUgPT09IFN5bnRheC5jb21iaW5hdG9yKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLlBhdHRlcm5QYXJ0aWFsV2l0aENvbWJpbmF0b3IsIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgcGF0dGVyblNwYW4gPSB0aGlzLmFsbERlY2xhcmF0aW9uc1swXTtcblx0XHRcdGlmIChwYXR0ZXJuU3Bhbi5pbmZpeGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpbmZpeFNwYW5zOiBJbmZpeFNwYW5bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4IG9mIHBhdHRlcm5TcGFuLmluZml4ZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxocyA9IEFycmF5LmZyb20ocGF0dGVyblNwYW4uZWFjaERlY2xhcmF0aW9uRm9ySW5maXgoaW5maXgpKTtcblx0XHRcdFx0Y29uc3QgcmhzID0gQXJyYXkuZnJvbShwYXR0ZXJuU3Bhbi5lYWNoQW5ub3RhdGlvbkZvckluZml4KGluZml4KSk7XG5cdFx0XHRcdGNvbnN0IGFsbCA9IGxocy5jb25jYXQocmhzKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoaXMgaXMgYSBiaXQgb3V0IG9mIHBsYWNlIC4uLiBidXQgd2UgbmVlZCB0byBwb3B1bGF0ZSB0aGVcblx0XHRcdFx0Ly8gaW5maXhTcGFucyBhcnJheSBhbmQgdGhpcyBpcyBwcm9iYWJseSB0aGUgbW9zdCBlZmZpY2llbnRcblx0XHRcdFx0Ly8gcGxhY2UgdG8gZG8gdGhhdC5cblx0XHRcdFx0aW5maXhTcGFucy5wdXNoKC4uLmFsbCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiBhbGwpXG5cdFx0XHRcdFx0aWYgKGluZml4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LmlzTGlzdClcblx0XHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuSW5maXhVc2luZ0xpc3RPcGVyYXRvciwgaW5maXhTcGFuKTtcblx0XHRcdFx0XG5cdFx0XHRcdHlpZWxkICpub3JtYWxpemVJbmZpeFNwYW5zKGxocyk7XG5cdFx0XHRcdHlpZWxkICpub3JtYWxpemVJbmZpeFNwYW5zKHJocyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBsaHNTdWJqZWN0cyA9IGxocy5tYXAobmZ4U3BhbiA9PiBcblx0XHRcdFx0XHRuZnhTcGFuLmJvdW5kYXJ5LnN1YmplY3QudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiByaHMpXG5cdFx0XHRcdFx0aWYgKGxoc1N1YmplY3RzLmluY2x1ZGVzKGluZml4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LnRvU3RyaW5nKCkpKVxuXHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5JbmZpeEhhc1NlbGZSZWZlcmVudGlhbFR5cGUsIGluZml4U3Bhbik7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaW5maXguaXNQb3B1bGF0aW9uKVxuXHRcdFx0XHRcdGZvciAobGV0IGlkeCA9IDE7IGlkeCA8IGxocy5sZW5ndGg7IGlkeCsrKVxuXHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5JbmZpeFBvcHVsYXRpb25DaGFpbmluZywgbGhzW2lkeF0pO1xuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQgKmV4cGVkaWVudExpc3RDaGVjayhsaHMpO1xuXHRcdFx0XHR5aWVsZCAqZXhwZWRpZW50TGlzdENoZWNrKHJocyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIGVhY2hSZXBlYXRlZEluZml4KFxuXHRcdFx0XHRwYXR0ZXJuU3Bhbixcblx0XHRcdFx0aW5maXggPT4gcGF0dGVyblNwYW4uZWFjaERlY2xhcmF0aW9uRm9ySW5maXgoaW5maXgpKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGluZml4U3Bhbi5jb250YWluaW5nSW5maXguaXNQb3B1bGF0aW9uKVxuXHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChcblx0XHRcdFx0XHRcdEZhdWx0cy5Qb3B1bGF0aW9uSW5maXhIYXNNdWx0aXBsZURlZmluaXRpb25zLFxuXHRcdFx0XHRcdFx0aW5maXhTcGFuKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgZWFjaFJlcGVhdGVkSW5maXgoXG5cdFx0XHRcdHBhdHRlcm5TcGFuLFxuXHRcdFx0XHRpbmZpeCA9PiBwYXR0ZXJuU3Bhbi5lYWNoQW5ub3RhdGlvbkZvckluZml4KGluZml4KSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpbmZpeFNwYW4uY29udGFpbmluZ0luZml4LmlzUG9ydGFiaWxpdHkpXG5cdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KFxuXHRcdFx0XHRcdFx0RmF1bHRzLlBvcnRhYmlsaXR5SW5maXhIYXNNdWx0aXBsZURlZmluaXRpb25zLCBcblx0XHRcdFx0XHRcdGluZml4U3Bhbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX2luZml4U3BhbnMgPSBPYmplY3QuZnJlZXplKGluZml4U3BhbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhlIGpvaW50IG9wZXJhdG9yIGV4aXN0cyBhdCB0aGVcblx0XHQgKiBlbmQgb2YgdGhlIHN0YXRlbWVudCwgZm9yY2luZyB0aGUgc3RhdGVtZW50J3Ncblx0XHQgKiBkZWNsYXJhdGlvbnMgdG8gYmUgXCJyZWZyZXNoIHR5cGVzXCIuXG5cdFx0ICovXG5cdFx0Z2V0IGlzUmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc1JlZnJlc2g7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoZSBzdGF0ZW1lbnQgY29udGFpbnMgbm90aGluZ1xuXHRcdCAqIG90aGVyIHRoYW4gYSBzaW5nbGUgam9pbnQgb3BlcmF0b3IuXG5cdFx0ICovXG5cdFx0Z2V0IGlzVmFjdW91cygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc1ZhY3VvdXM7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoZSBzdGF0ZW1lbnQgaXMgYSBjb21tZW50LlxuXHRcdCAqL1xuXHRcdGdldCBpc0NvbW1lbnQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGYgPSBMaW5lRmxhZ3MuaXNDb21tZW50O1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgZikgPT09IGY7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGUgc3RhdGVtZW50IGNvbnRhaW5zXG5cdFx0ICogbm8gbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cblx0XHQgKi9cblx0XHRnZXQgaXNXaGl0ZXNwYWNlKClcblx0XHR7XG5cdFx0XHRjb25zdCBmID0gTGluZUZsYWdzLmlzV2hpdGVzcGFjZTtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIGYpID09PSBmO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhlIHN0YXRlbWVudCBpcyBhIGNvbW1lbnQgb3Igd2hpdGVzcGFjZS5cblx0XHQgKi9cblx0XHRnZXQgaXNOb29wKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0NvbW1lbnQgfHwgdGhpcy5pc1doaXRlc3BhY2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGlzIFN0YXRlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXQnc1xuXHRcdCAqIGNvbnRhaW5pbmcgZG9jdW1lbnQuIFJlbW92YWwgb2NjdXJzIGFmdGVyIHRoZSBzdGF0ZW1lbnRcblx0XHQgKiBoYXMgYmVlbiBpbnZhbGlkYXRlZC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgYmUgZmFsc2Vcblx0XHQgKiBiZWZvcmUgdGhlIGludmFsaWRhdGlvbiBwaGFzZSBoYXMgb2NjdXJlZCwgZXZlbiBpZiBpdCB3aWxsIGJlXG5cdFx0ICogZGlzcG9zZWQgaW4gdGhlIGN1cnJlbnQgZWRpdCB0cmFuc2FjdGlvbi5cblx0XHQgKi9cblx0XHRnZXQgaXNEaXNwb3NlZCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc0Rpc3Bvc2VkO1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgZikgPT09IGY7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGUgU3RhdGVtZW50IGhhcyBiZWVuIG1hcmtlZCBhcyBjcnVmdCxcblx0XHQgKiBkdWUgdG8gYSBwYXJzaW5nIGVycm9yIChhbmQgc3BlY2lmaWNhbGx5IG5vdCBhIHR5cGUgZXJyb3IpLlxuXHRcdCAqL1xuXHRcdGdldCBpc0NydWZ0KClcblx0XHR7XG5cdFx0XHRjb25zdCBmID0gTGluZUZsYWdzLmlzQ3J1ZnQ7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgVVJJIGVtYmVkZGVkIHdpdGhpbiB0aGUgU3RhdGVtZW50LCBpbiB0aGUgY2FzZVxuXHRcdCAqIHdoZW4gdGhlIHN0YXRlbWVudCBpcyBhIFVSSSBzdGF0ZW1lbnQuXG5cdFx0ICogXG5cdFx0ICogR2V0cyBudWxsIGluIHRoZSBjYXNlIHdoZW4gdGhlIFN0YXRlbWVudCBpcyBub3QgYSBVUklcblx0XHQgKiBzdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0IHVyaSgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5oYXNVcmk7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZiA/XG5cdFx0XHRcdHRoaXMuZGVjbGFyYXRpb25zWzBdLmJvdW5kYXJ5LnN1YmplY3QgYXMgS25vd25VcmkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cHJpdmF0ZSBmbGFncyA9IExpbmVGbGFncy5ub25lO1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgYSBsaXN0IG9mIHRoZSBwYXJzZS1yZWxhdGVkIGZhdWx0cyB0aGF0IHdlcmUgZGV0ZWN0ZWQgb24gdGhpcyBTdGF0ZW1lbnQuICovXG5cdFx0cmVhZG9ubHkgZmF1bHRzOiByZWFkb25seSBGYXVsdFtdO1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRoYXQgY29udGFpbnMgdGhpcyBTdGF0ZW1lbnQuICovXG5cdFx0cmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50O1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgdGhlIGluZGVudCBsZXZlbCBvZiB0aGUgU3RhdGVtZW50LiAqL1xuXHRcdHJlYWRvbmx5IGluZGVudDogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc2V0IG9mIG9iamVjdHMgdGhhdCBhcmUgY29udGFpbmVkIGJ5IHRoaXMgU3RhdGVtZW50LCBcblx0XHQgKiBhbmQgYXJlIG1hcmtlZCBhcyBjcnVmdC4gTm90ZSB0aGF0IHRoZSBvbmx5IFN0YXRlbWVudCBvYmplY3Rcblx0XHQgKiB0aGF0IG1heSBiZSBsb2NhdGVkIGluIHRoaXMgc2V0IGlzIHRoaXMgU3RhdGVtZW50IG9iamVjdCBpdHNlbGYuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgY3J1ZnRPYmplY3RzOiBSZWFkb25seVNldDxTdGF0ZW1lbnQgfCBTcGFuIHwgSW5maXhTcGFuPjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBsaW5lIG51bWJlciBvZiB0aGlzIHN0YXRlbWVudCBpbiBpdCdzIGNvbnRhaW5pbmdcblx0XHQgKiBkb2N1bWVudCwgb3IgLTEgaWYgdGhlIHN0YXRlbWVudCBpcyBkaXNwb3NlZCBhbmQvb3IgaXMgbm90XG5cdFx0ICogaW4gdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGdldCBsaW5lKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pc0Rpc3Bvc2VkKVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQgP1xuXHRcdFx0XHR0aGlzLmRvY3VtZW50LmxpbmVOdW1iZXJPZih0aGlzKSA6XG5cdFx0XHRcdC0xO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IG9mIHNwYW5zIGluIHRoYXQgcmVwcmVzZW50IHRoZSBkZWNsYXJhdGlvbnNcblx0XHQgKiBvZiB0aGlzIHN0YXRlbWVudCwgZXhjbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZFxuXHRcdCAqIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRnZXQgZGVjbGFyYXRpb25zKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jcnVmdE9iamVjdHMuc2l6ZSA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWxsRGVjbGFyYXRpb25zO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBvdXQ6IFNwYW5bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgdGhpcy5hbGxEZWNsYXJhdGlvbnMpXG5cdFx0XHRcdGlmICghdGhpcy5jcnVmdE9iamVjdHMuaGFzKHNwYW4pKVxuXHRcdFx0XHRcdG91dC5wdXNoKHNwYW4pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHNwYW5zIHRoYXQgcmVwcmVzZW50IHRoZSBkZWNsYXJhdGlvbnNcblx0XHQgKiBvZiB0aGlzIHN0YXRlbWVudCwgaW5jbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZFxuXHRcdCAqIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBhbGxEZWNsYXJhdGlvbnM6IHJlYWRvbmx5IFNwYW5bXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgbGlzdCBvZiBhbGwgaW5maXhlcyBkZWZpbmVkIGluIHRoZSBwYXR0ZXJuIG9mIHRoaXMgc3RhdGVtZW50LlxuXHRcdCAqL1xuXHRcdGdldCBpbmZpeFNwYW5zKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW5maXhTcGFucztcblx0XHR9XG5cdFx0cHJpdmF0ZSBfaW5maXhTcGFuczogcmVhZG9ubHkgSW5maXhTcGFuW10gPSBPYmplY3QuZnJlZXplKFtdKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IG9mIHNwYW5zIGluIHRoYXQgcmVwcmVzZW50IHRoZSBhbm5vdGF0aW9uc1xuXHRcdCAqIG9mIHRoaXMgc3RhdGVtZW50LCBmcm9tIGxlZnQgdG8gcmlnaHQsIGV4Y2x1ZGluZyB0aG9zZSB0aGF0XG5cdFx0ICogaGF2ZSBiZWVuIG1hcmtlZCBhcyBvYmplY3QtbGV2ZWwgY3J1ZnQuXG5cdFx0ICovXG5cdFx0Z2V0IGFubm90YXRpb25zKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jcnVmdE9iamVjdHMuc2l6ZSA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWxsQW5ub3RhdGlvbnM7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dDogU3BhbltdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbEFubm90YXRpb25zKVxuXHRcdFx0XHRpZiAoIXRoaXMuY3J1ZnRPYmplY3RzLmhhcyhzcGFuKSlcblx0XHRcdFx0XHRvdXQucHVzaChzcGFuKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob3V0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBhcnJheSBvZiBzcGFucyB0aGF0IHJlcHJlc2VudCB0aGUgYW5ub3RhdGlvbnNcblx0XHQgKiBvZiB0aGlzIHN0YXRlbWVudCwgaW5jbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZFxuXHRcdCAqIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBhbGxBbm5vdGF0aW9uczogcmVhZG9ubHkgU3BhbltdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgb2Ygc3BhbnMgaW4gdGhhdCByZXByZXNlbnQgYm90aCB0aGUgZGVjbGFyYXRpb25zXG5cdFx0ICogYW5kIHRoZSBhbm5vdGF0aW9ucyBvZiB0aGlzIHN0YXRlbWVudCwgZXhjbHVkaW5nIHRob3NlIHRoYXQgaGF2ZVxuXHRcdCAqIGJlZW4gbWFya2VkIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRnZXQgc3BhbnMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmlzQ3J1ZnQgP1xuXHRcdFx0XHRbXSA6XG5cdFx0XHRcdHRoaXMuZGVjbGFyYXRpb25zLmNvbmNhdCh0aGlzLmFubm90YXRpb25zKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0IGFsbFNwYW5zKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnMuY29uY2F0KHRoaXMuYW5ub3RhdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBqb2ludCBvcGVyYXRvciBleGlzdHNcblx0XHQgKiBpbiB0aGUgc3RhdGVtZW50LiBBIG5lZ2F0aXZlIG51bWJlciBpbmRpY2F0ZXMgdGhhdFxuXHRcdCAqIHRoZSBqb2ludCBvcGVyYXRvciBkb2VzIG5vdCBleGlzdCBpbiB0aGUgc3RhdGVtZW50LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGpvaW50UG9zaXRpb246IG51bWJlcjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHVucHJvY2Vzc2VkIHRleHQgY29udGVudCBvZiB0aGUgc3RhdGVtZW50LCBcblx0XHQgKiBhcyBpdCBhcHBlYXJzIGluIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzb3VyY2VUZXh0OiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBzdGF0ZW1lbnQncyB0ZXh0dWFsICpzdW0qLCB3aGljaCBpcyB0aGVcblx0XHQgKiByYXcgdGV4dCBvZiB0aGUgc3RhdGVtZW50J3MgYW5ub3RhdGlvbnMsIHdpdGggd2hpdGVzcGFjZVxuXHRcdCAqIHRyaW1tZWQuIFRoZSBzdW0gaXMgc3VpdGFibGUgYXMgYW4gaW5wdXQgdG8gYSB0b3RhbFxuXHRcdCAqIHBhdHRlcm4uXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgc3VtOiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGVcblx0XHQgKiBzdGF0ZW1lbnQgY29udGFpbnMgYSBkZWNsYXJhdGlvbiBvZiBhIHBhdHRlcm4uXG5cdFx0ICovXG5cdFx0Z2V0IGhhc1BhdHRlcm4oKVxuXHRcdHtcblx0XHRcdGNvbnN0IGQgPSB0aGlzLmFsbERlY2xhcmF0aW9ucztcblx0XHRcdHJldHVybiBkLmxlbmd0aCA9PT0gMSAmJiBkWzBdLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBNYXJrcyB0aGUgc3RhdGVtZW50IGFzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdCdzIGNvbnRhaW5pbmcgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0ZGlzcG9zZSgpXG5cdFx0e1xuXHRcdFx0dGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBMaW5lRmxhZ3MuaXNEaXNwb3NlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGtpbmQgb2YgU3RhdGVtZW50Wm9uZSB0aGF0IGV4aXN0c1xuXHRcdCAqIGF0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgb2Zmc2V0IHdpdGhpbiB0aGUgU3RhdGVtZW50LlxuXHRcdCAqL1xuXHRcdGdldFpvbmUob2Zmc2V0OiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaXNDb21tZW50IHx8IG9mZnNldCA8IHRoaXMuaW5kZW50IHx8IHRoaXMuaXNDcnVmdClcblx0XHRcdFx0cmV0dXJuIFN0YXRlbWVudFpvbmUudm9pZDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNXaGl0ZXNwYWNlKVxuXHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50Wm9uZS53aGl0ZXNwYWNlO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNQYXR0ZXJuKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBibmQgPSB0aGlzLmFsbERlY2xhcmF0aW9uc1swXS5ib3VuZGFyeTtcblx0XHRcdFx0aWYgKG9mZnNldCA+PSBibmQub2Zmc2V0U3RhcnQgJiYgb2Zmc2V0IDw9IGJuZC5vZmZzZXRFbmQpXG5cdFx0XHRcdFx0cmV0dXJuIFN0YXRlbWVudFpvbmUucGF0dGVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG9mZnNldCA8PSB0aGlzLmpvaW50UG9zaXRpb24gfHwgdGhpcy5qb2ludFBvc2l0aW9uIDwgMClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuYWxsRGVjbGFyYXRpb25zKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYm5kID0gc3Bhbi5ib3VuZGFyeTtcblx0XHRcdFx0XHRpZiAob2Zmc2V0ID49IGJuZC5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gYm5kLm9mZnNldEVuZClcblx0XHRcdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRab25lLmRlY2xhcmF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50Wm9uZS5kZWNsYXJhdGlvblZvaWQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbEFubm90YXRpb25zKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBibmQgPSBzcGFuLmJvdW5kYXJ5O1xuXHRcdFx0XHRpZiAob2Zmc2V0ID49IGJuZC5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gYm5kLm9mZnNldEVuZClcblx0XHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50Wm9uZS5hbm5vdGF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gU3RhdGVtZW50Wm9uZS5hbm5vdGF0aW9uVm9pZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0U3ViamVjdChvZmZzZXQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXREZWNsYXJhdGlvbihvZmZzZXQpIHx8IHRoaXMuZ2V0QW5ub3RhdGlvbihvZmZzZXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHNwYW4gdG8gdGhlIGRlY2xhcmF0aW9uIHN1YmplY3QgYXQgdGhlIFxuXHRcdCAqIHNwZWNpZmllZCBvZmZzZXQsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZSB3YXMgZm91bmQuXG5cdFx0ICovXG5cdFx0Z2V0RGVjbGFyYXRpb24ob2Zmc2V0OiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuZGVjbGFyYXRpb25zKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBibmQgPSBzcGFuLmJvdW5kYXJ5O1xuXHRcdFx0XHRpZiAob2Zmc2V0ID49IGJuZC5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gYm5kLm9mZnNldEVuZClcblx0XHRcdFx0XHRyZXR1cm4gc3Bhbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3BhbiB0byB0aGUgYW5ub3RhdGlvbiBzdWJqZWN0IGF0IHRoZSBcblx0XHQgKiBzcGVjaWZpZWQgb2Zmc2V0LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUgd2FzIGZvdW5kLlxuXHRcdCAqL1xuXHRcdGdldEFubm90YXRpb24ob2Zmc2V0OiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGJuZCA9IHNwYW4uYm91bmRhcnk7XG5cdFx0XHRcdGlmIChvZmZzZXQgPj0gYm5kLm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBibmQub2Zmc2V0RW5kKVxuXHRcdFx0XHRcdHJldHVybiBzcGFuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgaW5uZXIgY29tbWVudCB0ZXh0IG9mXG5cdFx0ICogdGhpcyBzdGF0ZW1lbnQsIGV4Y2x1ZGluZyB0aGUgY29tbWVudCBzeW50YXggdG9rZW4uXG5cdFx0ICogSWYgdGhlIHN0YXRlbWVudCBpc24ndCBhIGNvbW1lbnQsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRnZXRDb21tZW50VGV4dCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNDb21tZW50ID9cblx0XHRcdFx0dGhpcy5zb3VyY2VUZXh0LnNsaWNlKHRoaXMuaW5kZW50ICsgU3ludGF4LmNvbW1lbnQubGVuZ3RoKS50cmltKCkgOlxuXHRcdFx0XHRcIlwiO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGUgc3RhdGVtZW50IHRvIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhpbmNsdWRlSW5kZW50ID0gZmFsc2UpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc2VyaWFsaXplU3BhbnMgPSAoXG5cdFx0XHRcdHNwYW5zOiByZWFkb25seSBTcGFuW10sXG5cdFx0XHRcdGVzY1N0eWxlOiBUZXJtRXNjYXBlS2luZCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHNwYW5zXG5cdFx0XHRcdFx0LmZpbHRlcihzcCA9PiAhKHNwLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBBbm9uKSlcblx0XHRcdFx0XHQubWFwKHNwID0+IFN1YmplY3RTZXJpYWxpemVyLmZvckV4dGVybmFsKHNwLCBlc2NTdHlsZSkpXG5cdFx0XHRcdFx0LmpvaW4oU3ludGF4LmNvbWJpbmF0b3IgKyBTeW50YXguc3BhY2UpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5kZW50ID0gaW5jbHVkZUluZGVudCA/IFN5bnRheC50YWIucmVwZWF0KHRoaXMuaW5kZW50KSA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzQ3J1ZnQpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQgKyBcIihjcnVmdClcIjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNXaGl0ZXNwYWNlKVxuXHRcdFx0XHRyZXR1cm4gaW5kZW50O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc1ZhY3VvdXMpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQgKyBTeW50YXguam9pbnQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlY2xzID0gc2VyaWFsaXplU3BhbnModGhpcy5hbGxEZWNsYXJhdGlvbnMsIFRlcm1Fc2NhcGVLaW5kLmRlY2xhcmF0aW9uKTtcblx0XHRcdGNvbnN0IGFubm9zID0gc2VyaWFsaXplU3BhbnModGhpcy5hbGxBbm5vdGF0aW9ucywgVGVybUVzY2FwZUtpbmQuYW5ub3RhdGlvbik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGpvaW50ID0gYW5ub3MubGVuZ3RoID4gMCB8fCB0aGlzLmlzUmVmcmVzaCA/IFN5bnRheC5qb2ludCA6IFwiXCI7XG5cdFx0XHRjb25zdCBqb2ludEwgPSBkZWNscy5sZW5ndGggPiAwICYmIGpvaW50ICE9PSBcIlwiID8gU3ludGF4LnNwYWNlIDogXCJcIjtcblx0XHRcdGNvbnN0IGpvaW50UiA9IGFubm9zLmxlbmd0aCA+IDAgPyBTeW50YXguc3BhY2UgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gaW5kZW50ICsgZGVjbHMgKyBqb2ludEwgKyBqb2ludCArIGpvaW50UiArIGFubm9zO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIGFyZWFzIG9mIGEgc3RhdGVtZW50IHRoYXQgYXJlIHNpZ25pZmljYW50bHlcblx0ICogZGlmZmVyZW50IHdoZW4gcGVyZm9ybWluZyBpbnNwZWN0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGVudW0gU3RhdGVtZW50Wm9uZVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogUmVmZXJzIHRvIHRoZSBhcmVhIHdpdGhpbiBhIGNvbW1lbnQgc3RhdGVtZW50LFxuXHRcdCAqIG9yIHRoZSB3aGl0ZXNwYWNlIHByZWNlZWRpbmcgYSBub24tbm8tb3AuXG5cdFx0ICovXG5cdFx0dm9pZCxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWZlcnMgdG8gdGhlIGFyZWEgaW4gdGhlIGluZGVudGF0aW9uIGFyZWEuXG5cdFx0ICovXG5cdFx0d2hpdGVzcGFjZSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWZlcnMgdG8gdGhlIFxuXHRcdCAqL1xuXHRcdHBhdHRlcm4sXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZGVjbGFyYXRpb24sXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YW5ub3RhdGlvbixcblx0XHRcblx0XHQvKiogKi9cblx0XHRkZWNsYXJhdGlvblZvaWQsXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YW5ub3RhdGlvblZvaWRcblx0fVxuXHRcblx0LyoqXG5cdCAqIFlpZWxkcyBmYXVsdHMgb24gaW5maXggc3BhbnMgaW4gdGhlIGNhc2Ugd2hlbiBhIHRlcm1cblx0ICogZXhpc3RzIG11bHRpcGxlIHRpbWVzIHdpdGhpbiB0aGUgc2FtZSBpbmZpeC5cblx0ICovXG5cdGZ1bmN0aW9uICpub3JtYWxpemVJbmZpeFNwYW5zKHNpZGU6IEluZml4U3BhbltdKVxuXHR7XG5cdFx0aWYgKHNpZGUubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdFxuXHRcdGNvbnN0IHN1YmplY3RzID0gbmV3IFNldDxTdWJqZWN0PigpO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgbmZ4U3BhbiBvZiBzaWRlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN1YiA9IG5meFNwYW4uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdGlmIChzdWJqZWN0cy5oYXMoc3ViKSlcblx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5JbmZpeEhhc0R1cGxpY2F0ZVRlcm0sIG5meFNwYW4pO1xuXHRcdFx0XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHN1YmplY3RzLmFkZChzdWIpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFlpZWxkcyBmYXVsdHMgb24gaW5maXggc3BhbnMgaW4gdGhlIGNhc2Ugd2hlbiBhIHRlcm1cblx0ICogaGFzIGJlZW4gcmUtZGVjbGFyZWQgbXVsdGlwbGUgdGltZXMgYWNyb3NzIHRoZSBpbmZpeGVzLlxuXHQgKiBcblx0ICogWWllbGRzIGluZml4ZXMgdGhhdCBoYXZlIHRlcm1zIHRoYXQgZXhpc3QgbXVsdGlwbGUgdGltZXNcblx0ICogd2l0aGluIHRoZSBzYW1lIHN0YXRlbWVudC5cblx0ICovXG5cdGZ1bmN0aW9uICplYWNoUmVwZWF0ZWRJbmZpeChcblx0XHRzcGFuOiBTcGFuLFxuXHRcdGluZml4Rm46IChuZng6IEluZml4KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPEluZml4U3Bhbj4pXG5cdHtcblx0XHRjb25zdCBzdWJqZWN0cyA9IG5ldyBTZXQ8U3ViamVjdD4oKTtcblx0XHRcdFxuXHRcdGZvciAoY29uc3QgaW5maXggb2Ygc3Bhbi5pbmZpeGVzKVxuXHRcdHtcblx0XHRcdGNvbnN0IGluZml4U3BhbnMgPSBBcnJheS5mcm9tKGluZml4Rm4oaW5maXgpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgaW5maXhTcGFucylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3ViID0gaW5maXhTcGFuLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3ViamVjdHMuaGFzKHN1YikpXG5cdFx0XHRcdFx0eWllbGQgaW5maXhTcGFuO1xuXHRcdFx0XHRcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHN1YmplY3RzLmFkZChzdWIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFBlcmZvcm1zIGEgcXVpY2sgYW5kIGRpcnR5IGNoZWNrIHRvIHNlZSBpZiB0aGUgaW5maXggaXMgcmVmZXJlbmNpbmdcblx0ICogYSBsaXN0LCBieSBsb29raW5nIHRvIHNlZSBpZiBpdCBoYXMgdGhlIGxpc3Qgb3BlcmF0b3IuIEEgZnVsbCBjaGVjayBuZWVkc1xuXHQgKiB0byBwZXJmb3JtIHR5cGUgaW5zcGVjdGlvbiB0byBzZWUgaWYgYW55IG9mIHRoZSB0eXBlcyB0aGF0IGNvcnJlc3BvbmRcblx0ICogdG8gdGhlIHRlcm1zIHNwZWNpZmllZCBhcmUgYWN0dWFsbHkgbGlzdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiAqZXhwZWRpZW50TGlzdENoZWNrKHNpZGU6IEluZml4U3BhbltdKVxuXHR7XG5cdFx0aWYgKHNpZGUubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgbmZ4U3BhbiBvZiBzaWRlKVxuXHRcdFx0aWYgKG5meFNwYW4uYm91bmRhcnkuc3ViamVjdC5pc0xpc3QpXG5cdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuSW5maXhVc2luZ0xpc3RPcGVyYXRvciwgbmZ4U3Bhbik7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQYXR0ZXJuXG5cdHtcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSB1bml0czogcmVhZG9ubHkgKFJlZ2V4VW5pdCB8IEluZml4KVtdLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGUgcGF0dGVybiBpcyBjb25zaWRlcmVkIHRvIGJlIFwiVG90YWxcIlxuXHRcdFx0ICogb3IgXCJQYXJ0aWFsXCIuIFRvdGFsIHBhdHRlcm5zIG11c3QgbWF0Y2ggYW4gZW50aXJlIGFubm90YXRpb25cblx0XHRcdCAqIHNldCAodGhlIGVudGlyZSBzdHJpcCBvZiBjb250ZW50IHRvIHRoZSByaWdodCBvZiBhIGpvaW50LCBhZnRlclxuXHRcdFx0ICogYmVpbmcgdHJpbW1lZCkuIFBhcnRpYWwgcGF0dGVybnMgbWF0Y2ggaW5kaXZpZHVhbGx5IFxuXHRcdFx0ICogc3BlY2lmaWVkIHN1YmplY3RzIChzZXBhcmF0ZWQgYnkgY29tbWFzKS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgaXNUb3RhbDogYm9vbGVhbixcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIGEgaGFzaCB3aGljaCBpcyBjb21wdXRlZCBmcm9tIHRoZSBzZXQgb2Zcblx0XHRcdCAqIGFubm90YXRpb25zIHNwZWNpZmllZCB0byB0aGUgcmlnaHQgb2YgdGhlIHBhdHRlcm4uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGhhc2g6IHN0cmluZylcblx0XHR7XG5cdFx0XHR0aGlzLmNvbXBpbGVkUmVnRXhwID0gUGF0dGVyblByZWNvbXBpbGVyLmV4ZWModGhpcyk7XG5cdFx0XHR0aGlzLmlzVmFsaWQgPSB0aGlzLmNvbXBpbGVkUmVnRXhwIGluc3RhbmNlb2YgUmVnRXhwO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGUgaW50ZXJuYWwgcmVndWxhciBleHByZXNzaW9uXG5cdFx0ICogd2FzIGNvbXBpbGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc1ZhbGlkOiBib29sZWFuO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IGVudW1lcmF0ZXMgdGhyb3VnaCB0aGlzIFBhdHRlcm4ncyB1bml0IHN0cnVjdHVyZS5cblx0XHQgKi9cblx0XHQqZWFjaFVuaXQoKVxuXHRcdHtcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlKHVuaXRzOiByZWFkb25seSAoUmVnZXhVbml0IHwgSW5maXgpW10pXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiB1bml0cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpZWxkIHVuaXQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyb3VwKVxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCB1bml0Q2FzZSBvZiB1bml0LmNhc2VzKVxuXHRcdFx0XHRcdFx0XHRyZWN1cnNlKHVuaXRDYXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR5aWVsZCAqcmVjdXJzZSh0aGlzLnVuaXRzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXJcblx0XHQgKiB0aGlzIFBhdHRlcm4gaGFzIGF0IGxlYXN0IG9uZSBpbmZpeCwgb2YgYW55IHR5cGUuXG5cdFx0ICovXG5cdFx0aGFzSW5maXhlcygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudW5pdHMuc29tZSh1ID0+IHUgaW5zdGFuY2VvZiBJbmZpeCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZml4ZXMgb2YgdGhlXG5cdFx0ICogc3BlY2lmaWVkIHR5cGUgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGlzIFBhdHRlcm4uXG5cdFx0ICogSWYgdGhlIGFyZ3VtZW50IGlzIG9taXR0ZWQsIGFsbCBpbmZpeGVzIG9mIGFueSB0eXBlXG5cdFx0ICogZGVmaW5lZCBvbiB0aGlzIFBhdHRlcm4gYXJlIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdGdldEluZml4ZXModHlwZSA9IEluZml4RmxhZ3Mubm9uZSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy51bml0c1xuXHRcdFx0XHQuZmlsdGVyKCh1KTogdSBpcyBJbmZpeCA9PiB1IGluc3RhbmNlb2YgSW5maXgpXG5cdFx0XHRcdC5maWx0ZXIobmZ4ID0+IChuZnguZmxhZ3MgJiB0eXBlKSA9PT0gdHlwZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGFuIFwiZXhwZWRpZW50XCIgdGVzdCB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGVcblx0XHQgKiBzcGVjaWZpZWQgaW5wdXQgaGFzIGEgY2hhbmNlIG9mIGJlaW5nIG1hdGNoZWQgYnkgdGhpcyBwYXR0ZXJuLlxuXHRcdCAqIFRoZSBjaGVjayBpcyBjb25zaWRlcmVkIGV4cGVkaWVudCwgcmF0aGVyIHRoYW4gdGhvcm91Z2gsXG5cdFx0ICogYmVjYXVzZSBhbnkgaW5maXhlcyB0aGF0IGV4aXN0IGluIHRoaXMgcGF0dGVybiBhcmUgcmVwbGFjZWRcblx0XHQgKiB3aXRoIFwiY2F0Y2ggYWxsXCIgcmVndWxhciBleHByZXNzaW9uIHNlcXVlbmNlLCByYXRoZXIgdGhhblxuXHRcdCAqIGVtYmVkZGluZyB0aGUgcGF0dGVybiBhc3NvY2lhdGVkIHdpdGggdGhlIHR5cGUgc3BlY2lmaWVkXG5cdFx0ICogaW4gdGhlIGluZml4LlxuXHRcdCAqL1xuXHRcdHRlc3QoaW5wdXQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCByZWdFeHAgPSB0aGlzLmNvbXBpbGVkUmVnRXhwO1xuXHRcdFx0aWYgKHJlZ0V4cCA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpbnB1dFRyaW1tZWQgPSBpbnB1dC50cmltKCk7XG5cdFx0XHRpZiAoaW5wdXRUcmltbWVkID09PSBcIlwiKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZWdFeHAudGVzdChpbnB1dCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIHRoZSBwYXR0ZXJuIChsaWtlIGEgZnVuY3Rpb24pIHVzaW5nIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBzdHJpbmcgYXMgdGhlIGlucHV0LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgUmVhZG9ubHlNYXAgd2hvc2Uga2V5cyBhbGlnbiB3aXRoIHRoZSBpbmZpeGVzXG5cdFx0ICogY29udGFpbmVkIGluIHRoaXMgUGF0dGVybiwgYW5kIHdob3NlIHZhbHVlcyBhcmUgc3RyaW5ncyB0aGF0XG5cdFx0ICogYXJlIHRoZSBleHRyYWN0ZWQgXCJpbnB1dHNcIiwgZm91bmQgaW4gdGhlIHBsYWNlIG9mIGVhY2ggaW5maXguIFxuXHRcdCAqIElmIHRoaXMgUGF0dGVybiBoYXMgbm8gaW5maXhlcywgYW4gZW1wdHkgbWFwIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdGV4ZWMocGF0dGVyblBhcmFtZXRlcjogc3RyaW5nKTogUmVhZG9ubHlNYXA8SW5maXgsIHN0cmluZz5cblx0XHR7XG5cdFx0XHRjb25zdCByZWdFeHAgPSB0aGlzLmNvbXBpbGVkUmVnRXhwO1xuXHRcdFx0aWYgKHJlZ0V4cCA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIG5ldyBNYXAoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gbmV3IE1hcDxJbmZpeCwgc3RyaW5nPigpO1xuXHRcdFx0Y29uc3QgaW5maXhlcyA9IHRoaXMuZ2V0SW5maXhlcygpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5nZXRJbmZpeGVzKCkubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpbmZpeENhcHR1cmVHcm91cEluZGV4ZXMgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaWR4QXJyYXk6IG51bWJlcltdID0gW107XG5cdFx0XHRcdGxldCBpZHggPSAwO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCB1bml0IG9mIHRoaXMuZWFjaFVuaXQoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICh1bml0IGluc3RhbmNlb2YgSW5maXgpXG5cdFx0XHRcdFx0XHRpZHhBcnJheS5wdXNoKCsraWR4KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JvdXApXG5cdFx0XHRcdFx0XHRpZHgrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8vTWFrZSBzdXJlIHRoZSBhYm92ZSBwcm9kdWNlcyB0aGUgc2FtZSBiZWhhdmlvciBiZWZvcmUgZGVsZXRpbmdcblx0XHRcdFx0Ly8vY29uc3QgcmVjdXJzZVVuaXRzID0gKHVuaXRzOiByZWFkb25seSAoUmVnZXhVbml0IHwgSW5maXg+KVtdKSA9PlxuXHRcdFx0XHQvLy97XG5cdFx0XHRcdC8vL1x0Zm9yIChjb25zdCB1bml0IG9mIHVuaXRzKVxuXHRcdFx0XHQvLy9cdHtcblx0XHRcdFx0Ly8vXHRcdGlmICh1bml0IGluc3RhbmNlb2YgSW5maXgpXG5cdFx0XHRcdC8vL1x0XHR7XG5cdFx0XHRcdC8vL1x0XHRcdGlkeEFycmF5LnB1c2goKytpZHgpO1xuXHRcdFx0XHQvLy9cdFx0fVxuXHRcdFx0XHQvLy9cdFx0ZWxzZSBpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JvdXApXG5cdFx0XHRcdC8vL1x0XHR7XG5cdFx0XHRcdC8vL1x0XHRcdCsraWR4O1xuXHRcdFx0XHQvLy9cdFx0XHRmb3IgKGNvbnN0IHVuaXRDYXNlIG9mIHVuaXQuY2FzZXMpXG5cdFx0XHRcdC8vL1x0XHRcdFx0cmVjdXJzZVVuaXRzKHVuaXRDYXNlKTtcblx0XHRcdFx0Ly8vXHRcdH1cblx0XHRcdFx0Ly8vXHR9XG5cdFx0XHRcdC8vL31cblx0XHRcdFx0Ly8vcmVjdXJzZVVuaXRzKHRoaXMudW5pdHMpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGlkeEFycmF5O1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVnID0gbmV3IFJlZ0V4cChyZWdFeHAuc291cmNlLCByZWdFeHAuZmxhZ3MpO1xuXHRcdFx0Y29uc3QgbWF0Y2hlcyA9IHJlZy5leGVjKHBhdHRlcm5QYXJhbWV0ZXIpO1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2hlcyA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbaWR4LCBpbmZpeF0gb2YgaW5maXhlcy5lbnRyaWVzKCkpXG5cdFx0XHRcdHJlc3VsdC5zZXQoaW5maXgsIG1hdGNoZXNbaW5maXhDYXB0dXJlR3JvdXBJbmRleGVzW2lkeF1dKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjb21waWxlZFJlZ0V4cDogUmVnRXhwIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydHMgdGhpcyBQYXR0ZXJuIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuXHRcdCAqIChOb3RlIHRoYXQgdGhlIHNlcmlhbGl6ZWQgcGF0dGVybiBjYW5ub3QgYmUgdXNlZFxuXHRcdCAqIGFzIGEgcGFyYW1ldGVyIHRvIGEgSmF2YVNjcmlwdCBSZWdFeHAgb2JqZWN0Lilcblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5jbHVkZUhhc2hQcmVmaXggSWYgdHJ1ZSwgdGhlIFBhdHRlcm4ncyBoYXNoXG5cdFx0ICogcHJlZml4IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBzZXJpYWxpemVkIHJlc3VsdC5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhpbmNsdWRlSGFzaFByZWZpeD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3QgcHJlZml4ID0gaW5jbHVkZUhhc2hQcmVmaXggPyBlc2NhcGUodGhpcy5oYXNoKSA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlbGltID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbi50b1N0cmluZygpO1xuXHRcdFx0cmV0dXJuIGRlbGltICsgcHJlZml4ICtcblx0XHRcdFx0dGhpcy51bml0cy5tYXAodSA9PiB1LnRvU3RyaW5nKCkpLmpvaW4oXCJcIikgKyBcblx0XHRcdFx0KHRoaXMuaXNUb3RhbCA/IGRlbGltIDogXCJcIik7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIFBhdHRlcm5QcmVjb21waWxlclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQ29tcGlsZXMgdGhlIHNwZWNpZmllZCBwYXR0ZXJuIGludG8gYSBKUy1uYXRpdmVcblx0XHQgKiBSZWdFeHAgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSByZWd1bGFyXG5cdFx0ICogZXhwcmVzc2lvbiBwcmUtbWF0Y2hpbmcgKGkuZS4gY2hlY2tzIHRoYXQgZXNzZW50aWFsbHlcblx0XHQgKiBpZ25vcmUgYW55IGluZml4ZXMgdGhhdCB0aGUgcGF0dGVybiBtYXkgaGF2ZSkuXG5cdFx0ICovXG5cdFx0c3RhdGljIGV4ZWMocGF0dGVybjogUGF0dGVybilcblx0XHR7XG5cdFx0XHRjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiBwYXR0ZXJuLnVuaXRzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JhcGhlbWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAobXVzdEVzY2FwZUNoYXJzLmluY2x1ZGVzKHVuaXQuZ3JhcGhlbWUpKVxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goU3ludGF4LmVzY2FwZUNoYXIgKyB1bml0LmdyYXBoZW1lKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCh1bml0LmdyYXBoZW1lKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodW5pdC5xdWFudGlmaWVyKVxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2godW5pdC5xdWFudGlmaWVyLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHVuaXQgaW5zdGFuY2VvZiBJbmZpeClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGV4cGVkaWVudEluZml4UGF0dGVybik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2godW5pdC50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXN1bHQudW5zaGlmdChcIl5cIik7XG5cdFx0XHRyZXN1bHQucHVzaChcIiRcIik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlZ1RleHQgPSByZXN1bHQuam9pbihcIlwiKTtcblx0XHRcdFxuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKHJlZ1RleHQsIFwidVwiKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIGxpc3Qgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZFxuXHQgKiBpbiBvcmRlciBmb3IgdGhlIFRydXRoIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGF2b3IgdG9cblx0ICogYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBlbmdpbmUgYnVpbGQgaW50byBKYXZhU2NyaXB0LlxuXHQgKi9cblx0Y29uc3QgbXVzdEVzY2FwZUNoYXJzID0gW1wiJFwiLCBcIl5cIiwgXCJ7XCIsIFwifVwiXTtcblx0XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHBhdHRlcm4gdGhhdCBpcyBmZWQgaW50byBhIHBhdHRlcm4gaW5cblx0ICogcGxhY2Ugb2Ygd2hlcmUgaW5maXhlcyBhcmUsIGluIG9yZGVyIHRvIGJlIGFibGUgdG9cblx0ICogZG8gZWFybHkgdGVzdHMgb24gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRob3V0XG5cdCAqIGRvaW5nIGEgZnVsbCByZXNvbHV0aW9uIG9mIHRoZSB0eXBlcyB0aGF0IHRoZSBpbmZpeGVzXG5cdCAqIHJlZmVyZW5jZS4gVGhlIHBhdHRlcm4gZXNzZW50aWFsbHkgbWVhbnM6XG5cdCAqIFxuXHQgKiBcIk1hdGNoIG9uZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIsIG9yIGEgc2VyaWVzXG5cdCAqIG9mIGNoYXJhY3RlcnMsIHByb3ZpZGVkIHRoYXQgdGhlIHN0cmluZyBvZiBjaGFyYWN0ZXJzXG5cdCAqIGRvbid0IGJlZ2luIG9yIGVuZCB3aXRoIHdoaXRlc3BhY2UuXCJcblx0ICovXG5cdGNvbnN0IGV4cGVkaWVudEluZml4UGF0dGVybiA9IFwiKFxcXFxTKyhcXFxccytcXFxcUyspKilcIjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBbWJpZW50IHVuaWZpZXIgZm9yIGFsbCBQYXR0ZXJuVW5pdCBpbnN0YW5jZXNcblx0ICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWdleFVuaXRcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpIHsgfVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZztcblx0fVxuXHRcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlZ2V4U2V0IGV4dGVuZHMgUmVnZXhVbml0XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGtub3duczogcmVhZG9ubHkgUmVnZXhTeW50YXhLbm93blNldFtdLFxuXHRcdFx0cmVhZG9ubHkgcmFuZ2VzOiByZWFkb25seSBSZWdleENoYXJSYW5nZVtdLFxuXHRcdFx0cmVhZG9ubHkgdW5pY29kZUJsb2NrczogcmVhZG9ubHkgc3RyaW5nW10sXG5cdFx0XHRyZWFkb25seSBzaW5nbGVzOiByZWFkb25seSBzdHJpbmdbXSxcblx0XHRcdHJlYWRvbmx5IGlzTmVnYXRlZDogYm9vbGVhbixcblx0XHRcdHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIocXVhbnRpZmllcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBrTGVuID0gdGhpcy5rbm93bnMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgckxlbiA9IHRoaXMucmFuZ2VzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHVMZW4gPSB0aGlzLnVuaWNvZGVCbG9ja3MubGVuZ3RoO1xuXHRcdFx0Y29uc3QgY0xlbiA9IHRoaXMuc2luZ2xlcy5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNldFRleHQgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGtMZW4gPT09IDEgJiYgckxlbiArIHVMZW4gKyBjTGVuID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmtub3duc1swXS50b1N0cmluZygpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHVMZW4gPT09IDEgJiYga0xlbiArIHJMZW4gKyBjTGVuID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRTdGFydCArIFxuXHRcdFx0XHRcdFx0c2VyaWFsaXplVW5pY29kZUJsb2NrKHRoaXMudW5pY29kZUJsb2Nrc1swXSkgK1xuXHRcdFx0XHRcdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kXG5cdFx0XHRcdFx0XS5qb2luKFwiXCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNMZW4gPT09IDEgJiYga0xlbiArIHJMZW4gKyB1TGVuID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnNpbmdsZXNbMF07XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLnNldFN0YXJ0LFxuXHRcdFx0XHRcdC4uLnRoaXMua25vd25zLFxuXHRcdFx0XHRcdC4uLnRoaXMucmFuZ2VzLm1hcChyID0+IGVzYyhyLmZyb20pICsgXCItXCIgKyBlc2Moci50bykpLFxuXHRcdFx0XHRcdC4uLnRoaXMudW5pY29kZUJsb2Nrcy5tYXAoc2VyaWFsaXplVW5pY29kZUJsb2NrKSxcblx0XHRcdFx0XHQuLi5lc2NNYW55KHRoaXMuc2luZ2xlcyksXG5cdFx0XHRcdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kXG5cdFx0XHRcdF0uam9pbihcIlwiKTtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZXRUZXh0ICsgKHRoaXMucXVhbnRpZmllciA/IHRoaXMucXVhbnRpZmllci50b1N0cmluZygpIDogXCJcIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXHRcdHRvQWxwaGFiZXQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGFscGhhYmV0QnVpbGRlciA9IG5ldyBBbHBoYWJldEJ1aWxkZXIoKTtcblx0XHRcdGNvbnN0IGd0ID0gKGNoYXI6IHN0cmluZykgPT4gY2hhci5jaGFyQ29kZUF0KDApICsgMTtcblx0XHRcdGNvbnN0IGx0ID0gKGNoYXI6IHN0cmluZykgPT4gY2hhci5jaGFyQ29kZUF0KDApIC0gMTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBrbm93biBvZiB0aGlzLmtub3ducylcblx0XHRcdHtcblx0XHRcdFx0c3dpdGNoIChrbm93bilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5kaWdpdDpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoXCIwXCIsIFwiOVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5kaWdpdE5vbjpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMCwgbHQoXCIwXCIpKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoZ3QoXCI5XCIpLCBVbmljb2RlTWF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5hbHBoYW51bWVyaWM6XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKFwiMFwiLCBcIjlcIik7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKFwiQVwiLCBcIlpcIik7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKFwiYVwiLCBcInpcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4S25vd25TZXQuYWxwaGFudW1lcmljTm9uOlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgwLCBsdChcIjBcIikpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZChndChcIjlcIiksIGx0KFwiQVwiKSk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKGd0KFwiWlwiKSwgbHQoXCJhXCIpKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoZ3QoXCJ6XCIpLCBVbmljb2RlTWF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC53aGl0ZXNwYWNlOlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg5LCAxMyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDE2MCk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDU3NjApO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MTkyLCA4MjAyKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIzMik7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMzMpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjM5KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODI4Nyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDEyMjg4KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoNjUyNzkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheEtub3duU2V0LndoaXRlc3BhY2VOb246XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDAsIDgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgxNCwgMTU5KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMTYxLCA1NzU5KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoNTc2MSwgODE5MSk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMDMsIDgyMzEpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjMyKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIzMyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMzQsIDgyMzgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjQwLCA4Mjg2KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODI4OCwgMTIyODcpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgxMjI4OSwgNjUyNzgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg2NTI4MCwgVW5pY29kZU1heCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4S25vd25TZXQud2lsZDpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGRXaWxkKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzaW5nbGUgb2YgdGhpcy5zaW5nbGVzKVxuXHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKHNpbmdsZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBhbHBoYWJldEJ1aWxkZXIudG9BbHBoYWJldCh0aGlzLmlzTmVnYXRlZCk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhDaGFyUmFuZ2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgZnJvbTogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgdG86IG51bWJlcilcblx0XHR7IH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlZ2V4R3JvdXAgZXh0ZW5kcyBSZWdleFVuaXRcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgY2FzZXM6IHJlYWRvbmx5IChyZWFkb25seSBSZWdleFVuaXRbXSlbXSxcblx0XHRcdHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIocXVhbnRpZmllcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jYXNlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdGFydCA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwU3RhcnQ7XG5cdFx0XHRjb25zdCBtaWQgPSB0aGlzLmNhc2VzXG5cdFx0XHRcdC5tYXAoY2EgPT4gY2EubWFwKHVuaXQgPT4gZXNjKHVuaXQudG9TdHJpbmcoKSkpLmpvaW4oXCJcIikpXG5cdFx0XHRcdC5qb2luKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBlbmQgPSBSZWdleFN5bnRheERlbGltaXRlci5ncm91cEVuZDtcblx0XHRcdGNvbnN0IHF1YW50ID0gdGhpcy5xdWFudGlmaWVyID8gdGhpcy5xdWFudGlmaWVyLnRvU3RyaW5nKCkgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc3RhcnQgKyBtaWQgKyBlbmQgKyBxdWFudDtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBIHBhdHRlcm4gXCJncmFwaGVtZVwiIGlzIGEgcGF0dGVybiB1bml0IGNsYXNzIHRoYXRcblx0ICogcmVwcmVzZW50czpcblx0ICogXG5cdCAqIGEpIEEgXCJMaXRlcmFsXCIsIHdoaWNoIGlzIGEgc2luZ2xlIHVuaWNvZGUtYXdhcmUgY2hhcmFjdGVyLFxuXHQgKiB3aXRoIHBvc3NpYmxlIHJlcHJlc2VudGF0aW9ucyBiZWluZyBhbiBhc2NpaSBjaGFyYWN0ZXIsXG5cdCAqIGEgdW5pY29kZSBjaGFyYWN0ZXIsIG9yIGFuIGFzY2lpIG9yIHVuaWNvZGUgZXNjYXBlXG5cdCAqIHNlcXVlbmNlLlxuXHQgKiBcblx0ICogb3IgYikgQSBcIlNwZWNpYWxcIiwgd2hpY2ggaXMgYSBzZXF1ZW5jZSB0aGF0IG1hdGNoZXNcblx0ICogc29tZXRoaW5nIG90aGVyIHRoYW4gdGhlIGNoYXJhY3RlciBzcGVjaWZpZWQsXG5cdCAqIHN1Y2ggYXMgLiBcXGIgXFxzXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhHcmFwaGVtZSBleHRlbmRzIFJlZ2V4VW5pdFxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBncmFwaGVtZTogc3RyaW5nLFxuXHRcdFx0cmVhZG9ubHkgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbClcblx0XHR7XG5cdFx0XHRzdXBlcihxdWFudGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHEgPSB0aGlzLnF1YW50aWZpZXI7XG5cdFx0XHRjb25zdCBxRXNjID0gcSA9PT0gbnVsbCA/IFwiXCIgOiBlc2MocS50b1N0cmluZygpKTtcblx0XHRcdGNvbnN0IGcgPSB0aGlzLmdyYXBoZW1lLnRvU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBlc2NhcGFibGVHcmFwaGVtZXMuaW5jbHVkZXMoZykgP1xuXHRcdFx0XHRcIlxcXFxcIiArIGcgKyBxRXNjIDpcblx0XHRcdFx0ZyArIHFFc2M7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKiogKi9cblx0Y29uc3QgZXNjYXBhYmxlR3JhcGhlbWVzOiBzdHJpbmdbXSA9IFtcblx0XHRSZWdleFN5bnRheE1pc2Muc3Rhcixcblx0XHRSZWdleFN5bnRheE1pc2MucGx1cyxcblx0XHRSZWdleFN5bnRheE1pc2MubmVnYXRlLFxuXHRcdFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkLFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwU3RhcnQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBFbmQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuYWx0ZXJuYXRvcixcblx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRTdGFydCxcblx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRFbmQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclN0YXJ0LFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJFbmRcblx0XTtcblx0XG5cdC8qKlxuXHQgKiBBIFJlZ2V4IFwiU2lnblwiIHJlZmVycyB0byBhbiBlc2NhcGUgc2VxdWVuY2UgdGhhdCByZWZlcnNcblx0ICogdG8gb25lIG90aGVyIGNoYXJhY3RlciwgYXMgb3Bwb3NlZCB0byB0aGF0IGNoYXJhY3RlclxuXHQgKiBiZWluZyB3cml0dGVuIGRpcmVjdGx5IGluIHRoZSBwYXJzZSBzdHJlYW0uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhTaWduIGV4dGVuZHMgUmVnZXhVbml0XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHNpZ246IFJlZ2V4U3ludGF4U2lnbixcblx0XHRcdHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIocXVhbnRpZmllcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBxID0gdGhpcy5xdWFudGlmaWVyO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2lnbi50b1N0cmluZygpICsgKHEgPT09IG51bGwgPyBcIlwiIDogZXNjKHEudG9TdHJpbmcoKSkpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEEgcGF0dGVybiB1bml0IGNsYXNzIHRoYXQgcmVwcmVzZW50cyArLCAqLCBcblx0ICogYW5kIGV4cGxpY2l0IHF1YW50aWZpZXJzIHN1Y2ggYXMgezEsMn0uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhRdWFudGlmaWVyXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBsb3dlciBib3VuZCBvZiB0aGUgcXVhbnRpZmllciwgXG5cdFx0XHQgKiBvciB0aGUgZmV3ZXN0IG51bWJlciBvZiBncmFwaGVtZXMgdG8gYmUgbWF0Y2hlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgbWluOiBudW1iZXIgPSAwLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBxdWFudGlmaWVyLCBcblx0XHRcdCAqIG9yIHRoZSBtb3N0IG51bWJlciBvZiBncmFwaGVtZXMgdG8gYmUgbWF0Y2hlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgbWF4OiBudW1iZXIgPSBJbmZpbml0eSxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhlIHRoZSBxdWFudGlmaWVyIGlzIHJlc3RyYWluZWQsXG5cdFx0XHQgKiBpbiB0aGF0IGl0IG1hdGNoZXMgdGhlIGZld2VzdCBwb3NzaWJsZSBudW1iZXJcblx0XHRcdCAqIG9mIGNoYXJhY3RlcnMuXG5cdFx0XHQgKiBcblx0XHRcdCAqIChTb21lIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGF2b3VycyBhd2t3YXJkbHlcblx0XHRcdCAqIHJlZmVyIHRvIHRoaXMgYXMgXCJub24tZ3JlZWR5XCIuKVxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSByZXN0cmFpbmVkOiBib29sZWFuKVxuXHRcdHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoZSByZWdleCBxdWFudGlmaWVyIHRvIGFuIG9wdGltaXplZCBzdHJpbmcuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJzdCA9IHRoaXMucmVzdHJhaW5lZCA/IFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkIDogXCJcIjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubWluID09PSAwICYmIHRoaXMubWF4ID09PSBJbmZpbml0eSlcblx0XHRcdFx0cmV0dXJuIFJlZ2V4U3ludGF4TWlzYy5zdGFyICsgcnN0O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5taW4gPT09IDEgJiYgdGhpcy5tYXggPT09IEluZmluaXR5KVxuXHRcdFx0XHRyZXR1cm4gUmVnZXhTeW50YXhNaXNjLnBsdXMgKyByc3Q7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLm1pbiA9PT0gMCAmJiB0aGlzLm1heCA9PT0gMSlcblx0XHRcdFx0cmV0dXJuIFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBxcyA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJTdGFydDtcblx0XHRcdGNvbnN0IHFwID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclNlcGFyYXRvcjtcblx0XHRcdGNvbnN0IHFlID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllckVuZDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMubWluID09PSB0aGlzLm1heCA/XG5cdFx0XHRcdHFzICsgdGhpcy5taW4gKyBxZSA6XG5cdFx0XHRcdHFzICsgdGhpcy5taW4gKyBxcCArICh0aGlzLm1heCA9PT0gSW5maW5pdHkgPyBcIlwiIDogdGhpcy5tYXgudG9TdHJpbmcoKSkgKyBxZTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRvdWJsZSBlc2NhcGVcblx0ICogaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGJhY2tzbGFzaC5cblx0ICovXG5cdGZ1bmN0aW9uIGVzYyhtYXliZUJhY2tzbGFzaDogc3RyaW5nIHwgbnVtYmVyKVxuXHR7XG5cdFx0aWYgKG1heWJlQmFja3NsYXNoID09PSA5MiB8fCBtYXliZUJhY2tzbGFzaCA9PT0gXCJcXFxcXCIpXG5cdFx0XHRyZXR1cm4gXCJcXFxcXFxcXFwiO1xuXHRcdFxuXHRcdGlmICh0eXBlb2YgbWF5YmVCYWNrc2xhc2ggPT09IFwibnVtYmVyXCIpXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobWF5YmVCYWNrc2xhc2gpO1xuXHRcdFxuXHRcdHJldHVybiBtYXliZUJhY2tzbGFzaDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZnVuY3Rpb24gZXNjTWFueShhcnJheTogcmVhZG9ubHkgKHN0cmluZyB8IG51bWJlcilbXSlcblx0e1xuXHRcdHJldHVybiBhcnJheS5tYXAoZXNjKS5qb2luKFwiXCIpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXJpYWxpemVVbmljb2RlQmxvY2soYmxvY2tOYW1lOiBzdHJpbmcpXG5cdHtcblx0XHRjb25zdCBibG9jayA9IFVuaWNvZGVCbG9ja3MuZ2V0KGJsb2NrTmFtZS50b0xvd2VyQ2FzZSgpKTsgXG5cdFx0aWYgKGJsb2NrID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XG5cdFx0Y29uc3Qgcm5nID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIucmFuZ2U7XG5cdFx0Y29uc3QgZnJvbSA9IGJsb2NrWzBdLnRvU3RyaW5nKDE2KTtcblx0XHRjb25zdCB0byA9IGJsb2NrWzFdLnRvU3RyaW5nKDE2KTtcblx0XHRyZXR1cm4gYFxcXFx1eyR7ZnJvbX19JHtybmd9XFxcXHV7JHt0b319YDtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcG9ydGlvbiBvZiB0aGUgY29udGVudCBcblx0ICogd2l0aGluIGFuIEluZml4IHRoYXQgc3BhbnMgYSB0eXBlIHJlZmVyZW5jZS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBJbmZpeFxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgbGVmdC1tb3N0IGNoYXJhY3RlciBwb3NpdGlvbiBvZiB0aGUgSW5maXhcblx0XHRcdCAqIChiZWZvcmUgdGhlIGRlbGltaXRlciksIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIHN0YXRlbWVudC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgb2Zmc2V0U3RhcnQ6IG51bWJlcixcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIGxlZnQtbW9zdCBjaGFyYWN0ZXIgcG9zaXRpb24gb2YgdGhlIEluZml4XG5cdFx0XHQgKiAoYWZ0ZXIgdGhlIGRlbGltaXRlciksIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIHN0YXRlbWVudC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgb2Zmc2V0RW5kOiBudW1iZXIsXG5cdFx0XHRcblx0XHRcdC8qKiBcblx0XHRcdCAqIFN0b3JlcyB0aGUgQm91bmRzIG9iamVjdCB0aGF0IG1hcmtzIG91dCB0aGUgcG9zaXRpb25zXG5cdFx0XHQgKiBvZiB0aGUgdGVybXMgaW4gdGhlIEluZml4IHRoYXQgYXJlIGxvY2F0ZWQgYmVmb3JlXG5cdFx0XHQgKiBhbnkgSm9pbnQgb3BlcmF0b3IuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGxoczogQm91bmRhcnlHcm91cDxUZXJtPixcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIEJvdW5kcyBvYmplY3QgdGhhdCBtYXJrcyBvdXQgdGhlIHBvc2l0aW9uc1xuXHRcdFx0ICogb2YgdGhlIHRlcm1zIGluIHRoZSBJbmZpeCB0aGF0IGFyZSBsb2NhdGVkIGFmdGVyXG5cdFx0XHQgKiBhbnkgSm9pbnQgb3BlcmF0b3IuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHJoczogQm91bmRhcnlHcm91cDxUZXJtPixcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRyZWFkb25seSBmbGFnczogSW5maXhGbGFncylcblx0XHR7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBJbmZpeCBpcyBvZiB0aGUgXCJwYXR0ZXJuXCIgdmFyaWV0eS5cblx0XHQgKi9cblx0XHRnZXQgaXNQYXR0ZXJuKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBJbmZpeEZsYWdzLnBhdHRlcm4pID09PSBJbmZpeEZsYWdzLnBhdHRlcm47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGlzIEluZml4IGlzIG9mIHRoZSBcInBvcnRhYmlsaXR5XCIgdmFyaWV0eS5cblx0XHQgKi9cblx0XHRnZXQgaXNQb3J0YWJpbGl0eSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgSW5maXhGbGFncy5wb3J0YWJpbGl0eSkgPT09IEluZml4RmxhZ3MucG9ydGFiaWxpdHk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGlzIEluZml4IGlzIG9mIHRoZSBcInBvcHVsYXRpb25cIiB2YXJpZXR5LlxuXHRcdCAqL1xuXHRcdGdldCBpc1BvcHVsYXRpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIEluZml4RmxhZ3MucG9wdWxhdGlvbikgPT09IEluZml4RmxhZ3MucG9wdWxhdGlvbjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgSW5maXggaGFzIHRoZSBcIm5vbWluYWxcIiBvcHRpb24gc2V0LlxuXHRcdCAqL1xuXHRcdGdldCBpc05vbWluYWwoKVxuXHRcdHtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIEluZml4RmxhZ3Mubm9taW5hbCkgPT09IEluZml4RmxhZ3Mubm9taW5hbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlbGltTCA9XG5cdFx0XHRcdHRoaXMuaXNQYXR0ZXJuID8gSW5maXhTeW50YXgucGF0dGVyblN0YXJ0IDpcblx0XHRcdFx0dGhpcy5pc05vbWluYWwgPyBJbmZpeFN5bnRheC5ub21pbmFsU3RhcnQgOlxuXHRcdFx0XHR0aGlzLmlzUG9ydGFiaWxpdHkgPyBJbmZpeFN5bnRheC5zdGFydCArIFN5bnRheC5zcGFjZSArIFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSA6XG5cdFx0XHRcdEluZml4U3ludGF4LnN0YXJ0O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkZWxpbVIgPSBcblx0XHRcdFx0dGhpcy5pc1BhdHRlcm4gPyBJbmZpeFN5bnRheC5wYXR0ZXJuRW5kIDpcblx0XHRcdFx0dGhpcy5pc05vbWluYWwgPyBJbmZpeFN5bnRheC5ub21pbmFsRW5kIDpcblx0XHRcdFx0SW5maXhTeW50YXguZW5kO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBqb2luID0gKHNwYW5zOiBCb3VuZGFyeUdyb3VwPFRlcm0+KSA9PlxuXHRcdFx0XHRBcnJheS5mcm9tKHNwYW5zKVxuXHRcdFx0XHRcdC5tYXAoZW50cnkgPT4gZW50cnkuc3ViamVjdClcblx0XHRcdFx0XHQuam9pbihTeW50YXguY29tYmluYXRvciArIFN5bnRheC5zcGFjZSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzUG9ydGFiaWxpdHkpXG5cdFx0XHRcdHJldHVybiBqb2luKHRoaXMucmhzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNQYXR0ZXJuKVxuXHRcdFx0XHRyZXR1cm4gam9pbih0aGlzLmxocyk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGpvaW50ID0gdGhpcy5yaHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdFN5bnRheC5zcGFjZSArIFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSA6XG5cdFx0XHRcdFwiXCI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBkZWxpbUwgKyBqb2luKHRoaXMubGhzKSArIGpvaW50ICsgam9pbih0aGlzLnJocykgKyBkZWxpbVI7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgZW51bSBJbmZpeEZsYWdzXG5cdHtcblx0XHRub25lID0gMCxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgam9pbnQgd2FzIHNwZWNpZmllZCB3aXRoaW5cblx0XHQgKiB0aGUgaW5maXguIENhbiBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgaW5maXhcblx0XHQgKiBjb250YWlucyBzb21lIChlcnJvbmVvdXMpIHN5bnRheCByZXNlbWJpbmdcblx0XHQgKiBhIHJlZnJlc2ggdHlwZSwgZWcgLSAvPFR5cGUgOiA+L1xuXHRcdCAqL1xuXHRcdGhhc0pvaW50ID0gMSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgPC9QYXR0ZXJuLz4gc3ludGF4IHdhc1xuXHRcdCAqIHVzZWQgdG8gZW1iZWQgdGhlIHBhdHRlcm5zIGFzc29jaWF0ZWRcblx0XHQgKiB3aXRoIGEgc3BlY2lmaWVkIHR5cGUuXG5cdFx0ICovXG5cdFx0cGF0dGVybiA9IDIsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgdGhlIGluZml4IGlzIG9mIHRoZSBcInBvcnRhYmlpdHlcIlxuXHRcdCAqIHZhcmlldHksIHVzaW5nIHRoZSBzeW50YXggPCA6IFR5cGU+XG5cdFx0ICovXG5cdFx0cG9ydGFiaWxpdHkgPSA0LFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IHRoZSBpbmZpeCBpcyBvZiB0aGUgXCJwb3B1YXRpb25cIlxuXHRcdCAqIHZhcmlldHksIHVzaW5nIHRoZSBzeW50YXggPERlY2xhcmF0aW9uIDogQW5ub3RhdGlvbj5cblx0XHQgKiBvciA8RGVjbGFyYXRpb24+XG5cdFx0ICovXG5cdFx0cG9wdWxhdGlvbiA9IDgsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgdGhlIDw8RG91YmxlPj4gYW5nbGUgYnJhY2tldFxuXHRcdCAqIHN5bnRheCB3YXMgdXNlZCB0byBvbmx5IG1hdGNoIG5hbWVkIHR5cGVzLFxuXHRcdCAqIHJhdGhlciB0aGFuIGFsaWFzZXMuXG5cdFx0ICovXG5cdFx0bm9taW5hbCA9IDE2XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIGEgc3RhdGVtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFNwYW5cblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIExvZ2ljYWwgY2xvY2sgdmFsdWUgdXNlZCB0byBtYWtlIGNocm9ub2xvZ2ljYWwgXG5cdFx0ICogY3JlYXRpb24tdGltZSBjb21wYXJpc29ucyBiZXR3ZWVuIFNwYW5zLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHN0YW1wID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBTdGF0ZW1lbnQgdGhhdCBjb250YWlucyB0aGlzIFNwYW4uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHN0YXRlbWVudDogU3RhdGVtZW50LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgc3ViamVjdCwgYW5kIHRoZSBsb2NhdGlvbiBvZiBpdCBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGJvdW5kYXJ5OiBCb3VuZGFyeTxTdWJqZWN0Pilcblx0XHR7XG5cdFx0XHR0aGlzLm5hbWUgPSBcblx0XHRcdFx0U3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwoYm91bmRhcnkpICsgXG5cdFx0XHRcdGAgKCR7Ym91bmRhcnkub2Zmc2V0U3RhcnR9LCAke2JvdW5kYXJ5Lm9mZnNldEVuZH0pYDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogU3RvcmVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgU3BhbiwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBuYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgSW5maXhlcyBzdG9yZWQgd2l0aGluIHRoaXMgU3BhbiwgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdCAqIHRoZSBTcGFuIGNvcnJlc3BvbmRzIHRvIGEgUGF0dGVybi4gSW4gb3RoZXIgY2FzZXMsIGFuZFxuXHRcdCAqIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdGdldCBpbmZpeGVzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW5maXhlcyB8fCAodGhpcy5faW5maXhlcyA9IE9iamVjdC5mcmVlemUoKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuID9cblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuYm91bmRhcnkuc3ViamVjdC5nZXRJbmZpeGVzKCkpIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH0pKCkpKTtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfaW5maXhlczogcmVhZG9ubHkgSW5maXhbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoRGVjbGFyYXRpb25Gb3JJbmZpeChpbmZpeDogSW5maXgpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLmluZml4ZXMuaW5jbHVkZXMoaW5maXgpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZENhbGwoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgeyBsaHMgfSA9IHRoaXMucXVlcnlJbmZpeFNwYW5UYWJsZShpbmZpeCk7XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiBsaHMpXG5cdFx0XHRcdHlpZWxkIGluZml4U3Bhbjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVhY2hBbm5vdGF0aW9uRm9ySW5maXgoaW5maXg6IEluZml4KVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5pbmZpeGVzLmluY2x1ZGVzKGluZml4KSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRDYWxsKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHsgcmhzIH0gPSB0aGlzLnF1ZXJ5SW5maXhTcGFuVGFibGUoaW5maXgpO1xuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgcmhzKVxuXHRcdFx0XHR5aWVsZCBpbmZpeFNwYW47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcXVlcnlJbmZpeFNwYW5UYWJsZShpbmZpeDogSW5maXgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5maXhTcGFuVGFibGUuZ2V0KGluZml4KSB8fCAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbGhzOiBJbmZpeFNwYW5bXSA9IFtdO1xuXHRcdFx0XHRjb25zdCByaHM6IEluZml4U3BhbltdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGJvdW5kYXJ5IG9mIGluZml4Lmxocylcblx0XHRcdFx0XHRsaHMucHVzaChuZXcgSW5maXhTcGFuKHRoaXMsIGluZml4LCBib3VuZGFyeSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBib3VuZGFyeSBvZiBpbmZpeC5yaHMpXG5cdFx0XHRcdFx0cmhzLnB1c2gobmV3IEluZml4U3Bhbih0aGlzLCBpbmZpeCwgYm91bmRhcnkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7IGxocywgcmhzIH07XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGluZml4U3BhblRhYmxlID0gbmV3IE1hcDxJbmZpeCwgeyBsaHM6IEluZml4U3BhbltdOyByaHM6IEluZml4U3BhbltdIH0+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHRoYXQgcmVwcmVzZW50IHRoZSBzdGF0ZW1lbnRcblx0XHQgKiBjb250YWlubWVudCBwcm9ncmVzc2lvbiwgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgY29udGFpbmluZ1xuXHRcdCAqIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGdldCBhbmNlc3RyeSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2FuY2VzdHJ5KVxuXHRcdFx0XHRpZiAodGhpcy5fYW5jZXN0cnkuZXZlcnkoc210ID0+ICFzbXQuaXNEaXNwb3NlZCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FuY2VzdHJ5O1xuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgYW5jZXN0cnkgaGFzIG5vIHlldCBiZWVuIGNvbXB1dGVkLCBvciBpdCBoYXMsIGJ1dCBhdCBsZWFzdCBvZlxuXHRcdFx0Ly8gaXQncyBzdGF0ZW1lbnRzIGhhdmUgYmVlbiBkaXNwb3NlZCwgdGhlbiBpdCBtdXN0IGJlIHJlY29tcHV0ZWQuXG5cdFx0XHR0aGlzLl9hbmNlc3RyeSA9IHRoaXMuc3RhdGVtZW50LmRvY3VtZW50LmdldEFuY2VzdHJ5KHRoaXMuc3RhdGVtZW50KTtcblx0XHRcdGlmICghdGhpcy5fYW5jZXN0cnkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2FuY2VzdHJ5O1xuXHRcdH1cblx0XHRwcml2YXRlIF9hbmNlc3RyeTogcmVhZG9ubHkgU3RhdGVtZW50W10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTcGxpdHMgYXBhcnQgdGhlIGdyb3VwcyBzdWJqZWN0cyBzcGVjaWZpZWQgaW4gdGhlIGNvbnRhaW5pbmdcblx0XHQgKiBzdGF0ZW1lbnQncyBhbmNlc3RyeSwgYW5kIGdlbmVyYXRlcyBhIHNlcmllcyBvZiBzcGluZXMsIFxuXHRcdCAqIGVhY2ggaW5kaWNhdGluZyBhIHNlcGFyYXRlIHBhdGh3YXkgb2YgZGVjbGFyYXRpb25zIHRocm91Z2hcblx0XHQgKiB0aGUgYW5jZXN0cnkgdGhhdCByZWFjaCB0aGUgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50XG5cdFx0ICogcmVmZXJlbmNlZCBieSB0aGlzIGdsb2JhbCBzcGFuIG9iamVjdC5cblx0XHQgKiBcblx0XHQgKiBUaGUgZ2VuZXJhdGVkIHNwaW5lcyBhcmUgcmVmZXJlbnRpYWxseSBvcGFxdWUuIFJ1bm5pbmcgdGhpc1xuXHRcdCAqIG1ldGhvZCBvbiB0aGUgc2FtZSBTcGFuIG9iamVjdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZVxuXHRcdCAqIFNwaW5lIGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdGZhY3RvcigpOiByZWFkb25seSBTcGluZVtdXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuZmFjdG9yZWRTcGluZXMpXG5cdFx0XHRcdHJldHVybiB0aGlzLmZhY3RvcmVkU3BpbmVzO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc0NydWZ0IHx8IHRoaXMuc3RhdGVtZW50LmlzQ3J1ZnQpXG5cdFx0XHRcdHJldHVybiB0aGlzLmZhY3RvcmVkU3BpbmVzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmFuY2VzdHJ5Lmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXMuZmFjdG9yZWRTcGluZXMgPSBPYmplY3QuZnJlZXplKFtuZXcgU3BpbmUoW3RoaXNdKV0pO1xuXHRcdFx0XG5cdFx0XHQvLyBXZSBuZWVkIHRvIGZhY3RvciB0aGUgYW5jZXN0cnkuIFRoaXMgbWVhbnMgd2UncmUgdGFraW5nIHRoZVxuXHRcdFx0Ly8gc3BlY2lmaWVkIGFuY2VzdHJ5IHBhdGgsIGFuZCBzcGxpdHRpbmcgd2hlcmUgYW55IGhhcy1hIHNpZGUgdW5pb25zXG5cdFx0XHQvLyBleGlzdCwgaW4gZWZmZWN0IGNyZWF0aW5nIGFsbCBwb3NzaWJsZSBwYXRocyB0byB0aGUgc3BlY2lmaWVkIHRpcC5cblx0XHRcdC8vIEl0J3MgcG9zc2libGUgdG8gaGF2ZSBzdGF0ZW1lbnRzIGluIHRoZSBzcGFuIHBhdGggaW4gdGhlIGNhc2Vcblx0XHRcdC8vIHdoZW4gdGhlIHN0YXRlbWVudCBoYXMgYmVlbiBkZWVtZWQgYXMgY3J1ZnQsIGFuZCB0aGVyZWZvcmUsXG5cdFx0XHQvLyBpcyBpbXBvc3NpYmxlIHRvIGV4dHJhY3QgYW55IHNwYW5zIGZyb20gaXQuXG5cdFx0XHRjb25zdCBmYWN0b3JlZFNwYW5QYXRoczogKFNwYW4gfCBTdGF0ZW1lbnQpW11bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBBbiBhcnJheSBvZiBhcnJheXMuIFRoZSBmaXJzdCBkaW1lbnNpb24gY29ycmVzcG9uZHMgdG8gYSBzdGF0ZW1lbnQuIFxuXHRcdFx0Ly8gVGhlIHNlY29uZCBkaW1lbnNpb24gc3RvcmVzIHRoZSBkZWNsYXJhdGlvbiBzcGFucyB0aGVtc2VsdmVzLlxuXHRcdFx0Y29uc3QgYW5jZXN0cnlNYXRyaXggPSB0aGlzLmFuY2VzdHJ5Lm1hcChzbXQgPT4gQXJyYXkuZnJvbShzbXQuZGVjbGFyYXRpb25zKSk7XG5cdFx0XHRcblx0XHRcdC8vIEFuIGFycmF5IHRoYXQgc3RvcmVzIHRoZSBudW1iZXIgb2YgZGVjbGFyYXRpb24gc3BhbnMgaW4gZWFjaCBzdGF0ZW1lbnQuXG5cdFx0XHRjb25zdCBhbmNlc3RyeUxlbmd0aHMgPSBhbmNlc3RyeU1hdHJpeC5tYXAoc3BhbiA9PiBzcGFuLmxlbmd0aCk7XG5cdFx0XHRcblx0XHRcdC8vIE11bHRpcGx5aW5nIHRvZ2V0aGVyIHRoZSBudW1iZXIgb2Ygc3BhbnMgaW4gZWFjaCBzdGF0ZW1lbnQgd2lsbFxuXHRcdFx0Ly8gZ2l2ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHVuaXF1ZSBzcGluZXMgdGhhdCB3aWxsIGJlIHByb2R1Y2VkLlxuXHRcdFx0Y29uc3QgbnVtU3BpbmVzID0gYW5jZXN0cnlMZW5ndGhzLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuXHRcdFx0XG5cdFx0XHQvLyBTdGFydCB3aXRoIGFuIGFycmF5IG9mIDAncywgd2hvc2UgbGVuZ3RoIG1hdGNoZXMgdGhlIG51bWJlclxuXHRcdFx0Ly8gb2Ygc3RhdGVtZW50cyBpbiB0aGUgYW5jZXN0cnkuIEVhY2ggbnVtYmVyIGluIHRoaXMgYXJyYXkgd2lsbCBiZSBcblx0XHRcdC8vIGluY3JlbWVudGVkIGJ5IDEsIGZyb20gcmlnaHQgdG8gbGVmdCwgZWFjaCBudW1iZXIgbWF4aW5nIG91dCBhdFxuXHRcdFx0Ly8gdGhlIG51bWJlciBvZiBkZWNsYXJhdGlvbnMgaW4gdGhlIGFuY2VzdG9yLiBBZnRlciBlYWNoIGluY3JlbWVudGF0aW9uLFxuXHRcdFx0Ly8gdGhlIHByb2dyZXNzaW9uIG9mIG51bWJlcnMgd2lsbCBydW4gdGhyb3VnaCBhbGwgaW5kZXhlcyByZXF1aXJlZCB0b1xuXHRcdFx0Ly8gcGVyZm9ybSBhIGZ1bGwgZmFjdG9yaXphdGlvbiBvZiB0aGUgdGVybXMgaW4gdGhlIGFuY2VzdHJ5LiBUaGlzIGFycmF5XG5cdFx0XHQvLyB0ZWxscyB0aGUgYWxnb3JpdGhtIHdoaWNoIGluZGV4ZXMgaW4gYW5jZXN0cnlNYXRyaXggdG8gcHVsbCB3aGVuXG5cdFx0XHQvLyBjb25zdHJ1Y3RpbmcgYSBzcGluZS5cblx0XHRcdGNvbnN0IGNoZXJyeVBpY2tJbmRleGVzID0gYW5jZXN0cnlMZW5ndGhzLm1hcCgoKSA9PiAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIHRoZSBwb3NpdGlvbiBpbiBjaGVycnlQaWNrSW5kZXhlcyB0aGF0IHdlJ3JlIGN1cnJlbnRseVxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nLiBNb3ZlcyBiYWNrd2FyZCB3aGVuIHRoZSBudW1iZXIgYXQgXG5cdFx0XHQvLyB0aGUgdGFyZ2V0IHBvc2l0aW9uIGlzID49IHRoZSBudW1iZXIgb2YgdGVybXMgYXQgdGhhdCBwb3NpdGlvbi5cblx0XHRcdGxldCB0YXJnZXRJbmNMZXZlbCA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgbnVtU3BpbmVzOylcblx0XHRcdHtcblx0XHRcdFx0Ly8gRG8gYW4gaW5zZXJ0aW9uIGF0IHRoZSBpbmRleGVzIHNwZWNpZmllZCBieSBpbnNlcnRpb25JbmRleGVzXG5cdFx0XHRcdGNvbnN0IHNwYW5QYXRoOiAoU3BhbiB8IFN0YXRlbWVudClbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlcnJ5IHBpY2sgYSBzZXJpZXMgb2YgdGVybXMgZnJvbSB0aGUgYW5jZXN0cnkgdGVybXMsXG5cdFx0XHRcdC8vIGFjY29yZGluZyB0byB0aGUgaW5kZXggc2V0IHdlJ3JlIGN1cnJlbnRseSBvbi5cblx0XHRcdFx0Zm9yIChsZXQgbGV2ZWwgPSAtMTsgKytsZXZlbCA8IHRoaXMuYW5jZXN0cnkubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlbWVudCA9IHRoaXMuYW5jZXN0cnlbbGV2ZWxdO1xuXHRcdFx0XHRcdGlmIChzdGF0ZW1lbnQuaXNDcnVmdClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzcGFuUGF0aC5wdXNoKHN0YXRlbWVudCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3BhbnNGb3JTdGF0ZW1lbnQgPSBhbmNlc3RyeU1hdHJpeFtsZXZlbF07XG5cdFx0XHRcdFx0Y29uc3Qgc3BhbkluZGV4ID0gY2hlcnJ5UGlja0luZGV4ZXNbbGV2ZWxdO1xuXHRcdFx0XHRcdGNvbnN0IHNwYW4gPSBzcGFuc0ZvclN0YXRlbWVudFtzcGFuSW5kZXhdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghc3Bhbilcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzcGFuUGF0aC5wdXNoKHNwYW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgdGlwIHNwYW4gc3BlY2lmaWVkIGluIHRoZSBtZXRob2QgYXJndW1lbnRzXG5cdFx0XHRcdC8vIGlzIGFkZGVkIGF0IHRoZSBlbmQgb2YgYWxsIGdlbmVyYXRlZCBzcGFuIHBhdGhzLlxuXHRcdFx0XHRzcGFuUGF0aC5wdXNoKHRoaXMpO1xuXHRcdFx0XHRmYWN0b3JlZFNwYW5QYXRocy5wdXNoKHNwYW5QYXRoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEJ1bXAgdXAgdGhlIGN1cnJlbnQgY2hlcnJ5IHBpY2sgaW5kZXgsIFxuXHRcdFx0XHQvLyBvciBpZiB3ZSBoaXQgdGhlIHJvb2YsIG1vdmUgdG8gdGhlIG5leHQgbGV2ZWwsXG5cdFx0XHRcdC8vIGFuZCBrZWVwIGRvaW5nIHRoaXMgdW50aWwgd2UgZmluZCBhIG51bWJlclxuXHRcdFx0XHQvLyB0byBpbmNyZW1lbnQuXG5cdFx0XHRcdHdoaWxlIChjaGVycnlQaWNrSW5kZXhlc1t0YXJnZXRJbmNMZXZlbF0gPj0gYW5jZXN0cnlMZW5ndGhzW3RhcmdldEluY0xldmVsXSAtIDEpXG5cdFx0XHRcdFx0dGFyZ2V0SW5jTGV2ZWwrKztcblx0XHRcdFx0XG5cdFx0XHRcdGNoZXJyeVBpY2tJbmRleGVzW3RhcmdldEluY0xldmVsXSsrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mYWN0b3JlZFNwaW5lcyA9IFxuXHRcdFx0XHRPYmplY3QuZnJlZXplKGZhY3RvcmVkU3BhblBhdGhzLm1hcChzcGFuUGF0aCA9PiBcblx0XHRcdFx0XHRuZXcgU3BpbmUoc3BhblBhdGgpKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAgKi9cblx0XHRwcml2YXRlIGZhY3RvcmVkU3BpbmVzOiByZWFkb25seSBTcGluZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIFNwYW4gaXMgY29uc2lkZXJlZFxuXHRcdCAqIG9iamVjdC1sZXZlbCBjcnVmdCwgYW5kIHNob3VsZCB0aGVyZWZvcmUgYmUgaWdub3JlZCBkdXJpbmcgdHlwZSBhbmFseXNpcy5cblx0XHQgKi9cblx0XHRnZXQgaXNDcnVmdCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50LmNydWZ0T2JqZWN0cy5oYXModGhpcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoaXMgU3BhbiB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5jbHVkZUhhc2hQcmVmaXggSWYgdGhlIHN1YmplY3QgaW5zaWRlIHRoaXMgU3BhbiBpcyBhXG5cdFx0ICogUGF0dGVybiwgYW5kIHRoaXMgYXJndW1lbnQgaXMgdHJ1ZSwgdGhlIFBhdHRlcm4ncyBoYXNoIHByZWZpeFxuXHRcdCAqIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBzZXJpYWxpemVkIHJlc3VsdC5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhpbmNsdWRlSGFzaFByZWZpeD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3ViID0gdGhpcy5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0cmV0dXJuIHN1YiBpbnN0YW5jZW9mIFBhdHRlcm4gP1xuXHRcdFx0XHRzdWIudG9TdHJpbmcoISFpbmNsdWRlSGFzaFByZWZpeCkgOlxuXHRcdFx0XHRzdWIudG9TdHJpbmcoKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgbWFuYWdlcyBhbiBhcnJheSBvZiBTcGFuIG9iamVjdHMgdGhhdFxuXHQgKiByZXByZXNlbnQgYSBzcGVjaWZpYyBzcGluZSBvZiBkZWNsYXJhdGlvbnMsIHN0YXJ0aW5nIGF0XG5cdCAqIGEgZG9jdW1lbnQsIHBhc3NpbmcgdGhyb3VnaCBhIHNlcmllcyBvZiBzcGFucyxcblx0ICogYW5kIGVuZGluZyBhdCBhIHRpcCBzcGFuLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFNwaW5lXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcih2ZXJ0ZWJyYWU6IChTcGFuIHwgU3RhdGVtZW50KVtdKVxuXHRcdHtcblx0XHRcdGlmICh2ZXJ0ZWJyYWUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZENhbGwoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy52ZXJ0ZWJyYWUgPSB2ZXJ0ZWJyYWUubWFwKHYgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHYgaW5zdGFuY2VvZiBTcGFuKVxuXHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZXhpc3RDcnVmdE1hcmtlciA9IGNydWZ0TWFya2Vycy5nZXQodik7XG5cdFx0XHRcdGlmIChleGlzdENydWZ0TWFya2VyICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGV4aXN0Q3J1ZnRNYXJrZXI7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBuZXdDcnVmdE1hcmtlciA9IG5ldyBDcnVmdE1hcmtlcih2KTtcblx0XHRcdFx0Y3J1ZnRNYXJrZXJzLnNldCh2LCBuZXdDcnVmdE1hcmtlcik7XG5cdFx0XHRcdHJldHVybiBuZXdDcnVmdE1hcmtlcjtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB0aXAgPSB0aGlzLnZlcnRlYnJhZVt2ZXJ0ZWJyYWUubGVuZ3RoIC0gMV07XG5cdFx0XHRpZiAodGlwIGluc3RhbmNlb2YgQ3J1ZnRNYXJrZXIpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQ2FsbCgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRpcCA9IHRpcDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyB0aGUgbGFzdCBzcGFuIGluIHRoZSBhcnJheSBvZiBzZWdtZW50cy4gKi9cblx0XHRyZWFkb25seSB0aXA6IFNwYW47XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IHN0YXRlbWVudCgpIHsgcmV0dXJuIHRoaXMudGlwLnN0YXRlbWVudDsgfVxuXHRcdFxuXHRcdC8qKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0aGF0IHNpdHMgYXQgdGhlIHRvcCBvZiB0aGUgc3BpbmUuICovXG5cdFx0Z2V0IGRvY3VtZW50KCkgeyByZXR1cm4gdGhpcy5zdGF0ZW1lbnQuZG9jdW1lbnQ7IH1cblx0XHRcblx0XHQvKiogU3RvcmVzIGFuIGFycmF5IG9mIHRoZSBTcGFucyB0aGF0IGNvbXBvc2UgdGhlIFNwaW5lLiAqL1xuXHRcdHJlYWRvbmx5IHZlcnRlYnJhZTogcmVhZG9ubHkgKFNwYW4gfCBDcnVmdE1hcmtlcilbXSA9IFtdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IGFjdHMgYXMgYSBzdGFuZC1pbiBmb3IgYSBzdGF0ZW1lbnQgdGhhdCBoYXMgYmVlblxuXHQgKiBtYXJrZWQgYXMgY3J1ZnQsIHN1aXRhYmxlIGZvciB1c2FnZSBpbiBhIFNwaW5lLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIENydWZ0TWFya2VyXG5cdHtcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgc3RhdGVtZW50OiBTdGF0ZW1lbnQpIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoaXMgY3J1ZnQgbWFya2VyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLFxuXHRcdCAqIHdoaWNoIGlzIGRlcml2ZWQgZnJvbSBhIGhhc2ggY2FsY3VsYXRlZCBmcm9tIHRoaXNcblx0XHQgKiBtYXJrZXIncyB1bmRlcmx5aW5nIHN0YXRlbWVudC5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFwi4omIXCIgKyBIYXNoLmNhbGN1bGF0ZSh0aGlzLnN0YXRlbWVudC5zb3VyY2VUZXh0KTtcblx0XHR9XG5cdH1cblx0XG5cdGNvbnN0IGNydWZ0TWFya2VycyA9IG5ldyBXZWFrTWFwPFN0YXRlbWVudCwgQ3J1ZnRNYXJrZXI+KCk7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSB0eXBlIGFsaWFzIHRoYXQgcmVmZXJzIHRvIHRoZSBraW5kcyBvZiBvYmplY3RzIHRoYXQgZXhpc3QgXG5cdCAqIGF0IHRoZSBib3R0b20gb2YgYSBTdGF0ZW1lbnQncyBhYnN0cmFjdCBzeW50YXggdHJlZS5cblx0ICovXG5cdGV4cG9ydCB0eXBlIFN1YmplY3QgPSBUZXJtIHwgUGF0dGVybiB8IEtub3duVXJpO1xuXHRcblx0LyoqIEFsaWFzZXMgYSB0eXBlIHRoYXQgaXMgb3IgY29udGFpbnMgYSBTdWJqZWN0LiAqL1xuXHRleHBvcnQgdHlwZSBTdWJqZWN0Q29udGFpbmVyID0gU3BhbiB8IEluZml4U3BhbiB8IEJvdW5kYXJ5PFN1YmplY3Q+IHwgU3ViamVjdDtcblx0XG5cdC8qKiAqL1xuXHRleHBvcnQgY2xhc3MgU3ViamVjdFNlcmlhbGl6ZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFVuaXZlcnNhbCBtZXRob2QgZm9yIHNlcmlhbGl6aW5nIGEgc3ViamVjdCB0byBhIHN0cmluZyxcblx0XHQgKiB1c2VmdWwgZm9yIGRlYnVnZ2luZyBhbmQgc3VwcG9ydGluZyB0ZXN0cy5cblx0XHQgKi9cblx0XHRzdGF0aWMgZm9yRXh0ZXJuYWwoXG5cdFx0XHR0YXJnZXQ6IFN1YmplY3RDb250YWluZXIsXG5cdFx0XHRlc2NhcGVTdHlsZTogVGVybUVzY2FwZUtpbmQgPSBUZXJtRXNjYXBlS2luZC5ub25lKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN1YmplY3QgPSB0aGlzLnJlc29sdmVTdWJqZWN0KHRhcmdldCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXJpYWxpemUoc3ViamVjdCwgZXNjYXBlU3R5bGUsIGZhbHNlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VyaWFsaXplcyBhIHN1YmplY3QsIG9yIGEga25vd24gc3ViamVjdCBjb250YWluaW5nIG9iamVjdCBmb3IgaW50ZXJuYWwgdXNlLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBmb3JJbnRlcm5hbCh0YXJnZXQ6IFN1YmplY3RDb250YWluZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3ViamVjdCA9IHRoaXMucmVzb2x2ZVN1YmplY3QodGFyZ2V0KTtcblx0XHRcdHJldHVybiB0aGlzLnNlcmlhbGl6ZShzdWJqZWN0LCBUZXJtRXNjYXBlS2luZC5ub25lLCB0cnVlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgcmVzb2x2ZVN1YmplY3QodGFyZ2V0OiBTdWJqZWN0Q29udGFpbmVyKTogU3ViamVjdFxuXHRcdHtcblx0XHRcdHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBCb3VuZGFyeSA/IHRhcmdldC5zdWJqZWN0IDpcblx0XHRcdFx0dGFyZ2V0IGluc3RhbmNlb2YgU3BhbiA/IHRhcmdldC5ib3VuZGFyeS5zdWJqZWN0IDpcblx0XHRcdFx0dGFyZ2V0IGluc3RhbmNlb2YgSW5maXhTcGFuID8gdGFyZ2V0LmJvdW5kYXJ5LnN1YmplY3QgOlxuXHRcdFx0XHR0YXJnZXQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHNlcmlhbGl6ZShcblx0XHRcdHN1YmplY3Q6IFN1YmplY3RDb250YWluZXIsXG5cdFx0XHRlc2NhcGVTdHlsZTogVGVybUVzY2FwZUtpbmQsXG5cdFx0XHRpbmNsdWRlSGFzaDogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRpZiAoc3ViamVjdCBpbnN0YW5jZW9mIFRlcm0pXG5cdFx0XHRcdHJldHVybiBzdWJqZWN0LnRvU3RyaW5nKGVzY2FwZVN0eWxlKTtcblx0XHRcdFxuXHRcdFx0ZWxzZSBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdHJldHVybiBzdWJqZWN0LnRvU3RyaW5nKGluY2x1ZGVIYXNoKTtcblx0XHRcdFxuXHRcdFx0ZWxzZSBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEtub3duVXJpKVxuXHRcdFx0XHRyZXR1cm4gc3ViamVjdC50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFN0b3JlcyBhIHJlcHJlc2VudGF0aW9uIG9mIGEgVHJ1dGggcHJvZ3JhbSBpbiBhIGdyYXBoXG5cdCAqIGZvcm1hdCwgd2hpY2ggbGF5cyB0aGUgZm91bmRhdGlvbiBmb3IgdHlwZSBhbmFseXNpcy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBIeXBlckdyYXBoXG5cdHtcblx0XHQvKipcblx0XHQgKiBUZXN0LW9ubHkgZmllbGQgdXNlZCB0byBkaXNhYmxlIHRoZSBmdW5jdGlvbnMgb2YgdGhlIEdyYXBoLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBkaXNhYmxlZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0dGhpcy5ub2RlSW5kZXggPSBuZXcgTm9kZUluZGV4KCk7XG5cdFx0XHRcblx0XHRcdGlmIChIeXBlckdyYXBoLmRpc2FibGVkKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZG9jIG9mIHByb2dyYW0uZG9jdW1lbnRzKVxuXHRcdFx0XHR0aGlzLmluY2x1ZGUoZG9jKTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZURvY3VtZW50Q3JlYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuaW5jbHVkZShkYXRhLmRvY3VtZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlRG9jdW1lbnREZWxldGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5leGNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VJbnZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnBhcmVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRcdHRoaXMuZXhjbHVkZShzbXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdGhpcy5leGNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VSZXZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnBhcmVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRcdHRoaXMuaW5jbHVkZShzbXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdGhpcy5pbmNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VFZGl0Q29tcGxldGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5hY3RpdmVUcmFuc2FjdGlvbnMuZGVsZXRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgYSBkb2N1bWVudC1sZXZlbCBleGNsdXNpb24sIHdoaWNoIGlzIHRoZSByZW1vdmFsIFxuXHRcdCAqIG9mIGEgc2VjdGlvbiBvZiBTcGFucyB3aXRoaW4gYSBkb2N1bWVudCwgb3IgcG9zc2libHkgdGhlXG5cdFx0ICogZW50aXJlIGRvY3VtZW50IGl0c2VsZi5cblx0XHQgKi9cblx0XHRwcml2YXRlIGV4Y2x1ZGUocm9vdDogRG9jdW1lbnQgfCBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgeyBkb2N1bWVudCwgaXRlcmF0b3IgfSA9IHRoaXMubWV0aG9kU2V0dXAocm9vdCk7XG5cdFx0XHRjb25zdCB0eG4gPSB0aGlzLmdldFRyYW5zYWN0aW9uKHJvb3QpO1xuXHRcdFx0Y29uc3QgZW50cmllcyA9IEFycmF5LmZyb20oaXRlcmF0b3IpO1xuXHRcdFx0XG5cdFx0XHQvLy9jb25zdCBtYXliZURlc3RhYmlsaXplZEVkZ2VzOiBIeXBlckVkZ2VbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgc3RhdGVtZW50IH0gb2YgZW50cmllcylcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBzdGF0ZW1lbnQuZGVjbGFyYXRpb25zKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYXNzb2NpYXRlZE5vZGVzID0gbmV3IFNldChkZWNsYXJhdGlvblxuXHRcdFx0XHRcdFx0LmZhY3RvcigpXG5cdFx0XHRcdFx0XHQubWFwKHNwaW5lID0+IFBocmFzZS5mcm9tU3BpbmUoc3BpbmUpPy5hc3NvY2lhdGVkTm9kZSlcblx0XHRcdFx0XHRcdC5maWx0ZXIoKG4pOiBuIGlzIE5vZGUgPT4gbiBpbnN0YW5jZW9mIE5vZGUpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGFzc29jaWF0ZWROb2RlIG9mIGFzc29jaWF0ZWROb2Rlcylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhc3NvY2lhdGVkTm9kZS5yZW1vdmVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChhc3NvY2lhdGVkTm9kZS5kZWNsYXJhdGlvbnMuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRcdFx0dHhuLmRlc3RhYmlsaXplZE5vZGVzLnB1c2goYXNzb2NpYXRlZE5vZGUpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG9iIG9mIGFzc29jaWF0ZWROb2RlLm91dGJvdW5kcylcblx0XHRcdFx0XHRcdFx0aWYgKG9iLmZyYWdtZW50cy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHRcdFx0dHhuLmRlc3RhYmxpemVkRWRnZXMucHVzaChvYik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vL2ZvciAoY29uc3QgaWIgb2YgYXNzb2NpYXRlZE5vZGUuaW5ib3VuZHMpXG5cdFx0XHRcdFx0XHQvLy9cdG1heWJlRGVzdGFiaWxpemVkRWRnZXMucHVzaChpYik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vL2ZvciAoY29uc3QgZWRnZSBvZiBtYXliZURlc3RhYmlsaXplZEVkZ2VzKVxuXHRcdFx0Ly8vXHRpZiAoZWRnZS5zdWNjZXNzb3JzLmV2ZXJ5KHNjc3IgPT4gdHhuLmRlc3RhYmlsaXplZE5vZGVzLmluY2x1ZGVzKHNjc3Iubm9kZSkpKVxuXHRcdFx0Ly8vXHRcdHR4bi5kZXN0YWJsaXplZEVkZ2VzLnB1c2goZWRnZSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWN0aXZlVHJhbnNhY3Rpb25zLnNldChkb2N1bWVudCwgdHhuKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgYSByZXZhbGlkYXRpb24gb2YgdGhlIE5vZGVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGVcblx0XHQgKiBpbnB1dCBhcmd1bWVudC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gcm9vdCBUaGUgcm9vdCBvYmplY3QgdW5kZXIgd2hpY2ggd2hpY2ggcmV2YWxpZGF0aW9uXG5cdFx0ICogc2hvdWxkIG9jY3VyLiBJbiB0aGUgY2FzZSB3aGVuIGEgRG9jdW1lbnQgaW5zdGFuY2UgaXMgcGFzc2VkLFxuXHRcdCAqIGFsbCBOb2RlcyBwcmVzZW50IHdpdGhpbiB0aGUgZG9jdW1lbnQgYXJlIHJldmFsaWRhdGVkLiBJbiB0aGUgXG5cdFx0ICogY2FzZSB3aGVuIGEgU3RhdGVtZW50IGluc3RhbmNlIGlzIHBhc3NlZCwgdGhlIE5vZGVzIHRoYXRcblx0XHQgKiBjb3JyZXNwb25kIHRvIHRoZSBTdGF0ZW1lbnQsIGFuZCBhbGwgb2YgaXQncyBjb250ZW50cyBhcmVcblx0XHQgKiByZXZhbGlkYXRlZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIGluY2x1ZGUocm9vdDogRG9jdW1lbnQgfCBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgeyBkb2N1bWVudCwgaXRlcmF0b3IgfSA9IHRoaXMubWV0aG9kU2V0dXAocm9vdCk7XG5cdFx0XHRjb25zdCB0eG4gPSB0aGlzLmdldFRyYW5zYWN0aW9uKGRvY3VtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGZpcnN0IHN0ZXAgaXMgdG8gY29sbGVjdCBhbGwgdGhlIFBocmFzZSBvYmplY3RzIGluIHRoZSBpbnZhbGlkYXRlZCBhcmVhLFxuXHRcdFx0Ly8gYW5kIHRoZSBTcGFucyBhbmQgSW5maXhTcGFucyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhhdCBQaHJhc2UuIFRoZVxuXHRcdFx0Ly8gZGF0YSBzdHJ1Y3R1cmUgaGVyZSBpcyBhIE11bHRpTWFwLCB0byB0aGUgY29ycmVzcG9uZGVuY2UgaXMgXG5cdFx0XHQvLyAxIFBocmFzZSB0byBOIFNwYW5zLlxuXHRcdFx0Y29uc3QgcGhyYXNlU3BhbnNNYXAgPSBuZXcgTXVsdGlNYXA8UGhyYXNlLCAoU3BhbiB8IEluZml4U3Bhbik+KCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBpdGVyYXRvcilcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBkZWNsIG9mIHN0YXRlbWVudC5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNwaW5lIG9mIGRlY2wuZmFjdG9yKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcGhyYXNlID0gUGhyYXNlLmZyb21TcGluZShzcGluZSk7XG5cdFx0XHRcdFx0XHRpZiAoIXBocmFzZSlcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHBocmFzZVNwYW5zTWFwLmFkZChwaHJhc2UsIGRlY2wpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgZGVjbGFyYXRpb24gaGFzIHBvcHVsYXRpb24gaW5maXhlcywgdGhlc2Vcblx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhlIG1hcCBhcyB0aG91Z2ggdGhleVxuXHRcdFx0XHRcdFx0Ly8gd2VyZSByZWd1bGFyIGRlY2xhcmF0aW9ucy5cblx0XHRcdFx0XHRcdGZvciAoY29uc3QgcG9wSW5maXggb2YgZGVjbC5pbmZpeGVzLmZpbHRlcihuZnggPT4gbmZ4LmlzUG9wdWxhdGlvbikpXG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIGRlY2wuZWFjaERlY2xhcmF0aW9uRm9ySW5maXgocG9wSW5maXgpKVxuXHRcdFx0XHRcdFx0XHRcdHBocmFzZVNwYW5zTWFwLmFkZChcblx0XHRcdFx0XHRcdFx0XHRcdHBocmFzZS5mb3J3YXJkKGluZml4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0KSxcblx0XHRcdFx0XHRcdFx0XHRcdGluZml4U3Bhbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwaHJhc2VTcGFuc01hcC5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIFBocmFzZXMgYXJlIGVudW1lcmF0ZWQgaW4gYnJlYWR0aC1maXJzdFxuXHRcdFx0Ly8gb3JkZXIuIEZvciBleGFtcGxlLCB0aGlzIG1lYW5zIHRoYXQgYWxsIFBocmFzZXMgd2l0aCBhIGxlbmd0aCBvZiAyXG5cdFx0XHQvLyAoc3VjaCBhcyBPYmplY3QgLyBEZW5zaXR5KSBtdXN0IGJlIGV2YWx1YXRlZCBiZWZvcmUgYWxsIFBocmFzZXNcblx0XHRcdC8vIHdpdGggYSBsZW5ndGggb2YgMyAoc3VjaCBhcyBPYmplY3QgLyBEZW5zaXR5IC8gVG9sZXJhbmNlKS4gVGhpcyBpc1xuXHRcdFx0Ly8gYmVjYXVzZSBpbiBvcmRlciB0byBjb25zdHJ1Y3QgYSAzcmQtbGV2ZWwgTm9kZSwgd2UgaGF2ZSB0byBcblx0XHRcdC8vIGd1YXJhbnRlZSB0aGF0IGl0J3Mgb3V0ZXIgMm5kLWxldmVsIG5vZGUgd2FzIGZ1bGx5IGNvbnN0cnVjdGVkLFxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCB0aGUgM3JkLWxldmVsIG5vZGUgd2lsbCBoYXZlIG5vd2hlcmUgdG8gY29ubmVjdC5cblx0XHRcdGNvbnN0IG5ld0FyZWFTb3J0ZWQgPSBcblx0XHRcdFx0QXJyYXkuZnJvbShwaHJhc2VTcGFuc01hcC5lbnRyaWVzKCkpXG5cdFx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IGFbMF0ubGVuZ3RoIC0gYlswXS5sZW5ndGgpO1xuXHRcdFx0XG5cdFx0XHQvLyBTdG9yZXMgYWxsIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBhZmZlY3RlZCBieSBhIG5ld1xuXHRcdFx0Ly8gZnJhZ21lbnQgZWl0aGVyIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSBpdC5cblx0XHRcdGNvbnN0IGFmZmVjdGVkTm9kZXMgPSBuZXcgTWFwPFBocmFzZSwgTm9kZT4oKTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIGEgc3Vic2V0IG9mIHRoZSBhZmZlY3RlZE5vZGVzIGFycmF5LiBDb250YWluc1xuXHRcdFx0Ly8gb25seSB0aGUgbm9kZXMgdGhhdCBhcmUgYXQgdGhlIG91dGVyLW1vc3QgbGV2ZWwgb2YgZGVwdGhcblx0XHRcdC8vIHdpdGhpbiB0aGUgbm9kZSBzZXQgKG5vdCBuZWNlc3NhcmlseSB0aGUgZG9jdW1lbnQgcm9vdCkuXG5cdFx0XHRjb25zdCBhZmZlY3RlZE5vZGVzQXBleGVzOiBOb2RlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcmV0dXJucyBUaGUgY29udGFpbmluZyBub2RlIHRoYXRcblx0XHRcdCAqIGNvcnJlc3BvbmRzIHRvIHRoZSBzcGVjaWZpZWQgcGhyYXNlLlxuXHRcdFx0ICovIFxuXHRcdFx0Y29uc3QgZmluZE5vZGUgPSAocGhyYXNlOiBQaHJhc2UpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChwaHJhc2UubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBhZmZlY3RlZE5vZGVzLmdldChwaHJhc2UpIHx8IHBocmFzZS5hc3NvY2lhdGVkTm9kZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBmb2xsb3dpbmcgYmxvY2sgcG9wdWxhdGVzIHRoZSBhcHByb3ByaWF0ZSBOb2Rlc1xuXHRcdFx0Ly8gaW4gdGhlIGdyYXBoIHdpdGggdGhlIG5ldyBTcGFuIG9iamVjdHMgdGhhdCB3ZXJlIHNlbnRcblx0XHRcdC8vIGluIHRocm91Z2ggdGhlIFwicm9vdFwiIHBhcmFtZXRlci4gTmV3IE5vZGUgb2JqZWN0c1xuXHRcdFx0Ly8gYXJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0Zm9yIChjb25zdCBbcGhyYXNlLCBkZWNsYXJhdGlvbnNdIG9mIG5ld0FyZWFTb3J0ZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgZGVjbGFyYXRpb25zKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgbm9kZUF0UGhyYXNlID0gZmluZE5vZGUocGhyYXNlKTtcblx0XHRcdFx0XHRpZiAobm9kZUF0UGhyYXNlKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIFdlIGFkZCB0aGUgcGhyYXNlIHRvIHRoZSB0YWJsZSBvZiBhZmZlY3RlZCBub2Rlcyxcblx0XHRcdFx0XHRcdC8vIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVuIGl0IHdhcyBleHRyYWN0ZWQgZnJvbSB0aGVcblx0XHRcdFx0XHRcdC8vIGNhY2hlLlxuXHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlcy5zZXQocGhyYXNlLCBub2RlQXRQaHJhc2UpO1xuXHRcdFx0XHRcdFx0bm9kZUF0UGhyYXNlLmFkZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBjb250YWluZXIgPSBwaHJhc2UubGVuZ3RoID4gMSA/XG5cdFx0XHRcdFx0XHRmaW5kTm9kZShwaHJhc2UuYmFjaygpKSA6XG5cdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwaHJhc2UubGVuZ3RoID4gMSAmJiBjb250YWluZXIgPT09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gTm90ZSB0aGF0IHdoZW4gY3JlYXRpbmcgYSBOb2RlLCBpdCdzXG5cdFx0XHRcdFx0Ly8gYXV0b21hdGljYWxseSBib3VuZCB0byBpdCdzIGNvbnRhaW5lci5cblx0XHRcdFx0XHRjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUoY29udGFpbmVyLCBkZWNsYXJhdGlvbik7XG5cdFx0XHRcdFx0YWZmZWN0ZWROb2Rlcy5zZXQocGhyYXNlLCBuZXdOb2RlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBQb3B1bGF0ZSB0aGUgYWZmZWN0ZWROb2Rlc0FwZXhlcyBhcnJheSwgXG5cdFx0XHRcdFx0Ly8gd2hpY2ggaXMgbmVlZGVkIHRvIGZpbmQgdGhlIG5vZGVzIHRoYXQgYXJlXG5cdFx0XHRcdFx0Ly8gYWZmZWN0ZWQgYnkgdGhlIGNoYW5nZSwgYnV0IGFyZSBub3QgbG9jYXRlZFxuXHRcdFx0XHRcdC8vIGRpcmVjdGx5IHdpdGhpbiB0aGUgcGF0Y2guXG5cdFx0XHRcdFx0aWYgKGFmZmVjdGVkTm9kZXNBcGV4ZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGFmZmVjdGVkTm9kZXNBcGV4ZXMucHVzaChuZXdOb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIElmIHdlJ3ZlIGVuY291bnRlcmVkIGEgbm9kZSB0aGF0IGlzIGhpZ2hlclxuXHRcdFx0XHRcdFx0Ly8gdGhhbiB0aGUgbGV2ZWwgb2YgZGVwdGggZGVmaW5lZCBpbiB0aGUgbm9kZXNcblx0XHRcdFx0XHRcdC8vIGN1cnJlbnRseSBpbiB0aGUgYWZmZWN0ZWROb2Rlc0FwZXhlcyBhcnJheS5cblx0XHRcdFx0XHRcdGNvbnN0IGhpZ2hlc3REZXB0aCA9IGFmZmVjdGVkTm9kZXNBcGV4ZXNbMF0ucGhyYXNlLmxlbmd0aDtcblx0XHRcdFx0XHRcdGNvbnN0IG5vZGVEZXB0aCA9IG5ld05vZGUucGhyYXNlLmxlbmd0aDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKG5vZGVEZXB0aCA8IGhpZ2hlc3REZXB0aClcblx0XHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlc0FwZXhlcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobm9kZURlcHRoIDw9IGhpZ2hlc3REZXB0aClcblx0XHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlc0FwZXhlcy5wdXNoKG5ld05vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFsbCBuZXcgSHlwZXJFZGdlcyBieSBmZWVkaW5nIGluIGFsbFxuXHRcdFx0Ly8gYW5ub3RhdGlvbiBzcGFucyBmb3IgZWFjaCBkZWNsYXJhdGlvbiBzcGFuLlxuXHRcdFx0Ly8gVGhpcyBuZWVkcyB0byBoYXBwZW4gaW4gYSBzZWNvbmQgcGFzcyBiZWNhdXNlXG5cdFx0XHQvLyBhbGwgbmV3IG5vZGVzIG5lZWQgdG8gYmUgY3JlYXRlZCBhbmQgcG9zaXRpb25lZFxuXHRcdFx0Ly8gaW4gdGhlIGdyYXBoIGJlZm9yZSBuZXcgXCJIeXBlckVkZ2Ugc3BhbnNcIiBjYW4gYmUgYWRkZWQsXG5cdFx0XHQvLyBiZWNhdXNlIGRvaW5nIHRoaXMgY2F1c2VzIHJlc29sdXRpb24gdG8gb2NjdXIuXG5cdFx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgYWZmZWN0ZWROb2Rlcy52YWx1ZXMoKSlcblx0XHRcdFx0Zm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBub2RlLmRlY2xhcmF0aW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIFNwYW4pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGRlY2xhcmF0aW9uLnN0YXRlbWVudC5hbm5vdGF0aW9ucylcblx0XHRcdFx0XHRcdFx0bm9kZS5hZGRFZGdlRnJhZ21lbnQoYW5ub3RhdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBuZnggPSBkZWNsYXJhdGlvbi5jb250YWluaW5nSW5maXg7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgYm91bmRhcnkgb2YgbmZ4LnJocylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bm9kZS5hZGRFZGdlRnJhZ21lbnQobmV3IEluZml4U3Bhbihcblx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvbi5jb250YWluaW5nU3Bhbixcblx0XHRcdFx0XHRcdFx0XHRuZngsXG5cdFx0XHRcdFx0XHRcdFx0Ym91bmRhcnkpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVGhpcyBpcyBkb2luZyB0aGUgcmV2ZXJzZSBvZiB3aGF0IHRoZSBhYm92ZSBhZmZlY3RlZE5vZGVzXG5cdFx0XHQvLyBsb29wIGlzIGRvaW5nIC4uLiB0aGlzIGlzIGNvbm5lY3Rpbmcgb3RoZXIgbm9kZXMgdG8gdGhlIGFmZmVjdGVkXG5cdFx0XHQvLyBub2Rlcywgd2hlcmVhcyB0aGUgbG9vcCBhYm92ZSBpcyBjb25uZWN0aW5nIGFmZmVjdGVkTm9kZXNcblx0XHRcdC8vIHRvIG90aGVycy5cblx0XHRcdGlmIChhZmZlY3RlZE5vZGVzQXBleGVzLmxlbmd0aCA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFN0b3JlcyB0aGUgc2VyaWVzIG9mIGNvbnRhaW5lcnMgdGhhdCBhbnkgb2YgdGhlIG5ld2x5IGRpc2NvdmVyZWRcblx0XHRcdFx0Ly8gcG9zc2libHkgYWZmZWN0ZWQgbm9kZXMgbXVzdCBoYXZlIGluIHRoZWlyIGNvbnRhaW5tZW50IGxpc3Rcblx0XHRcdFx0Ly8gaW4gb3JkZXIgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIFwiYWZmZWN0ZWROb2Rlc1wiIGFycmF5LlxuXHRcdFx0XHRjb25zdCBhcGV4Q29udGFpbmVycyA9IGFmZmVjdGVkTm9kZXNBcGV4ZXNcblx0XHRcdFx0XHQubWFwKG5vZGUgPT4gbm9kZS5jb250YWluZXIpXG5cdFx0XHRcdFx0LmZpbHRlcigobm9kZSk6IG5vZGUgaXMgTm9kZSA9PiBub2RlICE9PSBudWxsKVxuXHRcdFx0XHRcdC5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjaGVja1Jvb3QgPSBhcGV4Q29udGFpbmVycy5sZW5ndGggPT09IDA7XG5cdFx0XHRcdGNvbnN0IGlzQmVsb3dBbkFwZXhDb250YWluZXIgPSAobm9kZTogTm9kZSkgPT5cblx0XHRcdFx0XHRub2RlLmNvbnRhaW5tZW50LnNvbWUobiA9PiBhcGV4Q29udGFpbmVycy5pbmNsdWRlcyhuKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHNjc3JOb2RlIG9mIGFmZmVjdGVkTm9kZXNBcGV4ZXMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBQYXR0ZXJuIGFuZCBVUkkgcmVzb2x1dGlvbiBkb2Vzbid0IG9jY3VyIGluIHRoZVxuXHRcdFx0XHRcdC8vIE5vZGUgZ3JhcGgsIHNvIHdoZW4gdGhlIG5vZGUncyBzdWJqZWN0IGlzbid0IFxuXHRcdFx0XHRcdC8vIGEgdGVybSwgd2UgZG9uJ3QgYWRkIGFueSBlZGdlcyB0byBpdC5cblx0XHRcdFx0XHRpZiAoIShzY3NyTm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgVGVybSkpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0ZXJtcyA9IHRoaXMubm9kZUluZGV4LmdldEFzc29jaWF0ZWRUZXJtcyhzY3NyTm9kZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCB0ZXJtIG9mIHRlcm1zKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHByZWRlY2Vzc29ycyA9IHRoaXMubm9kZUluZGV4LmdldE5vZGVzQnlUZXJtKHRlcm0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHByZWRlY2Vzc29yIG9mIHByZWRlY2Vzc29ycylcblx0XHRcdFx0XHRcdFx0aWYgKGNoZWNrUm9vdCB8fCBpc0JlbG93QW5BcGV4Q29udGFpbmVyKHByZWRlY2Vzc29yKSlcblx0XHRcdFx0XHRcdFx0XHRwcmVkZWNlc3Nvci5hZGRFZGdlU3VjY2Vzc29yKHNjc3JOb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlcmUncyBubyBhY3RpdmUgdHJhbnNhY3Rpb24gdGhlIGNvcnJlc3BvbmRzIHRvIHRoZSBpbnB1dFxuXHRcdFx0Ly8gZG9jdW1lbnQsIHRoZSBtb3N0IGxpa2VseSByZWFzb24gaXMgdGhhdCBhbiBlbnRpcmUgZG9jdW1lbnRcblx0XHRcdC8vIGlzIGJlaW5nIGluY2x1ZGVkIGZvciB0aGUgZmlyc3QgdGltZS5cblx0XHRcdGlmICh0eG4pXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgbWF5YmVEZWFkRWRnZSBvZiB0eG4uZGVzdGFibGl6ZWRFZGdlcylcblx0XHRcdFx0XHRpZiAobWF5YmVEZWFkRWRnZS5mcmFnbWVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRcdG1heWJlRGVhZEVkZ2UucHJlZGVjZXNzb3IuZGlzcG9zZUVkZ2UobWF5YmVEZWFkRWRnZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IG1heWJlRGVhZE5vZGUgb2YgdHhuLmRlc3RhYmlsaXplZE5vZGVzKVxuXHRcdFx0XHRcdGlmIChtYXliZURlYWROb2RlLmRlY2xhcmF0aW9ucy5zaXplID09PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG1heWJlRGVhZE5vZGUuZGlzcG9zZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5ub2RlSW5kZXguZGVsZXRlKG1heWJlRGVhZE5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gUG9wdWxhdGUgbm9kZUNhY2hlIHdpdGggYW55IG5ld2x5IGNyZWF0ZWQgbm9kZXMuXG5cdFx0XHRmb3IgKGNvbnN0IGFmZmVjdGVkTm9kZSBvZiBhZmZlY3RlZE5vZGVzLnZhbHVlcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRhZmZlY3RlZE5vZGUuc29ydE91dGJvdW5kcygpO1xuXHRcdFx0XHRjb25zdCBjYWNoZWROb2RlID0gYWZmZWN0ZWROb2RlLnBocmFzZS5hc3NvY2lhdGVkTm9kZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjYWNoZWROb2RlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNhY2hlZE5vZGUgIT09IGFmZmVjdGVkTm9kZSlcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLm5vZGVJbmRleC51cGRhdGUoYWZmZWN0ZWROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5zYW5pdGl6ZShhZmZlY3RlZE5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBzZXR1cCBmb3IgdGhlIGludmFsaWRhdGUgYW5kIHJldmFsaWRhdGUgbWV0aG9kcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIG1ldGhvZFNldHVwKHJvb3Q6IERvY3VtZW50IHwgU3RhdGVtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IGRvY3VtZW50ID0gcm9vdCBpbnN0YW5jZW9mIERvY3VtZW50ID9cblx0XHRcdFx0cm9vdCA6XG5cdFx0XHRcdHJvb3QuZG9jdW1lbnQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gcm9vdCBpbnN0YW5jZW9mIERvY3VtZW50ID9cblx0XHRcdFx0ZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQoKSA6XG5cdFx0XHRcdGRvY3VtZW50LmVhY2hEZXNjZW5kYW50KHJvb3QsIHRydWUpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4geyBkb2N1bWVudCwgaXRlcmF0b3IgfTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwb3J0cyBhbnkgTm9kZS1sZXZlbCBmYXVsdHMgZGV0ZWN0ZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBzYW5pdGl6ZShub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdC8vIENoZWNrIGZvciBmYXVsdHkgcmVmcmVzaCB0eXBlc1xuXHRcdFx0Ly8gVGhpcyBjYW4gb25seSBoYXBwZW4gb24gbm9uLWluZml4IHNwYW5zXG5cdFx0XHRpZiAoIShub2RlLmRlY2xhcmF0aW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgaW5zdGFuY2VvZiBTcGFuKSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzbXRzID0gbm9kZS5zdGF0ZW1lbnRzO1xuXHRcdFx0Y29uc3Qgc210c1JlZnJlc2ggPSBzbXRzLmZpbHRlcihzbXQgPT4gc210LmlzUmVmcmVzaCk7XG5cdFx0XHRjb25zdCBzbXRzQW5ub3RhdGVkID0gc210cy5maWx0ZXIoc210ID0+IHNtdC5hbGxBbm5vdGF0aW9ucy5sZW5ndGggPiAwKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNtdHNSZWZyZXNoLmxlbmd0aCA+IDAgJiYgc210c0Fubm90YXRlZC5sZW5ndGggPiAwKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzbXRzUmVmcmVzaClcblx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChuZXcgRmF1bHQoXG5cdFx0XHRcdFx0XHRGYXVsdHMuVHlwZUNhbm5vdEJlUmVmcmVzaGVkLFxuXHRcdFx0XHRcdFx0c210KSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCBvZiBhbGwgbm9kZXMgdGhhdFxuXHRcdCAqIGhhdmUgYmVlbiBsb2FkZWQgaW50byB0aGUgcHJvZ3JhbSwgaW5kZXhlZFxuXHRcdCAqIGJ5IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0J3MgVVJJLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgbm9kZUluZGV4OiBOb2RlSW5kZXg7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgR3JhcGhUcmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBzb3VyY2Ugb2JqZWN0LlxuXHRcdCAqIEEgbmV3IEdyYXBoVHJhbnNhY3Rpb24gaXMgY3JlYXRlZCBpbiB0aGUgY2FzZSB3aGVuIG5vIG1hdGNoIGFjdGl2ZSBcblx0XHQgKiB0cmFuc2FjdGlvbiBpcyBhdmFpbGFibGUsIG9yIHdoZW4gdGhlIGFjdGl2ZSB0cmFuc2FjdGlvbiBpcyBmcm9tIGEgcHJldmlvdXNcblx0XHQgKiB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRwcml2YXRlIGdldFRyYW5zYWN0aW9uKHNvdXJjZTogRG9jdW1lbnQgfCBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZG9jID0gc291cmNlLmNsYXNzID09PSBDbGFzcy5kb2N1bWVudCA/XG5cdFx0XHRcdHNvdXJjZSA6XG5cdFx0XHRcdHNvdXJjZS5kb2N1bWVudDtcblx0XHRcdFxuXHRcdFx0bGV0IHR4biA9IHRoaXMuYWN0aXZlVHJhbnNhY3Rpb25zLmdldChkb2MpO1xuXHRcdFx0aWYgKCF0eG4gfHwgZG9jLnZlcnNpb24ubmV3ZXJUaGFuKHR4bi52ZXJzaW9uKSlcblx0XHRcdFx0dGhpcy5hY3RpdmVUcmFuc2FjdGlvbnMuc2V0KGRvYywgdHhuID0gbmV3IEdyYXBoVHJhbnNhY3Rpb24oZG9jLnZlcnNpb24pKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHR4bjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgR3JhcGhUcmFuc2FjdGlvbiBpbnN0YW5jZSBpbiB0aGUgY2FzZVxuXHRcdCAqIHdoZW4gYW4gZWRpdCB0cmFuc2FjdGlvbiBpcyB1bmRlcndheS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGFjdGl2ZVRyYW5zYWN0aW9ucyA9IG5ldyBNYXA8RG9jdW1lbnQsIEdyYXBoVHJhbnNhY3Rpb24+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VyaWFsaXplcyB0aGUgR3JhcGggaW50byBhIGZvcm1hdCBzdWl0YWJsZVxuXHRcdCAqIGZvciBkZWJ1Z2dpbmcgYW5kIGNvbXBhcmluZyBhZ2FpbnN0IGJhc2VsaW5lcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZUluZGV4LnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRjbGFzcyBHcmFwaFRyYW5zYWN0aW9uXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgdG8gd2hpY2ggdGhpcyBHcmFwaFRyYW5zYWN0aW9uXG5cdFx0XHQgKiBpcyBhcHBsaWVkLiBHcmFwaFRyYW5zYWN0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gb3BlcmF0ZSBvbiBkb2N1bWVudHNcblx0XHRcdCAqIHdpdGhpbiB0aGUgdGltZSBmcmFtZSBvZiBhIHNpbmdsZSB2ZXJzaW9uLiBJZiBhIGRvY3VtZW50J3MgdmVyc2lvblxuXHRcdFx0ICogY2hhbmdlcywgdGhlIEdyYXBoVHJhbnNhY3Rpb24gaXMgbm8gbG9uZ2VyIGFwcGxpY2FibGUuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHZlcnNpb246IFZlcnNpb25TdGFtcCkgeyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGFuIGFycmF5IG9mIE5vZGVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgYW55XG5cdFx0ICogdW5kZXJseWluZyBTcGFuIG9iamVjdHMsIGR1ZSB0byB0aGVpciByZW1vdmFsIGluXG5cdFx0ICogdGhlIGludmFsaWRhdGlvbiBwaGFzZS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBkZXN0YWJpbGl6ZWROb2RlczogTm9kZVtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGFuIGFycmF5IG9mIEZhbnMgdGhhdCBubyBsb25nZXIgaGF2ZSBhbnlcblx0XHQgKiB1bmRlcmx5aW5nIFNwYW4gb2JqZWN0cywgZHVlIHRvIHRoZWlyIHJlbW92YWwgaW5cblx0XHQgKiB0aGUgaW52YWxpZGF0aW9uIHBoYXNlLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGRlc3RhYmxpemVkRWRnZXM6IEh5cGVyRWRnZVtdID0gW107XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogRGVidWcgdXRpbGl0eS5cblx0ICovXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzOiBOb2RlW10pXG5cdHtcblx0XHRyZXR1cm4gXCJcXG5cIiArIG5vZGVzLm1hcChub2RlID0+IG5vZGUudG9TdHJpbmcodHJ1ZSkpLmpvaW4oXCJcXG5cIik7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzaW5nbGUgTm9kZSBjb250YWluZWQgd2l0aGluXG5cdCAqIHRoZSBQcm9ncmFtJ3MgR3JhcGguIE5vZGVzIGFyZSBsb25nLWxpdmVkLCByZWZlcmVudGlhbGx5XG5cdCAqIHNpZ25pZmljYW50IG9iamVjdHMgdGhhdCBwZXJzaXN0IGJldHdlZW4gZWRpdCBmcmFtZXMuXG5cdCAqIFxuXHQgKiBOb2RlcyBhcmUgY29ubmVjdGVkIGluIGEgZ3JhcGggbm90IGJ5IGVkZ2VzLCBidXQgYnlcblx0ICogSHlwZXJFZGdlcy4gQSBIeXBlckVkZ2UgKGZyb20gZ3JhcGggdGhlb3J5KSBpcyBzaW1pbGFyIFxuXHQgKiB0byBhIGRpcmVjdGVkIGVkZ2UgaW4gdGhhdCBpdCBoYXMgYSBzaW5nbGUgcHJlZGVjZXNzb3IsXG5cdCAqIGJ1dCBkaWZmZXJzIGluIHRoYXQgaXQgaGFzIG11bHRpcGxlIHN1Y2Nlc3NvcnMuXG5cdCAqIFxuXHQgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIE5vZGVzIHRvIGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyXG5cdCAqIGluIHRoaXMgd2F5LCBpbiBvcmRlciBmb3IgZnVydGhlciBwaGFzZXMgaW4gdGhlIHBpcGVsaW5lXG5cdCAqIHRvIGV4ZWN1dGUgdGhlIHZhcmlvdXMga2luZHMgb2YgcG9seW1vcnBoaWMgdHlwZVxuXHQgKiByZXNvbHV0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIE5vZGVcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0Y29udGFpbmVyOiBOb2RlIHwgbnVsbCxcblx0XHRcdGRlY2xhcmF0aW9uOiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNwYW4gPSBkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIFNwYW4gP1xuXHRcdFx0XHRkZWNsYXJhdGlvbiA6IFxuXHRcdFx0XHRkZWNsYXJhdGlvbi5jb250YWluaW5nU3Bhbjtcblx0XHRcdFxuXHRcdFx0dGhpcy5kb2N1bWVudCA9IHNwYW4uc3RhdGVtZW50LmRvY3VtZW50O1xuXHRcdFx0dGhpcy5zdGFtcCA9IHRoaXMuZG9jdW1lbnQudmVyc2lvbjtcblx0XHRcdFxuXHRcdFx0dGhpcy5fZGVjbGFyYXRpb25zID0gbmV3IFNldChbZGVjbGFyYXRpb25dKTtcblx0XHRcdGlmICh0aGlzLl9kZWNsYXJhdGlvbnMuc2l6ZSA9PT0gMClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnN1YmplY3QgPSBkZWNsYXJhdGlvbi5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0XG5cdFx0XHR0aGlzLmlzTGlzdEludHJpbnNpYyA9IFxuXHRcdFx0XHR0aGlzLnN1YmplY3QgaW5zdGFuY2VvZiBUZXJtICYmXG5cdFx0XHRcdHRoaXMuc3ViamVjdC5pc0xpc3Q7XG5cdFx0XHRcblx0XHRcdGlmIChjb250YWluZXIpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdFx0XHR0aGlzLnBocmFzZSA9IGNvbnRhaW5lci5waHJhc2UuZm9yd2FyZCh0aGlzLnN1YmplY3QpO1xuXHRcdFx0XHRjb250YWluZXIuX2NvbnRlbnRzLnNldCh0aGlzLnN1YmplY3QsIHRoaXMpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhpcyBhcHBlYXJzIHRvIG5lZWQgdG8gYmUgYnJvdWdodCBiYWNrIGluIHRoZSBjYXNlXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGNvZGUgYmVsb3cgaXMgdW5jb21tZW50ZWQuXG5cdFx0XHRcdC8vLyByZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5waHJhc2UgPSB0aGlzLmRvY3VtZW50LnBocmFzZS5mb3J3YXJkKHRoaXMuc3ViamVjdCk7XG5cdFx0XHRcdHRoaXMuYWRkUm9vdE5vZGUodGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFBlcmZvcm1hbmNlIHNob3J0Y3V0LiBTZWUgbm90ZXMgaW4gXCJhc3NvY2lhdGVkTm9kZVwiLlxuXHRcdFx0dGhpcy5waHJhc2UuYXNzb2NpYXRlZE5vZGUgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHQvLy9pZiAoIShkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIFNwYW4pKVxuXHRcdFx0Ly8vXHRyZXR1cm4gdGhpcztcblx0XHRcdC8vL1xuXHRcdFx0Ly8vY29uc3QgdGVybSA9IGRlY2xhcmF0aW9uLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmICghKHRlcm0gaW5zdGFuY2VvZiBUZXJtKSlcblx0XHRcdC8vL1x0cmV0dXJuIHRoaXM7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2NvbnN0IGNvbnRhaW5lclBhdHRlcm4gPSAoKCkgPT5cblx0XHRcdC8vL3tcblx0XHRcdC8vL1x0Zm9yIChjb25zdCBkZWNsIG9mIHRoaXMuY29udGFpbmVyLmRlY2xhcmF0aW9ucylcblx0XHRcdC8vL1x0XHRpZiAoZGVjbC5ib3VuZGFyeS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdC8vL1x0XHRcdHJldHVybiBkZWNsLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHQvLy99KSgpO1xuXHRcdFx0Ly8vXG5cdFx0XHQvLy9pZiAoIWNvbnRhaW5lclBhdHRlcm4pXG5cdFx0XHQvLy9cdHJldHVybiB0aGlzO1xuXHRcdFx0Ly8vXG5cdFx0XHQvLy9mb3IgKGNvbnN0IG5meCBvZiBjb250YWluZXJQYXR0ZXJuLmdldEluZml4ZXMoSW5maXhGbGFncy5wb3B1bGF0aW9uKSlcblx0XHRcdC8vL1x0Zm9yIChjb25zdCB0ZXJtIG9mIG5meC5saHMuZWFjaFN1YmplY3QoKSlcblx0XHRcdC8vL1x0XHRpZiAodGVybS5mdWxsTmFtZSA9PT0gdGVybS5mdWxsTmFtZSlcblx0XHRcdC8vL1x0XHRcdC8vcmV0dXJuICh0aGlzLmNvbnRhaW5lckluZml4ID0gbmZ4KSwgdGhpcztcblx0XHRcdC8vL1x0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoaXMgTm9kZSwgYW5kIGFsbCBpdHMgY29udGVudHMgZnJvbSB0aGUgZ3JhcGguXG5cdFx0ICovXG5cdFx0ZGlzcG9zZSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuY29udGFpbmVyID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBtYXAgPSBOb2RlLnJvb3ROb2Rlcy5nZXQodGhpcy5kb2N1bWVudCk7XG5cdFx0XHRcdGlmIChtYXApXG5cdFx0XHRcdFx0bWFwLmRlbGV0ZSh0aGlzLnN1YmplY3QpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB0aGlzLmNvbnRhaW5lci5fY29udGVudHMuZGVsZXRlKHRoaXMuc3ViamVjdCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaWIgb2YgdGhpcy5faW5ib3VuZHMpXG5cdFx0XHRcdGliLnJlbW92ZVN1Y2Nlc3Nvcih0aGlzKTtcblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gcmVjdXJzZShub2RlOiBOb2RlKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAobm9kZS5waHJhc2UuYXNzb2NpYXRlZE5vZGUgPT09IG5vZGUpXG5cdFx0XHRcdFx0bm9kZS5waHJhc2UuYXNzb2NpYXRlZE5vZGUgPSBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBlZGdlIG9mIG5vZGUuX291dGJvdW5kcylcblx0XHRcdFx0XHRub2RlLmRpc3Bvc2VFZGdlKGVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBjb250YWluZWROb2RlIG9mIG5vZGUuX2NvbnRlbnRzLnZhbHVlcygpKVxuXHRcdFx0XHRcdHJlY3Vyc2UoY29udGFpbmVkTm9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBNYW51YWwgbWVtb3J5IG1hbmFnZW1lbnQgZ29pbmcgb24gaGVyZS5cblx0XHRcdFx0Ly8gQ2xlYXJpbmcgb3V0IHRoZSBTZXRzIGlzIHByb2JhYmx5IHVubmVjZXNzYXJ5XG5cdFx0XHRcdC8vIGJlY2F1c2UgdGhlIEdDIHdvdWxkIGNhdGNoIGl0IGFueXdheXMsIGJ1dFxuXHRcdFx0XHQvLyB0aGVzZSBjYWxscyBhcmUgaGVyZSBqdXN0IHRvIGJlIHNhZmUuXG5cdFx0XHRcdC8vIEl0J3Mgc3RpbGwgcmVxdWlyZWQgdGhhdCB3ZSBjbGVhciBvdXQgdGhlIGluYm91bmRzXG5cdFx0XHRcdC8vIGZyb20gdGhlIG5vZGVzIHRvIHdoaWNoIHRoaXMgb25lIGlzIGNvbm5lY3RlZC5cblx0XHRcdFx0bm9kZS5fZGVjbGFyYXRpb25zLmNsZWFyKCk7XG5cdFx0XHRcdG5vZGUuX2luYm91bmRzLmNsZWFyKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJlY3Vyc2UodGhpcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBIeXBlckVkZ2UgZnJvbSB0aGlzIE5vZGUnc1xuXHRcdCAqIHNldCBvZiBvdXRib3VuZHMuXG5cdFx0ICogXG5cdFx0ICogQHRocm93cyBJbiB0aGUgY2FzZSB3aGVuIHRoZSBzcGVjaWZpZWQgSHlwZXJFZGdlIGlzXG5cdFx0ICogbm90IG93bmVkIGJ5IHRoaXMgTm9kZS5cblx0XHQgKi9cblx0XHRkaXNwb3NlRWRnZShlZGdlOiBIeXBlckVkZ2UpXG5cdFx0e1xuXHRcdFx0aWYgKGVkZ2UucHJlZGVjZXNzb3IgIT09IHRoaXMpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWR4ID0gdGhpcy5fb3V0Ym91bmRzLmluZGV4T2YoZWRnZSk7XG5cdFx0XHR0aGlzLl9vdXRib3VuZHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc2NzciBvZiBlZGdlLnN1Y2Nlc3NvcnMpXG5cdFx0XHRcdHNjc3Iubm9kZS5faW5ib3VuZHMuZGVsZXRlKGVkZ2UpO1xuXHRcdFx0XG5cdFx0XHRlZGdlLmNsZWFyRnJhZ21lbnRzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGNvbnRhaW5lcjogTm9kZSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluIHRoZSBjYXNlIHdoZW4gdGhpcyBub2RlIGlzIGEgZGlyZWN0IGRlc2NlbmRlbnQgb2YgYVxuXHRcdCAqIHBhdHRlcm4gbm9kZSwgYW5kIHRoYXQgcGF0dGVybiBoYXMgcG9wdWxhdGlvbiBpbmZpeGVzLFxuXHRcdCAqIGFuZCB0aGlzIG5vZGUgZGlyZWN0bHkgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRob3NlIGluZml4ZXMsXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSBnZXRzIGEgcmVmZXJlbmNlIHRvIHNhaWQgY29ycmVzcG9uZGluZyBpbmZpeC5cblx0XHQgKi9cblx0XHRnZXQgY29udGFpbmVySW5maXgoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGZsYWcgPSBJbmZpeEZsYWdzLnBvcHVsYXRpb247XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmNvbnRhaW5lcj8uc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdGZvciAoY29uc3QgbmZ4IG9mIHRoaXMuY29udGFpbmVyLnN1YmplY3QuZ2V0SW5maXhlcyhmbGFnKSlcblx0XHRcdFx0XHRpZiAobmZ4Lmxocy5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5meDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEdldHMgYSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgTm9kZSdzIHN1YmplY3QsXG5cdFx0ICogZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBvbmx5LlxuXHRcdCAqL1xuXHRcdGdldCBuYW1lKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gU3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwodGhpcy5zdWJqZWN0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgc3ViamVjdDogU3ViamVjdDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBwaHJhc2U6IFBocmFzZTtcblx0XHRcblx0XHQvKiogU3RvcmVzIHRoZSBkb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoaXMgTm9kZS4gKi9cblx0XHRyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQ7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgc3RhbXA6IFZlcnNpb25TdGFtcDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGlzIE5vZGUgaGFzIGJlZW4gZXhwbGljaXRseSBkZWZpbmVkIGFzXG5cdFx0ICogYSBsaXN0IGludHJpbnNpYy5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc0xpc3RJbnRyaW5zaWM6IGJvb2xlYW47XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgTm9kZSBoYXMgYmVlbiBleHBsaWNpdGx5IGRlZmluZWQgYXMgYSBsaXN0XG5cdFx0ICogZXh0cmluc2ljLiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB0aGlzIHByb3BlcnR5IGluIGFuZCBvZiBpdHNlbGYgaXNcblx0XHQgKiBub3Qgc3VmZmljaWVudCB0byBkZXRlcm1pbmUgd2hldGhlciBhbnkgY29ycmVzcG9uZGluZyB0eXBlIGlzXG5cdFx0ICogYWN0dWFsbHkgYSBsaXN0IChmdWxsIHR5cGUgYW5hbHlzaXMgaXMgcmVxdWlyZWQgdG8gbWFrZSB0aGlzIGNvbmNsdXNpb24pLlxuXHRcdCAqL1xuXHRcdGdldCBpc0xpc3RFeHRyaW5zaWMoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgb2Igb2YgdGhpcy5vdXRib3VuZHMpXG5cdFx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIG9iLmZyYWdtZW50cylcblx0XHRcdFx0XHRpZiAoc291cmNlLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBUZXJtKVxuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZS5ib3VuZGFyeS5zdWJqZWN0LmlzTGlzdClcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgXCJvcHBvc2l0ZSBzaWRlIG9mIHRoZSBsaXN0XCIuXG5cdFx0ICogXG5cdFx0ICogSWYgdGhpcyBOb2RlIHJlcHJlc2VudHMgYSBsaXN0IGludHJpbnNpYyB0eXBlLCB0aGlzIHByb3BlcnR5IGdldHNcblx0XHQgKiBhIHJlZmVyZW5jZSB0byB0aGUgTm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvcnJlc3BvbmRpbmdcblx0XHQgKiBleHRyaW5zaWMgc2lkZS5cblx0XHQgKiBcblx0XHQgKiBJZiB0aGlzIE5vZGUgcmVwcmVzZW50cyBhbnl0aGluZyB0aGF0ICppc24ndCogYSBsaXN0IGludHJpbnNpYyB0eXBlLFxuXHRcdCAqIHRoZSBwcm9wZXJ0eSBnZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBOb2RlIHRoYXQgcmVwcmVzZW50cyB0aGVcblx0XHQgKiBjb3JyZXNwb25kaW5nIGludHJpbnNpYyBzaWRlICh3aGV0aGVyIHRoZSBub2RlIGlzIGEgbGlzdCBvciBub3QpLlxuXHRcdCAqIFxuXHRcdCAqIEdldHMgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgbGlzdCBpbnRyaW5zaWNcblx0XHQgKiBvciBleHRyaW5zaWMgTm9kZSB0byBjb25uZWN0LlxuXHRcdCAqL1xuXHRcdGdldCBpbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UoKTogTm9kZSB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5zdWJqZWN0IGluc3RhbmNlb2YgVGVybSlcblx0XHRcdFx0Zm9yIChjb25zdCBhZGphY2VudCBvZiB0aGlzLmFkamFjZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0XHRpZiAoYWRqYWNlbnQuc3ViamVjdCBpbnN0YW5jZW9mIFRlcm0pXG5cdFx0XHRcdFx0XHRpZiAoYWRqYWNlbnQuc3ViamVjdCA9PT0gdGhpcy5zdWJqZWN0KVxuXHRcdFx0XHRcdFx0XHRpZiAoYWRqYWNlbnQuc3ViamVjdC5pc0xpc3QgIT09IHRoaXMuaXNMaXN0SW50cmluc2ljKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBhZGphY2VudDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc2V0IG9mIGRlY2xhcmF0aW9uLXNpZGUgU3BhbiBpbnN0YW5jZXMgdGhhdFxuXHRcdCAqIGNvbXBvc2UgdGhpcyBOb2RlLiBJZiB0aGlzIHRoZSBzaXplIG9mIHRoaXMgc2V0IHdlcmUgdG9cblx0XHQgKiByZWFjaCB6ZXJvLCB0aGUgTm9kZSB3b3VsZCBiZSBtYXJrZWQgZm9yIGRlbGV0aW9uLlxuXHRcdCAqIChOb2RlIGNsZWFudXAgdXNlcyBhIHJlZmVyZW5jZSBjb3VudGVkIGNvbGxlY3Rpb25cblx0XHQgKiBtZWNoYW5pc20gdGhhdCB1c2VzIHRoZSBzaXplIG9mIHRoaXMgc2V0IGFzIGl0J3MgZ3VpZGUpLlxuXHRcdCAqIFxuXHRcdCAqIE5vdGUgdGhhdCBhbHRob3VnaCB0aGUgdHlwZSBvZiB0aGlzIGZpZWxkIGlzIGRlZmluZWQgYXNcblx0XHQgKiBcIlNldDxTcGFuIHwgSW5maXhTcGFuPlwiLCBpbiBwcmFjdGljZSwgaXQgaXMgZWl0aGVyIGEgc2V0XG5cdFx0ICogb2YgU3BhbiBpbnN0YW5jZXMsIG9yIGEgc2V0IGNvbnRhaW5pbmcgb25lIHNpbmdsZVxuXHRcdCAqIEluZml4U3BhbiBpbnN0YW5jZS4gVGhpcyBpcyBiZWNhdXNlIGl0J3MgcG9zc2libGUgdG8gaGF2ZVxuXHRcdCAqIGZyYWdtZW50cyBvZiBhIHR5cGUgZGVjbGFyZWQgaW4gbXVsdGlwbGUgcGxhY2VzIGluXG5cdFx0ICogYSBkb2N1bWVudCwgaG93ZXZlciwgSW5maXhTcGFucyBjYW4gb25seSBleGlzdCBpbiBvbmVcblx0XHQgKiBwbGFjZS5cblx0XHQgKi9cblx0XHRnZXQgZGVjbGFyYXRpb25zKCk6IFJlYWRvbmx5U2V0PFNwYW4gfCBJbmZpeFNwYW4+XG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RlY2xhcmF0aW9ucztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfZGVjbGFyYXRpb25zOiBTZXQ8U3BhbiB8IEluZml4U3Bhbj47XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkRGVjbGFyYXRpb24oc3BhbjogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHR0aGlzLl9kZWNsYXJhdGlvbnMuYWRkKHNwYW4pO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZW1vdmVEZWNsYXJhdGlvbihzcGFuOiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHdhc0RlbGV0ZWQgPSB0aGlzLl9kZWNsYXJhdGlvbnMuZGVsZXRlKHNwYW4pO1xuXHRcdFx0aWYgKHdhc0RlbGV0ZWQpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbGwgb2YgdGhlIGFubm90YXRpb25zIHRoYXQgZXhpc3Qgb24gdGhlIHNhbWVcblx0XHRcdFx0Ly8gc3RhdGVtZW50IGFzIHRoZSBvbmUgdGhhdCBjb250YWlucyB0aGUgZGVjbGFyYXRpb24gdGhhdFxuXHRcdFx0XHQvLyB3YXMgcmVtb3ZlZC4gTm90ZSB0aGF0IHRoaXMgd29uJ3QgbWVzcyB1cCBmcmFnbWVudGVkXG5cdFx0XHRcdC8vIHR5cGVzLiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhlIHNpdHVhdGlvbiB3aGVuIHRoZSBmaXJzdFxuXHRcdFx0XHQvLyBzdGF0ZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBmb2xsb3dpbmcgZG9jdW1lbnQ6XG5cdFx0XHRcdC8vIFxuXHRcdFx0XHQvLyBBLCBCIDogWCwgWVxuXHRcdFx0XHQvLyBBLCBDIDogWCwgWVxuXHRcdFx0XHQvLyBcblx0XHRcdFx0Ly8gU3RhdGVtZW50cyBhcmUgcmVtb3ZlZCBhdG9taWNhbGx5LCBzbyB3aGVuIHRoZSBzdGF0ZW1lbnRcblx0XHRcdFx0Ly8gaXMgcmVtb3ZlZCwgdGhpcyB3aWxsIHJlc3VsdCBpbiAyIGNhbGxzIHRvIHRoaXMgbWV0aG9kOiBvbmUgZm9yXG5cdFx0XHRcdC8vIHRoZSBmaXJzdCBcIkFcIiwgYW5kIG9uZSBmb3IgdGhlIFwiQlwiLiBXaGVuIHRoZSBzZWNvbmQgY2FsbCBpcyBtYWRlLFxuXHRcdFx0XHQvLyB0aGUgYXNzb2NpYXRlZCBhbm5vdGF0aW9ucyB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHJlbW92ZWQuXG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gdGhpcy5fb3V0Ym91bmRzLmxlbmd0aDsgaS0tID4gMDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBvYiA9IHRoaXMuX291dGJvdW5kc1tpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGFubm8gb2Ygc3Bhbi5zdGF0ZW1lbnQuYWxsQW5ub3RhdGlvbnMpXG5cdFx0XHRcdFx0XHRvYi5yZW1vdmVGcmFnbWVudChhbm5vKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAob2IuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdHRoaXMuX291dGJvdW5kcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdGF0ZW1lbnRzIHRoYXRcblx0XHQgKiBjb250YWluIHRoaXMgTm9kZS5cblx0XHQgKi9cblx0XHRnZXQgc3RhdGVtZW50cygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoXG5cdFx0XHRcdEFycmF5LmZyb20odGhpcy5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdFx0Lm1hcChkZWNsID0+IGRlY2wuc3RhdGVtZW50KVxuXHRcdFx0XHRcdC5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgcmVhZG9ubHkgbWFwIG9mIE5vZGVzIHRoYXQgYXJlIGNvbnRhaW5lZFxuXHRcdCAqIGJ5IHRoaXMgbm9kZSBpbiB0aGUgY29udGFpbm1lbnQgaGllcmFyY2h5LlxuXHRcdCAqL1xuXHRcdGdldCBjb250ZW50cygpOiBOb2RlTWFwXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnRzO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9jb250ZW50cyA9IG5ldyBNYXA8U3ViamVjdCwgTm9kZT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgcmVhZG9ubHkgbmFtZSBvZiBOb2RlcyB0aGF0IGFyZSBhZGphY2VudFxuXHRcdCAqIHRvIHRoaXMgTm9kZSBpbiB0aGUgY29udGFpbm1lbnQgaGllcmFyY2h5LlxuXHRcdCAqL1xuXHRcdGdldCBhZGphY2VudHMoKTogTm9kZU1hcFxuXHRcdHtcblx0XHRcdGNvbnN0IGFkamFjZW50Tm9kZXMgPSB0aGlzLmNvbnRhaW5lciA/XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyLmNvbnRlbnRzIDpcblx0XHRcdFx0dGhpcy5nZXRSb290Tm9kZXMoKTtcblx0XHRcdFxuXHRcdFx0Ly8gRmlsdGVyIHRoaXMgbm9kZSBvdXQgb2YgdGhlIHJlc3VsdCBzZXQsIGJlY2F1c2Vcblx0XHRcdC8vIE5vZGVzIGNhbm5vdCBiZSBhZGphY2VudCB0byB0aGVtc2VsdmVzLlxuXHRcdFx0Y29uc3Qgb3V0ID0gbmV3IE1hcDxTdWJqZWN0LCBOb2RlPigpO1xuXHRcdFx0Zm9yIChjb25zdCBbc3ViamVjdCwgbm9kZV0gb2YgYWRqYWNlbnROb2Rlcylcblx0XHRcdFx0aWYgKG5vZGUgIT09IHRoaXMpXG5cdFx0XHRcdFx0b3V0LnNldChzdWJqZWN0LCBub2RlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIDItZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2Zcblx0XHQgKiB0aGUgcG9ydGFiaWxpdHkgaW5maXhlcyB0aGF0IGhhdmUgYmVlbiBkZWZpbmVkIHdpdGhpblxuXHRcdCAqIHRoaXMgbm9kZSwgd2l0aCB0aGUgZmlyc3QgZGltZW5zaW9uIGNvcnJlc3BvbmRpbmcgdG9cblx0XHQgKiBhIHVuaXF1ZSBwb3J0YWJpbGl0eSBpbmZpeCwgYW5kIHRoZSBzZWNvbmQgZGltZW5zaW9uXG5cdFx0ICogY29ycmVzcG9uZGluZyB0byB0aGUgbmFtZXMgZGVmaW5lZCB3aXRoaW4gdGhhdCBpbmZpeC5cblx0XHQgKiBcblx0XHQgKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuXHRcdCAqIC88IDogQSwgQiwgQz48IDogRCwgRSwgRj4gOiA/Pz9cblx0XHQgKiBcblx0XHQgKiBUaGUgZm9sbG93aW5nIHJlc3VsdCB3b3VsZCBiZSBwcm9kdWNlZDpcblx0XHQgKiBbW1wiQVwiLCBcIkJcIiwgXCJDXCJdLCBbXCJEXCIsIFwiRVwiLCBcIkZcIl1dXG5cdFx0ICovXG5cdFx0Z2V0IHBvcnRhYmlsaXR5VGFyZ2V0cygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX3BvcnRhYmlsaXR5VGFyZ2V0cyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BvcnRhYmlsaXR5VGFyZ2V0cztcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybikpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wb3J0YWJpbGl0eVRhcmdldHMgPSBbXTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX3BvcnRhYmlsaXR5VGFyZ2V0cyA9IHRoaXMuc3ViamVjdFxuXHRcdFx0XHQuZ2V0SW5maXhlcyhJbmZpeEZsYWdzLnBvcnRhYmlsaXR5KVxuXHRcdFx0XHQubWFwKG5meCA9PiBBcnJheS5mcm9tKG5meC5yaHMuZWFjaFN1YmplY3QoKSkpO1xuXHRcdH1cblx0XHRwcml2YXRlIF9wb3J0YWJpbGl0eVRhcmdldHM6IHJlYWRvbmx5IChyZWFkb25seSBUZXJtW10pW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHNldCBvZiBub2RlcyB0aGF0IGFyZSBtYXRjaGVkIGJ5XG5cdFx0ICogcGF0dGVybnMgb2YgYWRqYWNlbnQgbm9kZXMuXG5cdFx0ICogXG5cdFx0ICogKE5vdGUgdGhhdCB0aGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgYW5ub3RhdGlvbnNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIGEgcGF0dGVybiBjYW5ub3QgYmVcblx0XHQgKiBwb2x5bW9ycGhpYylcblx0XHQgKi9cblx0XHRnZXRQYXR0ZXJuTm9kZXNNYXRjaGluZyhub2RlczogTm9kZVtdKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dE5vZGVzOiBOb2RlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoaXMgZG9lc24ndCB3b3JrIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBpZlxuXHRcdFx0Ly8gYSBub2RlIGhhcyBiZWVuIG1hcmtlZCBhcyBjcnVmdCBhdCB0aGlzIHBvaW50LlxuXHRcdFx0Ly8gVGhpcyBtZXRob2QgbWF5IHJldHVybiBqdW5rIHJlc3VsdHMgaW4gdGhlXG5cdFx0XHQvLyBjYXNlIHdoZW4gb25lIG9mIHRoZSByZXF1aXJlZCBub2RlcyBoYXNcblx0XHRcdC8vIGJlZW4gbWFya2VkIGFzIGNydWZ0IChidXQgdGhlbiwgd291bGRuJ3QgdGhlXG5cdFx0XHQvLyBpbmNvbWluZyBub2RlIGFsc28gYmUgY3J1ZnQ/KVxuXHRcdFx0Ly9cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBub2RlIG9mIHRoaXMuYWRqYWNlbnRzLnZhbHVlcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAobm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHVub3JwaGFuZWQgPSBub2RlLm91dGJvdW5kc1xuXHRcdFx0XHRcdFx0LmZpbHRlcihvYiA9PiBvYi5zdWNjZXNzb3JzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0XHQubWFwKG9iID0+IG9iLnN1Y2Nlc3NvcnNbMF0ubm9kZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVub3JwaGFuZWQubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVub3JwaGFuZWQubGVuZ3RoID09PSBub2Rlcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRpZiAodW5vcnBoYW5lZC5ldmVyeShub2RlID0+IG5vZGVzLmluY2x1ZGVzKG5vZGUpKSlcblx0XHRcdFx0XHRcdFx0b3V0Tm9kZXMucHVzaCguLi51bm9ycGhhbmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0Tm9kZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gaW1tdXRhYmxlIHNldCBvZiBIeXBlckVkZ2VzIGZyb20gYWRqYWNlbnRcblx0XHQgKiBvciBjb250YWluZWQgTm9kZXMgdGhhdCByZWZlcmVuY2UgdGhpcyBOb2RlLiBcblx0XHQgKiBcblx0XHQgKiAoVGhlIG9yZGVyaW5nIG9mIGluYm91bmRzIGlzbid0IGltcG9ydGFudCwgYXNcblx0XHQgKiB0aGV5IGhhdmUgbm8gcGh5c2ljYWwgcmVwcmVzZW50YXRpb24gaW4gdGhlXG5cdFx0ICogZG9jdW1lbnQsIHdoaWNoIGlzIHdoeSB0aGV5J3JlIHN0b3JlZCBpbiBhIFNldFxuXHRcdCAqIHJhdGhlciB0aGFuIGFuIGFycmF5Lilcblx0XHQgKi9cblx0XHRnZXQgaW5ib3VuZHMoKTogUmVhZG9ubHlTZXQ8SHlwZXJFZGdlPlxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9pbmJvdW5kcztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfaW5ib3VuZHMgPSBuZXcgU2V0PEh5cGVyRWRnZT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IG9mIEh5cGVyRWRnZXMgdGhhdCBjb25uZWN0IHRoaXMgTm9kZSB0b1xuXHRcdCAqIG90aGVycywgYmVpbmcgZWl0aGVyIGFkamFjZW50cywgb3IgTm9kZXMgdGhhdFxuXHRcdCAqIGV4aXN0cyBzb21ld2hlcmUgaW4gdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeS5cblx0XHQgKi9cblx0XHRnZXQgb3V0Ym91bmRzKCk6IHJlYWRvbmx5IEh5cGVyRWRnZVtdXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX291dGJvdW5kcztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfb3V0Ym91bmRzOiBIeXBlckVkZ2VbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIFNvcnRzIHRoZSBvdXRib3VuZCBIeXBlckVkZ2VzLCBzbyB0aGF0IHRoZXkncmUgb3JkZXJpbmdcblx0XHQgKiBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHdheSB0aGVpciBjb3JyZXNwb25kaW5nXG5cdFx0ICogYW5ub3RhdGlvbnMgYXBwZWFyIGluIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHNvcnRPdXRib3VuZHMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9vdXRib3VuZHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9vdXRib3VuZHMubGVuZ3RoID09PSAxKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBlZGdlID0gdGhpcy5fb3V0Ym91bmRzWzBdO1xuXHRcdFx0XHRpZiAoZWRnZS5mcmFnbWVudHMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZWRnZUxvb2t1cCA9IG5ldyBNYXA8SHlwZXJFZGdlLCBbU3RhdGVtZW50LCBudW1iZXJdPigpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5fb3V0Ym91bmRzKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHNyYyBvZiBlZGdlLmZyYWdtZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHNtdCA9IHNyYy5zdGF0ZW1lbnQ7XG5cdFx0XHRcdFx0Y29uc3QgbGluZU51bSA9IHNtdC5kb2N1bWVudC5saW5lTnVtYmVyT2Yoc210KTtcblx0XHRcdFx0XHRjb25zdCBleGlzdGluZ1R1cGxlID0gZWRnZUxvb2t1cC5nZXQoZWRnZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nVHVwbGUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBleGlzdGluZ1N0bXQgPSBleGlzdGluZ1R1cGxlWzBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdTdG10TGluZU51bSA9IGV4aXN0aW5nVHVwbGVbMV07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChsaW5lTnVtIDwgZXhpc3RpbmdTdG10TGluZU51bSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZXhpc3RpbmdUdXBsZVswXSA9IGV4aXN0aW5nU3RtdDtcblx0XHRcdFx0XHRcdFx0ZXhpc3RpbmdUdXBsZVsxXSA9IGV4aXN0aW5nU3RtdExpbmVOdW07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGdlTG9va3VwLnNldChlZGdlLCBbc210LCBsaW5lTnVtXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFNvcnQgdGhlIG91dHB1dCBlZGdlcyBpbiB0aGUgYXJyYXksIHNvIHRoYXQgdGhlIHNvcnRpbmcgb2Zcblx0XHRcdC8vIHRoZSBhcnJheSBhbGlnbnMgd2l0aCB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgdW5kZXJseWluZ1xuXHRcdFx0Ly8gc3BhbnMgaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0dGhpcy5fb3V0Ym91bmRzLnNvcnQoKGVkZ2VBLCBlZGdlQikgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdHVwbGVBID0gZWRnZUxvb2t1cC5nZXQoZWRnZUEpO1xuXHRcdFx0XHRjb25zdCB0dXBsZUIgPSBlZGdlTG9va3VwLmdldChlZGdlQik7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBvYnMgPSB0aGlzLl9vdXRib3VuZHM7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodHVwbGVBID09PSB1bmRlZmluZWQgfHwgdHVwbGVCID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgW3NtdEEsIHNtdElkeEFdID0gdHVwbGVBO1xuXHRcdFx0XHRjb25zdCBbc210Qiwgc210SWR4Ql0gPSB0dXBsZUI7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB0aGUgdG9wLW1vc3Qgc3BhbiBvZiB0aGUgcHJlZGVjZXNzb3JzIG9mXG5cdFx0XHRcdC8vIHRoZSBlZGdlcyBhcmUgbG9jYXRlZCBpbiBkaWZmZXJlbnQgc3RhdGVtZW50cyxcblx0XHRcdFx0Ly8gYSBzaW1wbGUgY29tcGFyaXNvbiBvZiB0aGUgc3RhdGVtZW50IGluZGV4ZXNcblx0XHRcdFx0Ly8gaXMgcG9zc2libGUuXG5cdFx0XHRcdGlmIChzbXRJZHhBIDwgc210SWR4Qilcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc210SWR4QiA8IHNtdElkeEEpXG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBzdGF0ZW1lbnQgQSBhbmQgc3RhdGVtZW50IEIgXG5cdFx0XHRcdC8vIGFyZSBhY3R1YWxseSBlcXVhbC5cblx0XHRcdFx0aWYgKHNtdEEgIT09IHNtdEIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGFubm9zID0gc210QS5hbm5vdGF0aW9ucztcblx0XHRcdFx0Y29uc3QgZmluZE1pbkluZGV4ID0gKGVkZ2U6IEh5cGVyRWRnZSkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBtaW5JZHggPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNyYyBvZiBlZGdlLmZyYWdtZW50cylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoc3JjIGluc3RhbmNlb2YgSW5maXhTcGFuKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IGlkeCA9IGFubm9zLmluZGV4T2Yoc3JjKTtcblx0XHRcdFx0XHRcdGlmIChpZHggPCBtaW5JZHgpXG5cdFx0XHRcdFx0XHRcdG1pbklkeCA9IGlkeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1pbklkeCA9PT0gSW5maW5pdHkpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG1pbklkeDtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGVkZ2VBSWR4ID0gZmluZE1pbkluZGV4KGVkZ2VBKTtcblx0XHRcdFx0Y29uc3QgZWRnZUJJZHggPSBmaW5kTWluSW5kZXgoZWRnZUIpO1xuXHRcdFx0XHRyZXR1cm4gZWRnZUFJZHggLSBlZGdlQklkeDtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBBZGRzIGEgbmV3IGVkZ2UgdG8gdGhlIG5vZGUsIG9yIHVwZGF0ZXMgYW4gZXhpc3Rpbmcgb25lIHdpdGhcblx0XHQgKiBhIG5ldyBmcmFnbWVudC5cblx0XHQgKiBcblx0XHQgKiBJZiBubyBlZGdlIGV4aXN0cyBmb3IgdGhlIG5ldyBmcmFnbWVudCwgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdFx0ICovXG5cdFx0YWRkRWRnZUZyYWdtZW50KGZyYWdtZW50OiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRlcm0gPSBmcmFnbWVudC5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0aWYgKCEodGVybSBpbnN0YW5jZW9mIFRlcm0pKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBpbnB1dCBzb3VyY2UgaXMgXCJhbG9uZVwiLCBpdCBtZWFucyB0aGF0IGl0IHJlZmVycyB0b1xuXHRcdFx0Ly8gYSBzdGF0ZW1lbnQtbGV2ZWwgYW5ub3RhdGlvbiB0aGF0IGhhcyBubyBvdGhlciBhbm5vdGF0aW9uc1xuXHRcdFx0Ly8gYmVzaWRlIGl0IChlLmcuIGluIGFuIGFubm90YXRpb24gc3RydWN0dXJlIGxvb2tpbmcgbGlrZSBcIkQ6IEExLCBBMlwiKVxuXHRcdFx0Ly8gVGhpcyBpcyByZWxldmFudCwgYmVjYXVzZSBpZiB0aGUgc291cmNlIGlzIGFsb25lLCBpdCBhbHNvIG5lZWRzXG5cdFx0XHQvLyB0byBiZSBjb21wYXJlZCBhZ2FpbnN0IGFueSB2aXNpYmxlIHRvdGFsIHBhdHRlcm5zLlxuXHRcdFx0Y29uc3Qgc291cmNlSXNBbG9uZSA9XG5cdFx0XHRcdGZyYWdtZW50IGluc3RhbmNlb2YgU3BhbiAmJiBcblx0XHRcdFx0ZnJhZ21lbnQuc3RhdGVtZW50LmFubm90YXRpb25zLmxlbmd0aCA9PT0gMTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIGFuIGVkZ2UgdG8gaXQncyB0d28gYXBwbGljYWJsZSBzdWNjZXNzb3Igbm9kZXMuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGFwcGVuZCA9IChlZGdlOiBIeXBlckVkZ2UpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX291dGJvdW5kcy5wdXNoKGVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBzdWMgb2YgZWRnZS5zdWNjZXNzb3JzKVxuXHRcdFx0XHRcdHN1Yy5ub2RlLl9pbmJvdW5kcy5hZGQoZWRnZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGV4aXN0aW5nIG91dGJvdW5kIEh5cGVyRWRnZSwgd2UgY2FuXG5cdFx0XHQvLyBhZGQgdGhlIG5ldyBTcGFuIHRvIHRoZSBlZGdlJ3MgbGlzdCBvZiBTcGFucywgYW5kIHF1aXQuXG5cdFx0XHQvLyBUaGlzIHdvcmtzIHdoZXRoZXIgdGhlIGVkZ2UgaXMgZm9yIGEgdHlwZSBvciBwYXR0ZXJuLlxuXHRcdFx0Y29uc3QgZXhpc3RpbmdFZGdlID0gdGhpcy5fb3V0Ym91bmRzLmZpbmQoZWRnZSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZWRnZS50ZXJtLnNpbmd1bGFyID09PSB0ZXJtLnNpbmd1bGFyO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGlmIChleGlzdGluZ0VkZ2UpXG5cdFx0XHR7XG5cdFx0XHRcdGV4aXN0aW5nRWRnZS5hZGRGcmFnbWVudChmcmFnbWVudCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN1Y2Nlc3NvcnM6IFN1Y2Nlc3NvcltdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGxldmVsIG9mIHRoaXMuZW51bWVyYXRlQ29udGFpbm1lbnQoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN1Y2Nlc3Nvck5vZGUgPSBcblx0XHRcdFx0XHRcdGxldmVsLmNvbnRhaW5lciAhPT0gbnVsbCAmJiBcblx0XHRcdFx0XHRcdGxldmVsLmNvbnRhaW5lciAhPT0gdGhpcyAmJlxuXHRcdFx0XHRcdFx0bGV2ZWwuY29udGFpbmVyLnN1YmplY3QgPT09IHRlcm0gP1xuXHRcdFx0XHRcdFx0XHRsZXZlbC5jb250YWluZXIgOlxuXHRcdFx0XHRcdFx0XHRsZXZlbC5hZGphY2VudHMuZ2V0KHRlcm0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzdWNjZXNzb3JOb2RlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c3VjY2Vzc29ycy5wdXNoKG5ldyBTdWNjZXNzb3IoXG5cdFx0XHRcdFx0XHRcdHN1Y2Nlc3Nvck5vZGUsXG5cdFx0XHRcdFx0XHRcdGxldmVsLmxvbmdpdHVkZURlbHRhKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgYSBzaW5nbGUgc3VjY2Vzc29yIGluIHRoZSBjYXNlIHdoZW5cblx0XHRcdFx0XHRcdC8vIHRoZSBub2RlIGlzIGEgcGF0dGVybiBub2RlLCBiZWNhdXNlIHRoZSBhbm5vdGF0aW9ucyAod2hpY2hcblx0XHRcdFx0XHRcdC8vIGFyZSBldmVudHVhbGx5IGJlY29tZSBiYXNlcykgb2YgdGhlc2Ugbm9kZXMgZG8gbm90IGhhdmVcblx0XHRcdFx0XHRcdC8vIHBvbHltb3JwaGljIGJlaGF2aW9yLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0YXBwZW5kKG5ldyBIeXBlckVkZ2UodGhpcywgZnJhZ21lbnQsIHN1Y2Nlc3NvcnMpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gXG5cdFx0XHQvLyBSZWZyZXNoIHRoZSBzdW1zIGJlZm9yZSBxdWl0dGluZy5cblx0XHRcdC8vIFxuXHRcdFx0XG5cdFx0XHQvLy9jb25zdCBzdW1FZGdlRm9ySW5wdXRTcGFuSWR4ID0gdGhpcy5fb3V0Ym91bmRzLmZpbmRJbmRleChlZGdlID0+IFxuXHRcdFx0Ly8ve1xuXHRcdFx0Ly8vXHRpZiAoZWRnZS5raW5kID09PSBIeXBlckVkZ2VLaW5kLnN1bW1hdGlvbilcblx0XHRcdC8vL1x0XHRmb3IgKGNvbnN0IHNyYyBvZiBlZGdlLnNvdXJjZXMpXG5cdFx0XHQvLy9cdFx0XHRyZXR1cm4gc3JjLnN0YXRlbWVudCA9PT0gc210O1xuXHRcdFx0Ly8vXHRcblx0XHRcdC8vL1x0cmV0dXJuIGZhbHNlO1xuXHRcdFx0Ly8vfSk7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmIChzdW1FZGdlRm9ySW5wdXRTcGFuSWR4ID4gLTEpXG5cdFx0XHQvLy9cdHRoaXMuX291dGJvdW5kcy5zcGxpY2Uoc3VtRWRnZUZvcklucHV0U3BhbklkeCwgMSk7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmICghc291cmNlSXNBbG9uZSlcblx0XHRcdC8vL1x0Zm9yIChjb25zdCB7IGxvbmdpdHVkZURlbHRhLCBhZGphY2VudHMgfSBvZiB0aGlzLmVudW1lcmF0ZUNvbnRhaW5tZW50KCkpXG5cdFx0XHQvLy9cdFx0Zm9yIChjb25zdCBhZGphY2VudE5vZGUgb2YgYWRqYWNlbnRzLnZhbHVlcygpKVxuXHRcdFx0Ly8vXHRcdFx0aWYgKGFkamFjZW50Tm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdC8vL1x0XHRcdFx0aWYgKGFkamFjZW50Tm9kZS5zdWJqZWN0LmlzVG90YWwpXG5cdFx0XHQvLy9cdFx0XHRcdFx0aWYgKGFkamFjZW50Tm9kZS5zdWJqZWN0LnRlc3Qoc210LnN1bSkpXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRhcHBlbmQobmV3IEh5cGVyRWRnZShcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0c210LnN1bSxcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0W25ldyBTdWNjZXNzb3IoXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRcdFx0YWRqYWNlbnROb2RlLFxuXHRcdFx0Ly8vXHRcdFx0XHRcdFx0XHRcdGxvbmdpdHVkZURlbHRhKV0sXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRcdEh5cGVyRWRnZUtpbmQuc3VtbWF0aW9uKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGFkZEVkZ2VTdWNjZXNzb3Ioc3VjY2Vzc29yTm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCB0ZXJtID0gc3VjY2Vzc29yTm9kZS5zdWJqZWN0IGFzIFRlcm07XG5cdFx0XHRpZiAoISh0ZXJtIGluc3RhbmNlb2YgVGVybSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBvYiBvZiB0aGlzLm91dGJvdW5kcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKG9iLnRlcm0gIT09IHN1Y2Nlc3Nvck5vZGUuc3ViamVjdClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHNjc3JMb25nID0gc3VjY2Vzc29yTm9kZS5waHJhc2UubGVuZ3RoO1xuXHRcdFx0XHRjb25zdCBwcmVkTG9uZyA9IG9iLnByZWRlY2Vzc29yLnBocmFzZS5sZW5ndGg7XG5cdFx0XHRcdG9iLmFkZFN1Y2Nlc3NvcihzdWNjZXNzb3JOb2RlLCBwcmVkTG9uZyAtIHNjc3JMb25nKTtcblx0XHRcdFx0c3VjY2Vzc29yTm9kZS5faW5ib3VuZHMuYWRkKG9iKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRW51bWVyYXRlcyB1cHdhcmRzIHRocm91Z2ggdGhlIGNvbnRhaW5tZW50XG5cdFx0ICogaGllcmFyY2h5IG9mIHRoZSBOb2RlcyBwcmVzZW50IGluIHRoaXMgTm9kZSdzXG5cdFx0ICogY29udGFpbmluZyBkb2N1bWVudCwgeWllbGRpbmcgdGhlIGFkamFjZW50cyBhdFxuXHRcdCAqIGV2ZXJ5IGxldmVsLCBhbmQgdGhlbiBjb250aW51ZXMgdGhyb3VnaCB0byB0aGVcblx0XHQgKiByb290IGxldmVsIGFkamFjZW50cyBvZiBlYWNoIG9mIHRoZSBkb2N1bWVudCdzXG5cdFx0ICogZGVwZW5kZW5jaWVzLlxuXHRcdCAqL1xuXHRcdCplbnVtZXJhdGVDb250YWlubWVudCgpXG5cdFx0e1xuXHRcdFx0bGV0IGN1cnJlbnRMZXZlbDogTm9kZSB8IG51bGwgPSB0aGlzO1xuXHRcdFx0bGV0IGxvbmdpdHVkZUNvdW50ID0gMDtcblx0XHRcdFxuXHRcdFx0ZG9cblx0XHRcdHtcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdHNvdXJjZURvY3VtZW50OiB0aGlzLmRvY3VtZW50LFxuXHRcdFx0XHRcdGNvbnRhaW5lcjogY3VycmVudExldmVsIGFzIE5vZGUgfCBudWxsLFxuXHRcdFx0XHRcdGFkamFjZW50czogY3VycmVudExldmVsLmFkamFjZW50cyxcblx0XHRcdFx0XHRsb25naXR1ZGVEZWx0YTogbG9uZ2l0dWRlQ291bnQrK1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKChjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwuY29udGFpbmVyKSAhPT0gbnVsbCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZG9jIG9mIHRoaXMuZG9jdW1lbnQudHJhdmVyc2VEZXBlbmRlbmNpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdHNvdXJjZURvY3VtZW50OiBkb2MsXG5cdFx0XHRcdFx0Y29udGFpbmVyOiBudWxsLFxuXHRcdFx0XHRcdGFkamFjZW50czogdGhpcy5nZXRSb290Tm9kZXMoZG9jKSxcblx0XHRcdFx0XHRsb25naXR1ZGVEZWx0YTogbG9uZ2l0dWRlQ291bnRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgdGhhdCBzdG9yZXMgdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeVxuXHRcdCAqIG9mIHRoZSBOb2RlcyBwcmVzZW50IGluIHRoaXMgTm9kZSdzIGNvbnRhaW5pbmcgZG9jdW1lbnQsXG5cdFx0ICogeWllbGRpbmcgZWFjaCBjb250YWluZXJvZiB0aGlzIE5vZGUuXG5cdFx0ICovXG5cdFx0Z2V0IGNvbnRhaW5tZW50KClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fY29udGFpbm1lbnQgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jb250YWlubWVudDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRsZXQgY3VycmVudExldmVsOiBOb2RlIHwgbnVsbCA9IHRoaXM7XG5cdFx0XHR3aGlsZSAoKGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbC5jb250YWluZXIpICE9PSBudWxsKVxuXHRcdFx0XHRub2Rlcy5wdXNoKGN1cnJlbnRMZXZlbCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9jb250YWlubWVudCA9IE9iamVjdC5mcmVlemUobm9kZXMpO1xuXHRcdH1cblx0XHRwcml2YXRlIF9jb250YWlubWVudDogcmVhZG9ubHkgTm9kZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVtb3ZlRWRnZVNvdXJjZShzcmM6IFNwYW4gfCBJbmZpeFNwYW4pXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgaSA9IHRoaXMuX291dGJvdW5kcy5sZW5ndGg7IC0taSA+IDA7KVxuXHRcdFx0XHR0aGlzLl9vdXRib3VuZHNbaV0ucmVtb3ZlRnJhZ21lbnQoc3JjKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBhZGRSb290Tm9kZShub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGV4aXN0aW5nU2V0ID0gTm9kZS5yb290Tm9kZXMuZ2V0KG5vZGUuZG9jdW1lbnQpO1xuXHRcdFx0aWYgKGV4aXN0aW5nU2V0KVxuXHRcdFx0e1xuXHRcdFx0XHRleGlzdGluZ1NldC5zZXQobm9kZS5zdWJqZWN0LCBub2RlKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwID0gbmV3IE1hcDxTdWJqZWN0LCBOb2RlPigpO1xuXHRcdFx0XHRtYXAuc2V0KG5vZGUuc3ViamVjdCwgbm9kZSk7XG5cdFx0XHRcdE5vZGUucm9vdE5vZGVzLnNldChub2RlLmRvY3VtZW50LCBtYXApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlbW92ZVJvb3ROb2RlKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXhpc3RpbmdTZXQgPSBOb2RlLnJvb3ROb2Rlcy5nZXQobm9kZS5kb2N1bWVudCk7XG5cdFx0XHRpZiAoZXhpc3RpbmdTZXQpXG5cdFx0XHR7XG5cdFx0XHRcdGV4aXN0aW5nU2V0LmRlbGV0ZShub2RlLnN1YmplY3QpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhpcyBpcyBzb21ld2hhdCByZWR1bmRhbnQgYXMgdGhlIHNldFxuXHRcdFx0XHQvLyBpcyBsaWtlbHkgZ29pbmcgdG8gYmUgR0MnZCBhd2F5IGFueXdheSBpblxuXHRcdFx0XHQvLyB0aGlzIGNhc2UuIEl0J3MgaGVyZSBmb3IgY29tcGxldGVuZXNzIHNha2UuXG5cdFx0XHRcdGlmIChleGlzdGluZ1NldC5zaXplID09PSAwKVxuXHRcdFx0XHRcdE5vZGUucm9vdE5vZGVzLmRlbGV0ZShub2RlLmRvY3VtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBnZXRSb290Tm9kZXMoZnJvbURvY3VtZW50PzogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZnJvbURvYyA9IGZyb21Eb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50O1xuXHRcdFx0Y29uc3Qgb3V0ID0gTm9kZS5yb290Tm9kZXMuZ2V0KGZyb21Eb2MpIHx8IG5ldyBNYXA8U3ViamVjdCwgTm9kZT4oKTtcblx0XHRcdHJldHVybiBIaWdoZXJPcmRlci5jb3B5KG91dCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHJvb3ROb2RlcyA9IG5ldyBXZWFrTWFwPERvY3VtZW50LCBNYXA8U3ViamVjdCwgTm9kZT4+KCk7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoaW5jbHVkZVBhdGggPSB0cnVlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlY2xzID0gQXJyYXkuZnJvbSh0aGlzLmRlY2xhcmF0aW9ucyk7XG5cdFx0XHRjb25zdCBzcGFucyA9IGRlY2xzLmZpbHRlcigocyk6IHMgaXMgU3BhbiA9PiBzIGluc3RhbmNlb2YgU3Bhbik7XG5cdFx0XHRjb25zdCBhbmNob3JzID0gZGVjbHMuZmlsdGVyKChhKTogYSBpcyBJbmZpeFNwYW4gPT4gYSBpbnN0YW5jZW9mIEluZml4U3Bhbik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNwYW5zVGV4dCA9IHNwYW5zLm1hcChzID0+IFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKHMpKS5qb2luKFwiLCBcIik7XG5cdFx0XHRjb25zdCBhbmNob3JUZXh0ID0gYW5jaG9ycy5tYXAoYSA9PiBTdWJqZWN0U2VyaWFsaXplci5mb3JJbnRlcm5hbChhKSkuam9pbihcIiwgXCIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBvYiA9IHRoaXMub3V0Ym91bmRzLmxlbmd0aDtcblx0XHRcdGNvbnN0IGliID0gdGhpcy5pbmJvdW5kcy5zaXplO1xuXHRcdFx0Y29uc3QgcGF0aCA9IGluY2x1ZGVQYXRoID8gdGhpcy5waHJhc2UudG9TdHJpbmcoKSArIFwiIFwiIDogXCJcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc2ltcGxlID0gW1xuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRzcGFuc1RleHQubGVuZ3RoID8gXCJzcGFucz1cIiArIHNwYW5zVGV4dCA6IFwiXCIsXG5cdFx0XHRcdGFuY2hvclRleHQubGVuZ3RoID8gXCJhbmNob3I9XCIgKyBhbmNob3JUZXh0IDogXCJcIixcblx0XHRcdFx0XCJvdXQ9XCIgKyBvYixcblx0XHRcdFx0XCJpbj1cIiArIGliXG5cdFx0XHRdLmZpbHRlcihzID0+IHMudHJpbSgpKS5qb2luKFwiLCBcIik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZtdCA9IChzdHI6IHN0cmluZykgPT4gc3RyLnNwbGl0KFwiXFxuXCIpLm1hcChzID0+IFwiXFx0XFx0XCIgKyBzKS5qb2luKFwiXFxuXCIpO1xuXHRcdFx0Y29uc3Qgb2JzVmVyYm9zZSA9IHRoaXMub3V0Ym91bmRzXG5cdFx0XHRcdC5tYXAob2IgPT4gZm10KG9iLnRvU3RyaW5nKCkpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWJzVmVyYm9zZSA9IEFycmF5LmZyb20odGhpcy5pbmJvdW5kcy52YWx1ZXMoKSlcblx0XHRcdFx0Lm1hcChpYiA9PiBmbXQoaWIudG9TdHJpbmcoKSkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB2ZXJib3NlID0gXG5cdFx0XHRcdFwiXFxuXFx0T3V0czpcXG5cIiArIG9ic1ZlcmJvc2Uuam9pbihcIlxcblxcblwiKSArXG5cdFx0XHRcdFwiXFxuXFx0SW5zOlxcblwiICsgaWJzVmVyYm9zZS5qb2luKFwiXFxuXFxuXCIpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2ltcGxlICsgdmVyYm9zZTtcblx0XHR9XG5cdH1cblxuXHR0eXBlIE5vZGVNYXAgPSBSZWFkb25seU1hcDxTdWJqZWN0LCBOb2RlPjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBOb2RlSW5kZXhcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGluZGV4IGJ5IHJlZnJlc2hpbmcgaW4gdGhlIHNldCBvZiB0ZXJtc1xuXHRcdCAqIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIG5vZGUuXG5cdFx0ICovXG5cdFx0dXBkYXRlKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcGFzdFRlcm1zID0gdGhpcy5ub2Rlc1RvVGVybXNNYXAuZ2V0KG5vZGUpO1xuXHRcdFx0Y29uc3QgcHJlc2VudFRlcm1zID0gdGhpcy5nZXRBc3NvY2lhdGVkVGVybXMobm9kZSk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXN0VGVybXMgIT09IHVuZGVmaW5lZClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbaWR4LCB0ZXJtXSBvZiBwYXN0VGVybXMuZW50cmllcygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHByZXNlbnRUZXJtcy5pbmNsdWRlcyh0ZXJtKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHBhc3RUZXJtcy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBtYXAgPSB0aGlzLnRlcm1Ub05vZGVzTWFwLmdldCh0ZXJtKTtcblx0XHRcdFx0XHRpZiAobWFwID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRtYXAuZGVsZXRlKG5vZGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXAuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRcdHRoaXMudGVybVRvTm9kZXNNYXAuZGVsZXRlKHRlcm0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgdGVybSBvZiBwcmVzZW50VGVybXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5vZGVzRm9yVGVybSA9IHRoaXMudGVybVRvTm9kZXNNYXAuZ2V0KHRlcm0pIHx8ICgoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgb3V0ID0gbmV3IFNldDxOb2RlPigpO1xuXHRcdFx0XHRcdHRoaXMudGVybVRvTm9kZXNNYXAuc2V0KHRlcm0sIG91dCk7XG5cdFx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XG5cdFx0XHRcdG5vZGVzRm9yVGVybS5hZGQobm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMubm9kZXNUb1Rlcm1zTWFwLnNldChub2RlLCBwcmVzZW50VGVybXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBub2RlcyB0aGF0IGFyZSBhc3NvY2lhdGVkXG5cdFx0ICogd2l0aCB0aGUgc3BlY2lmaWVkIHRlcm0gdGhhdCBleGlzdCBhdCBvciBiZWxvdyB0aGUgc3BlY2lmaWVkXG5cdFx0ICogZGVwdGguIFwiQXNzb2NpYXRlZFwiIG1lYW5zIHRoYXQgdGhlIHRlcm0gaXMgZWl0aGVyIGVxdWl2YWxlbnRcblx0XHQgKiB0byB0aGUgTm9kZSdzIG1haW4gc3ViamVjdCwgb3IgaXQgaXMgcmVmZXJlbmNlZCBpbiBvbmUgb2YgaXQncyBlZGdlcy5cblx0XHQgKi9cblx0XHRnZXROb2Rlc0J5VGVybSh0ZXJtOiBUZXJtKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IHRoaXMudGVybVRvTm9kZXNNYXAuZ2V0KHRlcm0pO1xuXHRcdFx0cmV0dXJuIG91dCA/IEFycmF5LmZyb20ob3V0KSA6IFtdO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbm9kZSBmcm9tIHRoZSBpbmRleCwgaWYgaXQgZXhpc3RzLlxuXHRcdCAqL1xuXHRcdGRlbGV0ZShkZWFkTm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCBleGlzdGluZ1Rlcm1zID0gdGhpcy5ub2Rlc1RvVGVybXNNYXAuZ2V0KGRlYWROb2RlKTtcblx0XHRcdGlmIChleGlzdGluZ1Rlcm1zID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB0ZXJtIG9mIGV4aXN0aW5nVGVybXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5vZGVzID0gdGhpcy50ZXJtVG9Ob2Rlc01hcC5nZXQodGVybSk7XG5cdFx0XHRcdGlmIChub2RlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZXMuZGVsZXRlKGRlYWROb2RlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChub2Rlcy5zaXplID09PSAwKVxuXHRcdFx0XHRcdHRoaXMudGVybVRvTm9kZXNNYXAuZGVsZXRlKHRlcm0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLm5vZGVzVG9UZXJtc01hcC5kZWxldGUoZGVhZE5vZGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdGVybXMgYXNzb2NpYXRlZCB3aXRoXG5cdFx0ICogdGhlIHNwZWNpZmllZCBOb2RlLlxuXHRcdCAqL1xuXHRcdGdldEFzc29jaWF0ZWRUZXJtcyhub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRlcm1zOiBUZXJtW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUuc3ViamVjdCBpbnN0YW5jZW9mIFRlcm0pXG5cdFx0XHRcdHRlcm1zLnB1c2gobm9kZS5zdWJqZWN0KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzbXQgb2Ygbm9kZS5zdGF0ZW1lbnRzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGFubm8gb2Ygc210LmFsbEFubm90YXRpb25zKVxuXHRcdFx0XHRcdGlmIChhbm5vLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBUZXJtKVxuXHRcdFx0XHRcdFx0dGVybXMucHVzaChhbm5vLmJvdW5kYXJ5LnN1YmplY3QpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGVybXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCB3aGljaCBpcyBpbmRleGVkIGJ5IGEgdW5pcXVlIHRlcm0sIGFuZCB3aGljaCBhc1xuXHRcdCAqIHZhbHVlcyB0aGF0IGFyZSB0aGUgbm9kZXMgdGhhdCB1c2UgdGhhdCB0ZXJtLCBlaXRoZXIgYXMgYSBkZWNsYXJhdGlvblxuXHRcdCAqIG9yIGFuIGFubm90YXRpb24uXG5cdFx0ICogXG5cdFx0ICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjYWNoZSBpcyB0byBnZXQgYSBxdWljayBhbnN3ZXIgdG8gdGhlIHF1ZXN0aW9uOlxuXHRcdCAqIFwiV2UgYWRkZWQgYSBuZXcgdGVybSBhdCBwb3NpdGlvbiBYIC4uLiB3aGF0IG5vZGVzIG1pZ2h0IHBvc3NpYmx5XG5cdFx0ICogaGF2ZSBiZWVuIGFmZmVjdGVkIGJ5IHRoaXM/XCJcblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHRlcm1Ub05vZGVzTWFwID0gbmV3IE1hcDxUZXJtLCBTZXQ8Tm9kZT4+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIHdoaWNoIGlzIGVzc2VudGlhbGx5IGEgcmV2ZXJzZSBvZiB0ZXJtVG9Ob2Rlc01hcC5cblx0XHQgKiBUaGlzIGlzIHNvIHRoYXQgd2hlbiBub2RlcyBuZWVkIHRvIGJlIGRlbGV0ZWQgb3IgdXBkYXRlZCwgd2UgY2FuXG5cdFx0ICogcXVpY2tseSBmaW5kIHRoZSBwbGFjZSBpbiB0ZXJtVG9Ob2Rlc01hcCB3aGVyZSB0aGUgbm9kZSBoYXNcblx0XHQgKiBiZWVuIHJlZmVyZW5jZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBub2Rlc1RvVGVybXNNYXAgPSBuZXcgV2Vha01hcDxOb2RlLCBUZXJtW10+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VyaWFsaXplcyB0aGUgaW5kZXggaW50byBhIGZvcm1hdCBzdWl0YWJsZVxuXHRcdCAqIGZvciBkZWJ1Z2dpbmcgYW5kIGNvbXBhcmluZyBhZ2FpbnN0IGJhc2VsaW5lcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb3V0ID0gW1wiKFRlcm0gQ2FjaGUpXCJdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFt0ZXJtLCBub2Rlc10gb2YgdGhpcy50ZXJtVG9Ob2Rlc01hcClcblx0XHRcdHtcblx0XHRcdFx0b3V0LnB1c2goXCJcXHRcIiArIHRlcm0pO1xuXHRcdFx0XHRvdXQucHVzaChcIlxcdFxcdDogXCIgKyBBcnJheS5mcm9tKG5vZGVzKVxuXHRcdFx0XHRcdC5tYXAobm9kZSA9PiBub2RlLnBocmFzZS50b1N0cmluZygpKVxuXHRcdFx0XHRcdC5qb2luKFwiLCBcIikpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0LmpvaW4oXCJcXG5cIikudHJpbSgpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIEh5cGVyRWRnZSBjb25uZWN0cyBhbiBvcmlnaW4gcHJlZGVjZXNzb3IgTm9kZSB0byBhIHNlcmllcyBvZlxuXHQgKiBzdWNjZXNzb3IgTm9kZXMuIEZyb20gZ3JhcGggdGhlb3J5LCBhIFwiaHlwZXIgZWRnZVwiIGlzIGRpZmZlcmVudFxuXHQgKiBmcm9tIGFuIFwiZWRnZVwiIGluIHRoYXQgaXQgY2FuIGhhdmUgbWFueSBzdWNjZXNzb3JzOlxuXHQgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IeXBlcmdyYXBoXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgSHlwZXJFZGdlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIE5vZGUgZnJvbSB3aGVyZSB0aGUgSHlwZXJFZGdlIGNvbm5lY3Rpb24gYmVnaW5zLlxuXHRcdFx0ICogRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmcgZG9jdW1lbnQ6XG5cdFx0XHQgKiBcblx0XHRcdCAqIEZvb1xuXHRcdFx0ICogXHRCYXIgOiBGb29cblx0XHRcdCAqIFxuXHRcdFx0ICogVHdvIE5vZGUgb2JqZWN0cyB3b3VsZCBiZSBjcmVhdGVkLCBvbmUgZm9yIHRoZSBmaXJzdCBpbnN0YW5jZVxuXHRcdFx0ICogb2YgXCJGb29cIiwgYW5kIGFub3RoZXIgZm9yIHRoZSBpbnN0YW5jZSBvZiBcIkJhclwiLiBBIEh5cGVyRWRnZVxuXHRcdFx0ICogd291bGQgYmUgY3JlYXRlZCBiZXR3ZWVuIFwiQmFyXCIgYW5kIFwiRm9vXCIsIGFuZCBpdCdzXG5cdFx0XHQgKiBwcmVjZWRlc3NvciB3b3VsZCByZWZlciB0byB0aGUgTm9kZSByZXByZXNlbnRpbmcgdGhlXG5cdFx0XHQgKiBvY2N1cmVuY2Ugb2YgXCJCYXJcIi5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcHJlZGVjZXNzb3I6IE5vZGUsXG5cdFx0XHRzb3VyY2U6IFNwYW4gfCBJbmZpeFNwYW4sXG5cdFx0XHRzdWNjZXNzb3JzOiByZWFkb25seSBTdWNjZXNzb3JbXSlcblx0XHR7XG5cdFx0XHRpZiAoIShzb3VyY2UuYm91bmRhcnkuc3ViamVjdCBpbnN0YW5jZW9mIFRlcm0pKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN1Y2Nlc3Nvck5vZGVzID0gc3VjY2Vzc29yc1xuXHRcdFx0XHQubWFwKHNjc3IgPT4gc2Nzci5ub2RlKVxuXHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3VjY2Vzc29yTm9kZXMubGVuZ3RoICE9PSBzdWNjZXNzb3JzLmxlbmd0aClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRlcm0gPSBzb3VyY2UuYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdHRoaXMuX2ZyYWdtZW50cyA9IFtzb3VyY2VdO1xuXHRcdFx0dGhpcy5fc3VjY2Vzc29ycyA9IHN1Y2Nlc3NvcnMuc2xpY2UoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gYWRkIGFub3RoZXIgZnJhZ21lbnQgdG8gdGhlIEh5cGVyRWRnZS5cblx0XHQgKiBSZXBvcnRzIGEgZmF1bHQgaW5zdGVhZCBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGEgXG5cdFx0ICogbGlzdCBjb25mbGljdCBiZXR3ZWVuIHRoZSBzb3VyY2UgcHJvdmlkZWQgYW5kIHRoZVxuXHRcdCAqIGV4aXN0aW5nIHNvdXJjZXMuIChJLmUuIG9uZSBvZiB0aGUgc291cmNlcyBpcyBkZWZpbmVkXG5cdFx0ICogYXMgYSBsaXN0LCBhbmQgYW5vdGhlciBpcyBub3QpLlxuXHRcdCAqL1xuXHRcdGFkZEZyYWdtZW50KGZyYWdtZW50OiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdC8vL2NvbnN0IGlzUGF0dGVybiA9IHRoaXMucHJlZGVjZXNzb3Iuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm47XG5cdFx0XHQvLy9jb25zdCBpc0luZml4ID0gc291cmNlIGluc3RhbmNlb2YgSW5maXhTcGFuO1xuXHRcdFx0Ly8vaWYgKGlzUGF0dGVybiAhPT0gaXNJbmZpeClcblx0XHRcdC8vL1x0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRDYWxsKCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9mcmFnbWVudHMuaW5jbHVkZXMoZnJhZ21lbnQpKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdC8vISBUaGUgb3JkZXJpbmcgb2YgdGhlIHNvdXJjZXMgaXMgbm90IGJlaW5nIGhhbmRsZWQgaGVyZS5cblx0XHRcdFxuXHRcdFx0dGhpcy5fZnJhZ21lbnRzLnB1c2goZnJhZ21lbnQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgYW5ub3RhdGlvbi1zaWRlIFNwYW4gb3IgSW5maXhTcGFuXG5cdFx0ICogZnJvbSB0aGlzIGVkZ2UuXG5cdFx0ICovXG5cdFx0cmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQ6IFNwYW4gfCBJbmZpeFNwYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3QgZnJhZ1BvcyA9IHRoaXMuX2ZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50KTtcblx0XHRcdGlmIChmcmFnUG9zID49IDApXG5cdFx0XHRcdHRoaXMuX2ZyYWdtZW50cy5zcGxpY2UoZnJhZ1BvcywgMSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGNsZWFyRnJhZ21lbnRzKClcblx0XHR7XG5cdFx0XHR0aGlzLl9mcmFnbWVudHMubGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgc2V0IG9mIGFubm90YXRpb24tc2lkZSBTcGFucyBvciBhbm5vdGF0aW9uLXNpZGVcblx0XHQgKiBJbmZpeFNwYW5zIHRoYXQgYXJlIHJlc3BvbnNpYmxlIGZvciB0aGUgY29uY2VwdGlvbiBvZiB0aGlzXG5cdFx0ICogSHlwZXJFZGdlLlxuXHRcdCAqIFxuXHRcdCAqIFRoZSBhcnJheSBjb250YWlucyBlaXRoZXIgU3BhbiBpbnN0YW5jZXMgb3IgSW5maXhTcGFuIGluc3RhbmNlcyxcblx0XHQgKiBidXQgbmV2ZXIgYm90aC4gSW4gdGhlIGNhc2Ugd2hlbiB0aGUgYXJyYXkgc3RvcmVzIFNwYW4gaW5zdGFuY2VzLFxuXHRcdCAqIHRoZSBsb2NhdGlvbiBvZiB0aG9zZSBTcGFucyBhcmUgcG90ZW50aWFsbHkgc2NhdHRlcmVkIGFjcm9zcyBtYW55XG5cdFx0ICogc3RhdGVtZW50cy5cblx0XHQgKi9cblx0XHRnZXQgZnJhZ21lbnRzKCk6IHJlYWRvbmx5IChTcGFuIHwgSW5maXhTcGFuKVtdXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ZyYWdtZW50cztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfZnJhZ21lbnRzOiAoU3BhbiB8IEluZml4U3BhbilbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRhZGRTdWNjZXNzb3Iobm9kZTogTm9kZSwgbG9uZ2l0dWRlOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLl9zdWNjZXNzb3JzLmZpbmQoc2NzciA9PiBzY3NyLm5vZGUgPT09IG5vZGUpKVxuXHRcdFx0XHR0aGlzLl9zdWNjZXNzb3JzLnB1c2gobmV3IFN1Y2Nlc3Nvcihub2RlLCBsb25naXR1ZGUpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cmVtb3ZlU3VjY2Vzc29yKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgaSA9IHRoaXMuX3N1Y2Nlc3NvcnMubGVuZ3RoOyBpLS0gPiAwOylcblx0XHRcdFx0aWYgKHRoaXMuX3N1Y2Nlc3NvcnNbaV0ubm9kZSA9PT0gbm9kZSlcblx0XHRcdFx0XHR0aGlzLl9zdWNjZXNzb3JzLnNwbGljZShpLCAxKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGFsbCBwb3NzaWJsZSBzdWNjZXNzIE5vZGVzIHRvIHdoaWNoIHRoZSBwcmVkZWNlc3NvciBcblx0XHQgKiBOb2RlIGlzIHByZWVtcHRpdmVseSBjb25uZWN0ZWQgdmlhIHRoaXMgSHlwZXJFZGdlLiBUaGUgXG5cdFx0ICogY29ubmVjdGlvbiBpcyBzYWlkIHRvIGJlIHByZWVtcHRpdmUsIGJlY2F1c2UgdGhlIGNvbm5lY3Rpb25cblx0XHQgKiBtaWdodCBiZSBpZ25vcmVkIGR1cmluZyBwb2x5bW9ycGhpYyBuYW1lIHJlc29sdXRpb24uXG5cdFx0ICovXG5cdFx0Z2V0IHN1Y2Nlc3NvcnMoKTogcmVhZG9ubHkgU3VjY2Vzc29yW11cblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3VjY2Vzc29ycztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfc3VjY2Vzc29yczogU3VjY2Vzc29yW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgSHlwZXJFZGdlIGhhcyBubyBpbW1lZGlhdGVseSByZXNvbHZhYmxlXG5cdFx0ICogc3VjY2Vzc29ycy4gVGhpcyBtZWFucyB0aGF0IHRoZSBzdWJqZWN0IGJlaW5nIHJlZmVycmVkIHRvIGJ5XG5cdFx0ICogdGhpcyBIeXBlckVkZ2UgaXMgZWl0aGVyIGEgdHlwZSBhbGlhcyB3aGljaCB3aWxsIGJlIG1hdGNoZWQgYnlcblx0XHQgKiBhIHBhdHRlcm4sIG9yIGp1c3QgYSBwbGFpbiBvbGQgZmF1bHQuXG5cdFx0ICovXG5cdFx0Z2V0IGlzRGFuZ2xpbmcoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN1Y2Nlc3NvcnMubGVuZ3RoID09PSAwO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc291cmNlcyBvZiB0aGUgZWRnZVxuXHRcdCAqIGNhdXNlcyBpbmNyZW1lbnRhdGlvbiBvZiB0aGUgbGlzdCBkaW1lbnNpb25hbGl0eSBvZiB0aGUgdHlwZVxuXHRcdCAqIHRoYXQgY29ycmVzcG9ubmRzIHRvIHRoaXMgSHlwZXJFZGdlJ3MgcHJlZGVjZXNzb3IgTm9kZS5cblx0XHQgKiBcblx0XHQgKiAoTm90ZSB0aGF0IGFsbCBzb3VyY2VzIG5lZWQgdG8gYWdyZWUgb24gdGhpcyB2YWx1ZSwgYW5kIHRoZSBcblx0XHQgKiBuZWNlc3NhcnkgZmF1bHRzIGFyZSBnZW5lcmF0ZWQgdG8gZW5zdXJlIHRoYXQgdGhpcyBpcyBhbHdheXNcblx0XHQgKiB0aGUgY2FzZS4pXG5cdFx0ICovXG5cdFx0Z2V0IGlzTGlzdCgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzb3VyY2Ugb2YgdGhpcy5mcmFnbWVudHMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN1YiA9IHNvdXJjZS5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0XHRyZXR1cm4gc3ViIGluc3RhbmNlb2YgVGVybSAmJiBzdWIuaXNMaXN0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0dWFsIHZhbHVlIG9mIGFuIEVkZ2UgcmVwcmVzZW50cyBkaWZmZXJlbnQgdGhpbmdzXG5cdFx0ICogZGVwZW5kaW5nIG9uIHRoZSBFZGdlJ3MgKmtpbmQqIHByb3BlcnR5LlxuXHRcdCAqIFxuXHRcdCAqIElmICpraW5kKiBpcyAqbGl0ZXJhbCosIHRoZSB0ZXh0dWFsIHZhbHVlIGlzIHRoZSBnaXZlbiBuYW1lXG5cdFx0ICogb2YgdGhlIHR5cGUgYmVpbmcgcmVmZXJlbmNlZCwgZm9yIGV4YW1wbGUgXCJTdHJpbmdcIiBvclxuXHRcdCAqIFwiRW1wbG95ZWVcIi5cblx0XHQgKiBcblx0XHQgKiBJZiAqa2luZCogaXMgKmNhdGVnb3JpY2FsKiwgdGhlIHRleHR1YWwgdmFsdWUgaXMgYW4gYWxpYXMgdGhhdFxuXHRcdCAqIHdpbGwgbGF0ZXIgYmUgcmVzb2x2ZWQgdG8gYSBzcGVjaWZpYyB0eXBlLCBvciBzZXQgb2YgdHlwZXMsIGZvclxuXHRcdCAqIGV4YW1wbGUgXCIxMGNtXCIgKHByZXN1bWFibHkgcmVzb2x2aW5nIHRvIFwiVW5pdFwiKSBvclxuXHRcdCAqIFwidXNlckBlbWFpbC5jb21cIiAocHJlc3VtYWJsZSByZXNvbHZpbmcgdG8gXCJFbWFpbFwiKS5cblx0XHQgKiBcblx0XHQgKiBJZiAqa2luZCogaXMgKnN1bW1hdGlvbiogLCB0aGUgdGV4dHVhbCB2YWx1ZSBpcyB0aGUgcmF3XG5cdFx0ICogbGl0ZXJhbCB0ZXh0IG9mIHRoZSBhbm5vdGF0aW9uIGZvdW5kIGluIHRoZSBkb2N1bWVudC4gRm9yXG5cdFx0ICogZXhhbXBsZSwgaWYgdGhlIGRvY3VtZW50IGhhZCB0aGUgY29udGVudDpcblx0XHQgKiBcblx0XHQgKiBGb28sIEJhciA6IGZvbywgYmFyXG5cdFx0ICogXG5cdFx0ICogVGhpcyB3b3VsZCByZXN1bHQgaW4gdHdvIG5vZGVzIG5hbWVkIFwiRm9vXCIgYW5kIFwiQmFyXCIsXG5cdFx0ICogZWFjaCB3aXRoIHRoZWlyIG93biBIeXBlckVkZ2VzIHdob3NlIHRleHR1YWwgdmFsdWVzXG5cdFx0ICogd291bGQgYm90aCBiZTogXCJmb28sIGJhclwiLiBJbiB0aGUgY2FzZSBvZiBhIGZyYWdtZW50ZWRcblx0XHQgKiB0eXBlLCB0aGUgbGFzdCBzdW0gaW4gZG9jdW1lbnQgb3JkZXIgaXMgY291bnRlZCBhcyB0aGVcblx0XHQgKiB0ZXh0dWFsIHZhbHVlLiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZ1xuXHRcdCAqIGRvY3VtZW50OlxuXHRcdCAqIFxuXHRcdCAqIFQgOiBhYSwgYmJcblx0XHQgKiBUIDogeHgsIHl5XG5cdFx0ICogXG5cdFx0ICogVGhlIFwiVFwiIG5vZGUgd291bGQgaGF2ZSBhIEh5cGVyRWRnZSB3aXRoIGEgdGV4dHVhbCBcblx0XHQgKiB2YWx1ZSBiZWluZyBcInh4LCB5eVwiLlxuXHRcdCAqIFxuXHRcdCAqIFRoZSAqLW92ZXJsYXkga2luZHMgaGF2ZSBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdGVybTogVGVybTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIHNwZWNpZmljIHBhcnQgb2YgdGhlXG5cdFx0ICogcHJlZGVjZXNzb3Igd2hlcmUgdGhpcyBIeXBlckVkZ2UgYmVnaW5zLlxuXHRcdCAqL1xuXHRcdGdldCBwcmVkZWNlc3Nvck9yaWdpbigpOiBIeXBlckVkZ2VPcmlnaW5cblx0XHR7XG5cdFx0XHQvLyEgSXMgdGhpcyBzdGlsbCBuZWNlc3Nhcnk/XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9mcmFnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMuX2ZyYWdtZW50c1swXTtcblx0XHRcdGlmIChzcmMgaW5zdGFuY2VvZiBTcGFuKVxuXHRcdFx0XHRyZXR1cm4gSHlwZXJFZGdlT3JpZ2luLnN0YXRlbWVudDtcblx0XHRcdFxuXHRcdFx0aWYgKHNyYy5jb250YWluaW5nSW5maXguaXNQb3J0YWJpbGl0eSlcblx0XHRcdFx0cmV0dXJuIEh5cGVyRWRnZU9yaWdpbi5wb3J0YWJpbGl0eUluZml4O1xuXHRcdFx0XG5cdFx0XHRpZiAoc3JjLmNvbnRhaW5pbmdJbmZpeC5pc1BvcHVsYXRpb24pXG5cdFx0XHRcdHJldHVybiBIeXBlckVkZ2VPcmlnaW4ucG9wdWxhdGlvbkluZml4O1xuXHRcdFx0XG5cdFx0XHRpZiAoc3JjLmNvbnRhaW5pbmdJbmZpeC5pc1BhdHRlcm4pXG5cdFx0XHRcdHJldHVybiBIeXBlckVkZ2VPcmlnaW4ucGF0dGVybkluZml4O1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSHlwZXJFZGdlLFxuXHRcdCAqIHN1aXRhYmxlIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHByaW50ID0gKHN1YjogU3ViamVjdCkgPT4gU3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwoc3ViKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XCJWYWx1ZT1cIiArIHRoaXMudGVybSxcblx0XHRcdFx0XCJQcmVkZWNlc3NvcnM9XCIgKyBwcmludCh0aGlzLnByZWRlY2Vzc29yLnN1YmplY3QpLFxuXHRcdFx0XHRcIlN1Y2Nlc3NvcnM9XCIgKyB0aGlzLnN1Y2Nlc3NvcnNcblx0XHRcdFx0XHQubWFwKG4gPT4gcHJpbnQobi5ub2RlLnN1YmplY3QpICsgXCIgPDwgXCIgKyBuLmxvbmdpdHVkZSlcblx0XHRcdFx0XHQuam9pbihcIiwgXCIpLFxuXHRcdFx0XHRcIlNvdXJjZXM9XCIgKyBBcnJheS5mcm9tKHRoaXMuZnJhZ21lbnRzKVxuXHRcdFx0XHRcdC5tYXAoc3JjID0+IHNyYy5ib3VuZGFyeS5zdWJqZWN0KS5qb2luKFwiLCBcIiksXG5cdFx0XHRcdFwiLS0tXCJcblx0XHRcdF0uam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBTdWNjZXNzb3Jcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgbm9kZTogTm9kZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHRoZSBudW1iZXIgb2YgbGV2ZWxzIG9mIGRlcHRoIGluIHRoZSBjb250YWlubWVudFxuXHRcdFx0ICogaGllcmFyY2h5IHRoYXQgbmVlZCB0byBiZSBjcm9zc2VkIGluIG9yZGVyIGZvciB0aGUgY29udGFpbmluZ1xuXHRcdFx0ICogSHlwZXJFZGdlIHRvIGJlIGVzdGFibGlzaGVkIGJldHdlZW4gdGhlIHByZWRlY2Vzc29yIGFuZFxuXHRcdFx0ICogdGhpcyBzdWNjZXNzb3IuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGxvbmdpdHVkZTogbnVtYmVyKVxuXHRcdHsgfVxuXHRcdFxuXHRcdHJlYWRvbmx5IHN0YW1wID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBJbmRpY2F0ZXMgdGhlIHBsYWNlIGluIGEgc3RhdGVtZW50IHdoZXJlIGEgSHlwZXJFZGdlIHN0YXJ0cy5cblx0ICogKEh5cGVyRWRnZXMgY2FuIHN0YXJ0IGVpdGhlciBhdCB0aGUgc3RhdGVtZW50IGxldmVsLCBvciB3aXRoaW5cblx0ICogdmFyaW91cyBraW5kcyBvZiBpbmZpeGVzLilcblx0ICovXG5cdGV4cG9ydCBlbnVtIEh5cGVyRWRnZU9yaWdpblxuXHR7XG5cdFx0c3RhdGVtZW50LFxuXHRcdHBvcHVsYXRpb25JbmZpeCxcblx0XHRwb3J0YWJpbGl0eUluZml4LFxuXHRcdHBhdHRlcm5JbmZpeFxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IG1hcmtzIG91dCB0aGUgbG9jYXRpb24gb2YgYW4gaW5maXggdGVybSB3aXRoaW5cblx0ICogaXQncyBjb250YWluaW5nIEluZml4LCBpdCdzIGNvbnRhaW5pbmcgU3BhbiwgYW5kIHRoZW4gaXQncyBjb250YWluaW5nXG5cdCAqIFN0YXRlbWVudCwgRG9jdW1lbnQsIGFuZCBQcm9ncmFtLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEluZml4U3BhblxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBjb250YWluaW5nU3BhbjogU3Bhbixcblx0XHRcdHJlYWRvbmx5IGNvbnRhaW5pbmdJbmZpeDogSW5maXgsXG5cdFx0XHRyZWFkb25seSBib3VuZGFyeTogQm91bmRhcnk8VGVybT4pXG5cdFx0eyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgU3RhdGVtZW50IHRoYXQgY29udGFpbnMgdGhpcyBBbmNob3IuXG5cdFx0ICovXG5cdFx0Z2V0IHN0YXRlbWVudCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbmluZ1NwYW4uc3RhdGVtZW50O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoaXMgSW5maXhTcGFuXG5cdFx0ICogaXMgY29uc2lkZXJlZCBvYmplY3QtbGV2ZWwgY3J1ZnQsIGFuZCBzaG91bGQgdGhlcmVmb3JlIGJlXG5cdFx0ICogaWdub3JlZCBkdXJpbmcgdHlwZSBhbmFseXNpcy5cblx0XHQgKi9cblx0XHRnZXQgaXNDcnVmdCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbmluZ1NwYW4uc3RhdGVtZW50LmNydWZ0T2JqZWN0cy5oYXModGhpcyk7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgd29ya2VyIGNsYXNzIHRoYXQgaGFuZGxlcyB0aGUgY29uc3RydWN0aW9uIG9mIG5ldHdvcmtzXG5cdCAqIG9mIFBhcmFsbGVsIGluc3RhbmNlcywgd2hpY2ggYXJlIGV2ZW50dWFsbHkgdHJhbnNmb3JtZWRcblx0ICogaW50byB0eXBlIG9iamVjdHMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQ29uc3RydWN0aW9uV29ya2VyXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0dGhpcy5jcnVmdCA9IG5ldyBDcnVmdENhY2hlKHRoaXMucHJvZ3JhbSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdHMgdGhlIGNvcnJlc3BvbmRpbmcgUGFyYWxsZWwgaW5zdGFuY2VzIGZvclxuXHRcdCAqIGFsbCBleHBsaWNpdCB0eXBlcyB0aGF0IGV4aXN0IHdpdGhpbiB0aGUgcHJvdmlkZWQgRG9jdW1lbnQsXG5cdFx0ICogb3IgYmVsb3cgdGhlIHByb3ZpZGVkIEV4cGxpY2l0UGFyYWxsZWwuXG5cdFx0ICovXG5cdFx0ZXhjYXZhdGUoZnJvbTogRG9jdW1lbnQgfCBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmV4Y2F2YXRlZC5oYXMoZnJvbSkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0dGhpcy5leGNhdmF0ZWQuYWRkKGZyb20pO1xuXHRcdFx0Y29uc3QgcXVldWU6IEV4cGxpY2l0UGFyYWxsZWxbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRpZiAoZnJvbSBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHBocmFzZSBvZiBQaHJhc2Uucm9vdHNPZihmcm9tKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRyaWxsZWRQYXJhbGxlbCA9IHRoaXMuZHJpbGxGcm9tTm9kZShwaHJhc2UuYXNzb2NpYXRlZE5vZGUpO1xuXHRcdFx0XHRcdGlmIChkcmlsbGVkUGFyYWxsZWwgIT09IG51bGwpXG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGRyaWxsZWRQYXJhbGxlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgZm9yIChjb25zdCBjdXJyZW50UGFyYWxsZWwgb2YgcXVldWUpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiBjdXJyZW50UGFyYWxsZWwubm9kZS5jb250ZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRyaWxsZWRQYXJhbGxlbCA9IHRoaXMuZHJpbGxGcm9tTm9kZShub2RlKTtcblx0XHRcdFx0XHRpZiAoZHJpbGxlZFBhcmFsbGVsICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0cXVldWUucHVzaChkcmlsbGVkUGFyYWxsZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZXhjYXZhdGVkID0gbmV3IFdlYWtTZXQ8RXhwbGljaXRQYXJhbGxlbCB8IERvY3VtZW50PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdHMgdGhlIGZld2VzdCBwb3NzaWJsZSBQYXJhbGxlbCBpbnN0YW5jZXNcblx0XHQgKiB0byBhcnJpdmUgYXQgdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IHRoZSBkaXJlY3RpdmUuXG5cdFx0ICovXG5cdFx0ZHJpbGwoZGlyZWN0aXZlOiBQaHJhc2UpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5kcmlsbEZyb21QaHJhc2UoZGlyZWN0aXZlKTtcblx0XHRcdHRoaXMuZHJpbGxRdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBkcmlsbEZyb21QaHJhc2UoZGlyZWN0aXZlOiBQaHJhc2UpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucGFyYWxsZWxzLmhhcyhkaXJlY3RpdmUpKVxuXHRcdFx0XHRyZXR1cm4gTm90LnVuZGVmaW5lZCh0aGlzLnBhcmFsbGVscy5nZXQoZGlyZWN0aXZlKSk7XG5cdFx0XHRcblx0XHRcdGlmIChkaXJlY3RpdmUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZEFyZ3VtZW50KCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFuY2VzdHJ5ID0gZGlyZWN0aXZlLmFuY2VzdHJ5O1xuXHRcdFx0Y29uc3Qgc3VyZmFjZU5vZGUgPSBkaXJlY3RpdmUuY29udGFpbmluZ0RvY3VtZW50LnBocmFzZVxuXHRcdFx0XHQuZm9yd2FyZChhbmNlc3RyeVswXS50ZXJtaW5hbClcblx0XHRcdFx0LmFzc29jaWF0ZWROb2RlO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3VyZmFjZU5vZGUgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRsZXQgdHlwZUlkeCA9IDA7XG5cdFx0XHRsZXQgbGFzdFNlZWQgPSBcblx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuZ2V0KGRpcmVjdGl2ZS5iYWNrKCkpIHx8XG5cdFx0XHRcdHRoaXMucmFrZSh0aGlzLnBhcmFsbGVscy5jcmVhdGUoc3VyZmFjZU5vZGUsIHRoaXMuY3J1ZnQpKTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhpcyBjb2RlIHNraXBzIGJ5IGFueSBQYXJhbGxlbCBpbnN0YW5jZXMgdGhhdCBoYXZlIGFscmVhZHlcblx0XHRcdC8vIGJlZW4gY29uc3RydWN0ZWQuIFRoZSByZWFsIHdvcmsgYmVnaW5zIHdoZW4gd2UgZ2V0IHRvXG5cdFx0XHQvLyB0aGUgZmlyc3QgcG9pbnQgaW4gdGhlIFBocmFzZSB3aGVyZSB0aGVyZSBpcyBubyBjb25zdHJ1Y3RlZFxuXHRcdFx0Ly8gUGFyYWxsZWwgaW5zdGFuY2UuXG5cdFx0XHRmb3IgKGNvbnN0IHBocmFzZSBvZiBhbmNlc3RyeSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKCF0aGlzLnBhcmFsbGVscy5oYXMocGhyYXNlKSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGxhc3RTZWVkID0gTm90LnVuZGVmaW5lZCh0aGlzLnBhcmFsbGVscy5nZXQocGhyYXNlKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKyt0eXBlSWR4ID49IGRpcmVjdGl2ZS5sZW5ndGgpXG5cdFx0XHRcdFx0cmV0dXJuIGxhc3RTZWVkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRkb1xuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB0YXJnZXRTdWJqZWN0ID0gYW5jZXN0cnlbdHlwZUlkeF0udGVybWluYWw7XG5cdFx0XHRcdGNvbnN0IGRlc2NlbmRlZCA9IHRoaXMuZGVzY2VuZChsYXN0U2VlZCwgdGFyZ2V0U3ViamVjdCk7XG5cdFx0XHRcdGlmIChkZXNjZW5kZWQgPT09IG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRsYXN0U2VlZCA9IHRoaXMucmFrZShkZXNjZW5kZWQpO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCsrdHlwZUlkeCA8IGRpcmVjdGl2ZS5sZW5ndGgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGFzdFNlZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFuIGVudHJ5cG9pbnQgaW50byB0aGUgZHJpbGwgZnVuY3Rpb24gdGhhdCBvcGVyYXRlc1xuXHRcdCAqIG9uIGEgTm9kZSBpbnN0ZWFkIG9mIGEgUGhyYXNlLiBFc3NlbnRpYWxseSwgdGhpcyBtZXRob2Rcblx0XHQgKiBjYWxscyBcImRyaWxsRnJvbVBocmFzZSgpXCIgc2FmZWx5IChtZWFuaW5nIHRoYXQgaXQgZGV0ZWN0c1xuXHRcdCAqIGNpcmN1bGFyIGludm9rYXRpb25zLCBhbmQgcmV0dXJucyBudWxsIGluIHRoZXNlIGNhc2VzKS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGRyaWxsRnJvbU5vZGUobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHQvLyBDaXJjdWxhciBkcmlsbGluZyBpcyBvbmx5IGEgcHJvYmxlbSBpZiB3ZSdyZVxuXHRcdFx0Ly8gZHJpbGxpbmcgb24gdGhlIHNhbWUgbGV2ZWwuXG5cdFx0XHRjb25zdCBkcSA9IHRoaXMuZHJpbGxRdWV1ZTtcblx0XHRcdFxuXHRcdFx0aWYgKGRxLmxlbmd0aCA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0ZHEucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGRxWzBdLmNvbnRhaW5lciA9PT0gbm9kZS5jb250YWluZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkcS5pbmNsdWRlcyhub2RlKSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0ZHEubGVuZ3RoID0gMDtcblx0XHRcdFx0ZHEucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZHJpbGxSZXN1bHQgPSB0aGlzLmRyaWxsRnJvbVBocmFzZShub2RlLnBocmFzZSk7XG5cdFx0XHRpZiAoZHJpbGxSZXN1bHQgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoZHJpbGxSZXN1bHQgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZHJpbGxSZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBBIGNhbGwgcXVldWUgdXNlZCB0byBwcmV2ZW50IGNpcmN1bGFyIGRyaWxsaW5nLiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZHJpbGxRdWV1ZTogTm9kZVtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXCJSYWtpbmdcIiBhIFBhcmFsbGVsIGlzIHRoZSBwcm9jZXNzIG9mIGRlZXBseSB0cmF2ZXJzaW5nIGl0J3Ncblx0XHQgKiBQYXJhbGxlbCBHcmFwaCAoZGVwdGggZmlyc3QpLCBhbmQgZm9yIGVhY2ggdmlzaXRlZCBQYXJhbGxlbCxcblx0XHQgKiBkZWVwbHkgdHJhdmVyc2luZyBpdCdzIEJhc2UgR3JhcGggYXMgd2VsbCAoYWxzbyBkZXB0aCBmaXJzdCkuXG5cdFx0ICogVGhyb3VnaCB0aGlzIGRvdWJsZS10cmF2ZXJzYWwgcHJvY2VzcywgdGhlIFBhcmFsbGVsJ3MgZWRnZXNcblx0XHQgKiBhcmUgY29uc3RydWN0ZWQgaW50byBhIHRyYXZlcnNhYmxlIGdyYXBoLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmFrZShzZWVkOiBQYXJhbGxlbClcblx0XHR7XG5cdFx0XHQvLyBJZiB0aGUgc2VlZCdzIGNvbnRhaW5lciBpcyBudWxsLCB0aGlzIG1lYW5zIHRoYXQgdGhlIHNlZWRcblx0XHRcdC8vIGlzIHJvb3QtbGV2ZWwsIGFuZCBzbyBpdCBjYW5ub3QgaGF2ZSBhbnkgUGFyYWxsZWwgdHlwZXMuXG5cdFx0XHQvLyBJdCBtYXkgaG93ZXZlciBoYXZlIEJhc2UgdHlwZXMsIGFuZCB0aGVzZSBuZWVkIHRvIGJlXG5cdFx0XHQvLyBoYW5kbGVkLlxuXHRcdFx0aWYgKHNlZWQuY29udGFpbmVyID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIShzZWVkIGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbCkpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5yYWtlRXhwbGljaXRQYXJhbGxlbChzZWVkKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgdGhpcy5yYWtlUGFyYWxsZWxHcmFwaChzZWVkKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGRpZ3MgdGhyb3VnaCB0aGUgcGFyYWxsZWwgZ3JhcGgsXG5cdFx0ICogYW5kIHJha2VzIGFsbCBFeHBsaWNpdFBhcmFsbGVscyB0aGF0IGFyZSBkaXNjb3ZlcmVkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmFrZVBhcmFsbGVsR3JhcGgocGFyOiBQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVkZ2VQYXIgb2YgcGFyLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHR0aGlzLnJha2VQYXJhbGxlbEdyYXBoKGVkZ2VQYXIpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGFyIGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbClcblx0XHRcdFx0dGhpcy5yYWtlRXhwbGljaXRQYXJhbGxlbChwYXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTcGxpdHRlciBtZXRob2QgdGhhdCByYWtlcyBib3RoIGEgcGF0dGVybiBhbmQgYSBub24tcGF0dGVyblxuXHRcdCAqIGNvbnRhaW5pbmcgRXhwbGljaXRQYXJhbGxlbC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VFeHBsaWNpdFBhcmFsbGVsKHBhcjogRXhwbGljaXRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5yYWtlZFBhcmFsbGVscy5oYXMocGFyKSlcblx0XHRcdFx0cmV0dXJuIHBhcjtcblx0XHRcdFxuXHRcdFx0dGhpcy5yYWtlZFBhcmFsbGVscy5hZGQocGFyKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhci5wYXR0ZXJuKVxuXHRcdFx0XHR0aGlzLnJha2VQYXR0ZXJuQmFzZXMocGFyKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5yYWtlQmFzZUdyYXBoKHBhcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IGZvbGxvd3MgdGhlIGJhc2VzIG9mIHRoZSBzcGVjaWZpZWQgc291cmNlIE5vZGUuXG5cdFx0ICogUGFyYWxsZWwgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGZvciBhbnkgdmlzaXRlZCBOb2RlIGluc3RhbmNlXG5cdFx0ICogdGhhdCBkb2VzIG5vdCBoYXZlIG9uZSBhbHJlYWR5IGNyZWF0ZWQuXG5cdFx0ICogQWx0aG91Z2ggdGhlIGFsZ29yaXRobSBpcyBjYXJlZnVsIHRvIGF2b2lkIGNpcmN1bGFyIGJhc2VzLCBpdCdzXG5cdFx0ICogdG9vIGVhcmx5IGluIHRoZSBwcm9jZXNzaW5nIHBpcGVsaW5lIHRvIHJlcG9ydCB0aGVzZSBjaXJjdWxhclxuXHRcdCAqIGJhc2VzIGFzIGZhdWx0cy4gVGhpcyBpcyBiZWNhdXNlIHBvbHltb3JwaGljIG5hbWUgcmVzb2x1dGlvblxuXHRcdCAqIG5lZWRzIHRvIHRha2UgcGxhY2UgYmVmb3JlIHRoZSBzeXN0ZW0gY2FuIGJlIHN1cmUgdGhhdCBhIFxuXHRcdCAqIHNlZW1pbmdseS1jaXJjdWxhciBiYXNlIHN0cnVjdHVyZSBpcyBpbiBmYWN0IHdoYXQgaXQgc2VlbXMuXG5cdFx0ICogVHJ1ZSBjaXJjdWxhciBiYXNlIGRldGVjdGlvbiBpcyB0aGVyZWZvcmUgaGFuZGxlZCBhdCBhIGZ1dHVyZVxuXHRcdCAqIHBvaW50IGluIHRoZSBwaXBlbGluZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VCYXNlR3JhcGgoc3JjUGFyYWxsZWw6IEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKHNyY1BhcmFsbGVsLnBhdHRlcm4pXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBoeXBlckVkZ2Ugb2Ygc3JjUGFyYWxsZWwubm9kZS5vdXRib3VuZHMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmNydWZ0LmhhcyhoeXBlckVkZ2UpKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcG9zc2liaWxpdGllcyA9IGh5cGVyRWRnZS5zdWNjZXNzb3JzXG5cdFx0XHRcdFx0LmZpbHRlcihzY3NyID0+ICF0aGlzLmNydWZ0LmhhcyhzY3NyLm5vZGUpKVxuXHRcdFx0XHRcdC5zb3J0KChhLCBiKSA9PiBhLmxvbmdpdHVkZSAtIGIubG9uZ2l0dWRlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwb3NzaWJpbGl0aWVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIHdoZXJlIHRoZSBwb2x5bW9ycGhpYyBuYW1lIHJlc29sdXRpb24gYWxnb3JpdGhtXG5cdFx0XHRcdFx0Ly8gdGFrZXMgcGxhY2UuIFRoZSBhbGdvcml0aG0gb3BlcmF0ZXMgYnkgd29ya2luZyBpdCdzIHdheVxuXHRcdFx0XHRcdC8vIHVwIHRoZSBsaXN0IG9mIG5vZGVzIChha2EgdGhlIHNjb3BlIGNoYWluKSwgbG9va2luZyBmb3Jcblx0XHRcdFx0XHQvLyBhIHBvc3NpYmxlIHJlc29sdXRpb24gdGFyZ2V0IHdoZXJlIHRoZSBhY3Qgb2YgYXBwbHlpbmcgdGhlXG5cdFx0XHRcdFx0Ly8gYXNzb2NpYXRlZCBQYXJhbGxlbCBhcyBhIGJhc2UsIGNhdXNlcyBhdCBsZWFzdCBvbmUgb2YgdGhlIFxuXHRcdFx0XHRcdC8vIGNvbmRpdGlvbnMgb24gdGhlIGNvbnRyYWN0IHRvIGJlIHNhdGlzZmllZC4gT3IsIGluIHRoZSBjYXNlXG5cdFx0XHRcdFx0Ly8gd2hlbiB0aGVyZSBhcmUgbm8gY29uZGl0aW9ucyBvbiB0aGUgY29udHJhY3QsIHRoZSBub2RlXG5cdFx0XHRcdFx0Ly8gdGhhdCBpcyB0aGUgY2xvc2VzdCBhbmNlc3RvciBpcyB1c2VkLlxuXHRcdFx0XHRcdGZvciAoY29uc3QgcG9zc2libGVTY3NyIG9mIHBvc3NpYmlsaXRpZXMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcG9zc2libGVOb2RlID0gcG9zc2libGVTY3NyLm5vZGU7XG5cdFx0XHRcdFx0XHRjb25zdCBiYXNlUGFyYWxsZWwgPSB0aGlzLmRyaWxsRnJvbU5vZGUocG9zc2libGVOb2RlKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gYmFzZVBhcmFsbGVsIHdpbGwgYmUgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIGEgY2lyY3VsYXJcblx0XHRcdFx0XHRcdC8vIHJlbGF0aW9uc2hpcCBoYXMgYmVlbiBkZXRlY3RlZCAoYW5kIHF1aXR0aW5nIGlzXG5cdFx0XHRcdFx0XHQvLyByZXF1aXJlZCBoZXJlIGluIG9yZGVyIHRvIGF2b2lkIGEgc3RhY2sgb3ZlcmZsb3cpLlxuXHRcdFx0XHRcdFx0aWYgKGJhc2VQYXJhbGxlbCA9PT0gbnVsbClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHRoaXMucmFrZUV4cGxpY2l0UGFyYWxsZWwoYmFzZVBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgYXJlIGNhc2VzIHdoZW4gYW4gZW50aXJlIHBhcmFsbGVsIG5lZWRzIHRvIGJlXG5cdFx0XHRcdFx0XHQvLyBcImV4Y2F2YXRlZFwiLCBtZWFuaW5nIHRoYXQgdGhlIFBhcmFsbGVsJ3MgZW50aXJlIHN1YnRyZWVcblx0XHRcdFx0XHRcdC8vIG9mIGNvbnRlbnRzIG5lZWRzIHRvIGJlIGFuYWx5emVkIGFuZCBjb252ZXJ0ZWQgaW50b1xuXHRcdFx0XHRcdFx0Ly8gcGFyYWxsZWxzLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgZnVsbHkgZGVmaW5lZCBzZXRcblx0XHRcdFx0XHRcdC8vIG9mIHBhcmFsbGVscyBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBkZXRlY3QgZGlzY3JlcGFudFxuXHRcdFx0XHRcdFx0Ly8gdW5pb25zIChhbmQgdGhlcmVmb3JlLCByZXBvcnQgdGhlIGF0dGVtcHQgYXQgYSB0eXBlXG5cdFx0XHRcdFx0XHQvLyB1bmlvbiBhcyBmYXVsdHkpLlxuXHRcdFx0XHRcdFx0aWYgKHNyY1BhcmFsbGVsLmJhc2VDb3VudCA+IDApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChzcmNQYXJhbGxlbC5iYXNlQ291bnQgPT09IDEpXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5leGNhdmF0ZShzcmNQYXJhbGxlbC5maXJzdEJhc2UpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dGhpcy5leGNhdmF0ZShiYXNlUGFyYWxsZWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoIXNyY1BhcmFsbGVsLnRyeUFkZExpdGVyYWxCYXNlKGJhc2VQYXJhbGxlbCwgaHlwZXJFZGdlKSlcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZWRIeXBlckVkZ2VzLmhhcyhoeXBlckVkZ2UpKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHRoaXMuaGFuZGxlZEh5cGVyRWRnZXMuYWRkKGh5cGVyRWRnZSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UndmUgZGlzY292ZXJlZCBhbiBhbm5vdGF0aW9uIHRoYXQgd2UncmVcblx0XHRcdFx0XHQvLyBnb2luZyB0byB0cnkgdG8gcmVzb2x2ZSBhcyBhbiBhbGlhcy4gSWYgdGhpcyBkb2Vzbid0IHdvcmssXG5cdFx0XHRcdFx0Ly8gdGhlIGVkZ2Ugd2lsbCBiZSBtYXJrZWQgYXMgY3J1ZnQuIFBvc3NpYmx5IGEgZnV0dXJlIHZlcnNpb25cblx0XHRcdFx0XHQvLyBvZiB0aGlzIGNvbXBpbGVyIHdpbGwgYWxsb3cgb3RoZXIgYWdlbnRzIHRvIGhvb2sgaW50byB0aGlzXG5cdFx0XHRcdFx0Ly8gcHJvY2VzcyBhbmQgYXVnbWVudCB0aGUgcmVzb2x1dGlvbiBzdHJhdGVneS5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBjYW5kaWRhdGVQYXR0ZXJuUGFyczogRXhwbGljaXRQYXJhbGxlbFtdID0gW107XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCB7IHBhdHRlcm5QYXJhbGxlbCB9IG9mIHRoaXMuYXNjZW5kKHNyY1BhcmFsbGVsKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLnJha2VQYXR0ZXJuQmFzZXMocGF0dGVyblBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZVBhdHRlcm5QYXJzLnB1c2gocGF0dGVyblBhcmFsbGVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNhbmRpZGF0ZVBhdHRlcm5QYXJzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgdGVybXMgPSBoeXBlckVkZ2UuZnJhZ21lbnRzXG5cdFx0XHRcdFx0XHRcdC5tYXAoc3JjID0+IHNyYy5ib3VuZGFyeS5zdWJqZWN0KVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKCh2KTogdiBpcyBUZXJtID0+IHYgaW5zdGFuY2VvZiBUZXJtKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHRlcm1zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IGFsaWFzID0gdGVybXNbMF0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChzcmNQYXJhbGxlbC50cnlBZGRBbGlhc2VkQmFzZShjYW5kaWRhdGVQYXR0ZXJuUGFycywgaHlwZXJFZGdlLCBhbGlhcykpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHRoaXMuaGFuZGxlZEh5cGVyRWRnZXMuYWRkKGh5cGVyRWRnZSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIXRoaXMuaGFuZGxlZEh5cGVyRWRnZXMuaGFzKGh5cGVyRWRnZSkpXG5cdFx0XHRcdFx0XHR0aGlzLmNydWZ0LmFkZChoeXBlckVkZ2UsIEZhdWx0cy5VbnJlc29sdmVkQW5ub3RhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFzcmNQYXJhbGxlbC5pc0NvbnRyYWN0U2F0aXNmaWVkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzcmNQYXJhbGxlbC5ub2RlLnN0YXRlbWVudHMpXG5cdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmZhdWx0cy5yZXBvcnQobmV3IEZhdWx0KFxuXHRcdFx0XHRcdFx0RmF1bHRzLkNvbnRyYWN0VmlvbGF0aW9uLFxuXHRcdFx0XHRcdFx0c210KSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzcmNQYXJhbGxlbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZHMgdGhlIHNldCBvZiBiYXNlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm92aWRlZFxuXHRcdCAqIHBhdHRlcm4tY29udGFpbmluZyBFeHBsaWNpdFBhcmFsbGVsIGluc3RhbmNlLCBhbmQgYXR0ZW1wdHNcblx0XHQgKiB0byBoYXZlIHRoZW0gYXBwbGllZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VQYXR0ZXJuQmFzZXMocGF0dGVyblBhcmFsbGVsOiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICghcGF0dGVyblBhcmFsbGVsLnBhdHRlcm4pXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYmFzZXMgPSBuZXcgTWFwPEV4cGxpY2l0UGFyYWxsZWwsIEh5cGVyRWRnZT4oKTtcblx0XHRcdGNvbnN0IG9icyA9IHBhdHRlcm5QYXJhbGxlbC5ub2RlLm91dGJvdW5kcztcblx0XHRcdGNvbnN0IG5hbWVPZiA9IChlZGdlOiBIeXBlckVkZ2UpID0+XG5cdFx0XHRcdFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKGVkZ2UuZnJhZ21lbnRzWzBdKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBvYnMubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaHlwZXJFZGdlID0gb2JzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMuY3J1ZnQuaGFzKGh5cGVyRWRnZSkpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBsZW4gPSBoeXBlckVkZ2Uuc3VjY2Vzc29ycy5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBCZWNhdXNlIHJlc29sdmluZyBwYXR0ZXJuIGJhc2VzIGhhcyBub24tcG9seW1vcnBoaWMgYmVoYXZpb3IsIFxuXHRcdFx0XHQvLyB3ZSBjYW4gZ2V0IGF3YXkgd2l0aCBjaGVja2luZyBmb3IgdGhlc2UgZmF1bHRzIGhlcmUgd2l0aG91dCBnb2luZ1xuXHRcdFx0XHQvLyB0aHJvdWdoIHRoZSB3aG9sZSBkcmlsbGluZyBwcm9jZXNzLlxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxlbiA9PT0gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGh5cGVyRWRnZSwgRmF1bHRzLlVucmVzb2x2ZWRBbm5vdGF0aW9uKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9icy5maW5kSW5kZXgoZSA9PiBuYW1lT2YoZSkgPT09IG5hbWVPZihoeXBlckVkZ2UpKSAhPT0gaSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGh5cGVyRWRnZSwgRmF1bHRzLklnbm9yZWRBbm5vdGF0aW9uKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxlbiA+IDEpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYmFzZU5vZGUgPSBoeXBlckVkZ2Uuc3VjY2Vzc29yc1swXS5ub2RlO1xuXHRcdFx0XHRjb25zdCBiYXNlUGFyYWxsZWwgPSB0aGlzLmRyaWxsRnJvbU5vZGUoYmFzZU5vZGUpO1xuXHRcdFx0XHRpZiAoYmFzZVBhcmFsbGVsICE9PSBudWxsKVxuXHRcdFx0XHRcdGJhc2VzLnNldChiYXNlUGFyYWxsZWwsIGh5cGVyRWRnZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIENpcmN1bGFyIGJhc2VzIHN0aWxsIG5lZWQgdG8gYmUgY2hlY2tlZC4gSXQncyB1bmNsZWFyIGhvdyBhbmRcblx0XHRcdC8vIHdoZXJlIHRvIGFjdHVhbGx5IGRvIHRoaXMsIHdoaWxlIGZhY3RvcmluZyBpbiB0aGUgY29uc3RyYWludFxuXHRcdFx0Ly8gdGhhdCB0aGVzZSBjYW4gYmUgY2F1c2VkIHRocm91Z2ggdGhlIHVzZSBvZiBhbGlhc2VzLlxuXHRcdFx0XG5cdFx0XHQvLyBBbnl0aGluZyB0aGF0IGlzIGEgbGlzdCAod2l0aCBhbnkgZGltZW5zaW9uYWxpdHkpIG5lZWRzIHRvIGJlXG5cdFx0XHQvLyBjdXQgb2ZmLCBiZWNhdXNlIHRoZXNlIGJhc2VzIGNhbid0IGJlIGFwcGxpZWQgdG8gcGF0dGVybnMuXG5cdFx0XHRmb3IgKGNvbnN0IFtiYXNlLCB2aWFdIG9mIGJhc2VzKVxuXHRcdFx0XHRpZiAoYmFzZS5nZXRMaXN0RGltZW5zaW9uYWxpdHkoKSA+IDApXG5cdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQodmlhLCBGYXVsdHMuUGF0dGVybk1hdGNoaW5nTGlzdCk7XG5cdFx0XHRcblx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIGRldGVybWluZSBpZiBhbnkgb2YgdGhlc2UgYmFzZXMgYXJlIHJlZHVuZGFudC5cblx0XHRcdC8vIFRoaXMgaXMgZG9uZSBieSBjaGVja2luZyB0byBzZWUgaWYgYW55IG9mIHRoZSBiYXNlcyBhcmUgc3BlY2lmaWVkXG5cdFx0XHQvLyBzb21ld2hlcmUgaW4gdGhlIGJhc2UgZ3JhcGggb2YgYWxsIG90aGVycy5cblx0XHRcdGZvciAoY29uc3QgW2Jhc2VBXSBvZiBiYXNlcylcblx0XHRcdFx0Zm9yIChjb25zdCBbYmFzZUIsIHZpYV0gb2YgYmFzZXMpXG5cdFx0XHRcdFx0aWYgKGJhc2VBICE9PSBiYXNlQilcblx0XHRcdFx0XHRcdGlmIChiYXNlQS5oYXNCYXNlKGJhc2VCKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQodmlhLCBGYXVsdHMuSWdub3JlZEFubm90YXRpb24pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXR0ZXJuID0gcGF0dGVyblBhcmFsbGVsLm5vZGUuc3ViamVjdCBhcyBQYXR0ZXJuO1xuXHRcdFx0Y29uc3Qgc3BhbiA9IHBhdHRlcm5QYXJhbGxlbC5ub2RlLmRlY2xhcmF0aW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgYXMgU3Bhbjtcblx0XHRcdGNvbnN0IHBvcnRJbmZpeGVzID0gcGF0dGVybi5nZXRJbmZpeGVzKEluZml4RmxhZ3MucG9ydGFiaWxpdHkpO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9ydEluZml4ZXMubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdmFsaWRQb3J0YWJpbGl0eUluZml4ZXM6IEluZml4W10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgcG9ydEluZml4IG9mIHBvcnRJbmZpeGVzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmZ4QW5ub3NJdGVyID0gc3Bhbi5lYWNoQW5ub3RhdGlvbkZvckluZml4KHBvcnRJbmZpeCk7XG5cdFx0XHRcdFx0Y29uc3QgbmZ4QW5ub3MgPSBBcnJheS5mcm9tKG5meEFubm9zSXRlcik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5meEFubm9zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBBdCB0aGlzIHRpbWUsIHdlJ3JlIGN1cnJlbnRseSBnZW5lcmF0aW5nIGEgZmF1bHQgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdFx0XHRcdC8vIGEgcG9ydGFiaWxpdHkgaW5maXggaGFzIG11bHRpcGxlIGRlZmluaXRpb25zLiBBbHRob3VnaCB0aGUgcGFyc2VyXG5cdFx0XHRcdFx0Ly8gYW5kIHRoZSBHcmFwaC1sZXZlbCBpbmZyYXN0cnVjdHVyZSBzdXBwb3J0cyB0aGlzLCBtb3JlIHN0dWR5IGlzXG5cdFx0XHRcdFx0Ly8gcmVxdWlyZWQgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBjaGFyYWN0ZXJpc3RpYyBvZiBUcnV0aC5cblx0XHRcdFx0XHRpZiAobmZ4QW5ub3MubGVuZ3RoID4gMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG5meCBvZiBuZnhBbm5vcy5zbGljZSgxKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQobmZ4LCBGYXVsdHMuUG9ydGFiaWxpdHlJbmZpeEhhc1VuaW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB2YWxpZFBvcnRhYmlsaXR5SW5maXhlcy5wdXNoKHBvcnRJbmZpeCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoaXMgY29kZSBjaGVja3MgZm9yIG92ZXJsYXBwaW5nIHR5cGVzLiBUaGUgYWxnb3JpdGhtIHVzZWQgaGVyZSBpc1xuXHRcdFx0XHQvLyBzaW1pbGFyIHRvIHRoZSByZWR1bmRhbnQgYmFzZXMgY2hlY2sgdXNlZCBhYm92ZS4gSG93ZXZlciwgaW4gdGhlIGNhc2Vcblx0XHRcdFx0Ly8gb2YgaW5maXhlcywgdGhlc2UgYXJlbid0IGp1c3QgcmVkdW5kYW50LCB0aGV5IHdvdWxkIGJlIHByb2JsZW1hdGljIGlmXG5cdFx0XHRcdC8vIGxlZnQgaW4uIFRvIGV4cGxhaW4gd2h5LCB0cnkgdG8gZmlndXJlIG91dCBob3cgYSBTdHJpbmcgdHlwZSB3b3VsZCBkcmF3XG5cdFx0XHRcdC8vIGl0J3MgZGF0YSBvdXQgb2YgYW4gYWxpYXMgbWF0Y2hpbmcgdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuXHRcdFx0XHQvLyBcdC88IDogRW1haWw+PCA6IFN0cmluZz4gOiBUeXBlXG5cdFx0XHRcdC8vIChoaW50OiBpdCBkb2Vzbid0IHdvcmspXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyEgTm90IGltcGxlbWVudGVkXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRPRE86IENoZWNrIGZvciB1c2Ugb2YgbGlzdHMgd2l0aGluIGFueSBraW5kIG9mIGluZml4LlxuXHRcdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3Igbm8gY29sbGVjdGVkIGJhc2VzIHRvIGJlIHJldHVybmVkXG5cdFx0XHQvLyBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIHdlcmUgYWN0dWFsbHkgYW5ub3RhdGlvbnNcblx0XHRcdC8vIHNwZWNpZmllZCB3aXRoaW4gdGhlIGZpbGUsIGJ1dCB0aGV5IHdlcmUgYWxsIGZvdW5kIHRvXG5cdFx0XHQvLyBiZSBjcnVmdC5cblx0XHRcdGlmIChiYXNlcy5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdHBhdHRlcm5QYXJhbGxlbC50cnlBcHBseVBhdHRlcm5CYXNlcyhiYXNlcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgd29ya3MgaXRzIHdheSB1cHdhcmRzLCBzdGFydGluZyBhdCB0aGVcblx0XHQgKiBwcm92aWRlZCBFeHBsaWNpdFBhcmFsbGVsLiBUaGUgZnVuY3Rpb24geWllbGRzIHRoZSBzZXJpZXMgb2Zcblx0XHQgKiBQYXJhbGxlbHMgdGhhdCBjb250YWluIFBhdHRlcm5zIHRoYXQgYXJlIHZpc2libGUgdG8gdGhlIHByb3ZpZGVkXG5cdFx0ICogc3JjUGFyYWxsZWwuIFRoZSBiYXNlcyBvZiB0aGVzZSBwYXJhbGxlbHMgaGF2ZSBub3QgbmVjZXNzYXJpbHlcblx0XHQgKiBiZWVuIGFwcGxpZWQuXG5cdFx0ICogXG5cdFx0ICogVGhlIG9yZGVyaW5nIG9mIHRoZSBQYXJhbGxlbHMgeWllbGRlZCBpcyByZWxldmFudC4gVGhlIGluc3RhbmNlc1xuXHRcdCAqIHRoYXQgd2VyZSB5aWVsZGVkIGNsb3NlciB0byB0aGUgYmVnaW5uaW5nIHRha2UgcHJlc2NlZGVuY2Ugb3ZlclxuXHRcdCAqIHRoZSBvbmVzIHlpZWxkZWQgYXQgdGhlIGVuZC5cblx0XHQgKi9cblx0XHRwcml2YXRlICphc2NlbmQoc3JjUGFyYWxsZWw6IEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZGlzY292ZXJlZFBhdHRlcm5Ob2RlcyA9IG5ldyBTZXQ8Tm9kZT4oKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgeWllbGRhYmxlID0gKHBhdHRlcm5Ob2RlOiBOb2RlKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRkaXNjb3ZlcmVkUGF0dGVybk5vZGVzLmFkZChwYXR0ZXJuTm9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gTm90Lm51bGwoXG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuZ2V0KHBhdHRlcm5Ob2RlKSB8fFxuXHRcdFx0XHRcdHRoaXMucGFyYWxsZWxzLmNyZWF0ZShwYXR0ZXJuTm9kZSwgdGhpcy5jcnVmdCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2UoY3VycmVudDogRXhwbGljaXRQYXJhbGxlbCk6IFxuXHRcdFx0XHRJdGVyYWJsZUl0ZXJhdG9yPElQYXR0ZXJuUGFyYWxsZWw+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgY3VycmVudC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlKGJhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdFx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiBjdXJyZW50Lm5vZGUuY29udGVudHMudmFsdWVzKCkpXG5cdFx0XHRcdFx0XHRpZiAobm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0XHRcdFx0aWYgKCFkaXNjb3ZlcmVkUGF0dGVybk5vZGVzLmhhcyhub2RlKSlcblx0XHRcdFx0XHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiBub2RlLnN1YmplY3QsXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuUGFyYWxsZWw6IHlpZWxkYWJsZShub2RlKVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBwcm9jZXNzIHN0YXJ0cyBhdCB0aGUgY29udGFpbmVyIG9mIHRoZSBjdXJyZW50IHBhcmFsbGVsLFxuXHRcdFx0Ly8gZXZlbiB0aG91Z2ggdGhpcyBmdW5jdGlvbiBuZWVkcyB0byB5aWVsZCBvdGhlciBwYXJhbGxlbHMgdGhhdFxuXHRcdFx0Ly8gYXJlIGFkamFjZW50IHRvIHNyY1BhcmFsbGVsLCBiZWNhdXNlIHdlIHJlYWNoIGJhY2sgaW50byB0aGVcblx0XHRcdC8vIGFkamFjZW50cyBmcm9tIHRoZSBjb250YWluZXIuXG5cdFx0XHRmb3IgKGxldCBjdXJyZW50ID0gc3JjUGFyYWxsZWwuY29udGFpbmVyO1xuXHRcdFx0XHRjdXJyZW50IGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbDspXG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkICpyZWN1cnNlKGN1cnJlbnQpO1xuXHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5jb250YWluZXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcGhyYXNlIG9mIFBocmFzZS5yb290c09mKHNyY1BhcmFsbGVsLm5vZGUuZG9jdW1lbnQpKVxuXHRcdFx0XHRpZiAocGhyYXNlLnRlcm1pbmFsIGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0XHRpZiAoIWRpc2NvdmVyZWRQYXR0ZXJuTm9kZXMuaGFzKHBocmFzZS5hc3NvY2lhdGVkTm9kZSkpXG5cdFx0XHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IHBocmFzZS50ZXJtaW5hbCxcblx0XHRcdFx0XHRcdFx0cGF0dGVyblBhcmFsbGVsOiB5aWVsZGFibGUocGhyYXNlLmFzc29jaWF0ZWROb2RlKVxuXHRcdFx0XHRcdFx0fTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXNlZCBmb3Igc2FmZXR5IHB1cnBvc2VzIHRvIGNhdGNoIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBoYW5kbGVkSHlwZXJFZGdlcyA9IG5ldyBXZWFrU2V0PEh5cGVyRWRnZT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb25zdHJ1Y3RzIGFuZCByZXR1cm5zIGEgbmV3IHNlZWQgUGFyYWxsZWwgZnJvbSB0aGUgc3BlY2lmaWVkXG5cdFx0ICogemVuaXRoIFBhcmFsbGVsLCBuYXZpZ2F0aW5nIGRvd253YXJkcyB0byB0aGUgc3BlY2lmaWVkIHRhcmdldCBzdWJqZWN0LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgZGVzY2VuZCh6ZW5pdGg6IFBhcmFsbGVsLCB0YXJnZXRTdWJqZWN0OiBTdWJqZWN0KVxuXHRcdHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMgQSBuZXcgUGFyYWxsZWwgKGVpdGhlciBiZWluZyBhIEV4cGxpY2l0UGFyYWxsZWxcblx0XHRcdCAqIG9yIGFuIEltcGxpY2l0UGFyYWxsZWwgaW5zdGFuY2UpLCB0aGF0IGNvcnJlc3BvbmRzIHRvXG5cdFx0XHQgKiB0aGUgc3BlY2lmaWVkIHplbml0aCBwYXJhbGxlbC5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgZGVzY2VuZE9uZSA9ICh6ZW5pdGg6IFBhcmFsbGVsKTogUGFyYWxsZWwgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHplbml0aCBpbnN0YW5jZW9mIEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBuZXh0Tm9kZSA9IHplbml0aC5ub2RlLmNvbnRlbnRzLmdldCh0YXJnZXRTdWJqZWN0KTtcblx0XHRcdFx0XHRpZiAobmV4dE5vZGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3Qgb3V0ID0gdGhpcy5wYXJhbGxlbHMuZ2V0KG5leHROb2RlKSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBhcmFsbGVscy5jcmVhdGUobmV4dE5vZGUsIHRoaXMuY3J1ZnQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR0aGlzLnZlcmlmeURlc2NlbmQoemVuaXRoLCBvdXQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG5leHRQaHJhc2UgPSB6ZW5pdGgucGhyYXNlLmZvcndhcmQodGFyZ2V0U3ViamVjdCk7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuZ2V0KG5leHRQaHJhc2UpIHx8XG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuY3JlYXRlKG5leHRQaHJhc2UpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFjdFxuXHRcdFx0ICogb2YgZGVzY2VuZGluZyBmcm9tIHRoZSBzcGVjaWZpZWQgUGFyYWxsZWwgdG8gdGhlIHR5cGVOYW1lXG5cdFx0XHQgKiBwYXNzZWQgdG8gdGhlIGNvbnRhaW5pbmcgbWV0aG9kIGlzIGdvaW5nIHRvIHJlc3VsdCBpbiBhXG5cdFx0XHQgKiBFeHBsaWNpdFBhcmFsbGVsIGluc3RhbmNlLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBjYW5EZXNjZW5kVG9FeHBsaWNpdChwYXJhbGxlbDogUGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0cGFyYWxsZWwgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsICYmXG5cdFx0XHRcdFx0cGFyYWxsZWwubm9kZS5jb250ZW50cy5oYXModGFyZ2V0U3ViamVjdCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvL1xuXHRcdFx0Ly8gVE9ETzogVGhlc2UgZnVuY3Rpb25zIGNhbiBwcm9iYWJseSBiZSByZXBsYWNlZCB3aXRoXG5cdFx0XHQvLyBhIGNhbGwgdG8gTWlzYy5yZWR1Y2VSZWN1cnNpdmUoKVxuXHRcdFx0Ly9cblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2VQYXJhbGxlbHMocGFyOiBQYXJhbGxlbCk6IEl0ZXJhYmxlSXRlcmF0b3I8UGFyYWxsZWw+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgcGFyRWRnZSBvZiBwYXIuZ2V0UGFyYWxsZWxzKCkpXG5cdFx0XHRcdFx0eWllbGQgKnJlY3Vyc2VQYXJhbGxlbHMocGFyRWRnZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCBwYXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlQmFzZXMocGFyOiBFeHBsaWNpdFBhcmFsbGVsKTogSXRlcmFibGVJdGVyYXRvcjxQYXJhbGxlbD5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBwYXIuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHR5aWVsZCAqcmVjdXJzZUJhc2VzKGJhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQgcGFyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiAqcmVjdXJzZShwYXI6IFBhcmFsbGVsKTogSXRlcmFibGVJdGVyYXRvcjxQYXJhbGxlbD5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBwYXJhbGxlbEVkZ2Ugb2YgcmVjdXJzZVBhcmFsbGVscyhwYXIpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHBhcmFsbGVsRWRnZSBpbnN0YW5jZW9mIEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGJhc2VFZGdlIG9mIHJlY3Vyc2VCYXNlcyhwYXJhbGxlbEVkZ2UpKVxuXHRcdFx0XHRcdFx0XHR5aWVsZCBiYXNlRWRnZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR5aWVsZCBwYXJhbGxlbEVkZ2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGZvbGxvd2luZyBhbGdvcml0aG0gcGVyZm9ybXMgYSByZWN1cnNpdmUgcmVkdWN0aW9uIG9uXG5cdFx0XHQvLyB0aGUgemVuaXRoLCBhbmQgcHJvZHVjZXMgYSBzZXQgb2YgUGFyYWxsZWxzIHRvIHBydW5lIGZyb20gdGhlXG5cdFx0XHQvLyBkZXNjZW5zaW9uIHByb2Nlc3MuIFRoZSBQYXJhbGxlbHMgdGhhdCBlbmQgdXAgZ2V0dGluZyBwcnVuZWRcblx0XHRcdC8vIGFyZSB0aGUgb25lcyB0aGF0LCBpZiB1bnBydW5lZCwgd291bGQgcmVzdWx0IGluIGEgbGF5ZXIgdGhhdFxuXHRcdFx0Ly8gaGFzIEltcGxpY2l0UGFyYWxsZWxzIHRoYXQgc2hvdWxkbid0IGFjdHVhbGx5IGV4aXN0LiBGb3Jcblx0XHRcdC8vIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZG9jdW1lbnQ6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gQ2xhc3Ncblx0XHRcdC8vIFxuXHRcdFx0Ly8gU3ViQ2xhc3MgOiBDbGFzc1xuXHRcdFx0Ly8gXHRDaGlsZFxuXHRcdFx0Ly8gXG5cdFx0XHQvLyBcIkNsYXNzXCIgc2hvdWxkIG5vdCBoYXZlIGFuIEltcGxpY2l0UGFyYWxsZWwgY2FsbGVkIFwiQ2hpbGRcIixcblx0XHRcdC8vIGJlY2F1c2UgdGhhdCB3YXMgaW50cm9kdWNlZCBpbiB0aGUgZGVyaXZlZCBcIlN1YkNsYXNzXCIgdHlwZS5cblx0XHRcdC8vIEFuZCBzbyB0aGlzIGFsZ29yaXRobSBzdGFrZXMgb3V0IGN1dCBvZmYgcG9pbnRzIHNvIHRoYXQgd2UgZG9uJ3Rcblx0XHRcdC8vIGJsaW5kbHkganVzdCBkZXNjZW5kIGFsbCBQYXJhbGxlbHMgaW4gdGhlIGxheWVyLlxuXHRcdFx0Y29uc3QgcHJ1bmVkUGFyYWxsZWxzID0gbmV3IFNldDxQYXJhbGxlbD4oKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJ1bmVQYXJhbGxlbHNGb2xsb3dGbiA9IChwYXI6IFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1cHBlclBhcmFsbGVscyA9IHBhci5nZXRQYXJhbGxlbHMoKS5zbGljZSgpO1xuXHRcdFx0XHRpZiAocGFyIGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbClcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIHBhci5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdFx0dXBwZXJQYXJhbGxlbHMucHVzaChiYXNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB1cHBlclBhcmFsbGVscztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnN0IGhhc0V4cGxpY2l0Q29udGVudHMgPSBNaXNjLnJlZHVjZVJlY3Vyc2l2ZShcblx0XHRcdFx0emVuaXRoLFxuXHRcdFx0XHRwcnVuZVBhcmFsbGVsc0ZvbGxvd0ZuLFxuXHRcdFx0XHQoY3VycmVudCwgcmVzdWx0czogcmVhZG9ubHkgYm9vbGVhbltdKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcHJ1bmUgPSBcblx0XHRcdFx0XHRcdHJlc3VsdHMuZXZlcnkocmVzdWx0ID0+ICFyZXN1bHQpICYmXG5cdFx0XHRcdFx0XHQhY2FuRGVzY2VuZFRvRXhwbGljaXQoY3VycmVudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBydW5lKVxuXHRcdFx0XHRcdFx0cHJ1bmVkUGFyYWxsZWxzLmFkZChjdXJyZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gIXBydW5lO1xuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlbiB0aGUgbWV0aG9kIGlzIGF0dGVtcHRpbmcgdG8gZGVzY2VuZFxuXHRcdFx0Ly8gdG8gYSBsZXZlbCB3aGVyZSB0aGVyZSBhcmUgbm8gbm9kZXMgd2hvc2UgbmFtZSBtYXRjaFxuXHRcdFx0Ly8gdGhlIHR5cGUgbmFtZSBzcGVjaWZpZWQgKGkuZS4gdGhlIHdob2xlIGxheWVyIHdvdWxkIGJlIFxuXHRcdFx0Ly8gaW1wbGljaXQgcGFyYWxsZWxzKSwgbnVsbCBpcyByZXR1cm5lZCBiZWNhdXNlIGEgZGVzY2VuZFxuXHRcdFx0Ly8gd291bGRuJ3QgbWFrZSBzZW5zZS5cblx0XHRcdGlmICghaGFzRXhwbGljaXRDb250ZW50cylcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlc2NlbmRQYXJhbGxlbHNGb2xsb3dGbiA9IChwYXI6IFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIShwYXIgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKSlcblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBiYXNlcyA9IEFycmF5LmZyb20ocGFyLmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0Lm1hcChlbnRyeSA9PiBlbnRyeS5iYXNlIGFzIFBhcmFsbGVsKVxuXHRcdFx0XHRcdC5zbGljZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYmFzZXNcblx0XHRcdFx0XHQuY29uY2F0KHBhci5nZXRQYXJhbGxlbHMoKSlcblx0XHRcdFx0XHQuZmlsdGVyKHBhciA9PiAhcHJ1bmVkUGFyYWxsZWxzLmhhcyhwYXIpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzZWVkID0gTWlzYy5yZWR1Y2VSZWN1cnNpdmUoXG5cdFx0XHRcdHplbml0aCxcblx0XHRcdFx0ZGVzY2VuZFBhcmFsbGVsc0ZvbGxvd0ZuLFxuXHRcdFx0XHQoY3VycmVudCwgbmVzdGVkOiByZWFkb25seSBQYXJhbGxlbFtdKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dFBhciA9IGRlc2NlbmRPbmUoY3VycmVudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBlZGdlIG9mIG5lc3RlZClcblx0XHRcdFx0XHRcdG5leHRQYXIuYWRkUGFyYWxsZWwoZWRnZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5leHRQYXI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgdmVyaWZpY2F0aW9uIG9uIHRoZSBkZXNjZW5kIG9wZXJhdGlvbi5cblx0XHQgKiBSZXBvcnRzIGFueSBmYXVsdHMgdGhhdCBjYW4gb2NjdXIgZHVyaW5nIHRoaXMgcHJvY2Vzcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHZlcmlmeURlc2NlbmQoXG5cdFx0XHR6ZW5pdGhQYXJhbGxlbDogRXhwbGljaXRQYXJhbGxlbCxcblx0XHRcdGRlc2NlbmRQYXJhbGxlbDogRXhwbGljaXRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAoZGVzY2VuZFBhcmFsbGVsLm5vZGUuc3ViamVjdCBpbnN0YW5jZW9mIEFub24pXG5cdFx0XHRcdGlmICh6ZW5pdGhQYXJhbGxlbC5pc0xpc3RJbnRyaW5zaWMpXG5cdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmZhdWx0cy5yZXBvcnQobmV3IEZhdWx0KFxuXHRcdFx0XHRcdFx0RmF1bHRzLkFub255bW91c0luTGlzdEludHJpbnNpYyxcblx0XHRcdFx0XHRcdGRlc2NlbmRQYXJhbGxlbC5ub2RlLnN0YXRlbWVudHNbMF0pKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBwYXJhbGxlbHMgPSBuZXcgUGFyYWxsZWxDYWNoZSgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc2V0IG9mIFBhcmFsbGVsIGluc3RhbmNlcyB0aGF0IGhhdmUgYmVlbiBcInJha2VkXCIsXG5cdFx0ICogd2hpY2ggbWVhbnMgdGhhdCB0aGF0IGhhdmUgZ29uZSB0aHJvdWdoIHRoZSBwcm9jZXNzIG9mXG5cdFx0ICogaGF2aW5nIHRoZWlyIHJlcXVlc3RlZCBiYXNlcyBhcHBsaWVkLlxuXHRcdCAqIFxuXHRcdCAqIFRoaXMgc2V0IG1heSBpbmNsdWRlIGJvdGggcGF0dGVybiBhbmQgbm9uLXBhdHRlcm5zIFBhcmFsbGVscyxcblx0XHQgKiAoZXZlbiB0aG91Z2ggdGhlaXIgcmFraW5nIHByb2Nlc3NlcyBhcmUgY29tcGxldGVseSBkaWZmZXJlbnQpLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcmFrZWRQYXJhbGxlbHMgPSBuZXcgV2Vha1NldDxQYXJhbGxlbD4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGNydWZ0OiBDcnVmdENhY2hlO1xuXHR9XG5cdFxuXHQvKiogKi9cblx0aW50ZXJmYWNlIElQYXR0ZXJuUGFyYWxsZWxcblx0e1xuXHRcdHJlYWRvbmx5IHBhdHRlcm46IFBhdHRlcm47XG5cdFx0cmVhZG9ubHkgcGF0dGVyblBhcmFsbGVsOiBFeHBsaWNpdFBhcmFsbGVsO1xuXHR9XG5cdFxuXHQvKiogKi9cblx0ZXhwb3J0IHR5cGUgVEJhc2VUYWJsZSA9IFJlYWRvbmx5TWFwPEV4cGxpY2l0UGFyYWxsZWwsIEh5cGVyRWRnZT47XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgUGFyYWxsZWxcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEludm9rZWQgYnkgUGFyYWxsZWxDYWNoZS4gRG8gbm90IGNhbGwuXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBwaHJhc2U6IFBocmFzZSxcblx0XHRcdHJlYWRvbmx5IGNvbnRhaW5lcjogUGFyYWxsZWwgfCBudWxsKVxuXHRcdHtcblx0XHRcdGlmIChcIkRFQlVHXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubmFtZSA9IHBocmFzZS50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLm5hbWUuc3RhcnRzV2l0aChcIi9cIikpXG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gdW5lc2NhcGUodGhpcy5uYW1lKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGNvbnRhaW5lciAhPT0gbnVsbClcblx0XHRcdFx0Y29udGFpbmVyLl9jb250ZW50cy5zZXQocGhyYXNlLnRlcm1pbmFsLCB0aGlzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogU3RvcmVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUGFyYWxsZWwsXG5cdFx0ICogdXNlZnVsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgbmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGlzIGluc3RhbmNlLFxuXHRcdCAqIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGdldCBjb250ZW50cygpOiBSZWFkb25seU1hcDxTdWJqZWN0LCBQYXJhbGxlbD5cblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29udGVudHM7XG5cdFx0fVxuXHRcdHByaXZhdGUgX2NvbnRlbnRzID0gbmV3IE1hcDxTdWJqZWN0LCBQYXJhbGxlbD4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXRQYXJhbGxlbHMoKVxuXHRcdHtcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMuX3BhcmFsbGVscy5zbGljZSgpKTtcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfcGFyYWxsZWxzOiBQYXJhbGxlbFtdID0gW107XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGhhc1BhcmFsbGVscygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhcmFsbGVscy5sZW5ndGggPiAwO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGRQYXJhbGxlbChwYXJhbGxlbDogUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLl9wYXJhbGxlbHMuaW5jbHVkZXMocGFyYWxsZWwpKVxuXHRcdFx0XHR0aGlzLl9wYXJhbGxlbHMucHVzaChwYXJhbGxlbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQYXJhbGxlbCwgc3VpdGFibGUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMucGhyYXNlLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRXhwbGljaXRQYXJhbGxlbCBleHRlbmRzIFBhcmFsbGVsXG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBJbnZva2VkIGJ5IFBhcmFsbGVsQ2FjaGUuIERvIG5vdCBjYWxsLlxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0bm9kZTogTm9kZSxcblx0XHRcdGNvbnRhaW5lcjogRXhwbGljaXRQYXJhbGxlbCB8IG51bGwsXG5cdFx0XHRjcnVmdDogQ3J1ZnRDYWNoZSlcblx0XHR7XG5cdFx0XHRzdXBlcihub2RlLnBocmFzZSwgY29udGFpbmVyKTtcblx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHR0aGlzLmNydWZ0ID0gY3J1ZnQ7XG5cdFx0XHRcblx0XHRcdG5vZGUuZG9jdW1lbnQucHJvZ3JhbS5mYXVsdHMuaW5mb3JtKG5vZGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIE5vZGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGlzXG5cdFx0ICogRXhwbGljaXRQYXJhbGxlbCBpbnN0YW5jZS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBub2RlOiBOb2RlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBpc0NvbnRyYWN0U2F0aXNmaWVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250cmFjdC51bnNhdGlzZmllZENvbmRpdGlvbnMuc2l6ZSA9PT0gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBnZXQgY29udHJhY3QoKTogQ29udHJhY3Rcblx0XHR7XG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29udHJhY3QgaXMgY29tcHV0ZWQgbGF6aWx5LCBiZWNhdXNlXG5cdFx0XHQvLyBpZiB5b3UgdHJ5IHRvIGNvbXB1dGUgaXQgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgUGFyYWxsZWwgZ3JhcGhcblx0XHRcdC8vIHdvbid0IGJlIGNvbnN0cnVjdGVkLCBhbmQgeW91J2xsIGVuZCB1cCB3aXRoIGFuIGVtcHR5IGNvbnRyYWN0LlxuXHRcdFx0aWYgKHRoaXMuX2NvbnRyYWN0ID09PSBudWxsKVxuXHRcdFx0XHR0aGlzLl9jb250cmFjdCA9IG5ldyBDb250cmFjdCh0aGlzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRyYWN0O1xuXHRcdH1cblx0XHRwcml2YXRlIF9jb250cmFjdDogQ29udHJhY3QgfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGNydWZ0OiBDcnVmdENhY2hlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIGZpcnN0IGJhc2UgY29udGFpbmVkIGJ5IHRoaXMgaW5zdGFuY2UuXG5cdFx0ICogQHRocm93cyBJbiB0aGUgY2FzZSB3aGVuIHRoaXMgaW5zdGFuY2UgY29udGFpbnMgbm8gYmFzZXMuXG5cdFx0ICovXG5cdFx0Z2V0IGZpcnN0QmFzZSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBiYXNlRW50cnkgb2YgdGhpcy5fYmFzZXMudmFsdWVzKCkpXG5cdFx0XHRcdHJldHVybiBiYXNlRW50cnkucGFyYWxsZWxzWzBdO1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgc2hhbGxvdyB0cmF2ZXJzYWwgb24gdGhlIG5vbi1jcnVmdCBiYXNlc1xuXHRcdCAqIGRlZmluZWQgZGlyZWN0bHkgb24gdGhpcyBFeHBsaWNpdFBhcmFsbGVsLlxuXHRcdCAqL1xuXHRcdCplYWNoQmFzZSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBbZWRnZSwgYmFzZUVudHJ5XSBvZiB0aGlzLl9iYXNlcylcblx0XHRcdFx0aWYgKCF0aGlzLmNydWZ0LmhhcyhlZGdlKSlcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGJhc2Ugb2YgYmFzZUVudHJ5LnBhcmFsbGVscylcblx0XHRcdFx0XHRcdHlpZWxkIHsgYmFzZSwgZWRnZSwgYWxpYXNlZDogYmFzZUVudHJ5LmFsaWFzZWQgfTtcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfYmFzZXMgPSBuZXcgTWFwPEh5cGVyRWRnZSwgSUJhc2VFbnRyeT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIGFkZEJhc2VFbnRyeShcblx0XHRcdGJhc2U6IEV4cGxpY2l0UGFyYWxsZWwsXG5cdFx0XHRlZGdlOiBIeXBlckVkZ2UsXG5cdFx0XHRhbGlhc2VkOiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYmFzZXMuZ2V0KGVkZ2UpO1xuXHRcdFx0aWYgKGV4aXN0aW5nKVxuXHRcdFx0XHRleGlzdGluZy5wYXJhbGxlbHMucHVzaChiYXNlKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5fYmFzZXMuc2V0KGVkZ2UsIHsgcGFyYWxsZWxzOiBbYmFzZV0sIGFsaWFzZWQgfSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgZGVlcCB0cmF2ZXJzYWwgb24gdGhlIG5vbi1jcnVmdCBiYXNlc1xuXHRcdCAqIGRlZmluZWQgb24gdGhpcyBQYXJhbGxlbC5cblx0XHQgKi9cblx0XHQqZWFjaEJhc2VEZWVwKClcblx0XHR7XG5cdFx0XHRjb25zdCBxdWV1ZSA9IEFycmF5LmZyb20odGhpcy5lYWNoQmFzZSgpKS5tYXAoZSA9PiBlLmJhc2UpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZVtpXTtcblx0XHRcdFx0eWllbGQgY3VycmVudDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgY3VycmVudC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdGlmICghcXVldWUuaW5jbHVkZXMoYmFzZSkpXG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGJhc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcHJvdmlkZWRcblx0XHQgKiBFeHBsaWNpdFBhcmFsbGVsIGluc3RhbmNlIGV4aXN0cyBzb21ld2hlcmUsIHBvc3NpYmx5IG5lc3RlZCxcblx0XHQgKiBpbiB0aGUgYmFzZSBncmFwaCBvZiB0aGlzIGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdGhhc0Jhc2UodGVzdEJhc2U6IEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcXVldWUgPSBBcnJheS5mcm9tKHRoaXMuZWFjaEJhc2UoKSkubWFwKGUgPT4gZS5iYXNlKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBxdWV1ZS5sZW5ndGg7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjdXJyZW50ID0gcXVldWVbaV07XG5cdFx0XHRcdGlmIChjdXJyZW50ID09PSB0ZXN0QmFzZSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgY3VycmVudC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdGlmICghcXVldWUuaW5jbHVkZXMoYmFzZSkpXG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGJhc2UpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIGFkZCB0aGUgcHJvdmlkZWQgRXhwbGljaXRQYXJhbGxlbCBhcyBhIGJhc2Ugb2Zcblx0XHQgKiB0aGlzIGluc3RhbmNlLiBJZiB0aGUgYWRkaXRpb24gb2YgdGhlIG5ldyBiYXNlIHdvdWxkIG5vdCBnZW5lcmF0ZVxuXHRcdCAqIGFueSBjcml0aWNhbCBmYXVsdHMsIGl0IGlzIGFkZGVkLiBPdGhlcndpc2UsIGl0J3MgbWFya2VkIGFzIGNydWZ0LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBiYXNlXG5cdFx0ICogd2FzIGFkZGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKi9cblx0XHR0cnlBZGRMaXRlcmFsQmFzZShiYXNlOiBFeHBsaWNpdFBhcmFsbGVsLCB2aWE6IEh5cGVyRWRnZSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYmFzZXMuaGFzKHZpYSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Ly8gSnVzdCBhcyBhIHJlbWluZGVyIC0tIHBhdHRlcm4tY29udGFpbmluZyBwYXJhbGxlbHMgXG5cdFx0XHQvLyBkb24ndCBjb21lIGludG8gdGhpcyBtZXRob2QuIEJhc2VzIGFyZSBhcHBsaWVkIHRvXG5cdFx0XHQvLyBwYXR0ZXJucyBpbiB0cnlBcHBseVBhdHRlcm5CYXNlcy5cblx0XHRcdGlmICh0aGlzLnBhdHRlcm4pXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbnVtU2F0aXNmaWVkID0gdGhpcy5jb250cmFjdC50cnlTYXRpc2Z5Q29uZGl0aW9uKGJhc2UpO1xuXHRcdFx0aWYgKG51bVNhdGlzZmllZCA9PT0gMCAmJiB0aGlzLmNvbnRyYWN0Lmhhc0NvbmRpdGlvbnMpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc2FuaXRpemVyID0gbmV3IFNhbml0aXplcih0aGlzLCBiYXNlLCB2aWEsIHRoaXMuY3J1ZnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgbmVlZCB0byBkbyBhIFxuXHRcdFx0Ly8gc2hhbGxvdyBjaGVjayBmb3IgY2lyY3VsYXIgaW5oZXJpdGFuY2UuXG5cdFx0XHRpZiAoc2FuaXRpemVyLmRldGVjdENpcmN1bGFyUmVmZXJlbmNlcygpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChzYW5pdGl6ZXIuZGV0ZWN0TGlzdEZyYWdtZW50Q29uZmxpY3RzKCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuYmFzZUNvdW50ID4gMClcblx0XHRcdFx0aWYgKHNhbml0aXplci5kZXRlY3RMaXN0RGltZW5zaW9uYWxpdHlDb25mbGljdCgpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hZGRCYXNlRW50cnkoYmFzZSwgdmlhLCBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gaW5kaXJlY3RseSBhcHBseSBhIGJhc2UgdG8gdGhpcyBFeHBsaWNpdFBhcmFsbGVsIHZpYSBhbiBhbGlhc1xuXHRcdCAqIGFuZCBlZGdlLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzIFRoZSBwYXR0ZXJuLWNvbnRhaW5pbmdcblx0XHQgKiBFeHBsaWNpdFBhcmFsbGVsIGluc3RhbmNlIHdob3NlIGJhc2VzIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoaXNcblx0XHQgKiBFeHBsaWNpdFBhcmFsbGVsLCBpZiB0aGUgcHJvdmlkZWQgYWxpYXMgaXMgYSBtYXRjaC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gdmlhRWRnZSBUaGUgSHlwZXJFZGdlIGluIHdoaWNoIHRoZSBhbGlhcyB3YXMgZm91bmQuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHZpYUFsaWFzIFRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0IHRoZSBwYXJhbGxlbCBlbWJlZGRlZFxuXHRcdCAqIHdpdGhpbiBwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgYmFzZSB3YXMgYWRkZWRcblx0XHQgKiBzdWNjZXNzZnVsbHkuXG5cdFx0ICovXG5cdFx0dHJ5QWRkQWxpYXNlZEJhc2UoXG5cdFx0XHRwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzOiBFeHBsaWNpdFBhcmFsbGVsW10sXG5cdFx0XHR2aWFFZGdlOiBIeXBlckVkZ2UsXG5cdFx0XHR2aWFBbGlhczogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9iYXNlcy5oYXModmlhRWRnZSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY2hvc2VuUGFyYWxsZWxzID0gcGF0dGVyblBhcmFsbGVsQ2FuZGlkYXRlcy5zbGljZSgpO1xuXHRcdFx0Y29uc3QgY29uZGl0aW9ucyA9IHRoaXMuY29udHJhY3QudW5zYXRpc2ZpZWRDb25kaXRpb25zO1xuXHRcdFx0Y29uc3QgYmVnYW5XaXRoQ29uZGl0aW9ucyA9IGNvbmRpdGlvbnMuc2l6ZSA+IDA7XG5cdFx0XHRcblx0XHRcdGlmIChiZWdhbldpdGhDb25kaXRpb25zKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgbWF4TWF0Y2hDb3VudCA9IDE7XG5cdFx0XHRcdFxuXHRcdFx0XHRuZXh0Q2FuZGlkYXRlOiBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZW50cmllcyA9IEFycmF5LmZyb20oY2FuZGlkYXRlLl9iYXNlcy52YWx1ZXMoKSk7XG5cdFx0XHRcdFx0Y29uc3QgY2FuZGlkYXRlQmFzZXMgPSBlbnRyaWVzXG5cdFx0XHRcdFx0XHQubWFwKGUgPT4gZS5wYXJhbGxlbHMpXG5cdFx0XHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjYW5kaWRhdGVCYXNlcy5sZW5ndGggPCBtYXhNYXRjaENvdW50KVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjYW5kaWRhdGVCYXNlIG9mIGNhbmRpZGF0ZUJhc2VzKVxuXHRcdFx0XHRcdFx0aWYgKCFjb25kaXRpb25zLmhhcyhjYW5kaWRhdGVCYXNlKSlcblx0XHRcdFx0XHRcdFx0Y29udGludWUgbmV4dENhbmRpZGF0ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjaG9zZW5QYXJhbGxlbHMucHVzaChjYW5kaWRhdGUpO1xuXHRcdFx0XHRcdG1heE1hdGNoQ291bnQgPSBjYW5kaWRhdGVCYXNlcy5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjaG9zZW5QYXJhbGxlbHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bGV0IHdhc0FkZGVkID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgY2hvc2VuUGFyYWxsZWwgb2YgY2hvc2VuUGFyYWxsZWxzKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBKdXN0IGFzIGEgcmVtaW5kZXIgLS0gcGF0dGVybi1jb250YWluaW5nIHBhcmFsbGVscyBkb24ndCBjb21lXG5cdFx0XHRcdC8vIGludG8gdGhpcyBtZXRob2QgLi4uIG9ubHkgdGhlIGFsaWFzZXMgdGhhdCBtaWdodCBtYXRjaCB0aGVtLlxuXHRcdFx0XHRpZiAodGhpcy5wYXR0ZXJuIHx8ICFjaG9zZW5QYXJhbGxlbC5wYXR0ZXJuKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXRQYXR0ZXJuIGhhcyBubyBpbmZpeGVzLCB3ZSBjYW4gZ2V0IGF3YXkgd2l0aCBhIHNpbXBsZVxuXHRcdFx0XHQvLyBjaGVjayB0byBzZWUgaWYgdGhlIGFsaWFzIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi5cblx0XHRcdFx0aWYgKCFjaG9zZW5QYXJhbGxlbC5wYXR0ZXJuLmhhc0luZml4ZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghY2hvc2VuUGFyYWxsZWwucGF0dGVybi50ZXN0KHZpYUFsaWFzKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChiZWdhbldpdGhDb25kaXRpb25zKVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY29udHJhY3QudHJ5U2F0aXNmeUNvbmRpdGlvbihjaG9zZW5QYXJhbGxlbCkgPT09IDApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMuYWRkQmFzZUVudHJ5KGNob3NlblBhcmFsbGVsLCB2aWFFZGdlLCB0cnVlKTtcblx0XHRcdFx0XHR3YXNBZGRlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gTm90IGltcGxlbWVudGVkLCBidXQgd2Ugc2hvdWxkbid0IHRocm93IGFuIGV4Y2VwdGlvbiBoZXJlIHlldC5cblx0XHRcdHJldHVybiB3YXNBZGRlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gYXBwbHkgYSBzZXQgb2YgYmFzZXMgdG8gYSBwYXR0ZXJuLWNvbnRhaW5pbmcgcGFyYWxsZWwuXG5cdFx0ICogXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvcGF0dGVybiA6IFRoaXMsIEZ1bmN0aW9uLCBBZGRzLCBUaGVzZVxuXHRcdCAqL1xuXHRcdHRyeUFwcGx5UGF0dGVybkJhc2VzKGJhc2VUYWJsZTogVEJhc2VUYWJsZSlcblx0XHR7XG5cdFx0XHRjb25zdCBiYXNlcyA9IEFycmF5LmZyb20oYmFzZVRhYmxlLmtleXMoKSk7XG5cdFx0XHRcblx0XHRcdC8vIE5vbi1QYXR0ZXJuIG5vZGVzIHNob3VsZCBuZXZlciBjb21lIHRvIHRoaXMgbWV0aG9kLlxuXHRcdFx0aWYgKCF0aGlzLnBhdHRlcm4pXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYmFzZXNEZWVwID0gYmFzZXNcblx0XHRcdFx0Lm1hcChiID0+IEFycmF5LmZyb20oYi5lYWNoQmFzZURlZXAoKSkpXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSlcblx0XHRcdFx0LmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmVtaW5kZXI6IHRoZSBFeHBsaWNpdFBhcmFsbGVscyBpbiB0aGUgYmFzZXNEZWVwIGFycmF5XG5cdFx0XHQvLyBhcmUgZXhwZWN0ZWQgdG8gYmUgZnVsbHkgcHJvY2Vzc2VkIGJ5IHRoZSB0aW1lIHdlIGdldCB0b1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QuIEl0IHNob3VsZCBiZSBzYWZlIHRvIHRvdWNoIHRoZW0uXG5cdFx0XHRcblx0XHRcdGlmIChiYXNlc0RlZXAubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYmFzZXNOb2RlcyA9IGJhc2VzLm1hcChiID0+IGIubm9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBGaW5kcyBhbGwgcGF0dGVybiBub2RlcyB0aGF0IGhhdmUgYW4gZWRnZSB0aGF0IHBvaW50c1xuXHRcdFx0XHQvLyB0byBhdCBsZWFzdCBvbmUgb2YgdGhlIGJhc2VzIGluIHRoZSBiYXNlc0RlZXAgYXJyYXkuXG5cdFx0XHRcdGNvbnN0IGJhc2VzRGVlcFNwcmF3bCA9IGJhc2VzRGVlcFxuXHRcdFx0XHRcdC5tYXAoYiA9PiBBcnJheS5mcm9tKGIubm9kZS5pbmJvdW5kcykpXG5cdFx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuXHRcdFx0XHRcdC5tYXAoaW5iID0+IGluYi5wcmVkZWNlc3Nvcilcblx0XHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpXG5cdFx0XHRcdFx0LmZpbHRlcihub2RlID0+IG5vZGUuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0LmZpbHRlcihub2RlID0+IG5vZGUub3V0Ym91bmRzXG5cdFx0XHRcdFx0XHQuZmlsdGVyKG9iID0+IG9iLnN1Y2Nlc3NvcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0Lm1hcChvYiA9PiBvYi5zdWNjZXNzb3JzWzBdLm5vZGUpXG5cdFx0XHRcdFx0XHQuZXZlcnkobm9kZSA9PiBiYXNlc05vZGVzLmluY2x1ZGVzKG5vZGUpKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBiYXNlc0RlZXBTcHJhd2xQYXR0ZXJucyA9IGJhc2VzRGVlcFNwcmF3bFxuXHRcdFx0XHRcdC5tYXAobiA9PiBuLnN1YmplY3QpXG5cdFx0XHRcdFx0LmZpbHRlcigocyk6IHMgaXMgUGF0dGVybiA9PiBzIGluc3RhbmNlb2YgUGF0dGVybik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB0ZXN0IGV2ZXJ5IHNpbmdsZSBvbmUgb2YgdGhlIFxuXHRcdFx0XHQgKiBwYXR0ZXJucyBpbiBiYXNlc0RlZXBTcHJhd2xQYXR0ZXJucyBhZ2FpbnN0IHRoaXNcblx0XHRcdFx0ICogdGhpcy5ub2RlLnN1YmplY3QgdG8gbWFrZSBzdXJlIHRoZSB0d28gcGF0dGVybnMgYXJlXG5cdFx0XHRcdCAqIGNvbXBsaWFudC5cblx0XHRcdFx0ICogXG5cdFx0XHRcdCAqIElmIHRoZXkncmUgbm90IGNvbXBsaWFudCwgd2UgbmVlZCB0byBzdGFydCBtYXJraW5nXG5cdFx0XHRcdCAqIGJhc2VzIGFzIGNydWZ0IHVudGlsIHRoZXkgYXJlLlxuXHRcdFx0XHQgKiBcblx0XHRcdFx0ICogVGhlcmUgaXMgYWxzbyBhIHJlY3Vyc2l2ZSBpbmZpeCBlbWJlZCBwcm9jZXNzIHRoYXRcblx0XHRcdFx0ICogbmVlZHMgdG8gaGFwcGVuIGhlcmUsIGJ1dCBtYXliZSB3ZSBzaG91bGQganVzdFxuXHRcdFx0XHQgKiBwdXQgdGhpcyBvZmYgdW50aWwgdGhlIGJhc2ljIHBhdHRlcm4gZnVuY3Rpb25hbGl0eVxuXHRcdFx0XHQgKiBpcyB3b3JraW5nP1xuXHRcdFx0XHQgKi9cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIGFsc28gbmVlZHMgdG8gdGFrZSBpbnRvIGFjY291bnQgYW55IG90aGVyIHBhdHRlcm5zXG5cdFx0XHQgKiB0aGF0IGFyZSBhcHBsaWVkIHRvIGFueSBvZiB0aGUgYmFzZXMgZGVmaW5lZCBkaXJlY3RseVxuXHRcdFx0ICogaW5saW5lLlxuXHRcdFx0ICovXG5cdFx0XHRcblx0XHRcdC8vIEhlcmUgd2UncmUganVzdCBhZGRpbmcgYWxsIHRoZSBiYXNlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXJcblx0XHRcdC8vIG9yIG5vdCBhbnkgb2YgdGhlIGFzc29jaWF0ZWQgZWRnZXMgd2VyZSBtYXJrZWQgYXMgY3J1ZnQuXG5cdFx0XHQvLyBUaGUgb3RoZXIgZW51bWVyYXRvcnMgc2tpcCBvdmVyIGNydWZ0IGVkZ2VzLCBzbyB0aGlzIGxpa2VseVxuXHRcdFx0Ly8gaXNuJ3QgYSBwcm9ibGVtLCBhbmQgaXQga2VlcHMgaXQgY29uc2lzdGVudCB3aXRoIHRoZSB3YXkgdGhlXG5cdFx0XHQvLyByZXN0IG9mIHRoZSBzeXN0ZW0gd29ya3MuXG5cdFx0XHRmb3IgKGNvbnN0IFtiYXNlLCB2aWFdIG9mIGJhc2VUYWJsZSlcblx0XHRcdFx0dGhpcy5hZGRCYXNlRW50cnkoYmFzZSwgdmlhLCBmYWxzZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIG51bWJlciBvZiBiYXNlcyB0aGF0IGhhdmUgXG5cdFx0ICogYmVlbiBleHBsaWNpdGx5IGFwcGxpZWQgdG8gdGhpcyBQYXJhbGxlbC5cblx0XHQgKi9cblx0XHRnZXQgYmFzZUNvdW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYmFzZXMuc2l6ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzTGlzdEludHJpbnNpYygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZS5pc0xpc3RJbnRyaW5zaWM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBpbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2U7XG5cdFx0fVxuXHRcdHByaXZhdGUgX2ludHJpbnNpY0V4dHJpbnNpY0JyaWRnZTogRXhwbGljaXRQYXJhbGxlbCB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVzdGFibGlzaGVzIGEgYnJpZGdlIGJldHdlZW4gdGhpcyBFeHBsaWNpdFBhcmFsbGVsIGFuZCB0aGVcblx0XHQgKiBvbmUgcHJvdmlkZWQuIFxuXHRcdCAqL1xuXHRcdGNyZWF0ZUludHJpbnNpY0V4dHJpbnNpY0JyaWRnZShwYXJhbGxlbDogRXhwbGljaXRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5faW50cmluc2ljRXh0cmluc2ljQnJpZGdlICE9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbGxlbC5faW50cmluc2ljRXh0cmluc2ljQnJpZGdlICE9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbGxlbC5ub2RlLmlzTGlzdEludHJpbnNpYyA9PT0gdGhpcy5ub2RlLmlzTGlzdEludHJpbnNpYylcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UgPSBwYXJhbGxlbDtcblx0XHRcdHBhcmFsbGVsLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UgPSB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXRMaXN0RGltZW5zaW9uYWxpdHkoKTogbnVtYmVyXG5cdFx0e1xuXHRcdFx0Ly8gTk9URTogVGhpcyBhY3R1YWxseSBuZWVkcyB0byBiZSBcImVhY2ggYmFzZSBpbmZlcnJlZFwiXG5cdFx0XHRcblx0XHRcdC8vIFRoaXMgaXMgcHVycG9zZWx5IG9ubHkgcmV0dXJuaW5nIHRoZSBkaW1lbnNpb25hbGl0eSBvZlxuXHRcdFx0Ly8gdGhlIGZpcnN0IGJhc2UuIFRoZXJlIGlzIGEgZ3VhcmFudGVlIHRoYXQgYWxsIGRpbWVuc2lvbmFsaXRpZXNcblx0XHRcdC8vIHdpbGwgYmUgdGhlIHNhbWUgaGVyZS5cblx0XHRcdGZvciAoY29uc3QgeyBiYXNlLCBlZGdlIH0gb2YgdGhpcy5lYWNoQmFzZSgpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBpbml0aWFsRGltID0gYmFzZS5nZXRMaXN0RGltZW5zaW9uYWxpdHkoKTtcblx0XHRcdFx0cmV0dXJuIGVkZ2UuaXNMaXN0ID8gaW5pdGlhbERpbSArIDEgOiBpbml0aWFsRGltO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBjb21wYXJlUGF0dGVyblRvKG90aGVyOiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdFxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIG1heWJlQ29tcGlsZVBhdHRlcm4oKVxuXHRcdHtcblx0XHRcdC8vL2lmICghdGhpcy5wYXR0ZXJuKVxuXHRcdFx0Ly8vXHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdC8vL2lmICghcGF0dGVybi5oYXNJbmZpeGVzKCkpXG5cdFx0XHQvLy9cdHRoaXMuY29tcGlsZWRFeHByZXNzaW9uID0gcGF0dGVybi5cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgUGF0dGVybiBpbnN0YW5jZSB0aGF0IHJlc2lkZXMgaW5zaWRlIHRoaXMgRXhwbGljaXRQYXJhbGxlbCxcblx0XHQgKiBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gdGhpcyBFeHBsaWNpdFBhcmFsbGVsIGRvZXMgbm90IGhhdmUgYW5cblx0XHQgKiBpbm5lciBQYXR0ZXJuLlxuXHRcdCAqL1xuXHRcdGdldCBwYXR0ZXJuKCk6IFBhdHRlcm4gfCBudWxsXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybiA/XG5cdFx0XHRcdHRoaXMubm9kZS5zdWJqZWN0IDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21waWxlZCByZWd1bGFyIGV4cHJlc3Npb25cblx0XHQgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZSwgaW4gdGhlIGNhc2Ugd2hlbiB0aGlzIGluc3RhbmNlIGlzXG5cdFx0ICogYSBwYXR0ZXJuIHBhcmFsbGVsLlxuXHRcdCAqIFxuXHRcdCAqIFRoaXMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHNob3VsZCBoYXZlIGFueSBpbmZpeGVzIGNvbXBpbGVkIGF3YXksXG5cdFx0ICogYW5kIHNob3VsZCBiZSBwYXNzYWJsZSB0byBhIEphdmFTY3JpcHQgUmVnRXhwLCBvciB0byB0aGUgRnNtIHN5c3RlbS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGNvbXBpbGVkRXhwcmVzc2lvbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBIHR5cGUgdGhhdCBkZXNjcmliZXMgYW4gZW50cnkgaW4gdGhlIGJhc2VzIG1hcFxuXHQgKiBvZiBhIEV4cGxpY2l0UGFyYWxsZWwuXG5cdCAqL1xuXHRpbnRlcmZhY2UgSUJhc2VFbnRyeVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBzZXQgb2YgRXhwbGljaXRQYXJhbGxlbHMgdGhhdCBjYXVzZWQgdGhlIGJhc2UgdG8gYmUgY29uc3RydWN0ZWQuXG5cdFx0ICogTm90ZSB0aGF0IGEgYmFzZSBlbnRyeSBjYW4gaGF2ZSBtdWx0aXBsZSBwYXJhbGxlbHMgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgYmFzZVxuXHRcdCAqIGlzIGFjdHVhbGx5IGEgcGF0dGVybiB3aXRoIHR3byBlcXVhbGx5IHZpYWJsZSBtYXRjaGVzIGluIHNjb3BlLCBhbmQgbm8gY29udHJhY3Rcblx0XHQgKiBiZWluZyBpbXBvc2VkLCBmb3IgZXhhbXBsZTpcblx0XHQgKiBcblx0XHQgKiAvcGF0dGVybiA6IEFcblx0XHQgKiAvcGF0dGVybiA6IEJcblx0XHQgKiBcblx0XHQgKiBWYWx1ZSA6IHBhdHRlcm4gfiBBLCBCXG5cdFx0ICovXG5cdFx0cGFyYWxsZWxzOiBFeHBsaWNpdFBhcmFsbGVsW107XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyB3aGV0aGVyIHRoZSB0ZXJtIGlzIGFuIGFsaWFzIChtYXRjaGVkIGJ5IGEgcGF0dGVybikuICovXG5cdFx0YWxpYXNlZDogYm9vbGVhbjtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEltcGxpY2l0UGFyYWxsZWwgZXh0ZW5kcyBQYXJhbGxlbFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW52b2tlZCBieSBQYXJhbGxlbENhY2hlLiBEbyBub3QgY2FsbC5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHBocmFzZTogUGhyYXNlLFxuXHRcdFx0Y29udGFpbmVyOiBQYXJhbGxlbCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIocGhyYXNlLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdm9pZHMgZXJyb25lb3VzIHN0cnVjdHVyYWwgdHlwZSBjb21wYXRpYmlsaXR5IHdpdGggUGFyYWxsZWwuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1bmlxdWU6IHVuZGVmaW5lZDtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgc2ltcGxlIGNsYXNzIGZvciBoYW5kbGluZyBvYmplY3RzIG1hcmtlZCBhcyBjcnVmdC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDcnVmdENhY2hlXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYSBmYXVsdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgdG8gdGhlIGludGVybmFsIHNldCxcblx0XHQgKiBtYXJrcyBhbGwgcmVsZXZhbnQgb2JqZWN0cyBhcyBjcnVmdCwgYW5kIHJlcG9ydHMgdGhlXG5cdFx0ICogcmVsZXZhbnQgZmF1bHQgdHlwZS5cblx0XHQgKi9cblx0XHRhZGQoY3J1ZnQ6IFRDcnVmdCwgcmVsZXZhbnRGYXVsdFR5cGU6IEZhdWx0VHlwZSlcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdFNvdXJjZXM6IHJlYWRvbmx5IFRGYXVsdFNvdXJjZVtdID1cblx0XHRcdFx0Y3J1ZnQgaW5zdGFuY2VvZiBOb2RlID8gY3J1ZnQuc3RhdGVtZW50cyA6IFxuXHRcdFx0XHRjcnVmdCBpbnN0YW5jZW9mIEh5cGVyRWRnZSA/IGNydWZ0LmZyYWdtZW50cyA6XG5cdFx0XHRcdFtjcnVmdF07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZmF1bHRTcmMgb2YgZmF1bHRTb3VyY2VzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBmYXVsdCA9IG5ldyBGYXVsdChyZWxldmFudEZhdWx0VHlwZSwgZmF1bHRTcmMpO1xuXHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChmYXVsdCk7XG5cdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGZhdWx0U3JjKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5jcnVmdC5hZGQoY3J1ZnQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcblx0XHQgKiBzcGVjaWZpZWQgb2JqZWN0IGhhcyBiZWVuIG1hcmtlZCBhcyBjcnVmdC5cblx0XHQgKi9cblx0XHRoYXMoc291cmNlOiBUQ3J1ZnQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY3J1ZnQuaGFzKHNvdXJjZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgYSBzZXQgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgY3J1ZnQuICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjcnVmdCA9IG5ldyBTZXQ8VENydWZ0PigpO1xuXHR9XG5cdFxuXHQvKiogKi9cblx0ZXhwb3J0IHR5cGUgVENydWZ0ID0gVEZhdWx0U291cmNlIHwgTm9kZSB8IEh5cGVyRWRnZTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQYXJhbGxlbENhY2hlXG5cdHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgUGFyYWxsZWwgaW5zdGFuY2UgZnJvbSB0aGUgc3BlY2lmaWVkIE5vZGUgb3Jcblx0XHQgKiBVcmkgaW5zdGFuY2UuIFxuXHRcdCAqIFxuXHRcdCAqIEB0aHJvd3MgSW4gdGhlIGNhc2Ugd2hlbiBhbGwgY29udGFpbmluZyBQYXJhbGxlbFR5cGVzIHRvIGhhdmVcblx0XHQgKiBub3QgYmVlbiBjcmVhdGVkIGJlZm9yZWhhbmQuXG5cdFx0ICogXG5cdFx0ICogQHRocm93IEluIHRoZSBjYXNlIHdoZW4gYSBQYXJhbGxlbFR5cGUgY29ycmVzcG9uZGluZyB0byB0aGVcblx0XHQgKiBpbnB1dCB3YXMgYWxyZWFkeSBjcmVhdGVkLlxuXHRcdCAqL1xuXHRcdGNyZWF0ZShub2RlOiBOb2RlLCBjcnVmdDogQ3J1ZnRDYWNoZSk6IEV4cGxpY2l0UGFyYWxsZWw7XG5cdFx0Y3JlYXRlKHBocmFzZTogUGhyYXNlKTogSW1wbGljaXRQYXJhbGxlbDtcblx0XHRjcmVhdGUoa2V5OiBOb2RlIHwgUGhyYXNlLCBjcnVmdD86IENydWZ0Q2FjaGUpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaGFzKGtleSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc2F2ZSA9IChwYXI6IFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBrZXlWYWwgPSB0aGlzLmdldEtleVZhbChrZXkpO1xuXHRcdFx0XHR0aGlzLnBhcmFsbGVscy5zZXQoa2V5VmFsLCBwYXIpO1xuXHRcdFx0XHRyZXR1cm4gcGFyO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29udGFpbmVyID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChrZXkgaW5zdGFuY2VvZiBOb2RlKVxuXHRcdFx0XHRcdHJldHVybiBrZXkuY29udGFpbmVyICE9PSBudWxsID9cblx0XHRcdFx0XHRcdE5vdC51bmRlZmluZWQodGhpcy5nZXQoa2V5LmNvbnRhaW5lcikpIDpcblx0XHRcdFx0XHRcdG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4ga2V5Lmxlbmd0aCA+IDEgP1xuXHRcdFx0XHRcdE5vdC51bmRlZmluZWQodGhpcy5nZXQoa2V5LmJhY2soKSkpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIFBocmFzZSlcblx0XHRcdFx0cmV0dXJuIHNhdmUobmV3IEltcGxpY2l0UGFyYWxsZWwoa2V5LCBjb250YWluZXIpKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbCkgJiYgY29udGFpbmVyICE9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGlmIChjcnVmdCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dFBhciA9IG5ldyBFeHBsaWNpdFBhcmFsbGVsKGtleSwgY29udGFpbmVyLCBjcnVmdCk7XG5cdFx0XHRpZiAoa2V5LmludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHNhdmUob3V0UGFyKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFzKGtleS5pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGJyaWRnZVBhciA9IG5ldyBFeHBsaWNpdFBhcmFsbGVsKFxuXHRcdFx0XHRrZXkuaW50cmluc2ljRXh0cmluc2ljQnJpZGdlLFxuXHRcdFx0XHRjb250YWluZXIsXG5cdFx0XHRcdGNydWZ0KTtcblx0XHRcdFxuXHRcdFx0b3V0UGFyLmNyZWF0ZUludHJpbnNpY0V4dHJpbnNpY0JyaWRnZShicmlkZ2VQYXIpO1xuXHRcdFx0cmV0dXJuIHNhdmUob3V0UGFyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0KGtleTogUGhyYXNlKTogUGFyYWxsZWwgfCB1bmRlZmluZWQ7XG5cdFx0Z2V0KGtleTogTm9kZSk6IEV4cGxpY2l0UGFyYWxsZWwgfCB1bmRlZmluZWQ7XG5cdFx0Z2V0KGtleTogTm9kZSB8IFBocmFzZSlcblx0XHR7XG5cdFx0XHRjb25zdCBrZXlWYWwgPSB0aGlzLmdldEtleVZhbChrZXkpO1xuXHRcdFx0Y29uc3Qgb3V0ID0gdGhpcy5wYXJhbGxlbHMuZ2V0KGtleVZhbCk7XG5cdFx0XHRcblx0XHRcdGlmIChrZXkgaW5zdGFuY2VvZiBOb2RlKVxuXHRcdFx0XHRpZiAob3V0ICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0aWYgKCEob3V0IGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbCkpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGhhcyhrZXk6IE5vZGUgfCBQaHJhc2UpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyYWxsZWxzLmhhcyh0aGlzLmdldEtleVZhbChrZXkpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBnZXRLZXlWYWwoa2V5OiBOb2RlIHwgUGhyYXNlKVxuXHRcdHtcblx0XHRcdHJldHVybiBrZXkgaW5zdGFuY2VvZiBOb2RlID8ga2V5LnBocmFzZSA6IGtleTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIG9mIGFsbCBQYXJhbGxlbCBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkLFxuXHRcdCAqIGtleWVkIGJ5IHRoZSBQaHJhc2UgdG8gd2hpY2ggdGhleSBjb3JyZXNwb25kLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcGFyYWxsZWxzID0gbmV3IE1hcDxQaHJhc2UsIFBhcmFsbGVsPigpO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBkZWJ1ZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdGV4dDogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBwYXJhbGxlbCBvZiB0aGlzLnBhcmFsbGVscy52YWx1ZXMoKSlcblx0XHRcdFx0dGV4dC5wdXNoKHBhcmFsbGVsLm5hbWUgfHwgXCIodW5kZWZpbmVkKVwiKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRleHQuam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDb250cmFjdFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3Ioc291cmNlUGFyYWxsZWw6IEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVjdXJzZSA9IChzcmNQYXJhbGxlbDogUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChzcmNQYXJhbGxlbCBpbnN0YW5jZW9mIEltcGxpY2l0UGFyYWxsZWwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG5lc3RlZFBhcmFsbGVsIG9mIHNyY1BhcmFsbGVsLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRcdFx0cmVjdXJzZShuZXN0ZWRQYXJhbGxlbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoc3JjUGFyYWxsZWwgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBzcmNQYXJhbGxlbC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdFx0dGhpcy5fdW5zYXRpc2ZpZWRDb25kaXRpb25zLmFkZChiYXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBoaWdoZXJQYXJhbGxlbCBvZiBzb3VyY2VQYXJhbGxlbC5nZXRQYXJhbGxlbHMoKSlcblx0XHRcdFx0cmVjdXJzZShoaWdoZXJQYXJhbGxlbCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWxsQ29uZGl0aW9ucyA9IE9iamVjdC5mcmVlemUoQXJyYXkuZnJvbSh0aGlzLl91bnNhdGlzZmllZENvbmRpdGlvbnMpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29tcHV0ZXMgd2hldGhlciB0aGUgaW5wdXQgRXhwbGljaXRQYXJhbGxlbCBpcyBhIG1vcmUgZGVyaXZlZFxuXHRcdCAqIHR5cGUgb2YgdGhlIEV4cGxpY2l0UGFyYWxsZWwgdGhhdCBjb3JyZXNwb25kcyB0byB0aGlzIENvbnRyYWN0LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgbnVtYmVyIHRoYXQgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgY29uZGl0aW9ucyB0aGF0XG5cdFx0ICogd2VyZSBzYXRpc2ZpZWQgYXMgYSByZXN1bHQgb2YgYWRkaW5nIHRoZSBwcm92aWRlZCBFeHBsaWNpdFBhcmFsbGVsXG5cdFx0ICogdG8gdGhlIENvbnRyYWN0LlxuXHRcdCAqL1xuXHRcdHRyeVNhdGlzZnlDb25kaXRpb24oZm9yZWlnblBhcmFsbGVsOiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmFsbENvbmRpdGlvbnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZm9yZWlnblBhcmFsbGVsQmFzZXMgPSBuZXcgU2V0PEV4cGxpY2l0UGFyYWxsZWw+KCk7XG5cdFx0XHRmb3JlaWduUGFyYWxsZWxCYXNlcy5hZGQoZm9yZWlnblBhcmFsbGVsKTtcblx0XHRcdFxuXHRcdFx0bGV0IHNhdGlzZmllZCA9IDA7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFkZEZvcmVpZ25QYXJhbGxlbEJhc2VzID0gKHNyY1BhcmFsbGVsOiBFeHBsaWNpdFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIHNyY1BhcmFsbGVsLmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0YWRkRm9yZWlnblBhcmFsbGVsQmFzZXMoYmFzZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3JlaWduUGFyYWxsZWxCYXNlcy5hZGQoc3JjUGFyYWxsZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBmb3JlaWduUGFyYWxsZWwuZWFjaEJhc2UoKSlcblx0XHRcdFx0YWRkRm9yZWlnblBhcmFsbGVsQmFzZXMoYmFzZSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZm9yZWlnbkJhc2Ugb2YgZm9yZWlnblBhcmFsbGVsQmFzZXMpXG5cdFx0XHRcdGZvciAoY29uc3QgY29uZGl0aW9uIG9mIHRoaXMuYWxsQ29uZGl0aW9ucylcblx0XHRcdFx0XHRpZiAoZm9yZWlnbkJhc2UgPT09IGNvbmRpdGlvbilcblx0XHRcdFx0XHRcdHNhdGlzZmllZCArPSB0aGlzLl91bnNhdGlzZmllZENvbmRpdGlvbnMuZGVsZXRlKGNvbmRpdGlvbikgPyAxIDogMDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNhdGlzZmllZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGhhc0NvbmRpdGlvbnMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFsbENvbmRpdGlvbnMubGVuZ3RoID4gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IHVuc2F0aXNmaWVkQ29uZGl0aW9ucygpOiBSZWFkb25seVNldDxFeHBsaWNpdFBhcmFsbGVsPlxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl91bnNhdGlzZmllZENvbmRpdGlvbnM7XG5cdFx0fVxuXHRcdHByaXZhdGUgcmVhZG9ubHkgX3Vuc2F0aXNmaWVkQ29uZGl0aW9ucyA9IG5ldyBTZXQ8RXhwbGljaXRQYXJhbGxlbD4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGFyYWxsZWxzIHRoYXQgYW55IHN1cHBsaWVkXG5cdFx0ICogcGFyYWxsZWwgbXVzdCBoYXZlIGluIGl0J3MgYmFzZSBncmFwaCBpbiBvcmRlciB0byBiZSBkZWVtZWRcblx0XHQgKiBjb21wbGlhbnQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBhbGxDb25kaXRpb25zOiByZWFkb25seSBFeHBsaWNpdFBhcmFsbGVsW107XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBhY3R1YWwgZmF1bHQgZGV0ZWN0aW9uIGJlaGF2aW9yLFxuXHQgKiB3aXRoIGZhY2lsaXRpZXMgdG8gcGVyZm9ybSBhbmFseXNpcyBvbiBQYXJhbGxlbCBpbnN0YW5jZXMsIGJlZm9yZVxuXHQgKiB0aGUgYWN0dWFsIGJhc2UgaGFzIGJlZW4gYXBwbGllZCB0byBpdC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBTYW5pdGl6ZXJcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cHJpdmF0ZSByZWFkb25seSB0YXJnZXRQYXJhbGxlbDogRXhwbGljaXRQYXJhbGxlbCxcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgcHJvcG9zZWRCYXNlOiBFeHBsaWNpdFBhcmFsbGVsLFxuXHRcdFx0cHJpdmF0ZSByZWFkb25seSBwcm9wb3NlZEVkZ2U6IEh5cGVyRWRnZSxcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgY3J1ZnQ6IENydWZ0Q2FjaGUpIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERldGVjdHMgbGlzdCBvcGVyYXJ0b3IgY29uZmxpY3RzIGJldHdlZW4gdGhlIGZyYWdtZW50cyBvZiBhblxuXHRcdCAqIGFubm90YXRpb24uIEZvciBleGFtcGxlLCBjb25mbGljdHMgb2YgdGhlIGZvbGxvd2luZyB0eXBlIGFyZVxuXHRcdCAqIGNhdWdodCBoZXJlOlxuXHRcdCAqIFxuXHRcdCAqIExpc3QgOiBJdGVtXG5cdFx0ICogTGlzdCA6IEl0ZW0uLi5cblx0XHQgKi9cblx0XHRkZXRlY3RMaXN0RnJhZ21lbnRDb25mbGljdHMoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNvdXJjZXMgPSB0aGlzLnByb3Bvc2VkRWRnZS5mcmFnbWVudHM7XG5cdFx0XHRpZiAoc291cmNlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3BhbnMgPSBzb3VyY2VzLmZpbHRlcigoc3JjKTogc3JjIGlzIFNwYW4gPT4gc3JjIGluc3RhbmNlb2YgU3Bhbik7XG5cdFx0XHRjb25zdCB0ZXJtcyA9IHNwYW5zXG5cdFx0XHRcdC5tYXAoZiA9PiBmLmJvdW5kYXJ5LnN1YmplY3QpXG5cdFx0XHRcdC5maWx0ZXIoKHN1Yik6IHN1YiBpcyBUZXJtID0+IHN1YiBpbnN0YW5jZW9mIFRlcm0pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB0ZXJtc0xpc3QgPSB0ZXJtcy5maWx0ZXIoaWQgPT4gaWQuaXNMaXN0KTtcblx0XHRcdGNvbnN0IHRlcm1zTm9uTGlzdCA9IHRlcm1zLmZpbHRlcihpZCA9PiAhaWQuaXNMaXN0KTtcblx0XHRcdFxuXHRcdFx0aWYgKHRlcm1zTGlzdC5sZW5ndGggPiAwICYmIHRlcm1zTm9uTGlzdC5sZW5ndGggPiAwKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpXG5cdFx0XHRcdFx0dGhpcy5hZGRGYXVsdChzcGFuLCBGYXVsdHMuTGlzdEFubm90YXRpb25Db25mbGljdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZvdW5kQ3J1ZnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGRldGVjdENpcmN1bGFyUmVmZXJlbmNlcygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2lyY3VsYXJFZGdlUGF0aHM6IEh5cGVyRWRnZVtdW10gPSBbXTtcblx0XHRcdGNvbnN0IHJlY3Vyc2UgPSAoXG5cdFx0XHRcdHNyY0Jhc2U6IEV4cGxpY2l0UGFyYWxsZWwsXG5cdFx0XHRcdHBhdGg6IEh5cGVyRWRnZVtdKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSwgZWRnZSB9IG9mIHRoaXMuYmFzZXNPZihzcmNCYXNlKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChwYXRoLmluY2x1ZGVzKGVkZ2UpKVxuXHRcdFx0XHRcdFx0Y2lyY3VsYXJFZGdlUGF0aHMucHVzaChwYXRoLnNsaWNlKCkpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJlY3Vyc2UoYmFzZSwgcGF0aC5jb25jYXQoZWRnZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSwgZWRnZSB9IG9mIHRoaXMuYmFzZXNPZih0aGlzLnRhcmdldFBhcmFsbGVsKSlcblx0XHRcdFx0cmVjdXJzZShiYXNlLCBbXSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBjaXJjdWxhckVkZ2VQYXRocylcblx0XHRcdFx0Zm9yIChjb25zdCBjaXJjdWxhckVkZ2Ugb2YgaXRlbSlcblx0XHRcdFx0XHR0aGlzLmFkZEZhdWx0KGNpcmN1bGFyRWRnZSwgRmF1bHRzLkNpcmN1bGFyVHlwZVJlZmVyZW5jZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZvdW5kQ3J1ZnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGRldGVjdExpc3REaW1lbnNpb25hbGl0eUNvbmZsaWN0KClcblx0XHR7XG5cdFx0XHRjb25zdCB0YXJnZXREaW0gPSB0aGlzLnRhcmdldFBhcmFsbGVsLmdldExpc3REaW1lbnNpb25hbGl0eSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwcm9wb3NlZERpbSA9IFxuXHRcdFx0XHR0aGlzLnByb3Bvc2VkQmFzZS5nZXRMaXN0RGltZW5zaW9uYWxpdHkoKSArXG5cdFx0XHRcdCh0aGlzLnByb3Bvc2VkRWRnZS5pc0xpc3QgPyAxIDogMCk7XG5cdFx0XHRcblx0XHRcdGlmICh0YXJnZXREaW0gIT09IHByb3Bvc2VkRGltKVxuXHRcdFx0XHR0aGlzLmFkZEZhdWx0KHRoaXMucHJvcG9zZWRFZGdlLCBGYXVsdHMuTGlzdERpbWVuc2lvbmFsRGlzY3JlcGFuY3lGYXVsdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZvdW5kQ3J1ZnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBHZXRzIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgZmF1bHQgaGFzIGJlZW4gcmVwb3J0ZWQuICovXG5cdFx0Z2V0IGZvdW5kQ3J1ZnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9mb3VuZENydWZ0O1xuXHRcdH1cblx0XHRwcml2YXRlIF9mb3VuZENydWZ0ID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSAqYmFzZXNPZihwYXI6IEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCB7IGJhc2UsIGVkZ2UgfSBvZiBwYXIuZWFjaEJhc2UoKSlcblx0XHRcdFx0eWllbGQgeyBiYXNlLCBlZGdlIH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnRhcmdldFBhcmFsbGVsID09PSBwYXIpXG5cdFx0XHRcdHlpZWxkIHsgYmFzZTogdGhpcy5wcm9wb3NlZEJhc2UsIGVkZ2U6IHRoaXMucHJvcG9zZWRFZGdlIH07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgYWRkRmF1bHQoc291cmNlOiBUQ3J1ZnQsIHJlbGV2YW50RmF1bHRUeXBlOiBGYXVsdFR5cGUpXG5cdFx0e1xuXHRcdFx0dGhpcy5fZm91bmRDcnVmdCA9IHRydWU7XG5cdFx0XHR0aGlzLmNydWZ0LmFkZChzb3VyY2UsIHJlbGV2YW50RmF1bHRUeXBlKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKiAqL1xuXHRpbnRlcmZhY2UgSVN0b3JlZENvbnRleHRcblx0e1xuXHRcdHZlcnNpb246IFZlcnNpb25TdGFtcDtcblx0XHR3b3JrZXI6IENvbnN0cnVjdGlvbldvcmtlcjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZnVsbHkgY29uc3RydWN0ZWQgdHlwZSB3aXRoaW4gdGhlIHByb2dyYW0uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVHlwZVxuXHR7XG5cdFx0LyoqIFxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIENvbnN0cnVjdHMgb25lIG9yIG1vcmUgVHlwZSBvYmplY3RzIGZyb20gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cblx0XHQgKi9cblx0XHRzdGF0aWMgY29uc3RydWN0KHBocmFzZTogUGhyYXNlKTogVHlwZSB8IG51bGw7XG5cdFx0c3RhdGljIGNvbnN0cnVjdChzcGluZTogU3BpbmUpOiBUeXBlIHwgbnVsbDtcblx0XHRzdGF0aWMgY29uc3RydWN0KHBhcmFtOiBQaHJhc2UgfCBTcGluZSk6IFR5cGUgfCBudWxsXG5cdFx0e1xuXHRcdFx0Y29uc3QgcGhyYXNlID0gcGFyYW0gaW5zdGFuY2VvZiBQaHJhc2UgP1xuXHRcdFx0XHRwYXJhbSA6XG5cdFx0XHRcdFBocmFzZS5mcm9tU3BpbmUocGFyYW0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXBocmFzZSB8fCBwaHJhc2UubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKFR5cGVDYWNoZS5oYXMocGhyYXNlKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2FjaGVkID0gVHlwZUNhY2hlLmdldChwaHJhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgdGhlIGNhY2hlZCB0eXBlIGV4aXN0cywgYnV0IGhhc24ndCBiZWVuIGNvbXBpbGVkIHlldCxcblx0XHRcdFx0Ly8gd2UgY2FuJ3QgcmV0dXJuIGl0LCB3ZSBuZWVkIHRvIGNvbXBpbGUgaXQgZmlyc3QuXG5cdFx0XHRcdGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIFR5cGVQcm94eSkpXG5cdFx0XHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJvZ3JhbSA9IHBocmFzZS5jb250YWluaW5nRG9jdW1lbnQucHJvZ3JhbTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgd29ya2VyID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN0b3JlZCA9IHRoaXMucGFyYWxsZWxDb250ZXh0TWFwLmdldChwcm9ncmFtKTtcblx0XHRcdFx0aWYgKHN0b3JlZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV3U3RvcmVkOiBJU3RvcmVkQ29udGV4dCA9IHtcblx0XHRcdFx0XHRcdHZlcnNpb246IHByb2dyYW0udmVyc2lvbixcblx0XHRcdFx0XHRcdHdvcmtlcjogbmV3IENvbnN0cnVjdGlvbldvcmtlcihwcm9ncmFtKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbENvbnRleHRNYXAuc2V0KHByb2dyYW0sIG5ld1N0b3JlZCk7XG5cdFx0XHRcdFx0cmV0dXJuIG5ld1N0b3JlZC53b3JrZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocHJvZ3JhbS52ZXJzaW9uLm5ld2VyVGhhbihzdG9yZWQudmVyc2lvbikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdG9yZWQudmVyc2lvbiA9IHByb2dyYW0udmVyc2lvbjtcblx0XHRcdFx0XHRzdG9yZWQud29ya2VyID0gbmV3IENvbnN0cnVjdGlvbldvcmtlcihwcm9ncmFtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHN0b3JlZC53b3JrZXI7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJhbGxlbCA9IHdvcmtlci5kcmlsbChwaHJhc2UpO1xuXHRcdFx0aWYgKHBhcmFsbGVsID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRUeXBlQ2FjaGUuc2V0KHBocmFzZSwgbnVsbCk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJhbGxlbExpbmVhZ2UgPSBbcGFyYWxsZWxdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBjdXJyZW50UGFyYWxsZWwgPSBwYXJhbGxlbC5jb250YWluZXI7IGN1cnJlbnRQYXJhbGxlbCAhPT0gbnVsbDspXG5cdFx0XHR7XG5cdFx0XHRcdHBhcmFsbGVsTGluZWFnZS51bnNoaWZ0KGN1cnJlbnRQYXJhbGxlbCk7XG5cdFx0XHRcdGN1cnJlbnRQYXJhbGxlbCA9IGN1cnJlbnRQYXJhbGxlbC5jb250YWluZXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGxldCBsYXN0VHlwZTogVHlwZSB8IG51bGwgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGN1cnJlbnRQYXJhbGxlbCBvZiBwYXJhbGxlbExpbmVhZ2UpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChUeXBlQ2FjaGUuaGFzKGN1cnJlbnRQYXJhbGxlbC5waHJhc2UpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdUeXBlID0gVHlwZUNhY2hlLmdldChjdXJyZW50UGFyYWxsZWwucGhyYXNlKTtcblx0XHRcdFx0XHRpZiAoZXhpc3RpbmdUeXBlIGluc3RhbmNlb2YgVHlwZVByb3h5KVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChleGlzdGluZ1R5cGUgPT09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGFzdFR5cGUgPSBleGlzdGluZ1R5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZTogVHlwZSA9IG5ldyBUeXBlKGN1cnJlbnRQYXJhbGxlbCwgbGFzdFR5cGUpO1xuXHRcdFx0XHRcdFR5cGVDYWNoZS5zZXQoY3VycmVudFBhcmFsbGVsLnBocmFzZSwgdHlwZSk7XG5cdFx0XHRcdFx0bGFzdFR5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBsYXN0VHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogQ29uc3RydWN0cyB0aGUgaW52aXNpYmxlIHJvb3QtbGV2ZWwgVHlwZSBvYmplY3QgdGhhdCBjb3JyZXNwb25kc1xuXHRcdCAqIHRvIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNvbnN0cnVjdFJvb3RzKGRvY3VtZW50OiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCByb290czogVHlwZVtdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcGhyYXNlIG9mIFBocmFzZS5yb290c09mKGRvY3VtZW50KSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuY29uc3RydWN0KHBocmFzZSk7XG5cdFx0XHRcdGlmICh0eXBlICE9PSBudWxsKVxuXHRcdFx0XHRcdHJvb3RzLnB1c2godHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHJvb3RzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgcGFyYWxsZWxDb250ZXh0TWFwID0gbmV3IFdlYWtNYXA8UHJvZ3JhbSwgSVN0b3JlZENvbnRleHQ+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3Rvcihcblx0XHRcdHNlZWQ6IFBhcmFsbGVsLFxuXHRcdFx0Y29udGFpbmVyOiBUeXBlIHwgbnVsbClcblx0XHR7XG5cdFx0XHR0aGlzLnByaXZhdGUgPSBuZXcgVHlwZVByaXZhdGUoc2VlZCk7XG5cdFx0XHR0aGlzLm5hbWUgPSBzZWVkLnBocmFzZS50ZXJtaW5hbC50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5waHJhc2UgPSBzZWVkLnBocmFzZTtcblx0XHRcdHRoaXMub3V0ZXIgPSBjb250YWluZXI7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS5wYXJhbGxlbHMgPSBuZXcgVHlwZVByb3h5QXJyYXkoXG5cdFx0XHRcdHNlZWQuZ2V0UGFyYWxsZWxzKCkubWFwKGVkZ2UgPT5cblx0XHRcdFx0XHRuZXcgVHlwZVByb3h5KGVkZ2UucGhyYXNlKSkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBnZXRCYXNlcyA9IChlcDogRXhwbGljaXRQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYmFzZXMgPSBBcnJheS5mcm9tKGVwLmVhY2hCYXNlKCkpO1xuXHRcdFx0XHRyZXR1cm4gYmFzZXMubWFwKGVudHJ5ID0+IFxuXHRcdFx0XHRcdG5ldyBUeXBlUHJveHkoZW50cnkuYmFzZS5ub2RlLnBocmFzZSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlZWQgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnByaXZhdGUuYmFzZXMgPSBuZXcgVHlwZVByb3h5QXJyYXkoZ2V0QmFzZXMoc2VlZCkpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoc2VlZCBpbnN0YW5jZW9mIEltcGxpY2l0UGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHF1ZXVlOiBQYXJhbGxlbFtdID0gW3NlZWRdO1xuXHRcdFx0XHRjb25zdCBleHBsaWNpdFBhcmFsbGVsczogRXhwbGljaXRQYXJhbGxlbFtdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50ID0gcXVldWVbaV07XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBJbXBsaWNpdFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0cXVldWUucHVzaCguLi5jdXJyZW50LmdldFBhcmFsbGVscygpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbClcblx0XHRcdFx0XHRcdGV4cGxpY2l0UGFyYWxsZWxzLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJhc2VzID0gZXhwbGljaXRQYXJhbGxlbHNcblx0XHRcdFx0XHQubWFwKHBhciA9PiBnZXRCYXNlcyhwYXIpKVxuXHRcdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSlcblx0XHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5wcml2YXRlLmJhc2VzID0gbmV3IFR5cGVQcm94eUFycmF5KGJhc2VzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5pc0xpc3QgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlZWQgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdWIgPSBzZWVkLm5vZGUuc3ViamVjdDtcblx0XHRcdFx0dGhpcy5pc1BhdHRlcm4gPSBzdWIgaW5zdGFuY2VvZiBQYXR0ZXJuO1xuXHRcdFx0XHR0aGlzLmlzVXJpID0gc3ViIGluc3RhbmNlb2YgS25vd25Vcmk7XG5cdFx0XHRcdHRoaXMuaXNBbm9ueW1vdXMgPSBzdWIgaW5zdGFuY2VvZiBBbm9uO1xuXHRcdFx0XHR0aGlzLmlzRXhwbGljaXQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmlzRnJlc2ggPSBzZWVkLmdldFBhcmFsbGVscygpLmxlbmd0aCA9PT0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbmFtZSBvZiB0aGUgdHlwZSxcblx0XHQgKiBvciBhIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgcGF0dGVybiBjb250ZW50IGluIHRoZVxuXHRcdCAqIGNhc2Ugd2hlbiB0aGUgdHlwZSBpcyBhY3R1YWxseSBhIHBhdHRlcm4uXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgcGhyYXNlIHRoYXQgc3BlY2lmaWVzIHdoZXJlIHRoaXMgVHlwZSB3YXNcblx0XHQgKiBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBwaHJhc2U6IFBocmFzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gYXJyYXkgb2YgU3RhdGVtZW50IG9iamVjdHMgdGhhdCBhcmUgcmVzcG9uc2libGVcblx0XHQgKiBmb3IgdGhlIGluaXRpYXRpb24gb2YgdGhpcyB0eXBlLiBJbiB0aGUgY2FzZSB3aGVuIHRoaXMgVHlwZVxuXHRcdCAqIG9iamVjdCByZXByZXNlbnRzIGEgcGF0aCB0aGF0IGlzIGltcGxpY2l0bHkgZGVmaW5lZCwgdGhlXG5cdFx0ICogYXJyYXkgaXMgZW1wdHkuIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZm9sbG93aW5nIGRvY3VtZW50OlxuXHRcdCAqIFxuXHRcdCAqIGBgYFxuXHRcdCAqIENsYXNzXG5cdFx0ICogXHRGaWVsZFxuXHRcdCAqIFN1YkNsYXNzIDogQ2xhc3Ncblx0XHQgKiBgYGBcblx0XHQgKiBcblx0XHQgKiBUaGUgdHlwZSBhdCBwYXRoIFN1YkNsYXNzL0ZpZWxkIGlzIGFuIGltcGxpY2l0IHR5cGUsIGFuZFxuXHRcdCAqIHRoZXJlZm9yZSwgYWx0aG91Z2ggYSB2YWxpZCB0eXBlIG9iamVjdCwgaGFzIG5vIHBoeWlzaWNhbFxuXHRcdCAqIHN0YXRlbWVudHMgYXNzb2NpYXRlZC5cblx0XHQgKi9cblx0XHRnZXQgc3RhdGVtZW50cygpXG5cdFx0e1xuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLnN0YXRlbWVudHMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuc3RhdGVtZW50cztcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKSlcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5zdGF0ZW1lbnRzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuc3RhdGVtZW50cyA9IHRoaXMucHJpdmF0ZS5zZWVkLm5vZGUuc3RhdGVtZW50cy5zbGljZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIHR5cGUsIGFzIGl0J3MgZGVmaW5lZCBpbiBpdCdzXG5cdFx0ICogbmV4dCBtb3N0IGFwcGxpY2FibGUgdHlwZS5cblx0XHQgKi9cblx0XHRnZXQgcGFyYWxsZWxzKClcblx0XHR7XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gTm90Lm51bGwodGhpcy5wcml2YXRlLnBhcmFsbGVscykubWF5YmVDb21waWxlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyYWxsZWwgcm9vdHMgb2YgdGhpcyB0eXBlLlxuXHRcdCAqIFRoZSBwYXJhbGxlbCByb290cyBhcmUgdGhlIGVuZHBvaW50cyBmb3VuZCB3aGVuXG5cdFx0ICogdHJhdmVyc2luZyB1cHdhcmQgdGhyb3VnaCB0aGUgcGFyYWxsZWwgZ3JhcGguXG5cdFx0ICovXG5cdFx0Z2V0IHBhcmFsbGVsUm9vdHMoKVxuXHRcdHtcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5wYXJhbGxlbFJvb3RzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnBhcmFsbGVsUm9vdHM7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJvb3RzOiBUeXBlW10gPSBbXTtcblx0XHRcdGZvciAoY29uc3QgeyB0eXBlIH0gb2YgdGhpcy5pdGVyYXRlKHQgPT4gdC5wYXJhbGxlbHMpKVxuXHRcdFx0XHRpZiAodHlwZSAhPT0gdGhpcyAmJiB0eXBlLnBhcmFsbGVscy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cm9vdHMucHVzaCh0eXBlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5wYXJhbGxlbFJvb3RzID0gT2JqZWN0LmZyZWV6ZShyb290cyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgVHlwZSB0aGF0IGNvbnRhaW5zIHRoaXMgVHlwZSwgb3IgbnVsbCBpblxuXHRcdCAqIHRoZSBjYXNlIHdoZW4gdGhpcyBUeXBlIGlzIHRvcC1sZXZlbC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBvdXRlcjogVHlwZSB8IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IGFyZSBjb250YWluZWQgZGlyZWN0bHkgYnkgdGhpc1xuXHRcdCAqIG9uZS4gSW4gdGhlIGNhc2Ugd2hlbiB0aGlzIHR5cGUgaXMgYSBsaXN0IHR5cGUsIHRoaXMgYXJyYXkgZG9lc1xuXHRcdCAqIG5vdCBpbmNsdWRlIHRoZSBsaXN0J3MgaW50cmluc2ljIHR5cGVzLlxuXHRcdCAqL1xuXHRcdGdldCBpbm5lcnMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuaW5uZXJzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmlubmVycztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0Y29uc3QgaW5uZXJTdWJzOiBTdWJqZWN0W10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gRGlnIHRocm91Z2ggdGhlIHBhcmFsbGVsIGdyYXBoIHJlY3Vyc2l2ZWx5LCBhbmQgYXQgZWFjaCBwYXJhbGxlbCxcblx0XHRcdC8vIGRpZyB0aHJvdWdoIHRoZSBiYXNlIGdyYXBoIHJlY3Vyc2l2ZWx5LCBhbmQgY29sbGVjdCBhbGwgdGhlIG5hbWVzXG5cdFx0XHQvLyB0aGF0IGFyZSBmb3VuZC5cblx0XHRcdGZvciAoY29uc3QgeyB0eXBlOiBwYXJhbGxlbFR5cGUgfSBvZiB0aGlzLml0ZXJhdGUodCA9PiB0LnBhcmFsbGVscywgdHJ1ZSkpXG5cdFx0XHRcdGZvciAoY29uc3QgeyB0eXBlOiBiYXNlVHlwZSB9IG9mIHBhcmFsbGVsVHlwZS5pdGVyYXRlKHQgPT4gdC5iYXNlcywgdHJ1ZSkpXG5cdFx0XHRcdFx0aWYgKGJhc2VUeXBlLnByaXZhdGUuc2VlZCBpbnN0YW5jZW9mIEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHN1YmplY3Qgb2YgYmFzZVR5cGUucHJpdmF0ZS5zZWVkLm5vZGUuY29udGVudHMua2V5cygpKVxuXHRcdFx0XHRcdFx0XHRpZiAoIWlubmVyU3Vicy5pbmNsdWRlcyhzdWJqZWN0KSlcblx0XHRcdFx0XHRcdFx0XHRpbm5lclN1YnMucHVzaChzdWJqZWN0KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5uZXJzID0gaW5uZXJTdWJzXG5cdFx0XHRcdC5tYXAoaW5uZXJTdWIgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IG1heWJlSW5uZXJQaHJhc2UgPSB0aGlzLnBocmFzZS5mb3J3YXJkKGlubmVyU3ViKTtcblx0XHRcdFx0XHRyZXR1cm4gVHlwZS5jb25zdHJ1Y3QobWF5YmVJbm5lclBocmFzZSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5maWx0ZXIoKHQpOiB0IGlzIFR5cGUgPT4gdCAhPT0gbnVsbCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuaW5uZXJzID0gT2JqZWN0LmZyZWV6ZShpbm5lcnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgYXJlIGNvbnRhaW5lZCBkaXJlY3RseSBieSB0aGlzXG5cdFx0ICogb25lLiBJbiB0aGUgY2FzZSB3aGVuIHRoaXMgdHlwZSBpcyBub3QgYSBsaXN0IHR5cGUsIHRoaXMgYXJyYXlcblx0XHQgKiBpcyBlbXB0eS5cblx0XHQgKi9cblx0XHRnZXQgaW5uZXJzSW50cmluc2ljKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmlubmVyc0ludHJpbnNpYyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5pbm5lcnNJbnRyaW5zaWM7XG5cdFx0XHRcblx0XHRcdGlmICghdGhpcy5pc0xpc3QpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuaW5uZXJzSW50cmluc2ljID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgYXJyYXkgb2YgdHlwZXMgZnJvbSB3aGljaCB0aGlzIHR5cGUgZXh0ZW5kcy5cblx0XHQgKiBJZiB0aGlzIFR5cGUgZXh0ZW5kcyBmcm9tIGEgcGF0dGVybiwgaXQgaXMgaW5jbHVkZWQgaW4gdGhpc1xuXHRcdCAqIGFycmF5LlxuXHRcdCAqL1xuXHRcdGdldCBiYXNlcygpOiByZWFkb25seSBUeXBlW11cblx0XHR7XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuYmFzZXMgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5iYXNlcy5tYXliZUNvbXBpbGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogTm90IGltcGxlbWVudGVkLlxuXHRcdCAqL1xuXHRcdGdldCBzdXBlcm9yZGluYXRlcygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5zdXBlcm9yZGluYXRlcyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5zdXBlcm9yZGluYXRlcztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5zdXBlcm9yZGluYXRlcyA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBOb3QgaW1wbGVtZW50ZWQuXG5cdFx0ICovXG5cdFx0Z2V0IHN1Ym9yZGluYXRlcygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5zdWJvcmRpbmF0ZXMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuc3Vib3JkaW5hdGVzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnN1Ym9yZGluYXRlcyA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHR5cGVzIHRoYXQgZGVyaXZlIGZyb20gdGhlIFxuXHRcdCAqIHRoaXMgVHlwZSBpbnN0YW5jZS5cblx0XHQgKiBcblx0XHQgKiBUaGUgdHlwZXMgdGhhdCBkZXJpdmUgZnJvbSB0aGlzIG9uZSBhcyBhIHJlc3VsdCBvZiB0aGUgdXNlIG9mXG5cdFx0ICogYW4gYWxpYXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhpcyBhcnJheS5cblx0XHQgKi9cblx0XHRnZXQgZGVyaXZhdGlvbnMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuZGVyaXZhdGlvbnMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuZGVyaXZhdGlvbnM7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBFeHBsaWNpdFBhcmFsbGVsKSlcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5kZXJpdmF0aW9ucyA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkZXJpdmF0aW9ucyA9IEFycmF5LmZyb20odGhpcy5wcml2YXRlLnNlZWQubm9kZS5pbmJvdW5kcylcblx0XHRcdFx0Lm1hcChpYiA9PiBpYi5wcmVkZWNlc3Nvci5waHJhc2UpXG5cdFx0XHRcdC5tYXAocGhyYXNlID0+IFR5cGUuY29uc3RydWN0KHBocmFzZSkpXG5cdFx0XHRcdC5maWx0ZXIoKHQpOiB0IGlzIFR5cGUgPT4gdCBpbnN0YW5jZW9mIFR5cGUpXG5cdFx0XHRcdC5maWx0ZXIodHlwZSA9PiB0eXBlLmJhc2VzLmluY2x1ZGVzKHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5kZXJpdmF0aW9ucyA9IE9iamVjdC5mcmVlemUoZGVyaXZhdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHRoYXQgc2hhcmUgdGhlIHNhbWUgY29udGFpbmluZ1xuXHRcdCAqIHR5cGUgYXMgdGhpcyBvbmUuXG5cdFx0ICovXG5cdFx0Z2V0IGFkamFjZW50cygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5hZGphY2VudHMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWRqYWNlbnRzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLm91dGVyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmFkamFjZW50cyA9IHRoaXMub3V0ZXIuaW5uZXJzLmZpbHRlcih0ID0+IHQgIT09IHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkb2N1bWVudCA9IHRoaXMucGhyYXNlLmNvbnRhaW5pbmdEb2N1bWVudDtcblx0XHRcdGNvbnN0IHJvb3RzID0gQXJyYXkuZnJvbShQaHJhc2Uucm9vdHNPZihkb2N1bWVudCkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBhZGphY2VudHMgPSByb290c1xuXHRcdFx0XHQubWFwKHBocmFzZSA9PiBUeXBlLmNvbnN0cnVjdChwaHJhc2UpKVxuXHRcdFx0XHQuZmlsdGVyKCh0KTogdCBpcyBUeXBlID0+IHQgIT09IG51bGwgJiYgdCAhPT0gdGhpcyk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWRqYWNlbnRzID0gT2JqZWN0LmZyZWV6ZShhZGphY2VudHMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHBhdHRlcm5zIHRoYXQgcmVzb2x2ZSB0byB0aGlzIHR5cGUuXG5cdFx0ICovXG5cdFx0Z2V0IHBhdHRlcm5zKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLnBhdHRlcm5zICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnBhdHRlcm5zO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdC8vIFN0b3JlcyBhIG1hcCB3aG9zZSBrZXlzIGFyZSBhIGNvbmNhdGVuYXRpb24gb2YgdGhlIFVyaXMgb2YgYWxsXG5cdFx0XHQvLyB0aGUgYmFzZXMgdGhhdCBhcmUgbWF0Y2hlZCBieSBhIHBhcnRpY3VsYXIgcGF0dGVybiwgYW5kIHdob3NlXG5cdFx0XHQvLyB2YWx1ZXMgYXJlIHRoZSB0eXBlIG9iamVjdCBjb250YWluaW5nIHRoYXQgcGF0dGVybi4gVGhpcyBtYXBcblx0XHRcdC8vIHByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvIGRldGVybWluZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgcGF0dGVyblxuXHRcdFx0Ly8gdGhhdCBtYXRjaGVzIGEgcGFydGljdWxhciBzZXQgb2YgdHlwZXMgaW4gdGhlIHR5cGUgc2NvcGUuXG5cdFx0XHRjb25zdCBwYXR0ZXJuTWFwID0gbmV3IE1hcDxzdHJpbmcsIFR5cGU+KCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgeyB0eXBlIH0gb2YgdGhpcy5pdGVyYXRlKHQgPT4gdC5vdXRlcikpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGFwcGxpY2FibGVQYXR0ZXJuVHlwZXMgPSB0eXBlLmFkamFjZW50c1xuXHRcdFx0XHRcdC5maWx0ZXIodCA9PiB0LmlzUGF0dGVybilcblx0XHRcdFx0XHQuZmlsdGVyKHQgPT4gdC5iYXNlcy5pbmNsdWRlcyh0eXBlKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhcHBsaWNhYmxlUGF0dGVybnNCYXNlc0xhYmVscyA9XG5cdFx0XHRcdFx0YXBwbGljYWJsZVBhdHRlcm5UeXBlcy5tYXAocCA9PiBwLmJhc2VzXG5cdFx0XHRcdFx0XHQubWFwKGIgPT4gYi5waHJhc2UudG9TdHJpbmcoKSlcblx0XHRcdFx0XHRcdC5qb2luKFN5bnRheC50ZXJtaW5hbCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBhcHBsaWNhYmxlUGF0dGVyblR5cGVzLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBiYXNlTGFiZWwgPSBhcHBsaWNhYmxlUGF0dGVybnNCYXNlc0xhYmVsc1tpXTtcblx0XHRcdFx0XHRpZiAoIXBhdHRlcm5NYXAuaGFzKGJhc2VMYWJlbCkpXG5cdFx0XHRcdFx0XHRwYXR0ZXJuTWFwLnNldChiYXNlTGFiZWwsIGFwcGxpY2FibGVQYXR0ZXJuVHlwZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dCA9IEFycmF5LmZyb20ocGF0dGVybk1hcC52YWx1ZXMoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnBhdHRlcm5zID0gT2JqZWN0LmZyZWV6ZShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJhdyBzdHJpbmcgdmFsdWVzIHJlcHJlc2VudGluZ1xuXHRcdCAqIHRoZSB0eXBlIGFsaWFzZXMgd2l0aCB3aGljaCB0aGlzIHR5cGUgaGFzIGJlZW4gYW5ub3RhdGVkLlxuXHRcdCAqIFxuXHRcdCAqIElmIHRoaXMgdHlwZSBpcyB1bnNwZWNpZmllZCwgdGhlIHBhcmFsbGVsIGdyYXBoIGlzIHNlYXJjaGVkLFxuXHRcdCAqIGFuZCBhbnkgYXBwbGljYWJsZSB0eXBlIGFsaWFzZXMgd2lsbCBiZSBwcmVzZW50IGluIHRoZSByZXR1cm5lZFxuXHRcdCAqIGFycmF5LlxuXHRcdCAqL1xuXHRcdGdldCBhbGlhc2VzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmFsaWFzZXMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWxpYXNlcztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0Y29uc3QgYWxpYXNlczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZXh0cmFjdEFsaWFzID0gKGVwOiBFeHBsaWNpdFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHsgZWRnZSwgYWxpYXNlZCB9IG9mIGVwLmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0aWYgKGFsaWFzZWQpXG5cdFx0XHRcdFx0XHRhbGlhc2VzLnB1c2goZWRnZS50ZXJtLnRvU3RyaW5nKCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5zZWVkIGluc3RhbmNlb2YgRXhwbGljaXRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0ZXh0cmFjdEFsaWFzKHRoaXMucHJpdmF0ZS5zZWVkKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMucHJpdmF0ZS5zZWVkIGluc3RhbmNlb2YgSW1wbGljaXRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcXVldWU6IEltcGxpY2l0UGFyYWxsZWxbXSA9IFt0aGlzLnByaXZhdGUuc2VlZF07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50ID0gcXVldWVbaV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYXJhbGxlbCBvZiBjdXJyZW50LmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChwYXJhbGxlbCBpbnN0YW5jZW9mIEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRcdGV4dHJhY3RBbGlhcyhwYXJhbGxlbCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHBhcmFsbGVsIGluc3RhbmNlb2YgSW1wbGljaXRQYXJhbGxlbClcblx0XHRcdFx0XHRcdFx0cXVldWUucHVzaChwYXJhbGxlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWxpYXNlcyA9IGFsaWFzZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGdldCB2YWx1ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUudmFsdWVzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnZhbHVlcztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0Y29uc3QgdmFsdWVzOiB7IHZhbHVlOiBzdHJpbmcsIGJhc2U6IFR5cGUgfCBudWxsLCBhbGlhc2VkOiBib29sZWFuIH1bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBleHRyYWN0VHlwZSA9IChlcDogRXhwbGljaXRQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGVkZ2UsIGFsaWFzZWQgfSBvZiBlcC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHtcblx0XHRcdFx0XHRcdGFsaWFzZWQsXG5cdFx0XHRcdFx0XHR2YWx1ZTogZWRnZS50ZXJtLnRvU3RyaW5nKCksXG5cdFx0XHRcdFx0XHRiYXNlOiBUeXBlLmNvbnN0cnVjdChlZGdlLnByZWRlY2Vzc29yLnBocmFzZSlcblx0XHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuc2VlZCBpbnN0YW5jZW9mIEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdGV4dHJhY3RUeXBlKHRoaXMucHJpdmF0ZS5zZWVkKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMucHJpdmF0ZS5zZWVkIGluc3RhbmNlb2YgSW1wbGljaXRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcXVldWU6IEltcGxpY2l0UGFyYWxsZWxbXSA9IFt0aGlzLnByaXZhdGUuc2VlZF07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50ID0gcXVldWVbaV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYXJhbGxlbCBvZiBjdXJyZW50LmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChwYXJhbGxlbCBpbnN0YW5jZW9mIEV4cGxpY2l0UGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRcdGV4dHJhY3RUeXBlKHBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocGFyYWxsZWwgaW5zdGFuY2VvZiBJbXBsaWNpdFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmFsbGVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS52YWx1ZXMgPSB2YWx1ZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIGZpcnN0IGFsaWFzIHN0b3JlZCBpbiB0aGUgLnZhbHVlcyBhcnJheSwgb3IgbnVsbCBpZiB0aGVcblx0XHQgKiB2YWx1ZXMgYXJyYXkgaXMgZW1wdHkuXG5cdFx0ICovXG5cdFx0Z2V0IHZhbHVlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hbGlhc2VzLmxlbmd0aCA+IDAgPyB0aGlzLmFsaWFzZXNbMF0gOiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGlzIHR5cGUgcmVwcmVzZW50cyB0aGUgaW50cmluc2ljXG5cdFx0ICogc2lkZSBvZiBhIGxpc3QuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaXNMaXN0SW50cmluc2ljOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhpcyB0eXBlIHJlcHJlc2VudHMgdGhlIGV4dHJpbnNpY1xuXHRcdCAqIHNpZGUgb2YgYSBsaXN0LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlzTGlzdEV4dHJpbnNpYzogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoaXMgVHlwZSBpbnN0YW5jZSBoYXMgbm8gYW5ub3RhdGlvbnMgYXBwbGllZCB0byBpdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc0ZyZXNoOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzT3ZlcnJpZGUoKSB7IHJldHVybiB0aGlzLnBhcmFsbGVscy5sZW5ndGggPiAwOyB9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzSW50cm9kdWN0aW9uKCkgeyByZXR1cm4gdGhpcy5wYXJhbGxlbHMubGVuZ3RoID09PSAwOyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgaWYgdGhpcyBUeXBlIHdhcyBkaXJlY3RseSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgZG9jdW1lbnQsIG9yIGlmIGl0J3MgZXhpc3RlbmNlIHdhcyBpbmZlcnJlZC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc0V4cGxpY2l0OiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgaXNBbm9ueW1vdXM6IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBpc1BhdHRlcm46IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBpc1VyaTogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGlzTGlzdDogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBUeXBlXG5cdFx0ICogaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgZnJvbSBhIHByZXZpb3VzIGVkaXQgZnJhbWUsIGFuZFxuXHRcdCAqIHNob3VsZCBubyBsb25nZXIgYmUgdXNlZC5cblx0XHQgKi9cblx0XHRnZXQgaXNEaXJ0eSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5wcm9ncmFtLnZlcnNpb24ubmV3ZXJUaGFuKHRoaXMucHJpdmF0ZS5zdGFtcCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGFuIGFyYml0cmFyeSByZWN1cnNpdmUsIGJyZWFkdGgtZmlyc3QgdHJhdmVyc2FsXG5cdFx0ICogdGhhdCBiZWdpbnMgYXQgdGhpcyBUeXBlIGluc3RhbmNlLiBFbnN1cmVzIHRoYXQgbm8gdHlwZXNcblx0XHQgKiB0eXBlcyBhcmUgeWllbGRlZCBtdWx0aXBsZSB0aW1lcy5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gbmV4dEZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHlwZSwgb3IgYW5cblx0XHQgKiBpdGVyYWJsZSBvZiB0eXBlcyB0aGF0IGFyZSB0byBiZSB2aXNpdGVkIG5leHQuXG5cdFx0ICogQHBhcmFtIHJldmVyc2UgQW4gb3B0aW9uYWwgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlc1xuXHRcdCAqIHdoZXRoZXIgdHlwZXMgaW4gdGhlIHJldHVybmVkIGFycmF5IHNob3VsZCBiZSBzb3J0ZWRcblx0XHQgKiB3aXRoIHRoZSBtb3N0IGRlZXBseSB2aXNpdGVkIG5vZGVzIG9jY3VyaW5nIGZpcnN0LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IHRoYXQgc3RvcmVzIHRoZSBsaXN0IG9mIHR5cGVzIHRoYXQgd2VyZVxuXHRcdCAqIHZpc2l0ZWQuXG5cdFx0ICovXG5cdFx0dmlzaXQobmV4dEZuOiAodHlwZTogVHlwZSkgPT4gSXRlcmFibGU8VHlwZSB8IG51bGw+IHwgVHlwZSB8IG51bGwsIHJldmVyc2U/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKHRoaXMuaXRlcmF0ZShuZXh0Rm4sIHJldmVyc2UpKS5tYXAoZW50cnkgPT4gZW50cnkudHlwZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGFuIGFyYml0cmFyeSByZWN1cnNpdmUsIGJyZWFkdGgtZmlyc3QgaXRlcmF0aW9uXG5cdFx0ICogdGhhdCBiZWdpbnMgYXQgdGhpcyBUeXBlIGluc3RhbmNlLiBFbnN1cmVzIHRoYXQgbm8gdHlwZXNcblx0XHQgKiB0eXBlcyBhcmUgeWllbGRlZCBtdWx0aXBsZSB0aW1lcy5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gbmV4dEZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHlwZSwgb3IgYW4gaXRlcmFibGVcblx0XHQgKiBvZiB0eXBlcyB0aGF0IGFyZSB0byBiZSB2aXNpdGVkIG5leHQuXG5cdFx0ICogQHBhcmFtIHJldmVyc2UgQW4gb3B0aW9uYWwgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlc1xuXHRcdCAqIHdoZXRoZXIgdGhlIGl0ZXJhdG9yIHNob3VsZCB5aWVsZCB0eXBlcyBzdGFydGluZyB3aXRoIHRoZVxuXHRcdCAqIG1vc3QgZGVlcGx5IG5lc3RlZCB0eXBlcyBmaXJzdC5cblx0XHQgKiBcblx0XHQgKiBAeWllbGRzIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgYHR5cGVgIHByb3BlcnR5IHRoYXQgaXMgdGhlXG5cdFx0ICogdGhlIFR5cGUgYmVpbmcgdmlzaXRlZCwgYW5kIGEgYHZpYWAgcHJvcGVydHkgdGhhdCBpcyB0aGUgVHlwZVxuXHRcdCAqIHRoYXQgd2FzIHJldHVybmVkIGluIHRoZSBwcmV2aW91cyBjYWxsIHRvIGBuZXh0Rm5gLlxuXHRcdCAqL1xuXHRcdCppdGVyYXRlKG5leHRGbjogKHR5cGU6IFR5cGUpID0+IEl0ZXJhYmxlPFR5cGUgfCBudWxsPiB8IFR5cGUgfCBudWxsLCByZXZlcnNlPzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRjb25zdCB5aWVsZGVkOiBUeXBlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0dHlwZSBSZWN1cnNlVHlwZSA9IEl0ZXJhYmxlSXRlcmF0b3I8eyB0eXBlOiBUeXBlOyB2aWE6IFR5cGUgfCBudWxsIH0+O1xuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2UodHlwZTogVHlwZSwgdmlhOiBUeXBlIHwgbnVsbCk6IFJlY3Vyc2VUeXBlXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh5aWVsZGVkLmluY2x1ZGVzKHR5cGUpKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghcmV2ZXJzZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpZWxkZWQucHVzaCh0eXBlKTtcblx0XHRcdFx0XHR5aWVsZCB7IHR5cGUsIHZpYSB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCByZWR1Y2VkID0gbmV4dEZuKHR5cGUpO1xuXHRcdFx0XHRpZiAocmVkdWNlZCAhPT0gbnVsbCAmJiByZWR1Y2VkICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocmVkdWNlZCBpbnN0YW5jZW9mIFR5cGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4geWllbGQgKnJlY3Vyc2UocmVkdWNlZCwgdHlwZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBuZXh0VHlwZSBvZiByZWR1Y2VkKVxuXHRcdFx0XHRcdFx0aWYgKG5leHRUeXBlIGluc3RhbmNlb2YgVHlwZSlcblx0XHRcdFx0XHRcdFx0eWllbGQgKnJlY3Vyc2UobmV4dFR5cGUsIHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocmV2ZXJzZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpZWxkZWQucHVzaCh0eXBlKTtcblx0XHRcdFx0XHR5aWVsZCB7IHR5cGUsIHZpYSB9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHlpZWxkICpyZWN1cnNlKHRoaXMsIG51bGwpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBRdWVyaWVzIGZvciBhIFR5cGUgdGhhdCBpcyBuZXN0ZWQgdW5kZXJuZWF0aCB0aGlzIFR5cGUsXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCB0eXBlIHBhdGguXG5cdFx0ICovXG5cdFx0cXVlcnkoLi4udHlwZVBhdGg6IHN0cmluZ1tdKVxuXHRcdHtcblx0XHRcdGxldCBjdXJyZW50VHlwZTogVHlwZSB8IG51bGwgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHR5cGVOYW1lIG9mIHR5cGVQYXRoKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0VHlwZSA9IHRoaXMuaW5uZXJzLmZpbmQodHlwZSA9PiB0eXBlLm5hbWUgPT09IHR5cGVOYW1lKTtcblx0XHRcdFx0aWYgKCFuZXh0VHlwZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGN1cnJlbnRUeXBlID0gbmV4dFR5cGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjdXJyZW50VHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBUeXBlIGhhcyB0aGUgc3BlY2lmaWVkIHR5cGVcblx0XHQgKiBzb21ld2hlcmUgaW4gaXQncyBiYXNlIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGlzKGJhc2VUeXBlOiBUeXBlKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgeyB0eXBlIH0gb2YgdGhpcy5pdGVyYXRlKHQgPT4gdC5iYXNlcykpXG5cdFx0XHRcdGlmICh0eXBlID09PSBiYXNlVHlwZSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgaW4gdGhpcyBUeXBlJ3Ncblx0XHQgKiBgLmlubmVyc2AgcHJvcGVydHksIGVpdGhlciBkaXJlY3RseSwgb3IgaW5kaXJlY3RseSB2aWFcblx0XHQgKiB0aGUgcGFyYWxsZWwgZ3JhcGhzIG9mIHRoZSBgLmlubmVyc2AgVHlwZXMuXG5cdFx0ICovXG5cdFx0aGFzKHR5cGU6IFR5cGUpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaW5uZXJzLmluY2x1ZGVzKHR5cGUpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbm5lclR5cGUgb2YgdGhpcy5pbm5lcnMpXG5cdFx0XHRcdGlmICh0eXBlLm5hbWUgPT09IGlubmVyVHlwZS5uYW1lKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgcGFyYWxsZWwgb2YgaW5uZXJUeXBlLml0ZXJhdGUodCA9PiB0LnBhcmFsbGVscykpXG5cdFx0XHRcdFx0XHRpZiAocGFyYWxsZWwudHlwZSA9PT0gdHlwZSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW50ZXJuYWwgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBwcml2YXRlIG1lbWJlcnNcblx0XHQgKiBvZiB0aGUgVHlwZSBvYmplY3QuIERvIG5vdCB1c2UuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBwcml2YXRlOiBUeXBlUHJpdmF0ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIGhpZGRlbiBjbGFzcyB0aGF0IHN0b3JlcyB0aGUgcHJpdmF0ZSBpbmZvcm1hdGlvbiBvZlxuXHQgKiBhIFR5cGUgaW5zdGFuY2UsIHVzZWQgdG8gbWl0aWdhdGUgdGhlIHJpc2sgb2YgbG93LXJhbmtcblx0ICogZGV2ZWxvcGVycyBmcm9tIGdldHRpbmcgdGhlbXNlbHZlcyBpbnRvIHRyb3VibGUuXG5cdCAqL1xuXHRjbGFzcyBUeXBlUHJpdmF0ZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgc2VlZDogUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0dGhpcy5zdGFtcCA9IHRoaXMucHJvZ3JhbS52ZXJzaW9uO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgcHJvZ3JhbSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VlZC5waHJhc2UuY29udGFpbmluZ0RvY3VtZW50LnByb2dyYW07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IHN0YW1wOiBWZXJzaW9uU3RhbXA7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGVtZW50czogcmVhZG9ubHkgU3RhdGVtZW50W10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRpbm5lcnM6IHJlYWRvbmx5IFR5cGVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGlubmVyc0ludHJpbnNpYzogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YmFzZXM6IFR5cGVQcm94eUFycmF5IHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cGFyYWxsZWxzOiBUeXBlUHJveHlBcnJheSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHBhcmFsbGVsUm9vdHM6IHJlYWRvbmx5IFR5cGVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHBhdHRlcm5zOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRhbGlhc2VzOiByZWFkb25seSBzdHJpbmdbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHZhbHVlczogcmVhZG9ubHkgeyB2YWx1ZTogc3RyaW5nOyBiYXNlOiBUeXBlIHwgbnVsbDsgYWxpYXNlZDogYm9vbGVhbiB9W10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRzdXBlcm9yZGluYXRlczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3Vib3JkaW5hdGVzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRkZXJpdmF0aW9uczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRqYWNlbnRzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHR0aHJvd09uRGlydHkoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByb2dyYW0udmVyc2lvbi5uZXdlclRoYW4odGhpcy5zdGFtcCkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5vYmplY3REaXJ0eSgpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFR5cGVQcm94eVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwaHJhc2U6IFBocmFzZSlcblx0XHR7IH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRtYXliZUNvbXBpbGUoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbXBpbGVkVHlwZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZFR5cGU7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbXBpbGVkVHlwZSA9IFR5cGUuY29uc3RydWN0KHRoaXMucGhyYXNlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjb21waWxlZFR5cGU6IFR5cGUgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVHlwZVByb3h5QXJyYXlcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXJyYXk6IHJlYWRvbmx5IFR5cGVQcm94eVtdKSB7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRtYXliZUNvbXBpbGUoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbXBpbGVkQXJyYXkgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRBcnJheTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgb3V0ID0gdGhpcy5hcnJheVxuXHRcdFx0XHQubWFwKGxhenkgPT4gbGF6eS5tYXliZUNvbXBpbGUoKSlcblx0XHRcdFx0LmZpbHRlcigodHlwZSk6IHR5cGUgaXMgVHlwZSA9PiB0eXBlICE9PSBudWxsKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRBcnJheSA9IE9iamVjdC5mcmVlemUob3V0KTtcblx0XHR9XG5cdFx0XG5cdFx0cHJpdmF0ZSBjb21waWxlZEFycmF5OiByZWFkb25seSBUeXBlW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCB0eXBlIFRDYWNoZWRUeXBlID0gVHlwZSB8IFR5cGVQcm94eSB8IG51bGw7XG5cdFxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVHlwZUNhY2hlXG5cdHtcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaGFzKHBocmFzZTogUGhyYXNlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNhY2hlID0gdGhpcy5nZXRDYWNoZShwaHJhc2UuY29udGFpbmluZ0RvY3VtZW50LnByb2dyYW0pO1xuXHRcdFx0cmV0dXJuIGNhY2hlLm1hcC5oYXMocGhyYXNlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGdldChwaHJhc2U6IFBocmFzZSlcblx0XHR7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gcGhyYXNlLmNvbnRhaW5pbmdEb2N1bWVudC5wcm9ncmFtO1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmdldENhY2hlKHByb2dyYW0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2FjaGUubWFwLmhhcyhwaHJhc2UpKVxuXHRcdFx0XHRyZXR1cm4gTm90LnVuZGVmaW5lZChjYWNoZS5tYXAuZ2V0KHBocmFzZSkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwcm94eSA9IG5ldyBUeXBlUHJveHkocGhyYXNlKTtcblx0XHRcdHRoaXMuc2V0KHBocmFzZSwgcHJveHkpO1xuXHRcdFx0cmV0dXJuIHByb3h5O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgc2V0KHBocmFzZTogUGhyYXNlLCB0eXBlOiBUQ2FjaGVkVHlwZSk6IFRDYWNoZWRUeXBlXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmdldENhY2hlKHBocmFzZS5jb250YWluaW5nRG9jdW1lbnQucHJvZ3JhbSk7XG5cdFx0XHRjYWNoZS5tYXAuc2V0KHBocmFzZSwgdHlwZSk7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgZ2V0Q2FjaGUocHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMuYWxsQ2FjaGVzLmdldChwcm9ncmFtKSB8fCAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2FjaGUgPSBuZXcgVHlwZUNhY2hlKHByb2dyYW0pO1xuXHRcdFx0XHR0aGlzLmFsbENhY2hlcy5zZXQocHJvZ3JhbSwgY2FjaGUpO1xuXHRcdFx0XHRyZXR1cm4gY2FjaGU7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRjYWNoZS5tYXliZUNsZWFyKCk7XG5cdFx0XHRyZXR1cm4gY2FjaGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGFsbENhY2hlcyA9IG5ldyBXZWFrTWFwPFByb2dyYW0sIFR5cGVDYWNoZT4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHR0aGlzLnZlcnNpb24gPSBwcm9ncmFtLnZlcnNpb247XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgbWF5YmVDbGVhcigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJvZ3JhbS52ZXJzaW9uLm5ld2VyVGhhbih0aGlzLnZlcnNpb24pKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLm1hcC5jbGVhcigpO1xuXHRcdFx0XHR0aGlzLnZlcnNpb24gPSB0aGlzLnByb2dyYW0udmVyc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSB2ZXJzaW9uOiBWZXJzaW9uU3RhbXA7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBtYXAgPSBuZXcgTWFwPFBocmFzZSwgVENhY2hlZFR5cGU+KCk7XG5cdH1cbn1cbiIsIlxuLy8gVXRpbFxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9IZWxwZXJzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1V0aWwvTXVsdGlNYXAudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9Gcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL0hhc2gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9IaWdoZXJPcmRlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL05vdC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL1BhcnNlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL1VuaWNvZGVCbG9ja3MudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9NaXNjLnRzXCIgLz5cblxuLy8gU3lzdGVtXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vQWJzdHJhY3RDbGFzcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vUHJvZ3JhbS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL0FnZW50Q2FjaGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL0NhdXNlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1N5c3RlbS9FeGNlcHRpb24udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL1VyaVByb3RvY29sLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1N5c3RlbS9VcmlSZWFkZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL1N5bnRheC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vRmF1bHRTZXJ2aWNlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1N5c3RlbS9GYXVsdHMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL1BocmFzZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vVGVybS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vVmVyc2lvblN0YW1wLnRzXCIgLz5cblxuLy8gRmluaXRlIFN0YXRlIE1hY2hpbmVcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL0ZzbS9BbHBoYWJldC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9Gc20vVHJhbnNpdGlvbk1hcC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9Gc20vVHJhbnNpdGlvblN0YXRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL0ZzbS9HdWlkZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9Gc20vRnNtLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL0ZzbS9Gc21UcmFuc2xhdG9yLnRzXCIgLz5cblxuLy8gUGhhc2VzIC8gRmlsZSBSZXByZXNlbnRhdGlvblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvRG9jdW1lbnQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvRG9jdW1lbnRUeXBlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9DeWNsZURldGVjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0xpbmVQYXJzZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvQW5vbi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9MaW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0JvdW5kYXJ5LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL1N0YXRlbWVudC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9QYXR0ZXJuLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL1BhdHRlcm5QcmVjb21waWxlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9SZWdleFR5cGVzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0luZml4LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL1NwYW4udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvU3BpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvU3ViamVjdC50c1wiIC8+XG5cbi8vIFBoYXNlcyAvIEdyYXBoIFJlcHJlc2VudGF0aW9uXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvR3JhcGgvSHlwZXJHcmFwaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvR3JhcGgvTm9kZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvR3JhcGgvTm9kZUluZGV4LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9HcmFwaC9IeXBlckVkZ2UudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0dyYXBoL0luZml4U3Bhbi50c1wiIC8+XG5cbi8vIFBoYXNlcyAvIFBhcmFsbGVsIFJlcHJlc2VudGF0aW9uXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvQ29uc3RydWN0aW9uV29ya2VyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9QYXJhbGxlbC9QYXJhbGxlbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvRXhwbGljaXRQYXJhbGxlbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvSW1wbGljaXRQYXJhbGxlbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvQ3J1ZnRDYWNoZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvUGFyYWxsZWxDYWNoZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvQ29udHJhY3QudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL1BhcmFsbGVsL1Nhbml0aXplci50c1wiIC8+XG5cbi8vIFBoYXNlcyAvIFR5cGUgUmVwcmVzZW50YXRpb25cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9UeXBlL1R5cGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL1R5cGUvVHlwZVByb3h5LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9UeXBlL1R5cGVQcm94eUFycmF5LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9UeXBlL1R5cGVDYWNoZS50c1wiIC8+XG5cbi8vIE5vZGUgY29tcGF0aWJpbGl0eVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpXG5cdG1vZHVsZS5leHBvcnRzID0gVHJ1dGg7XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgbWluaW1hbCBhYnN0cmFjdGlvbiBvZiBhIEphdmFTY3JpcHQgYXJyYXksIGJ1dCB3aGVyZSB0aGUgaW5kZXhlc1xuXHQgKiBhcmUgdHJlYXRlZCBhcyAxLWJhc2VkLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEFycmF5MUJhc2VkPFQ+XG5cdHtcblx0XHQvKipcblx0XHQgKiBZaWVsZHMgaXRlbXMgc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgYW5kIGNvbnRpbnVlcyBmb3J3YXJkXG5cdFx0ICogdW50aWwgdGhlIGVuZCBvZiB0aGUgYXJyYXkgaXMgcmVhY2hlZC5cblx0XHQgKi9cblx0XHQqZW51bWVyYXRlRm9yd2FyZChmcm9tID0gMSlcblx0XHR7XG5cdFx0XHRjb25zdCBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAobGV0IGlkeCA9IHRoaXMudG9aZXJvQmFzZWQoZnJvbSk7IGlkeCA8IGxlbjsgaWR4KyspXG5cdFx0XHRcdHlpZWxkIHRoaXMuaXRlbXNbaWR4XTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogWWllbGRzIGl0ZW1zIHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24sIGFuZCBjb250aW51ZXMgYmFja3dhcmRcblx0XHQgKiB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIGFycmF5IGlzIHJlYWNoZWQuXG5cdFx0ICovXG5cdFx0KmVudW1lcmF0ZUJhY2t3YXJkKGZyb20gPSAtMSlcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBpZHggPSB0aGlzLnRvWmVyb0Jhc2VkKGZyb20pOyBpZHggPj0gMDsgaWR4LS0pXG5cdFx0XHRcdHlpZWxkIHRoaXMuaXRlbXNbaWR4XTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuXHRcdCAqL1xuXHRcdGdldCBsZW5ndGgoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHRcdCAqIElmIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaXMgbGVzcyB0aGFuIDAsIHRoZSBwb3NpdGlvblxuXHRcdCAqIGlzIGFzc3VtZWQgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG5cdFx0ICovXG5cdFx0Z2V0KHBvczogbnVtYmVyKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zW3RoaXMudG9aZXJvQmFzZWQocG9zKV07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHNldChwb3M6IG51bWJlciwgaXRlbTogVClcblx0XHR7XG5cdFx0XHR0aGlzLml0ZW1zW3RoaXMudG9aZXJvQmFzZWQocG9zKV0gPSBpdGVtO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgMS1iYXNlZCBwb3NpdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGl0ZW0uXG5cdFx0ICogUmV0dXJucyAtMSBpbiB0aGUgY2FzZSB3aGVuIHRoZSBpdGVtIHdhcyBub3QgZm91bmQgaW4gdGhlIGFycmF5LlxuXHRcdCAqL1xuXHRcdHBvc09mKGl0ZW06IFQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgaWR4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuXHRcdFx0cmV0dXJuIGlkeCA8IDAgPyAtMSA6IGlkeCArIDE7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYW4gaXRlbSB0byB0aGUgYXJyYXkuXG5cdFx0ICovXG5cdFx0cHVzaChpdGVtOiBUKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgc3RhbmRhcmQgQXJyYXkuc3BsaWNlKCkgY2FsbCBvbiB0aGUgYXJyYXkuXG5cdFx0ICovXG5cdFx0c3BsaWNlKHBvczogbnVtYmVyLCBkZWxldGVDb3VudDogbnVtYmVyLCAuLi5pdGVtczogVFtdKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLnRvWmVyb0Jhc2VkKHBvcyksIGRlbGV0ZUNvdW50LCAuLi5pdGVtcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIGEgMS1iYXNlZCBwb3NpdGlvbiBpbnRvIGEgMC1iYXNlZCBpbmRleC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHRvWmVyb0Jhc2VkKHBvczogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9zIDwgMClcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsIGxlbiAtIHBvcyk7XG5cdFx0XHRcblx0XHRcdGlmIChwb3MgPiBsZW4pXG5cdFx0XHRcdHJldHVybiBsZW4gLSAxO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9zID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZEFyZ3VtZW50KCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBwb3MgLSAxO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGl0ZW1zOiBUW10gPSBbXTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFRoaXMgaXMgYSBjbGFzcyB0aGF0IHdyYXBzIHRoZSBidWlsdC1pbiBVUkwgb2JqZWN0LlxuXHQgKiBJdCBlbnN1cmVzIHRoYXQgdGhlIHN5c3RlbSBvbmx5IGV2ZXJ5IHN0b3JlcyByZWZlcmVuY2VzXG5cdCAqIHRvIHVuaXF1ZSBVUkxzLCBzbyB0aGF0IGVxdWFsaXR5IG9mIHR3byBVcmlzIGNhbiBiZSB0ZXN0ZWRcblx0ICogYnkgZG9pbmcgYSBzaW1wbGUgcmVmZXJlbnRpYWwgY29tcGFyaXNvbi5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBLbm93blVyaVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogUmV0dXJucyBhIEtub3duVXJpIHN1aXRhYmxlIGZvciBpbnRlcm5hbCBkb2N1bWVudHMgdGhhdCBhcmVuJ3QgYWN0dWFsbHlcblx0XHQgKiBzdG9yZWQgYW55d2hlcmUgb3RoZXIgdGhhbiBpbiBtZW1vcnkuIFRoZSBudW1iZXIgcHJvdmlkZWQgZW5kcyB1cFxuXHRcdCAqIGFzIHRoZSBmaWN0aXRpb3VzIG5hbWUgb2YgdGhlIHRydXRoIGZpbGUgc3BlY2lmaWVkIGluIHRoZSBVUkkuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNyZWF0ZU1lbW9yeVVyaShudW1iZXI6IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gVXJpUHJvdG9jb2wubWVtb3J5ICsgXCIvL21lbW9yeS9cIiArIG51bWJlciArIFwiLnRydXRoXCI7XG5cdFx0XHRyZXR1cm4gTWlzYy5nZXQodGhpcy5jYWNoZSwgdXJpVGV4dCwgKCkgPT4gbmV3IEtub3duVXJpKG5ldyBVUkwodXJpVGV4dCkpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgS25vd25Vcmkgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgdGV4dCByZXByZXNlbnRhdGlvblxuXHRcdCAqIG9mIHRoZSBVUkkgc3BlY2lmaWVkLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gdGhlIHRleHQgdmFsdWUgc3BlY2lmaWVkXG5cdFx0ICogY291bGQgbm90IGJlIHBhcnNlZCBhcyBhIFVSSS5cblx0XHQgKi9cblx0XHRzdGF0aWMgZnJvbVN0cmluZyh1cmlUZXh0OiBzdHJpbmcsIGJhc2U/OiBLbm93blVyaSlcblx0XHR7XG5cdFx0XHRsZXQgbWVyZ2VkVXJsOiBVUkwgfCBudWxsID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdG1lcmdlZFVybCA9IG5ldyBVUkwodXJpVGV4dCwgYmFzZSA/IGJhc2UuaW5uZXJVcmwgOiB2b2lkIDApO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHsgfVxuXHRcdFx0XG5cdFx0XHRpZiAobWVyZ2VkVXJsID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdXJsID0gbWVyZ2VkVXJsO1xuXHRcdFx0cmV0dXJuIE1pc2MuZ2V0KHRoaXMuY2FjaGUsIG1lcmdlZFVybC5ocmVmLCAoKSA9PiBuZXcgS25vd25VcmkodXJsKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIGNhY2hlIG9mIGFsbCBLbm93blVyaXMgY3JlYXRlZCBieSB0aGUgY29tcGlsZXIsIFxuXHRcdCAqIGtleWVkIGJ5IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBLbm93blVyaSdzIGlubmVyIFVSTC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBLbm93blVyaT4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgaW5uZXJVcmw6IFVSTClcblx0XHR7XG5cdFx0XHQvLyBHZW5lcmF0ZXMgYW4gZXJyb3IgaWYgdGhlIFVSTCBpc24ndCBmcm9tIGEga25vd24gcHJvdG9jb2wuXG5cdFx0XHR0aGlzLnByb3RvY29sO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBwcm90b2NvbCBvZiB0aGUgdW5kZXJseWluZyBVUkwuXG5cdFx0ICovXG5cdFx0Z2V0IHByb3RvY29sKCk6IFVyaVByb3RvY29sXG5cdFx0e1xuXHRcdFx0cmV0dXJuIE5vdC5udWxsKFVyaVByb3RvY29sLnJlc29sdmUodGhpcy5pbm5lclVybC5wcm90b2NvbCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgZnVsbHktcXVhbGlmaWVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEtub3duVXJpLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbm5lclVybC5wcm90b2NvbCA9PT0gVXJpUHJvdG9jb2wuZmlsZSA/XG5cdFx0XHRcdHRoaXMuaW5uZXJVcmwucGF0aG5hbWUgOlxuXHRcdFx0XHR0aGlzLmlubmVyVXJsLmhyZWY7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKiogXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiAoTm90IGltcGxlbWVudGVkKVxuXHQgKiBBIGNsYXNzIHRoYXQgc3BlY2lmaWVzIGJlaGF2aW9yIGFyb3VuZCB0aGUgcmVjb2duaXRpb24gXG5cdCAqIG9mIHBhdHRlcm5zIGZvdW5kIHdpdGhpbiBkb2N1bWVudHMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVjb2duaXRpb25cblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKCkgeyB9XG5cdFx0XG5cdFx0LyoqIFdoZXRoZXIgRmlsZSBVUklzIHNob3VsZCBiZSByZWNvZ25pemVkIGluIHN0YXRlbWVudHMuICovXG5cdFx0ZmlsZVVyaXMgPSBSZWNvZ25pdGlvblN0YXRlLm9uO1xuXHRcdFxuXHRcdC8qKiBXaGV0aGVyIEhUVFAgVVJJcyBzaG91bGQgYmUgcmVjb2duaXplZCBpbiBzdGF0ZW1lbnRzLiAqL1xuXHRcdGh0dHBVcmlzID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0XHRcblx0XHQvKiogV2hldGhlciByZWd1bGFyIGV4cHJlc3Npb25zIHNob3VsZCBiZSByZWNvZ25pemVkIGluIHN0YXRlbWVudHMuICovXG5cdFx0cmVndWxhckV4cHJlc3Npb25zID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0XHRcblx0XHQvKiogV2hldGhlciBjb21tZW50cyBzaG91bGQgYmUgcmVjb2duaXplZCBpbiBzdGF0ZW1lbnRzLiAqL1xuXHRcdGNvbW1lbnRzID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0fVxuXHRcblx0ZXhwb3J0IGNvbnN0IGVudW0gUmVjb2duaXRpb25TdGF0ZVxuXHR7XG5cdFx0LyoqIEluZGljYXRlcyB0aGF0IGEgcGF0dGVybiBpcyByZWNvZ25pemVkIGJ5IHRoZSBzeXN0ZW0uICovXG5cdFx0b24sXG5cdFx0XG5cdFx0LyoqIEluZGljYXRlcyB0aGF0IGEgcGF0dGVybiBpcyBub3QgcmVjb2duaXplZCBieSB0aGUgc3lzdGVtLiAqL1xuXHRcdG9mZixcblx0XHRcblx0XHQvKiogSW5kaWNhdGVzIHRoYXQgYSBwYXR0ZXJuIGlzIHJlY29nbml6ZWQgYnkgdGhlIHN5c3RlbSwgYW5kIG9taXR0ZWQuICovXG5cdFx0b21pdHRlZFxuXHR9XG59XG4iXX0=