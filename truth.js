"use strict";
var Truth;
(function (Truth) {
    /**
     * Asynchronously reads a truth document, and all documents
     * it references from the specified file system or HTTP(s) path.
     * File system paths are only supported if this code is running
     * within a Node.js-compatible environment.
     *
     * @returns A reference to the document read, or an Error.
     */
    async function read(truthFilePathOrUri) {
        const program = new Truth.Program();
        return await program.documents.read(truthFilePathOrUri);
    }
    Truth.read = read;
    /**
     * Parses the specified truth content into a new Truth program.
     *
     * @returns A reference to the parsed document.
     */
    async function parse(truthContent) {
        const program = new Truth.Program();
        return await program.documents.create(truthContent);
    }
    Truth.parse = parse;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A Map of the generic key and value types.
     * Supports keys that refer to multiple values.
     */
    class MultiMap {
        constructor() {
            /** */
            this.map = new Map();
        }
        /** */
        *[Symbol.iterator]() {
            for (const entry of this.map)
                yield entry;
        }
        /** */
        entries() {
            return this.map.entries();
        }
        /** */
        get(key) {
            return this.map.get(key);
        }
        /** */
        has(key, value) {
            const values = this.get(key);
            if (!values)
                return false;
            if (value !== undefined)
                return values.includes(value);
            return true;
        }
        /** */
        add(key, value) {
            if (value) {
                const values = this.get(key);
                if (values) {
                    if (!values.includes(value))
                        values.push(value);
                }
                else {
                    this.map.set(key, [value]);
                }
            }
            return this;
        }
        /** */
        delete(key, value) {
            if (value === undefined)
                return !!this.map.delete(key);
            const storedValues = this.map.get(key);
            if (storedValues === undefined)
                return false;
            if (storedValues.length === 1 && storedValues[0] === value) {
                this.map.delete(key);
                return true;
            }
            const valueIdx = storedValues.indexOf(value);
            if (valueIdx < 0)
                return false;
            storedValues.splice(valueIdx, 1);
            return true;
        }
        /** */
        values() {
            return this.map.values();
        }
    }
    Truth.MultiMap = MultiMap;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Exposes the "fs" module used by the compiler,
     * as well as the ability to change the module used
     * with a custom implementation.
     */
    class Fs {
        /**
         * Assigns a new implementation of the node "fs" module.
         */
        static override(module) {
            this._module = module;
        }
        /** */
        static get module() {
            if (this._module)
                return this._module;
            this._module = require("fs");
            return Truth.Not.null(this._module);
        }
    }
    /** */
    Fs._module = null;
    Truth.Fs = Fs;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A class that provides browser-style fetch functionality,
     * but with the ability to change this functions behavior
     * with a custom implementation.
     */
    class Fetch {
        /**
         *
         */
        static async exec(url) {
            const uri = Truth.Uri.tryParse(url);
            if (!uri)
                throw Truth.Exception.invalidUri(url);
            if (typeof fetch === "function") {
                try {
                    const response = await fetch(url);
                    if (response.status === 200)
                        return response.text();
                    return new FetchError(response.status, response.statusText);
                }
                catch (e) {
                    return new Error("Unknown error.");
                }
            }
            else if (typeof require === "function") {
                const getFn = uri.protocol === Truth.UriProtocol.https ? require("https").get :
                    uri.protocol === Truth.UriProtocol.http ? require("http").get :
                        null;
                if (getFn === null)
                    throw Truth.Exception.invalidUri(url);
                return await new Promise(resolve => {
                    getFn(url, response => {
                        const data = [];
                        response.on("data", chunk => {
                            data.push(typeof chunk === "string" ?
                                chunk :
                                chunk.toString("utf8"));
                        });
                        response.on("error", error => {
                            resolve(error);
                        });
                        response.on("end", () => {
                            resolve(data.join(""));
                        });
                    });
                    return "";
                });
            }
            throw Truth.Exception.unsupportedPlatform();
        }
    }
    Truth.Fetch = Fetch;
    /**
     *
     */
    class FetchError extends Error {
        constructor(statusCode, statusText) {
            super();
            this.statusCode = statusCode;
            this.statusText = statusText;
        }
    }
    Truth.FetchError = FetchError;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that encapsulates string hashing functionality.
     */
    Truth.Hash = new class Hash {
        constructor() {
            /** Stores the constant number of characters in a returned hash. */
            this.length = 8;
        }
        /**
         * Calculates a hash code from the specified string.
         */
        calculate(text) {
            if (text.length === 0)
                return "0".repeat(8);
            let hash = 0;
            for (let i = -1; ++i < text.length;) {
                const char = text.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash %= 2 ** 32;
            }
            return (hash + Math.pow(2, 31)).toString(16).toUpperCase();
        }
    }();
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that provides various higher-order functions
     * across data structures.
     */
    class HigherOrder {
        static copy(param) {
            if (param instanceof Array)
                return Object.freeze(param.slice());
            if (param instanceof Set) {
                const set = new Set();
                for (const value of param)
                    set.add(value);
                return Object.freeze(set);
            }
            if (param instanceof Map) {
                const map = new Map();
                for (const [key, value] of param)
                    map.set(key, value);
                return Object.freeze(map);
            }
            throw new TypeError();
        }
        constructor() { }
    }
    Truth.HigherOrder = HigherOrder;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Utility class for performing basic guarding.
     */
    class Not {
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's strictly equal to null.
         */
        static null(param) {
            if (param === null) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's strictly equal to undefined.
         */
        static undefined(param) {
            if (param === undefined) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's null or undefined.
         */
        static nullable(param) {
            if (param === null || param === undefined) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
    }
    Truth.Not = Not;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A general parsing utility class that provides consumption
     * methods that operate over a given input.
     */
    class Parser {
        /**
         * Constructs a new Parser object that operates over
         * the specified input string, optionally starting at the
         * specified position.
         */
        constructor(input) {
            this._position = 0;
            this.input = input.normalize();
            this._position = 0;
        }
        /**
         * Attempts to read the specified token immediately
         * following the cursor.
         *
         * @returns The content read. In the case when no
         * match could be found, an empty string is returned.
         */
        read(token) {
            if (!token)
                throw new TypeError();
            const pos = this._position;
            if (this.input.substr(pos, token.length) === token) {
                this._position += token.length;
                return token;
            }
            return "";
        }
        /**
         * Reads any whitespace characters and floating
         * escape characters.
         *
         * @returns The number of whitespace characters
         * read.
         */
        readWhitespace() {
            let count = 0;
            while (this.more()) {
                const c = count;
                if (this.read("\t" /* tab */))
                    count++;
                if (this.read(" " /* space */))
                    count++;
                if (this.read("\\" /* escapeChar */ + " " /* space */))
                    count++;
                if (this.read("\\" /* escapeChar */ + "\t" /* tab */))
                    count++;
                if (c === count)
                    break;
            }
            return count;
        }
        /**
         * Attempts to read a single stream-level grapheme from the
         * parse stream, using unicode-aware extraction method.
         * If the parse stream specifies a unicode escape sequence,
         * such as \uFFFF, these are seen as 6 individual graphemes.
         *
         * @returns The read grapheme, or an empty string in the case
         * when there is no more content in the parse stream.
         */
        readGrapheme() {
            if (this._position >= this.input.length)
                return "";
            const codeAtCursor = this.input.codePointAt(this._position) || -1;
            this._position += codeAtCursor > 0xFFFF ? 2 : 1;
            return String.fromCodePoint(codeAtCursor);
        }
        /**
         * Reads graphemes from the parse stream, until either
         * the cursor reaches one of the specified quit tokens,
         * or the parse stream terminates.
         */
        readUntil(...quitTokens) {
            let stream = "";
            while (this.more()) {
                if (quitTokens.some(t => this.peek(t)))
                    break;
                stream += this.readGrapheme();
            }
            return stream;
        }
        /**
         * Attempts to read the specified token from the parse stream,
         * if and only if it's at the end of the parse stream.
         */
        readThenTerminal(token) {
            if (this.peek(token) && this._position === this.input.length - token.length) {
                this._position += token.length;
                return token;
            }
            return "";
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified string exists immediately at the position of
         * the cursor.
         */
        peek(token) {
            return this.input.substr(this._position, token.length) === token;
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified string exists immediately at the position of
         * the cursor, and following this token is the end of the
         * parse stream.
         */
        peekThenTerminal(token) {
            return (this._position === this.input.length - token.length &&
                this.input.substr(this._position, token.length) === token);
        }
        /**
         * @returns A boolean value that indicates whether
         * there are more characters to read in the input.
         */
        more() {
            return this._position < this.input.length;
        }
        /**
         * Gets or sets the position of the cursor from where
         * reading takes place in the cursor.
         */
        get position() {
            return this._position;
        }
        set position(value) {
            if (value < 0)
                throw new RangeError();
            this._position = value;
        }
        //
        // DEAD
        //
        /**
         *
         */
        atRealBackslash() {
            const esc = "\\" /* escapeChar */;
            return this.input.substr(this._position, 2) === esc + esc;
        }
        /**
         * @deprecated
         * @returns A boolean value that indicates whether an
         * escape character exists behind the current character.
         * The algorithm used is respective of sequences of
         * multiple escape characters.
         */
        escaped() {
            let escaped = false;
            let backtrackPos = this._position;
            while (--backtrackPos >= 0)
                if (this.input[backtrackPos] === "\\" /* escapeChar */)
                    escaped = !escaped;
            return escaped;
        }
    }
    Truth.Parser = Parser;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Converts the names in the UnicodeBlocks object
     * to a map with lower case keys, for easy lookup.
     */
    function toMap(blocks) {
        const entries = Object.entries(blocks);
        const entriesFmt = entries.map(entry => [entry[0].toLowerCase(), entry[1]]);
        return Object.freeze(new Map(entriesFmt));
    }
    /**
     * Stores the maximum character code in the unicode set.
     */
    Truth.UnicodeMax = 65536;
    /**
     * Stores a map of the names of all unicode blocks,
     * and their character ranges.
     */
    Truth.UnicodeBlocks = toMap({
        "Control character": [0x0000, 0x001F],
        "Basic Latin": [0x0020, 0x007F],
        "Latin-1 Supplement": [0x0080, 0x00FF],
        "Latin Extended-A": [0x0100, 0x017F],
        "Latin Extended-B": [0x0180, 0x024F],
        "IPA Extensions": [0x0250, 0x02AF],
        "Spacing Modifier Letters": [0x02B0, 0x02FF],
        "Combining Diacritical Marks": [0x0300, 0x036F],
        "Greek and Coptic": [0x0370, 0x03FF],
        "Cyrillic": [0x0400, 0x04FF],
        "Cyrillic Supplement": [0x0500, 0x052F],
        "Armenian": [0x0530, 0x058F],
        "Hebrew": [0x0590, 0x05FF],
        "Arabic": [0x0600, 0x06FF],
        "Syriac": [0x0700, 0x074F],
        "Arabic Supplement": [0x0750, 0x077F],
        "Thaana": [0x0780, 0x07BF],
        "NKo": [0x07C0, 0x07FF],
        "Samaritan": [0x0800, 0x083F],
        "Mandaic": [0x0840, 0x085F],
        "Syriac Supplement": [0x0860, 0x086F],
        "Arabic Extended-A": [0x08A0, 0x08FF],
        "Devanagari": [0x0900, 0x097F],
        "Bengali": [0x0980, 0x09FF],
        "Gurmukhi": [0x0A00, 0x0A7F],
        "Gujarati": [0x0A80, 0x0AFF],
        "Oriya": [0x0B00, 0x0B7F],
        "Tamil": [0x0B80, 0x0BFF],
        "Telugu": [0x0C00, 0x0C7F],
        "Kannada": [0x0C80, 0x0CFF],
        "Malayalam": [0x0D00, 0x0D7F],
        "Sinhala": [0x0D80, 0x0DFF],
        "Thai": [0x0E00, 0x0E7F],
        "Lao": [0x0E80, 0x0EFF],
        "Tibetan": [0x0F00, 0x0FFF],
        "Myanmar": [0x1000, 0x109F],
        "Georgian": [0x10A0, 0x10FF],
        "Hangul Jamo": [0x1100, 0x11FF],
        "Ethiopic": [0x1200, 0x137F],
        "Ethiopic Supplement": [0x1380, 0x139F],
        "Cherokee": [0x13A0, 0x13FF],
        "Unified Canadian Aboriginal Syllabics": [0x1400, 0x167F],
        "Ogham": [0x1680, 0x169F],
        "Runic": [0x16A0, 0x16FF],
        "Tagalog": [0x1700, 0x171F],
        "Hanunoo": [0x1720, 0x173F],
        "Buhid": [0x1740, 0x175F],
        "Tagbanwa": [0x1760, 0x177F],
        "Khmer": [0x1780, 0x17FF],
        "Mongolian": [0x1800, 0x18AF],
        "Unified Canadian Aboriginal Syllabics Extended": [0x18B0, 0x18FF],
        "Limbu": [0x1900, 0x194F],
        "Tai Le": [0x1950, 0x197F],
        "New Tai Lue": [0x1980, 0x19DF],
        "Khmer Symbols": [0x19E0, 0x19FF],
        "Buginese": [0x1A00, 0x1A1F],
        "Tai Tham": [0x1A20, 0x1AAF],
        "Combining Diacritical Marks Extended": [0x1AB0, 0x1AFF],
        "Balinese": [0x1B00, 0x1B7F],
        "Sundanese": [0x1B80, 0x1BBF],
        "Batak": [0x1BC0, 0x1BFF],
        "Lepcha": [0x1C00, 0x1C4F],
        "Ol Chiki": [0x1C50, 0x1C7F],
        "Cyrillic Extended C": [0x1C80, 0x1C8F],
        "Sundanese Supplement": [0x1CC0, 0x1CCF],
        "Vedic Extensions": [0x1CD0, 0x1CFF],
        "Phonetic Extensions": [0x1D00, 0x1D7F],
        "Phonetic Extensions Supplement": [0x1D80, 0x1DBF],
        "Combining Diacritical Marks Supplement": [0x1DC0, 0x1DFF],
        "Latin Extended Additional": [0x1E00, 0x1EFF],
        "Greek Extended": [0x1F00, 0x1FFF],
        "General Punctuation": [0x2000, 0x206F],
        "Superscripts and Subscripts": [0x2070, 0x209F],
        "Currency Symbols": [0x20A0, 0x20CF],
        "Combining Diacritical Marks for Symbols": [0x20D0, 0x20FF],
        "Letterlike Symbols": [0x2100, 0x214F],
        "Number Forms": [0x2150, 0x218F],
        "Arrows": [0x2190, 0x21FF],
        "Mathematical Operators": [0x2200, 0x22FF],
        "Miscellaneous Technical": [0x2300, 0x23FF],
        "Control Pictures": [0x2400, 0x243F],
        "Optical Character Recognition": [0x2440, 0x245F],
        "Enclosed Alphanumerics": [0x2460, 0x24FF],
        "Box Drawing": [0x2500, 0x257F],
        "Block Elements": [0x2580, 0x259F],
        "Geometric Shapes": [0x25A0, 0x25FF],
        "Miscellaneous Symbols": [0x2600, 0x26FF],
        "Dingbats": [0x2700, 0x27BF],
        "Miscellaneous Mathematical Symbols-A": [0x27C0, 0x27EF],
        "Supplemental Arrows-A": [0x27F0, 0x27FF],
        "Braille Patterns": [0x2800, 0x28FF],
        "Supplemental Arrows-B": [0x2900, 0x297F],
        "Miscellaneous Mathematical Symbols-B": [0x2980, 0x29FF],
        "Supplemental Mathematical Operators": [0x2A00, 0x2AFF],
        "Miscellaneous Symbols and Arrows": [0x2B00, 0x2BFF],
        "Glagolitic": [0x2C00, 0x2C5F],
        "Latin Extended-C": [0x2C60, 0x2C7F],
        "Coptic": [0x2C80, 0x2CFF],
        "Georgian Supplement": [0x2D00, 0x2D2F],
        "Tifinagh": [0x2D30, 0x2D7F],
        "Ethiopic Extended": [0x2D80, 0x2DDF],
        "Cyrillic Extended-A": [0x2DE0, 0x2DFF],
        "Supplemental Punctuation": [0x2E00, 0x2E7F],
        "CJK Radicals Supplement": [0x2E80, 0x2EFF],
        "Kangxi Radicals": [0x2F00, 0x2FDF],
        "Ideographic Description Characters": [0x2FF0, 0x2FFF],
        "CJK Symbols and Punctuation": [0x3000, 0x303F],
        "Hiragana": [0x3040, 0x309F],
        "Katakana": [0x30A0, 0x30FF],
        "Bopomofo": [0x3100, 0x312F],
        "Hangul Compatibility Jamo": [0x3130, 0x318F],
        "Kanbun": [0x3190, 0x319F],
        "Bopomofo Extended": [0x31A0, 0x31BF],
        "CJK Strokes": [0x31C0, 0x31EF],
        "Katakana Phonetic Extensions": [0x31F0, 0x31FF],
        "Enclosed CJK Letters and Months": [0x3200, 0x32FF],
        "CJK Compatibility": [0x3300, 0x33FF],
        "CJK Unified Ideographs Extension A": [0x3400, 0x4DBF],
        "Yijing Hexagram Symbols": [0x4DC0, 0x4DFF],
        "CJK Unified Ideographs": [0x4E00, 0x9FFF],
        "Yi Syllables": [0xA000, 0xA48F],
        "Yi Radicals": [0xA490, 0xA4CF],
        "Lisu": [0xA4D0, 0xA4FF],
        "Vai": [0xA500, 0xA63F],
        "Cyrillic Extended-B": [0xA640, 0xA69F],
        "Bamum": [0xA6A0, 0xA6FF],
        "Modifier Tone Letters": [0xA700, 0xA71F],
        "Latin Extended-D": [0xA720, 0xA7FF],
        "Syloti Nagri": [0xA800, 0xA82F],
        "Common Indic Number Forms": [0xA830, 0xA83F],
        "Phags-pa": [0xA840, 0xA87F],
        "Saurashtra": [0xA880, 0xA8DF],
        "Devanagari Extended": [0xA8E0, 0xA8FF],
        "Kayah Li": [0xA900, 0xA92F],
        "Rejang": [0xA930, 0xA95F],
        "Hangul Jamo Extended-A": [0xA960, 0xA97F],
        "Javanese": [0xA980, 0xA9DF],
        "Myanmar Extended-B": [0xA9E0, 0xA9FF],
        "Cham": [0xAA00, 0xAA5F],
        "Myanmar Extended-A": [0xAA60, 0xAA7F],
        "Tai Viet": [0xAA80, 0xAADF],
        "Meetei Mayek Extensions": [0xAAE0, 0xAAFF],
        "Ethiopic Extended-A": [0xAB00, 0xAB2F],
        "Latin Extended-E": [0xAB30, 0xAB6F],
        "Cherokee Supplement": [0xAB70, 0xABBF],
        "Meetei Mayek": [0xABC0, 0xABFF],
        "Hangul Syllables": [0xAC00, 0xD7AF],
        "Hangul Jamo Extended-B": [0xD7B0, 0xD7FF],
        "High Surrogates": [0xD800, 0xDB7F],
        "High Private Use Surrogates": [0xDB80, 0xDBFF],
        "Low Surrogates": [0xDC00, 0xDFFF],
        "Private Use Area": [0xE000, 0xF8FF],
        "CJK Compatibility Ideographs": [0xF900, 0xFAFF],
        "Alphabetic Presentation Forms": [0xFB00, 0xFB4F],
        "Arabic Presentation Forms-A": [0xFB50, 0xFDFF],
        "Variation Selectors": [0xFE00, 0xFE0F],
        "Vertical Forms": [0xFE10, 0xFE1F],
        "Combining Half Marks": [0xFE20, 0xFE2F],
        "CJK Compatibility Forms": [0xFE30, 0xFE4F],
        "Small Form Variants": [0xFE50, 0xFE6F],
        "Arabic Presentation Forms-B": [0xFE70, 0xFEFF],
        "Halfwidth and Fullwidth Forms": [0xFF00, 0xFFEF],
        "Specials": [0xFFF0, 0xFFFF],
        "Linear B Syllabary": [0x10000, 0x1007F],
        "Linear B Ideograms": [0x10080, 0x100FF],
        "Aegean Numbers": [0x10100, 0x1013F],
        "Ancient Greek Numbers": [0x10140, 0x1018F],
        "Ancient Symbols": [0x10190, 0x101CF],
        "Phaistos Disc": [0x101D0, 0x101FF],
        "Lycian": [0x10280, 0x1029F],
        "Carian": [0x102A0, 0x102DF],
        "Coptic Epact Numbers": [0x102E0, 0x102FF],
        "Old Italic": [0x10300, 0x1032F],
        "Gothic": [0x10330, 0x1034F],
        "Old Permic": [0x10350, 0x1037F],
        "Ugaritic": [0x10380, 0x1039F],
        "Old Persian": [0x103A0, 0x103DF],
        "Deseret": [0x10400, 0x1044F],
        "Shavian": [0x10450, 0x1047F],
        "Osmanya": [0x10480, 0x104AF],
        "Osage": [0x104B0, 0x104FF],
        "Elbasan": [0x10500, 0x1052F],
        "Caucasian Albanian": [0x10530, 0x1056F],
        "Linear A": [0x10600, 0x1077F],
        "Cypriot Syllabary": [0x10800, 0x1083F],
        "Imperial Aramaic": [0x10840, 0x1085F],
        "Palmyrene": [0x10860, 0x1087F],
        "Nabataean": [0x10880, 0x108AF],
        "Hatran": [0x108E0, 0x108FF],
        "Phoenician": [0x10900, 0x1091F],
        "Lydian": [0x10920, 0x1093F],
        "Meroitic Hieroglyphs": [0x10980, 0x1099F],
        "Meroitic Cursive": [0x109A0, 0x109FF],
        "Kharoshthi": [0x10A00, 0x10A5F],
        "Old South Arabian": [0x10A60, 0x10A7F],
        "Old North Arabian": [0x10A80, 0x10A9F],
        "Manichaean": [0x10AC0, 0x10AFF],
        "Avestan": [0x10B00, 0x10B3F],
        "Inscriptional Parthian": [0x10B40, 0x10B5F],
        "Inscriptional Pahlavi": [0x10B60, 0x10B7F],
        "Psalter Pahlavi": [0x10B80, 0x10BAF],
        "Old Turkic": [0x10C00, 0x10C4F],
        "Old Hungarian": [0x10C80, 0x10CFF],
        "Rumi Numeral Symbols": [0x10E60, 0x10E7F],
        "Brahmi": [0x11000, 0x1107F],
        "Kaithi": [0x11080, 0x110CF],
        "Sora Sompeng": [0x110D0, 0x110FF],
        "Chakma": [0x11100, 0x1114F],
        "Mahajani": [0x11150, 0x1117F],
        "Sharada": [0x11180, 0x111DF],
        "Sinhala Archaic Numbers": [0x111E0, 0x111FF],
        "Khojki": [0x11200, 0x1124F],
        "Multani": [0x11280, 0x112AF],
        "Khudawadi": [0x112B0, 0x112FF],
        "Grantha": [0x11300, 0x1137F],
        "Newa": [0x11400, 0x1147F],
        "Tirhuta": [0x11480, 0x114DF],
        "Siddham": [0x11580, 0x115FF],
        "Modi": [0x11600, 0x1165F],
        "Mongolian Supplement": [0x11660, 0x1167F],
        "Takri": [0x11680, 0x116CF],
        "Ahom": [0x11700, 0x1173F],
        "Warang Citi": [0x118A0, 0x118FF],
        "Zanabazar Square": [0x11A00, 0x11A4F],
        "Soyombo": [0x11A50, 0x11AAF],
        "Pau Cin Hau": [0x11AC0, 0x11AFF],
        "Bhaiksuki": [0x11C00, 0x11C6F],
        "Marchen": [0x11C70, 0x11CBF],
        "Masaram Gondi": [0x11D00, 0x11D5F],
        "Cuneiform": [0x12000, 0x123FF],
        "Cuneiform Numbers and Punctuation": [0x12400, 0x1247F],
        "Early Dynastic Cuneiform": [0x12480, 0x1254F],
        "Egyptian Hieroglyphs": [0x13000, 0x1342F],
        "Anatolian Hieroglyphs": [0x14400, 0x1467F],
        "Bamum Supplement": [0x16800, 0x16A3F],
        "Mro": [0x16A40, 0x16A6F],
        "Bassa Vah": [0x16AD0, 0x16AFF],
        "Pahawh Hmong": [0x16B00, 0x16B8F],
        "Miao": [0x16F00, 0x16F9F],
        "Ideographic Symbols and Punctuation": [0x16FE0, 0x16FFF],
        "Tangut": [0x17000, 0x187FF],
        "Tangut Components": [0x18800, 0x18AFF],
        "Kana Supplement": [0x1B000, 0x1B0FF],
        "Kana Extended-A": [0x1B100, 0x1B12F],
        "Nushu": [0x1B170, 0x1B2FF],
        "Duployan": [0x1BC00, 0x1BC9F],
        "Shorthand Format Controls": [0x1BCA0, 0x1BCAF],
        "Byzantine Musical Symbols": [0x1D000, 0x1D0FF],
        "Musical Symbols": [0x1D100, 0x1D1FF],
        "Ancient Greek Musical Notation": [0x1D200, 0x1D24F],
        "Tai Xuan Jing Symbols": [0x1D300, 0x1D35F],
        "Counting Rod Numerals": [0x1D360, 0x1D37F],
        "Mathematical Alphanumeric Symbols": [0x1D400, 0x1D7FF],
        "Sutton SignWriting": [0x1D800, 0x1DAAF],
        "Glagolitic Supplement": [0x1E000, 0x1E02F],
        "Mende Kikakui": [0x1E800, 0x1E8DF],
        "Adlam": [0x1E900, 0x1E95F],
        "Arabic Mathematical Alphabetic Symbols": [0x1EE00, 0x1EEFF],
        "Mahjong Tiles": [0x1F000, 0x1F02F],
        "Domino Tiles": [0x1F030, 0x1F09F],
        "Playing Cards": [0x1F0A0, 0x1F0FF],
        "Enclosed Alphanumeric Supplement": [0x1F100, 0x1F1FF],
        "Enclosed Ideographic Supplement": [0x1F200, 0x1F2FF],
        "Miscellaneous Symbols and Pictographs": [0x1F300, 0x1F5FF],
        "Emoji": [0x1F600, 0x1F64F],
        "Ornamental Dingbats": [0x1F650, 0x1F67F],
        "Transport and Map Symbols": [0x1F680, 0x1F6FF],
        "Alchemical Symbols": [0x1F700, 0x1F77F],
        "Geometric Shapes Extended": [0x1F780, 0x1F7FF],
        "Supplemental Arrows-C": [0x1F800, 0x1F8FF],
        "Supplemental Symbols and Pictographs": [0x1F900, 0x1F9FF],
        "CJK Unified Ideographs Extension B": [0x20000, 0x2A6DF],
        "CJK Unified Ideographs Extension C": [0x2A700, 0x2B73F],
        "CJK Unified Ideographs Extension D": [0x2B740, 0x2B81F],
        "CJK Unified Ideographs Extension E": [0x2B820, 0x2CEAF],
        "CJK Unified Ideographs Extension F": [0x2CEB0, 0x2EBEF],
        "CJK Compatibility Ideographs Supplement": [0x2F800, 0x2FA1F],
        "Tags": [0xE0000, 0xE007F],
        "Variation Selectors Supplement": [0xE0100, 0xE01EF]
    });
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Stores unsorted general utility methods.
     */
    class Misc {
        /**
         * Counts incrementally through numbers, using the specified
         * radix sequence. For example, if the radixes [2, 2, 2] were to
         * be specified, this would result in binary counting starting at
         * [0, 0, 0] and ending at [1, 1, 1].
         */
        static *variableRadixCounter(radixes) {
            if (radixes.length === 0)
                return;
            if (radixes.length === 1) {
                for (let i = -1; ++i < radixes[0];)
                    yield [i];
                return;
            }
            const total = radixes.reduce((a, b) => a * b, 1);
            const digits = radixes.map(() => 0);
            const divideFactors = [1];
            for (let baseIdx = radixes.length - 1; --baseIdx >= 0;)
                divideFactors.unshift(radixes.slice(baseIdx + 1).reduce((a, b) => a * b, 1));
            for (let count = -1; ++count < total;) {
                const sequence = [];
                let remainder = count;
                for (let digitIdx = -1; ++digitIdx < digits.length;) {
                    const div = divideFactors[digitIdx];
                    sequence.push(remainder / div | 0);
                    remainder %= div;
                }
                yield sequence;
            }
        }
        /**
         *
         */
        static calculatePowerset(array) {
            const result = [[]];
            for (let i = 0; i < array.length; i++)
                for (let n = 0; n < result.length; n++)
                    result.push(result[n].concat(array[i]));
            return result;
        }
        /**
         * @returns Whether the items of the first set object form
         * a subset (not a proper subset) of the items of the second
         * set.
         */
        static isSubset(sourceSet, possibleSubset) {
            for (const item of possibleSubset)
                if (!sourceSet.has(item))
                    return false;
            return true;
        }
        /**
         * @returns Whether the items of the first set object form
         * a superset (not a proper superset) of the items of the
         * second set.
         */
        static isSuperset(sourceSet, possibleSuperset) {
            for (const item of sourceSet)
                if (!possibleSuperset.has(item))
                    return false;
            return true;
        }
        /**
         * @returns The number of items that are missing
         * from the second set that exist in the first set.
         */
        static computeSubsetFactor(a, b) {
            let count = 0;
            for (const item of a)
                count += b.includes(item) ? 0 : 1;
            return count;
        }
        /**
         * Performs a recursive reduction operation on an initial object
         * that represents some abstract node of a graph. The traversal
         * algorithm used ensures all provided nodes are only visited
         * once.
         */
        static reduceRecursive(initialObject, followFn, reduceFn) {
            const visited = new Set();
            const recurse = (object) => {
                visited.add(object);
                const reduceResult = [];
                for (const next of followFn(object))
                    if (!visited.has(next))
                        reduceResult.push(recurse(next));
                return reduceFn(object, Object.freeze(reduceResult));
            };
            return recurse(initialObject);
        }
        /**
         * @returns A proxy of the specified object, whose members
         * have been patched with the specified patch object.
         */
        static patch(source, patch) {
            const patchKeys = Object.freeze(Object.keys(patch));
            return new Proxy(source, {
                get(target, key) {
                    return patchKeys.includes(key) ?
                        patch[key] :
                        source[key];
                }
            });
        }
        /**
         * Safely parses a JSON object, silencing any thrown parse exceptions.
         */
        static tryParseJson(jsonText) {
            try {
                return JSON.parse(jsonText);
            }
            catch (e) {
                return null;
            }
        }
        constructor() { }
    }
    Truth.Misc = Misc;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * The top-level object that manages Truth documents.
     */
    class Program {
        /**
         * Creates a new Program, into which Documents may
         * be added, and verified.
         */
        constructor() {
            /** @internal */
            this.causes = new Truth.MultiMap();
            /** */
            this.unverifiedStatements = [];
            /** */
            this.unverifiedDocuments = [];
            this._version = Truth.VersionStamp.next();
            // The ordering of these instantations is relevant,
            // because it reflects the order in which each of
            // these services are going to process hooks.
            this.on(Truth.CauseDocumentCreate, data => {
                this.unverifiedDocuments.push(data.document);
            });
            this.on(Truth.CauseDocumentDelete, data => {
                const idx = this.unverifiedDocuments.indexOf(data.document);
                if (idx > -1)
                    this.unverifiedDocuments.splice(idx, 1);
            });
            this.on(Truth.CauseDocumentUriChange, () => {
                this._version = Truth.VersionStamp.next();
            });
            this.on(Truth.CauseAgentDetach, data => {
                for (const [cause, attachments] of this.causes)
                    for (const attachment of attachments)
                        if (attachment.uri && attachment.uri.equals(data.uri))
                            this.causes.delete(cause, attachment);
            });
            this.agentCache = new Truth.AgentCache(this);
            this.documents = new Truth.DocumentGraph(this);
            this.graph = new Truth.HyperGraph(this);
            this.on(Truth.CauseRevalidate, data => {
                for (let i = this.unverifiedStatements.length; i-- > 0;)
                    if (this.unverifiedStatements[i].isDisposed)
                        this.unverifiedStatements.splice(i, 1);
                for (const statement of data.parents)
                    if (!statement.isCruft)
                        this.unverifiedStatements.push(statement);
            });
            this.faults = new Truth.FaultService(this);
            this.on(Truth.CauseEditComplete, () => {
                this._version = Truth.VersionStamp.next();
            });
        }
        /** */
        get version() {
            return this._version;
        }
        /**
         * Probes the program and returns an array containing information
         * about the callbacks that will be triggered if a cause of the specified
         * type is broadcasted. Essentially, this method answers the question,
         * "Who is listening for Causes of type X?".
         *
         * If no agents have attached to the specified type, an empty array
         * is returned.
         */
        probe(causeType, scope = this) {
            if (scope instanceof Truth.Type)
                throw Truth.Exception.notImplemented();
            const results = [];
            const push = (ca) => results.push({ uri: ca.uri, scope: ca.scope });
            for (const [causeTypeKey, attachments] of this.causes)
                if (causeType === causeTypeKey)
                    for (const ca of attachments)
                        if (scope === ca.scope ||
                            scope instanceof Program && ca.scope instanceof Truth.Document)
                            push(ca);
            return results;
        }
        /**
         *
         */
        on(causeType, fn, scope) {
            const info = getHolderInfo(this);
            const usingScope = scope || info.scope || this;
            const ca = new CauseAttachment(info.uri, fn, usingScope);
            this.causes.add(causeType, ca);
        }
        /**
         * Progates the specified Cause object to all subscribers that
         * are listening for causes of object's type.
         *
         * @param cause A reference to the Cause instance to broadcast.
         *
         * @param filter An optional array of Uri instances that
         * specify the origin from where an agent that is attached
         * to the cause must loaded in order to be delivered the
         * cause instance.
         *
         * @returns An object that stores information about the
         * cause results that were returned, and the URI of the
         * agent that produced the result. In the case when the
         * agent was attached programmatically, the URI value
         * will be null.
         */
        cause(cause, ...filters) {
            const causeType = cause.constructor;
            const attachmentsAll = this.causes.get(causeType) || [];
            const attachments = attachmentsAll.filter(attachment => {
                if (filters.length === 0)
                    return true;
                const otherUri = attachment.uri;
                if (otherUri === null)
                    return true;
                return filters.find(uri => uri.equals(otherUri));
            });
            if (attachments.length === 0)
                return [];
            const result = [];
            for (const attachment of attachments) {
                const returned = attachment.callback(cause);
                if (returned !== null && returned !== undefined)
                    result.push({ from: attachment.uri, returned });
            }
            return result;
        }
        /**
         * Augments the global scope of the agents attached to this
         * program with a variable whose name and value are specified
         * in the arguments to this method. (Note that this only affects
         * agents that are attached *after* this call has been made.)
         */
        augment(name, value) {
            this.agentCache.augment(name, value);
        }
        /**
         *
         */
        attach(agentUri) {
            return new Promise(() => {
                throw Truth.Exception.notImplemented();
            });
        }
        /**
         *
         */
        detach(agentUri) {
            throw Truth.Exception.notImplemented();
        }
        query(root, ...typePath) {
            if (arguments.length > 1 && typePath.length === 0)
                throw Truth.Exception.passedArrayCannotBeEmpty("typePath");
            if (root instanceof Truth.Document) {
                if (typePath.length === 0)
                    return Truth.Type.constructRoots(root);
                const uri = root.sourceUri.extendType(typePath);
                return Truth.Type.construct(uri, this);
            }
            const docUri = Truth.Uri.maybeParse(root);
            if (docUri === null)
                throw Truth.Exception.absoluteUriExpected();
            const doc = this.documents.get(root);
            if (!doc)
                return null;
            const types = docUri.types.map(t => t.toString()).concat(typePath);
            if (types.length === 0)
                return Truth.Type.constructRoots(doc);
            const fullUri = docUri.extendType(typePath);
            const constructed = Truth.Type.construct(fullUri, this);
            if (typePath.length === 0)
                return constructed ?
                    Object.freeze([constructed]) :
                    [];
            return constructed;
        }
        /**
         * Begin inspecting a document loaded
         * into this program, a specific location.
         */
        inspect(document, line, offset) {
            const statement = document.read(line);
            const region = statement.getRegion(offset);
            switch (region) {
                case Truth.StatementRegion.void:
                    return new ProgramInspectionResult(null, statement);
                // Return all the types in the declaration side of the parent.
                case Truth.StatementRegion.whitespace:
                    {
                        const parent = document.getParentFromPosition(line, offset);
                        if (parent instanceof Truth.Document)
                            return new ProgramInspectionResult(parent, statement);
                        const types = parent.declarations
                            .map(decl => decl.factor())
                            .reduce((spines, s) => spines.concat(s), [])
                            .map(spine => Truth.Type.construct(spine, this));
                        return new ProgramInspectionResult(types, statement, null);
                    }
                //
                case Truth.StatementRegion.pattern:
                    {
                        // TODO: This should not be returning a PatternLiteral,
                        // but rather a fully constructed IPattern object. This
                        // code is only here as a shim.
                        const patternTypes = [];
                        return new ProgramInspectionResult(patternTypes, statement);
                    }
                // Return all the types related to the specified declaration.
                case Truth.StatementRegion.declaration:
                    {
                        const decl = statement.getDeclaration(offset);
                        if (!decl)
                            throw Truth.Exception.unknownState();
                        const types = decl
                            .factor()
                            .map(spine => Truth.Type.construct(spine, this));
                        return new ProgramInspectionResult(types, statement, decl);
                    }
                // 
                case Truth.StatementRegion.annotation:
                    {
                        const anno = statement.getAnnotation(offset);
                        if (!anno)
                            throw Truth.Exception.unknownState();
                        const spine = statement.declarations[0].factor()[0];
                        const type = Truth.Type.construct(spine, this);
                        const annoText = anno.boundary.subject.toString();
                        const base = type.bases.find(b => b.name === annoText);
                        const bases = base ? [base] : null;
                        return new ProgramInspectionResult(bases, statement, anno);
                    }
            }
            return new ProgramInspectionResult(null, statement, null);
        }
        /**
         * Performs a full verification of all documents loaded into the program.
         * This Program's .faults field is populated with any faults generated as
         * a result of the verification. If no documents loaded into this program
         * has been edited since the last verification, verification is not re-attempted.
         *
         * @returns An entrypoint into performing analysis of the Types that
         * have been defined in this program.
         */
        verify() {
            for (const doc of this.documents.each())
                for (const { statement } of doc.eachDescendant())
                    this.verifyAssociatedDeclarations(statement);
            return this.finalizeVerification();
        }
        /**
         * Performs verification on the parts of the document that have
         * not been verified since the last call to this method. Once this
         * method has completed, any detected faults will be available
         * by using the methods located in the `.faults` property of this
         * instance.
         *
         * @returns A boolean value that indicates whether verification
         * completed without detecting any faults in this Program.
         */
        reverify() {
            for (const doc of this.unverifiedDocuments)
                for (const { statement } of doc.eachDescendant())
                    this.verifyAssociatedDeclarations(statement);
            for (const smt of this.unverifiedStatements)
                this.verifyAssociatedDeclarations(smt);
            return this.finalizeVerification();
        }
        /** */
        verifyAssociatedDeclarations(statement) {
            if (!statement.isDisposed)
                for (const decl of statement.declarations)
                    decl.factor().map(spine => Truth.Type.construct(spine, this));
        }
        /** */
        finalizeVerification() {
            this.faults.refresh();
            this.unverifiedDocuments.length = 0;
            this.unverifiedStatements.length = 0;
            return this.faults.count === 0;
        }
    }
    Truth.Program = Program;
    /**
     * Gets information about the object that holds
     * the specified Program instance.
     */
    function getHolderInfo(program) {
        const ih = program.instanceHolder;
        return {
            uri: (ih ? ih.uri : null),
            scope: (ih ? ih.scope : program)
        };
    }
    /**
     * @internal
     * Stores information about the attachment
     * of a cause callback function.
     */
    class CauseAttachment {
        /** */
        constructor(uri, callback, scope) {
            this.uri = uri;
            this.callback = callback;
            this.scope = scope;
        }
    }
    /**
     * Stores the details about a precise location in a Document.
     */
    class ProgramInspectionResult {
        /** @internal */
        constructor(
        /**
         * Stores the compilation object that most closely represents
         * what was found at the specified location. Stores null in the
         * case when the specified location contains an object that
         * has been marked as cruft (the statement and span fields
         * are still populated in this case).
         */
        foundObject, 
        /**
         * Stores the Statement found at the specified location.
         */
        statement, 
        /**
         * Stores the Span found at the specified location, or
         * null in the case when no Span was found, such as if
         * the specified location is whitespace or a comment.
         */
        span = null) {
            this.foundObject = foundObject;
            this.statement = statement;
            this.span = span;
            if (Array.isArray(foundObject) && foundObject.length === 0)
                this.foundObject = null;
        }
    }
    Truth.ProgramInspectionResult = ProgramInspectionResult;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A cache that stores agent build function loaded by a single program instance.
     */
    class AgentCache {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.agentFunctionParameters = new Map();
            /**
             * Stores the number of lines that are introduced by the script
             * engine when a code block is wrapped in a new Function()
             * block, which is then toString()'d. This is used in order to calculate
             * source map line offsets (which varies by engine).
             */
            this.sourceMapLineOffset = (() => {
                // eslint-disable-next-line no-new-func
                const testFn = new Function("a", "b", "c", ";");
                const lineCount = testFn.toString().split("\n").length;
                return lineCount - 2;
            })();
            /**
             * Stores a map whose keys are agent URIs, and whose values
             * are a set of Statement instances that reference the agent,
             * or, in the case when the agent is added to the program
             * through another means (such as programmatically),
             * a reference to the program is stored instead.
             *
             * Technically an agent should be attached in only one place
             * in the program, however, this may not always be the case,
             * and the system needs to be able to handle the case when
             * it isn't.
             *
             * This array is used to reference count / garbage collect
             * the attached agents.
             */
            this.cache = new Map();
            program.on(Truth.CauseUriReferenceAdd, data => {
                if (data.uri.ext === ".truth.js" /* js */)
                    this.attachAgent(data.uri, data.statement);
            });
            program.on(Truth.CauseUriReferenceRemove, data => {
                if (data.uri.ext === ".truth.js" /* js */)
                    this.detachAgent(data.uri, data.statement);
            });
        }
        /** */
        async attachAgent(uri, statement) {
            const uriText = uri.toStoreString();
            const existingCacheSet = this.cache.get(uriText);
            const reference = statement || this.program;
            if (existingCacheSet) {
                existingCacheSet.add(reference);
                return;
            }
            const scope = statement instanceof Truth.Statement ?
                statement.document :
                this.program;
            const sourceRaw = await Truth.UriReader.tryRead(uri);
            if (sourceRaw instanceof Error)
                return sourceRaw;
            const source = this.maybeAdjustSourceMap(uri, sourceRaw);
            const patchedProgram = Truth.Misc.patch(this.program, {
                instanceHolder: { uri, scope }
            });
            const params = [
                "program",
                "Truth",
                "require",
                ...this.agentFunctionParameters.keys(),
                source
            ];
            const args = [
                patchedProgram,
                Truth,
                AgentCache.hijackedRequireFn,
                ...this.agentFunctionParameters.values()
            ];
            try {
                const fn = Object.freeze(Function.apply(Function, params));
                await fn.apply(fn, args);
            }
            catch (e) {
                this.reportUserLandError(e);
                return;
            }
            this.program.cause(new Truth.CauseAgentAttach(uri, scope));
            const set = new Set([reference]);
            this.cache.set(uriText, set);
        }
        /** */
        detachAgent(uri, statement) {
            const uriText = uri.toStoreString();
            const existingCacheSet = this.cache.get(uriText);
            if (!existingCacheSet)
                return;
            existingCacheSet.delete(statement || this.program);
            if (existingCacheSet.size === 0) {
                this.cache.delete(uriText);
                this.program.cause(new Truth.CauseAgentDetach(uri));
            }
        }
        /**
         * @internal
         * (Called by Program)
         */
        augment(name, value) {
            if (this.agentFunctionParameters.has(name))
                throw Truth.Exception.causeParameterNameInUse(name);
            this.agentFunctionParameters.set(name, value);
        }
        /**
         * Adjusts the content of the sourcemap in the specified source code
         * file, to account for the discrepencies introduced by wrapping JavaScript
         * source code in a new Function() constructor.
         */
        maybeAdjustSourceMap(sourceUri, sourceCode) {
            // We can't do any of this source map mutation without Node.JS
            // access right now. Maybe this will change in the future.
            if (typeof require !== "function")
                return sourceCode;
            const lastLineStart = (() => {
                for (let i = sourceCode.length; i-- > 1;)
                    if (sourceCode[i - 1] === "\n")
                        return i;
                return -1;
            })();
            if (lastLineStart < 0)
                return sourceCode;
            const sourceMapUrl = ["//", "#", " source", "MappingURL="].join("");
            if (sourceCode.substr(lastLineStart, sourceMapUrl.length) !== sourceMapUrl)
                return sourceCode;
            const startPos = lastLineStart + sourceMapUrl.length;
            const ending = ";base64,";
            const endPos = sourceCode.indexOf(ending, startPos) + ending.length;
            // Unsupported source map format.
            if (endPos < ending.length)
                return sourceCode;
            const sourceMapRaw = this.fromBase64(sourceCode.slice(endPos));
            // There's probably some error in the source map
            if (!sourceMapRaw)
                return sourceCode;
            // The source map isn't parsing as a JSON object ... probably broken somehow
            const sourceMap = Truth.Misc.tryParseJson(sourceMapRaw);
            if (!sourceMap)
                return sourceCode;
            // Unsupported source map version
            if (typeof sourceMap.mappings !== "string")
                return sourceCode;
            // Placing a ; in the "mappings" property of the source map object
            // shifts the lines down by 1. It needs to be + 1, because we wrap
            // the code in our own setTimeout() block.
            const prefix = ";".repeat(this.sourceMapLineOffset + 1);
            const pathModule = require("path");
            const basePath = sourceUri.toStoreString(true);
            sourceMap.mappings = prefix + sourceMap.mappings;
            if (sourceMap.sources instanceof Array)
                sourceMap.sources = sourceMap.sources.map(s => pathModule.join(basePath, s));
            const newSourceMap = this.toBase64(JSON.stringify(sourceMap));
            const newSourceCode = sourceCode.slice(0, lastLineStart);
            // The source code is wrapped in a setTimeout in order
            // to give any attached debuggers a chance to connect.
            const varName = "$$__RESOLVE_FUNCTION__$$";
            const newSourceCodeDelayed = `return new Promise(${varName} => setTimeout(() => {\n` +
                newSourceCode +
                `; ${varName}(); }, 1))\n`;
            const newPrefix = sourceCode.slice(lastLineStart, endPos);
            return newSourceCodeDelayed + newPrefix + newSourceMap;
        }
        /** */
        reportUserLandError(e) {
            // NOTE: This should probably be reporting the error
            // somewhere where it's visible.
            debugger;
            throw e;
        }
        /** */
        toBase64(plain) {
            return typeof btoa === "function" ?
                btoa(plain) :
                Buffer.from(plain, "ascii").toString("base64");
        }
        /** */
        fromBase64(encoded) {
            return typeof atob === "function" ?
                atob(encoded) :
                Buffer.from(encoded, "base64").toString("ascii");
        }
    }
    /**
     * The require() function is not available within the context of an
     * agent for numerous (and non-obvious) reasons. This function
     * is fed into all agent functions to prevent any otherwise available
     * require() function from being accessed.
     */
    AgentCache.hijackedRequireFn = Object.freeze((specifier) => {
        throw new Error("The require() function is not available in this context. " +
            "Multi-file agents should be bundled with a bundler " +
            "such as RollupJS.");
    });
    Truth.AgentCache = AgentCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Abstract base class for all Causes defined both within
     * the compiler core, and in user code.
     */
    class Cause {
        constructor() {
            /**
             * Stores the return type of the Cause, if any. In a cause callback function,
             * this property exists as an array of objects that have been returned
             * from other cause aids.
             */
            this.returns = null;
        }
    }
    Truth.Cause = Cause;
    // 
    // Causes
    // 
    /** */
    class CauseAgentAttach extends Cause {
        constructor(
        /**
         * Stores the URI from where the agent was loaded.
         */
        uri, 
        /**
         * Stores an object that represents the scope of where the agent
         * applies.
         *
         * If the value is `instanceof Program`, this indicates that
         * the agent's causes are scoped to a particular program (which
         * is effectively "unscoped").
         *
         * If the value is `instanceof Document`, this indicates that
         * the agent's causes are scoped to the causes that can
         * originate from a single document.
         *
         * (Not implemented). If the value is `instanceof Type`, this
         * indicates that the agent's causes are scoped to the causes
         * that can originate from a single type.
         */
        scope) {
            super();
            this.uri = uri;
            this.scope = scope;
        }
    }
    Truth.CauseAgentAttach = CauseAgentAttach;
    /** */
    class CauseAgentDetach extends Cause {
        constructor(uri) {
            super();
            this.uri = uri;
        }
    }
    Truth.CauseAgentDetach = CauseAgentDetach;
    /** A cause that runs immediately after a document has been created. */
    class CauseDocumentCreate extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseDocumentCreate = CauseDocumentCreate;
    /** A cause that runs immediately before a document is removed from the program. */
    class CauseDocumentDelete extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseDocumentDelete = CauseDocumentDelete;
    /** A cause that runs when a document's file name changes. */
    class CauseDocumentUriChange extends Cause {
        constructor(document, newUri) {
            super();
            this.document = document;
            this.newUri = newUri;
        }
    }
    Truth.CauseDocumentUriChange = CauseDocumentUriChange;
    /** Abstract cause class for the resolution causes */
    class CauseResolve extends Cause {
        constructor(program, spine) {
            super();
            this.program = program;
            this.spine = spine;
        }
    }
    Truth.CauseResolve = CauseResolve;
    /** A cause that runs before the compiler is about to resolve a term. */
    class CauseBeforeResolve extends CauseResolve {
    }
    Truth.CauseBeforeResolve = CauseBeforeResolve;
    /** A cause that runs after the compiler has resolved a term. */
    class CauseAfterResolve extends CauseResolve {
    }
    Truth.CauseAfterResolve = CauseAfterResolve;
    /** A cause that runs when the compiler is unable to resolve a term. */
    class CauseNotResolved extends CauseResolve {
    }
    Truth.CauseNotResolved = CauseNotResolved;
    /** */
    class CauseInvalidate extends Cause {
        constructor(
        /**
         * A reference to the Document object in which the Invalidation occured.
         */
        document, 
        /**
         * An array of statements whose descendants should be invalidated.
         * If the array is empty, the entire document should be invalidated.
         */
        parents, 
        /**
         * An array of indexes whose length is the same as the parents field,
         * that represents the index of each parent within the document.
         */
        indexes) {
            super();
            this.document = document;
            this.parents = parents;
            this.indexes = indexes;
        }
    }
    Truth.CauseInvalidate = CauseInvalidate;
    /** */
    class CauseRevalidate extends Cause {
        constructor(
        /**
         * A reference to the Document object in which the Revalidation will occur.
         */
        document, 
        /**
         * An array of statements whose descendants should be revalidated.
         */
        parents, 
        /**
         * An array of indexes whose length is the same as the parents field,
         * that represents the index of each parent within the document.
         */
        indexes) {
            super();
            this.document = document;
            this.parents = parents;
            this.indexes = indexes;
        }
    }
    Truth.CauseRevalidate = CauseRevalidate;
    /** A cause that runs when a document edit transaction has completed. */
    class CauseEditComplete extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseEditComplete = CauseEditComplete;
    /** */
    class CauseUriReference extends Cause {
        constructor(
        /**
         * A reference to the Statement instance that references
         * this URI, or null in the case when the program itself
         * references the URI by another means.
         */
        statement, uri) {
            super();
            this.statement = statement;
            this.uri = uri;
        }
    }
    Truth.CauseUriReference = CauseUriReference;
    /**
     * A hook that runs when a URI reference is added to a document,
     * but before it resolves to a resource.
     */
    class CauseUriReferenceAdd extends CauseUriReference {
    }
    Truth.CauseUriReferenceAdd = CauseUriReferenceAdd;
    /**
     * A hook that runs when a URI reference is removed from a document.
     */
    class CauseUriReferenceRemove extends CauseUriReference {
    }
    Truth.CauseUriReferenceRemove = CauseUriReferenceRemove;
    /**
     * A hook that runs when the set of faults that are detected
     * within the document have changed.
     */
    class CauseFaultChange extends Cause {
        constructor(faultsAdded, faultsRemoved) {
            super();
            this.faultsAdded = faultsAdded;
            this.faultsRemoved = faultsRemoved;
        }
    }
    Truth.CauseFaultChange = CauseFaultChange;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** @internal */
    class Exception {
        /** */
        static objectDirty() {
            return error(`
				Cannot call this method or access this property,
				because the document has changed since it
				was created.`);
        }
        /** */
        static invalidArgument() {
            return error("Invalid argument.");
        }
        /** */
        static passedArrayCannotBeEmpty(paramName) {
            return error("Array cannot be empty for parameter: " + paramName);
        }
        /** */
        static unknownState() {
            return error("An unknown state has been reached in the program.");
        }
        /** */
        static invalidCall() {
            return error("Cannot call this method given the current state of the program.");
        }
        /** */
        static notImplemented() {
            return error("Not implemented.");
        }
        /** */
        static agentNotRead() {
            return error(`
				Cannot instantiate an agent of this type,
				added. See agents.add.`);
        }
        /** */
        static agentMissing(rawUri) {
            return error(`Could not load an agent from the URI ${rawUri}`);
        }
        /** */
        static agentImportError(agentUri, errorText) {
            return error(`
				An error occured while trying to evaluate the agent at "${agentUri}".
				The error message returned was: ${errorText}`);
        }
        /** */
        static agentInvalid(rawUri) {
            return error(`
				The code file at ${rawUri} does not export a function. Consider looking
				at the documention and examples for the proper way to stucture an
				agent code file.`);
        }
        /** */
        static noRemoteAgents() {
            return error(`
				Agents cannot be loaded from remote URIs in this context.
				(Most likely, this code is running in Node.js where the loading
				of remote code is a security risk).`);
        }
        /** */
        static causeParameterNameInUse(paramName) {
            return error(`
				Cannot use the name "${paramName}" as a parameter
				name because it's already in use.`);
        }
        /** */
        static doubleTransaction() {
            return error("Cannot start a new transaction while another is executing.");
        }
        /** */
        static invalidUriRetraction() {
            return error("URI contains too few path segments to perform this retraction.");
        }
        /** */
        static invalidUri(rawUri) {
            return error("Invalid URI" + (typeof rawUri === "string" ? ": " + rawUri : ""));
        }
        /** */
        static uriNotSupported() {
            return error("URIs of this type are not supported.");
        }
        /** */
        static cannotMakeAbsolute() {
            return error(`
				Cannot make this URI absolute because no 
				process or window object could be found`);
        }
        /** */
        static absoluteUriExpected() {
            return error(`This method expects an absolute URI to be specified.`);
        }
        /** */
        static mustSpecifyVia() {
            return error(`
				Must specify the "via" argument because the parsed URI 
				was found to be relative`);
        }
        /** */
        static viaCannotBeRelative() {
            return error(`URI instances specified in the "via" argument must not be relative`);
        }
        /** */
        static invalidTypePath() {
            return error(`
				One or more of the types in the specified type path are invalid,
				because they contain either leading or trailing whitespace, or
				is an empty string.`);
        }
        /** */
        static invalidExtension(requiredExtension) {
            return error(`
				This method requires URIs that have the 
				".${requiredExtension}" extension.`);
        }
        /** */
        static invalidDocumentReference() {
            return error(`
				This document cannot be added as a dependency
				of the target document because it's storage location
				(memory or disk) differs from the that of the target.`);
        }
        /** */
        static nonEmptyDocument() {
            return error("Cannot call this method on a non-empty document.");
        }
        /** */
        static invalidWhileInEditTransaction() {
            return error(`Cannot call this method, or run this hook while an edit
				transaction is underway.`);
        }
        /** */
        static uncachableDocument() {
            return error(`
				Cannot cache this document because it was not loaded from a file.`);
        }
        /** */
        static documentAlreadyLoaded() {
            return error(`
				A document with this URI has already been created.
				Use Document.fromUri() instead.`);
        }
        /** */
        static documentNotLoaded() {
            return error("This document has not been loaded into the current program.");
        }
        /** */
        static cannotRefresh() {
            return error(`
				This resource cannot be reloaded because it only exists in memory.`);
        }
        /** */
        static offsetRequired() {
            return error(`
				Offset argument is required because the a whitespace-only
				statement was passed.`);
        }
        /** */
        static unsupportedPlatform() {
            return error("This code appears to be operating in an unsupported platform.");
        }
    }
    Truth.Exception = Exception;
    /**
     * Generates a proper error object from the specified message.
     */
    function error(msg) {
        return new Error(msg.trim().replace(/\s\s+/g, " "));
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Universal class for handling URIs that exist within a Truth document.
     */
    class Uri {
        /**
         * @internal
         */
        constructor(...uriLike) {
            /**
             *
             */
            this.protocol = Truth.UriProtocol.file;
            /**
             * Stores the name of the file referenced in the URI, including any extension.
             */
            this.file = "";
            /**
             * Stores the extension of the file referenced in the URI, if any.
             */
            this.ext = ".truth" /* truth */;
            /**
             * Stores the store-side components of this URI.
             * Excludes the file name.
             */
            this.stores = [];
            /**
             * Stores the type-side components of this URI.
             */
            this.types = [];
            /**
             * Stores the number of retractions that are defined in this
             * URI, in the case when the URI is relative.
             */
            this.retractionCount = 0;
            /**
             * Stores whether the URI is a relative path.
             */
            this.isRelative = false;
            for (const uriProps of uriLike)
                Object.assign(this, uriProps);
            Object.freeze(this.stores);
            Object.freeze(this.types);
            Object.freeze(this);
        }
        /**
         * Constructs a new Uri instance that points to a (possibly nested)
         * type defined in the specified document.
         */
        static from(document, ...types) {
            return document.sourceUri.extendType(types);
        }
        /**
         * Attempts to parse the specified string or Uri into
         * another Uri instance. If the parameter is already
         * a Uri, it is returned without further processing.
         */
        static maybeParse(value) {
            if (value instanceof Uri)
                return value;
            if (!value)
                return null;
            return this.tryParse(value);
        }
        /**
         * Attempts to parse the specified string into a Uri instance.
         * Returns null in the case when the Uri could not be parsed.
         */
        static tryParse(uri, via) {
            if (!uri)
                return null;
            const uriLike = typeof uri === "string" ?
                Truth.UriParser.parse(uri) :
                uri;
            if (uriLike === null)
                return null;
            const outUri = (() => {
                if (!(uriLike.isRelative && via))
                    return new Uri(uriLike);
                const viaParsed = typeof via === "string" ?
                    Truth.UriParser.parse(via) :
                    via;
                if (viaParsed === null)
                    throw Truth.Exception.invalidUri();
                if (viaParsed.isRelative)
                    throw Truth.Exception.viaCannotBeRelative();
                const uriStores = Truth.Not.undefined(uriLike.stores);
                const viaStores = Truth.Not.undefined(viaParsed.stores);
                const retract = uriLike.retractionCount || 0;
                if (viaStores.length < retract)
                    throw Truth.Exception.invalidUri();
                return new Uri(uriLike, {
                    protocol: viaParsed.protocol,
                    stores: retract > 0 ?
                        viaStores.slice(0, -retract).concat(uriStores) :
                        viaStores.concat(uriStores),
                    retractionCount: -1,
                    isRelative: false
                });
            })();
            // Return null when an extension was found that isn't
            // unknown (also when no extension was found). This
            // is in order to reduce the number of terms that have
            // a special meaning in a truth document.
            if (outUri.ext === "" /* unknown */)
                return null;
            // You can't have a type path that points to a 
            // non-truth file, so null is returned in this case.
            if (outUri.types.length > 0)
                if (outUri.ext !== ".truth" /* truth */)
                    return null;
            return outUri;
        }
        /**
         * Copies the specified URI or Spine into another URI instance.
         */
        static clone(value) {
            if (value instanceof Uri)
                return value;
            const srcUri = value.document.sourceUri;
            const typeSegments = value.vertebrae.map(vert => new Truth.UriComponent(vert.toString(true)));
            return new Uri(srcUri, { types: typeSegments });
        }
        /**
         * @internal
         * Creates an internal URI used to uniquely identify a
         * document that exists only in memory.
         */
        static createInternal() {
            const max = Number.MAX_SAFE_INTEGER;
            const ext = ".truth" /* truth */;
            return new Uri({
                protocol: Truth.UriProtocol.internal,
                file: Math.floor(Math.random() * max).toString(36) + ext,
                ext
            });
        }
        /**
         * @internal
         * Debugging utility. Do not use.
         */
        get value() { return this.toTypeString(); }
        /**
         * Creates a new Uri whose path of types is
         * retracted by the specified number of levels
         * of depth.
         */
        retractType(factor) {
            const types = this.types.slice(0, -factor);
            return new Uri(this, { types });
        }
        /**
         * Creates a new Uri, whose path of types is
         * retracted to the specified level of depth.
         */
        retractTypeTo(depth) {
            return depth < this.types.length ?
                this.retractType(this.types.length - depth) :
                this;
        }
        /**
         * Creates a new Uri whose path of stores is
         * retracted by the specified number of levels
         * of depth.
         */
        retractStore(factor) {
            const folders = this.stores.slice(0, -factor);
            return new Uri(this, { stores: folders });
        }
        /**
         * Creates a new Uri, whose path of folders is
         * retracted to the specified level of depth.
         */
        retractStoreTo(depth) {
            return depth < this.stores.length ?
                this.retractType(this.stores.length - depth) :
                this;
        }
        /**
         *
         */
        extendType(additionalTypeNames) {
            if (!additionalTypeNames)
                return new Uri(this);
            const components = typeof additionalTypeNames === "string" ?
                [new Truth.UriComponent(additionalTypeNames)] :
                additionalTypeNames.map(t => new Truth.UriComponent(t));
            return new Uri(this, { types: this.types.concat(components) });
        }
        /**
         *
         */
        extendStore(additionalStores) {
            if (!additionalStores)
                return new Uri(this);
            const stores = typeof additionalStores === "string" ?
                [new Truth.UriComponent(additionalStores)] :
                additionalStores.map(s => new Truth.UriComponent(s));
            return new Uri(this, { stores });
        }
        /**
         * @returns A boolean value that indicates whether this
         * Uri is structurally equivalent to the specified Uri.
         */
        equals(other, compareTypes) {
            if (this === other)
                return true;
            if (compareTypes) {
                if (this.types.length !== other.types.length)
                    return false;
                if (this.types.some((t, i) => t.value !== other.types[i].value))
                    return false;
            }
            if (this.protocol !== other.protocol)
                return false;
            if (this.stores.some((s, i) => s.value !== other.stores[i].value))
                return false;
            return true;
        }
        /**
         *
         */
        toAbsolute() {
            if (!this.isRelative)
                return this;
            const via = (() => {
                try {
                    if (typeof process === "object")
                        if (typeof process.cwd === "function")
                            return process.cwd() || null;
                    if (typeof window !== "undefined")
                        if (typeof window.location !== "undefined")
                            if (typeof window.location.href === "string")
                                return window.location.href || null;
                }
                catch (e) { }
                return null;
            })();
            if (via === null)
                throw Truth.Exception.cannotMakeAbsolute();
            return Uri.tryParse(this, via);
        }
        /**
         * @returns The path of types contained by this URI,
         * concatenated into a single string.
         */
        toTypeString() {
            return this.types.map(t => t.toStringEncoded())
                .join("/" /* componentSeparator */);
        }
        /**
         * @returns The path of stores contained by this URI,
         * concatenated into a single string.
         */
        toStoreString(omitFile = false) {
            const thisAbsolute = Truth.Not.null(this.isRelative ? this.toAbsolute() : this);
            // In the case when the specified protocol is "file",
            // the string should start with a / so that we get
            // and output that looks like /Users/person/....
            const proto = thisAbsolute.protocol === Truth.UriProtocol.file ?
                "/" :
                thisAbsolute.protocol + "//";
            const isWeb = thisAbsolute.protocol === Truth.UriProtocol.http ||
                thisAbsolute.protocol === Truth.UriProtocol.https;
            const components = thisAbsolute.stores
                .concat(omitFile ? [] : [new Truth.UriComponent(this.file)])
                .map((t, i) => {
                return i === 0 && isWeb ?
                    t.toStringHost() :
                    t.toStringEncoded();
            })
                .join("/" /* componentSeparator */);
            return proto + components;
        }
        /**
         *
         */
        toString() {
            let out = this.toStoreString();
            if (this.types.length > 0)
                out += "//" /* typeSeparator */ + this.toTypeString();
            return out;
        }
    }
    Truth.Uri = Uri;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * An enumeration that lists all availble protocols
     * supported by the system. The list can be enumerated
     * via Uri.eachProtocol()
     */
    let UriProtocol;
    (function (UriProtocol) {
        UriProtocol["none"] = "";
        UriProtocol["unknown"] = "?";
        UriProtocol["file"] = "file:";
        UriProtocol["https"] = "https:";
        UriProtocol["http"] = "http:";
        UriProtocol["internal"] = "internal:";
    })(UriProtocol = Truth.UriProtocol || (Truth.UriProtocol = {}));
    (function (UriProtocol) {
        /**
         * @returns A UriProtocol member from the specified string.
         */
        function resolve(value) {
            const vals = Object.values(UriProtocol);
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        UriProtocol.resolve = resolve;
    })(UriProtocol = Truth.UriProtocol || (Truth.UriProtocol = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class UriParser {
        /**
         *
         */
        static parse(raw) {
            let isRelative = false;
            let retractionCount = 0;
            let protocol = "";
            const parser = new Truth.Parser(raw);
            /**
             * Reads ./
             */
            function maybeReadCurrent() {
                const mark = parser.position;
                if (parser.read("." /* current */))
                    if (parser.read("/" /* componentSeparator */))
                        return true;
                parser.position = mark;
                return false;
            }
            /**
             * Reads ../../../
             * @returns True if at least one retraction was read, otherwise false.
             */
            function readRetractions() {
                const token = ".." /* retract */ + "/" /* componentSeparator */;
                while (parser.more()) {
                    if (!parser.read(token))
                        break;
                    retractionCount++;
                }
                return retractionCount > 0;
            }
            /**
             * Reads proto:
             * Assigns the local protocol variable if necessary.
             * @returns Trus if a protocol was found, otherwise false.
             */
            function maybeReadProtocol() {
                const mark = parser.position;
                let rawProto = "";
                if (parser.read("//" /* protocolRelative */)) {
                    protocol = Truth.UriProtocol.unknown;
                    return true;
                }
                const cancel = () => {
                    parser.position = mark;
                    return false;
                };
                while (parser.more()) {
                    const char = parser.readGrapheme();
                    if (isUpperAscii(char)) {
                        rawProto += String.fromCharCode(char.charCodeAt(0) + 32);
                        continue;
                    }
                    if (isLowerAscii(char)) {
                        rawProto += char;
                        continue;
                    }
                    if (char === ":") {
                        rawProto += ":";
                        break;
                    }
                    return cancel();
                }
                // Protocols need to have the // suffix after them ... for now.
                if (!parser.read("//"))
                    return cancel();
                return (protocol = rawProto) !== "";
            }
            /**
             * Reads the store side or the type side of a URI.
             */
            function readComponents(side) {
                const mark = parser.position;
                const out = [];
                const cancel = () => {
                    parser.position = mark;
                    return null;
                };
                while (parser.more()) {
                    const comp = readComponent();
                    if (comp === null)
                        break;
                    // URIs cannot have type-side-only components on their store side
                    if (side === "store")
                        if (comp.index >= 0 || comp.isPattern)
                            return cancel();
                    out.push(comp);
                    if (side === "store" && parser.read("//" /* typeSeparator */))
                        break;
                    if (parser.read("/" /* componentSeparator */))
                        continue;
                    break;
                }
                return out;
            }
            /**
             * Reads a single URI component.
             */
            function readComponent() {
                const mark = parser.position;
                const encChars = "._-~%".split("");
                const portChar = ":";
                let value = "";
                let port = "";
                let isParsingPort = false;
                const anonComp = maybeReadAnonymousComponent();
                if (anonComp)
                    return anonComp;
                const quit = () => {
                    parser.position = mark;
                    return null;
                };
                while (parser.more()) {
                    if (parser.peek("/" /* componentSeparator */))
                        break;
                    const g = parser.readGrapheme();
                    if (g === portChar) {
                        if (!isValidHostName(value) || !isValidIPv4Address(value))
                            return quit();
                        isParsingPort = true;
                        continue;
                    }
                    if (isParsingPort) {
                        if (!isDigit(g))
                            return quit();
                        port += g;
                        if (port.length > 5)
                            return quit();
                    }
                    else if (!encChars.includes(g) && !isUpperAscii(g) && !isLowerAscii(g) && !isDigit(g)) {
                        return quit();
                    }
                    else
                        value += g;
                }
                if (value === "")
                    return quit();
                return new Truth.UriComponent(port ? value + portChar + port : value);
            }
            /**
             *
             */
            function maybeReadAnonymousComponent() {
                const mark = parser.position;
                const cancel = () => {
                    parser.position = mark;
                    return null;
                };
                let anon = parser.read("[" /* indexerStart */);
                if (!anon)
                    return null;
                while (parser.more()) {
                    if (parser.read("]" /* indexerEnd */))
                        return anon.length > 0 ?
                            new Truth.UriComponent(anon + "]" /* indexerEnd */) :
                            cancel();
                    const g = parser.readGrapheme();
                    if (!isDigit(g))
                        break;
                    anon += g;
                }
                return cancel();
            }
            if (maybeReadCurrent() || readRetractions()) {
                isRelative = true;
            }
            else if (maybeReadProtocol()) {
                // Do nothing
            }
            else if (parser.read("/" /* componentSeparator */)) {
                protocol = Truth.UriProtocol.file;
            }
            else
                return null;
            const stores = readComponents("store");
            if (stores === null || stores.length === 0)
                return null;
            // URI ends with a /, this isn't a valid URI
            if (parser.readThenTerminal("/" /* componentSeparator */))
                return null;
            // URI ends with a //, this isn't a valid URI
            if (parser.readThenTerminal("//" /* typeSeparator */))
                return null;
            const types = readComponents("type");
            if (types === null)
                return null;
            if (types.length > 0) {
                // We should be done by now. 
                // If we're not, there's some garbage at the 
                // end of the URI, such as a forward slash.
                if (parser.more())
                    return null;
            }
            const file = stores[stores.length - 1].value;
            const ext = (() => {
                if (file.endsWith(".truth" /* truth */))
                    return ".truth" /* truth */;
                if (file.endsWith(".truth.js" /* js */))
                    return ".truth.js" /* js */;
                if (file.endsWith(".truth.wasm" /* wasm */))
                    return ".truth.wasm" /* wasm */;
                return "" /* unknown */;
            })();
            // If an extension was detected, the last component
            // from the end of the URI should be removed, because
            // "stores" does not include file names.
            if (ext !== "" /* unknown */)
                stores.pop();
            return {
                protocol: Truth.UriProtocol.resolve(protocol) || Truth.UriProtocol.unknown,
                file: ext ? file : "",
                ext,
                retractionCount,
                isRelative,
                stores: Object.freeze(stores),
                types: Object.freeze(types)
            };
        }
    }
    Truth.UriParser = UriParser;
    /** */
    function isUpperAscii(char) {
        const point = char.codePointAt(0) || 0;
        return point >= 65 && point <= 90;
    }
    /** */
    function isLowerAscii(char) {
        const point = char.codePointAt(0) || 0;
        return point >= 97 && point <= 122;
    }
    /** */
    function isDigit(char) {
        const point = char.codePointAt(0) || 0;
        return point >= 48 && point <= 57;
    }
    /** */
    function isValidIPv4Address(maybeIP) {
        if (!maybeIP)
            return false;
        const ipParts = maybeIP.split(".").filter(s => s);
        if (ipParts.length !== 4)
            return false;
        if (ipParts.some(s => !/^\d{1,3}$/.test(s)))
            return false;
        if (ipParts.some(s => parseInt(s, 10) > 255))
            return false;
        return true;
    }
    /** */
    function isValidHostName(maybeHostName) {
        if (!maybeHostName)
            return false;
        const hostParts = maybeHostName.split(".");
        if (hostParts.some(s => s.length === 0))
            return false;
        for (const hostPart of hostParts) {
            // NOTE: This is a make-shift host name validation
            // method. It should be replaced with something
            // that conforms to the relevant RFC specifications.
            const hostSegmentParts = hostPart.split(/-|--/);
            for (const hostSegmentPart of hostSegmentParts) {
                if (hostSegmentPart.length === 0)
                    return false;
                for (const cp of [...hostSegmentPart].map(s => s.codePointAt(0))) {
                    if (!cp || !(cp >= 48 && cp <= 57 ||
                        cp >= 65 && cp <= 90 ||
                        cp >= 97 && cp <= 122 ||
                        cp >= 128 && cp <= 165 ||
                        cp >= 255))
                        return false;
                }
            }
        }
        return true;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    const hashRegex = new RegExp("[a-f0-9]{" + Truth.Hash.length + "}", "i");
    /**
     * A class that represents a single component of a Uri.
     * Handled encoding and decoding of the underlying value.
     */
    class UriComponent {
        /** */
        constructor(raw) {
            /**
             * Stores a number that indicates a type index that this UriComponent,
             * refers to, used in the case when this UriComponent is referring to
             * an anonymous type.
             *
             * Stores -1 in the case when an index value is not relevant to this
             * UriComponent instance.
             */
            this.index = -1;
            /**
             * Stores the decoded text value of this UriComponent.
             * Stores a string version of the .index property in the case when
             * it is greater than -1.
             * This has the same value as the result of the .toString() method.
             */
            this.value = "";
            /**
             * Stores a pattern hash, in the case when this UriComponent
             * relates to a pattern. Stores an empty string in other cases.
             */
            this.hash = "";
            this.isRetract = raw === "..";
            this.isCurrent = raw === ".";
            this.hash = this.tryExtractHash(raw);
            if (raw.length > 2)
                if (raw[0] === "[" /* indexerStart */)
                    if (raw[raw.length - 1] === "]" /* indexerEnd */)
                        if (/\d+/.test(raw.slice(1, -1)))
                            this.index = +raw.slice(1, -1);
            this.value = this.index >= 0 ?
                this.index.toString() :
                unescape(raw);
            Object.freeze(this);
        }
        /** */
        tryExtractHash(text) {
            const delim = "/" /* main */;
            const delimEsc = escape(delim);
            const delimLen = text.startsWith(delim) ? delim.length :
                text.startsWith(delimEsc) ? delimEsc.length :
                    -1;
            const hashLen = Truth.Hash.length;
            if (delimLen < 0 || text.length < delimLen + hashLen + 1)
                return "";
            const hash = text.substr(delimLen, hashLen);
            if (hash.length !== hashLen || !hashRegex.test(hash))
                return "";
            return hash;
        }
        /** Stores whether this component represents a pattern. */
        get isPattern() { return this.hash !== ""; }
        /**
         * @returns The raw decoded text value of this UriComponent.
         */
        toString() {
            return this.value;
        }
        /**
         * @returns The URL encoded text value of this UriComponent.
         */
        toStringEncoded() {
            if (this.isPattern) {
                const de = "/" /* main */;
                return de + escape(this.value.slice(de.length));
            }
            if (this.index >= 0)
                return "[" /* indexerStart */ + this.index + "]" /* indexerEnd */;
            return escape(this.value);
        }
        /**
         * @returns The text value of this UriComponent, using an
         * encoding that is compatible with an RFC 3986 host name.
         */
        toStringHost() {
            return new URL("http://" + this.value).host;
        }
    }
    Truth.UriComponent = UriComponent;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    Truth.UriReader = new class UriReader {
        /**
         * Attempts to read the contents of the given URI.
         * If an error is generated while trying to read a file
         * at the specified location, the errors is returned.
         */
        async tryRead(uri) {
            if (uri.protocol === Truth.UriProtocol.file)
                return await readFile(uri.toStoreString());
            else if (uri.protocol === Truth.UriProtocol.http ||
                uri.protocol === Truth.UriProtocol.https)
                return await Truth.Fetch.exec(uri.toStoreString());
            throw Truth.Exception.notImplemented();
        }
    }();
    /** */
    const fileExists = (path) => new Promise((resolve, reject) => {
        Truth.Fs.module.exists(path, resolve);
    });
    /** */
    const readFile = (path, opts = "utf8") => new Promise(resolve => {
        Truth.Fs.module.readFile(path, opts, (error, data) => {
            resolve(error && error.errno ?
                error :
                data || "");
        });
    });
    /** */
    const writeFile = (path, data, opts = "utf8") => new Promise(resolve => {
        Truth.Fs.module.writeFile(path, data, opts, error => {
            resolve(error || null);
        });
    });
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * An enumeration that stores the escape sequences
     * that only match a single kind of character. "Sign" in
     * this case refers to the fact that these are escape
     * sequences that refer to another character.
     */
    let RegexSyntaxSign;
    (function (RegexSyntaxSign) {
        RegexSyntaxSign["tab"] = "\\t";
        RegexSyntaxSign["lineFeed"] = "\\n";
        RegexSyntaxSign["carriageReturn"] = "\\r";
        RegexSyntaxSign["escapedFinalizer"] = "\\/";
        RegexSyntaxSign["backslash"] = "\\\\";
    })(RegexSyntaxSign = Truth.RegexSyntaxSign || (Truth.RegexSyntaxSign = {}));
    (function (RegexSyntaxSign) {
        /**
         * @returns A RegexSyntaxSign member from the
         * specified sign literal (ex: "\t") or raw signable
         * character (ex: "	").
         */
        function resolve(value) {
            if (value.length < 1 || value.length > 2)
                return null;
            const vals = Object.values(RegexSyntaxSign);
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        RegexSyntaxSign.resolve = resolve;
        /** */
        function unescape(value) {
            switch (value) {
                case RegexSyntaxSign.tab: return String.fromCodePoint(9);
                case RegexSyntaxSign.lineFeed: return String.fromCodePoint(10);
                case RegexSyntaxSign.carriageReturn: return String.fromCodePoint(13);
                case RegexSyntaxSign.escapedFinalizer: return String.fromCodePoint(47);
                case RegexSyntaxSign.backslash: return String.fromCodePoint(92);
            }
            return "";
        }
        RegexSyntaxSign.unescape = unescape;
    })(RegexSyntaxSign = Truth.RegexSyntaxSign || (Truth.RegexSyntaxSign = {}));
    /**
     * An enumeration that stores the escape sequences
     * that can match more than one kind of character.
     */
    let RegexSyntaxKnownSet;
    (function (RegexSyntaxKnownSet) {
        RegexSyntaxKnownSet["digit"] = "\\d";
        RegexSyntaxKnownSet["digitNon"] = "\\D";
        RegexSyntaxKnownSet["alphanumeric"] = "\\w";
        RegexSyntaxKnownSet["alphanumericNon"] = "\\W";
        RegexSyntaxKnownSet["whitespace"] = "\\s";
        RegexSyntaxKnownSet["whitespaceNon"] = "\\S";
        RegexSyntaxKnownSet["wild"] = ".";
    })(RegexSyntaxKnownSet = Truth.RegexSyntaxKnownSet || (Truth.RegexSyntaxKnownSet = {}));
    (function (RegexSyntaxKnownSet) {
        const vals = Object.values(RegexSyntaxKnownSet);
        function resolve(value) {
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        RegexSyntaxKnownSet.resolve = resolve;
    })(RegexSyntaxKnownSet = Truth.RegexSyntaxKnownSet || (Truth.RegexSyntaxKnownSet = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages the diagnostics that have been
     * reported for the current state of the program.
     */
    class FaultService {
        /** */
        constructor(program) {
            // Listen for invalidations and clear out any faults
            // that correspond to objects that don't exist in the
            // document anymore. 
            this.program = program;
            /** */
            this.inEditTransaction = false;
            /**
             * Stores the faults that are presented to external consumer
             * of the fault service when they use the accessor methods.
             */
            this.visibleFrame = new FaultFrame();
            /**
             * Stores the faults that have been built up during an edit transaction.
             * These faults are copied to the `visibleFrame` when the edit
             * transaction completes.
             */
            this.bufferFrame = new FaultFrame();
            /**
             * Stores the faults that were reported asynchronously, and therefore
             * are not bound to any edit transaction.
             */
            this.asyncFrame = new FaultFrame();
            program.on(Truth.CauseInvalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        for (const { statement } of smt.document.eachDescendant(smt, true))
                            this.removeStatementFaults(statement);
                }
                else
                    for (const { statement } of data.document.eachDescendant())
                        this.removeStatementFaults(statement);
                this.inEditTransaction = true;
            });
            program.on(Truth.CauseEditComplete, () => {
                this.inEditTransaction = false;
                this.refresh();
            });
        }
        /**
         * Removes all faults associated with the specified statement.
         */
        removeStatementFaults(statement) {
            this.bufferFrame.removeSource(statement);
            for (const span of statement.allSpans)
                this.bufferFrame.removeSource(span);
            for (const infixSpan of statement.infixSpans)
                this.bufferFrame.removeSource(infixSpan);
        }
        /**
         * Enumerates through the unrectified faults retained
         * by this FaultService.
         */
        *each() {
            const faultsSorted = Array.from(this.asyncFrame.faults.values())
                .concat(Array.from(this.visibleFrame.faults.values()))
                .map(faultMap => Array.from(faultMap.values()))
                .reduce((a, b) => a.concat(b), [])
                .sort((a, b) => a.line - b.line);
            for (const fault of faultsSorted)
                yield fault;
        }
        /**
         * Gets a number representing the number of
         * unrectified faults retained by this FaultService.
         */
        get count() {
            return this.visibleFrame.faults.size;
        }
        /**
         * Reports a fault. If a similar Fault on the same area
         * of the document hasn't been reported, the method
         * runs the FaultReported hook.
         */
        report(fault) {
            this.bufferFrame.addFault(fault);
        }
        /**
         * Reports a fault outside the context of an edit transaction.
         * This method is to be used for faults that are reported in
         * asynchronous callbacks, such as network errors.
         */
        reportAsync(fault) {
            this.bufferFrame.addFault(fault);
            if (!this.inEditTransaction)
                this.refresh();
        }
        /**
         * @returns A boolean value indicating whether this
         * FaultService retains a fault that is similar to the specified
         * fault (meaning that it has the same code and source).
         */
        has(similarFault) {
            for (const retainedFault of this.each())
                if (retainedFault.type.code === similarFault.type.code)
                    if (retainedFault.source === similarFault.source)
                        return true;
            return false;
        }
        /**
         * @returns An array of Fault objects that have been reported
         * at the specified source. If the source has no faults, an empty
         * array is returned.
         */
        check(source) {
            const out = [];
            for (const retainedFault of this.each())
                if (retainedFault.source === source)
                    out.push(retainedFault);
            return out;
        }
        /**
         * @internal
         * Used internally to inform the FaultService that type-level fault
         * analysis is being done on the provided Node. This is necessary
         * because type-level faults do not live beyond a single edit frame,
         * so the FaultService needs to know which Nodes were analyzed
         * so that newly rectified faults can be cleared out.
         *
         * When this method is called, any the faults corresponding to the
         * specified Node are cleared out, and are only added back in if
         * they were re-detected during this edit transaction.
         */
        inform(node) {
            const smts = node.statements.filter(smt => !smt.isDisposed);
            // Clear out any statement-level faults that touch the node
            for (const smt of smts)
                this.bufferFrame.removeSource(smt);
            // Clear out any span-level faults that touch the node
            const spans = smts
                .map(smt => smt.spans)
                .reduce((a, b) => a.concat(b), []);
            for (const span of spans)
                this.bufferFrame.removeSource(span);
            // Clear out any infix-level faults that touch the node
            const infixes = smts
                .map(smt => smt.infixSpans || [])
                .reduce((a, b) => a.concat(b), []);
            for (const infix of infixes)
                this.bufferFrame.removeSource(infix);
        }
        /**
         * @internal
         */
        refresh() {
            const faultsAdded = [];
            const faultsRemoved = [];
            for (const map of this.bufferFrame.faults.values())
                for (const fault of map.values())
                    if (!this.visibleFrame.hasFault(fault))
                        faultsAdded.push(fault);
            for (const map of this.visibleFrame.faults.values())
                for (const fault of map.values())
                    if (!this.bufferFrame.hasFault(fault))
                        faultsRemoved.push(fault);
            this.visibleFrame = this.bufferFrame;
            this.bufferFrame = this.bufferFrame.clone();
            if (faultsAdded.length + faultsRemoved.length > 0)
                this.program.cause(new Truth.CauseFaultChange(faultsAdded, faultsRemoved));
        }
    }
    Truth.FaultService = FaultService;
    /**
     *
     */
    class FaultFrame {
        constructor() {
            /**
             * A doubly-nested map of fault sources, fault codes, and the actual fault.
             */
            this.faults = new Map();
        }
        /** */
        clone() {
            const newFrame = new FaultFrame();
            for (const [faultSource, existingMap] of this.faults) {
                const newMap = new Map();
                for (const [code, fault] of existingMap)
                    newMap.set(code, fault);
                newFrame.faults.set(faultSource, newMap);
            }
            return newFrame;
        }
        /** */
        addFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            if (faultsForSource) {
                faultsForSource.set(fault.type.code, fault);
            }
            else {
                const map = new Map();
                map.set(fault.type.code, fault);
                this.faults.set(fault.source, map);
            }
        }
        /** */
        removeSource(source) {
            this.faults.delete(source);
            if (source instanceof Truth.Statement)
                for (const cruftObject of source.cruftObjects)
                    this.faults.delete(cruftObject);
        }
        /** */
        removeFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            if (faultsForSource)
                faultsForSource.delete(fault.type.code);
        }
        /** */
        hasFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            return faultsForSource ?
                faultsForSource.has(fault.type.code) :
                false;
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Fault {
        constructor(
        /** */
        type, 
        /** The document object that caused the fault to be reported. */
        source, 
        /**
         * A human-readable message that contains more in-depth detail
         * of the fault that occured, in addition to the standard message.
         */
        additionalDetail = "") {
            this.type = type;
            this.source = source;
            this.additionalDetail = additionalDetail;
            const src = this.source;
            // The +1's are necessary in order to deal with the fact that
            // most editors are 1-based whereas the internal representation
            // of statement strings are 0-based.
            if (src instanceof Truth.Statement) {
                // The TabsAndSpaces fault is the only fault that needs a
                // special case where it has a different reporting location.
                this.range = type.code === Truth.Faults.TabsAndSpaces.code ?
                    [1, src.indent + 1] :
                    [src.indent + 1, src.sourceText.length + 1];
            }
            else if (src instanceof Truth.Span || src instanceof Truth.InfixSpan) {
                this.range = [
                    src.boundary.offsetStart + 1,
                    src.boundary.offsetEnd + 1
                ];
            }
            else
                throw Truth.Exception.unknownState();
        }
        /**
         * Converts this fault into a string representation,
         * suitable for output as an error message.
         */
        toString() {
            const doc = this.document;
            const avoidProtocols = [
                Truth.UriProtocol.internal,
                Truth.UriProtocol.none,
                Truth.UriProtocol.unknown
            ];
            const uriText = avoidProtocols.includes(doc.sourceUri.protocol) ?
                "" : doc.sourceUri.toStoreString() + " ";
            const colNums = this.range.join("-");
            const colText = colNums ? ", Col " + colNums : "";
            return `${this.type.message} (${uriText}Line ${this.line}${colText})`;
        }
        /**
         * Gets a reference to the Document in which this Fault was detected.
         */
        get document() {
            return this.statement.document;
        }
        /**
         * Gets a reference to the Statement in which this Fault was detected.
         */
        get statement() {
            const src = this.source;
            return Truth.Not.null(src instanceof Truth.Statement ? src :
                src instanceof Truth.Span ? src.statement :
                    src instanceof Truth.InfixSpan ? src.statement :
                        null);
        }
        /**
         * Gets the line number of the Statement in which this Fault was detected.
         */
        get line() {
            const smt = this.statement;
            return smt.document.getLineNumber(smt) + 1;
        }
    }
    Truth.Fault = Fault;
    /**
     *
     */
    class FaultType {
        constructor(
        /**
         * An error code, useful for reference purposes, or display in a user interface.
         */
        code, 
        /**
         * A human-readable description of the fault.
         */
        message, 
        /**
         *
         */
        severity) {
            this.code = code;
            this.message = message;
            this.severity = severity;
            this.message = message.trim().replace(/\s\s+/g, " ");
        }
        /**
         * Creates a fault of this type.
         */
        create(source) {
            return new Fault(this, source);
        }
    }
    Truth.FaultType = FaultType;
    /**
     * Utility function for creating frozen fault instances.
     */
    function createFault(code, message, severity = 8 /* error */) {
        return Object.freeze(new FaultType(code, message, severity));
    }
    const quantifiers = `(${"*" /* star */}, 
		${"+" /* plus */},
		${"{" /* quantifierStart */}..${"}" /* quantifierEnd */})`;
    /**
     *
     */
    Truth.Faults = Object.freeze({
        /** */
        *each() {
            const values = Object.values(Truth.Faults);
            for (const faultType of values)
                if (faultType instanceof FaultType)
                    yield faultType;
        },
        /**
         * @returns An object containing the FaultType instance
         * associated with the fault with the specified code, as
         * well as the name of the instance. In the case when the
         * faultCode was not found, null is returned.
         */
        nameOf(faultCode) {
            const entries = Object.entries(Truth.Faults);
            for (const [name, type] of entries)
                if (type instanceof FaultType)
                    if (type.code === faultCode)
                        return name;
            return "";
        },
        //# Resource-related faults
        /** */
        UnresolvedResource: createFault(100, "URI points to a resource that could not be resolved."),
        /** */
        CircularResourceReference: createFault(102, "URI points to a resource that would cause a circular reference."),
        /** */
        InsecureResourceReference: createFault(104, `Documents loaded from remote locations
			cannot reference documents stored locally.`),
        //# Type verification faults
        /** */
        UnresolvedAnnotation: createFault(201, "Unresolved annotation."),
        /** */
        CircularTypeReference: createFault(203, "Circular type reference detected."),
        /** */
        ContractViolation: createFault(
        //! CHANGE THIS TO 204
        205, "Overridden types must explicitly expand the type as defined in the base."),
        /** */
        TypeCannotBeRefreshed: createFault(206, `This type cannot be refreshed, because one or more base
			types are imposing a specific type contract on it. Consider
			omitting the ${":" /* joint */} operator here.`, 4 /* warning */),
        /** */
        IgnoredAnnotation: createFault(207, `This annotation is ignored because another annotation
			in this statement resolves to the same type.`),
        /** */
        IgnoredAlias: createFault(209, `Aliases (meaning annotations that are matched by patterns)
			can't be added onto types that have a contract put in place
			by a base type.`),
        /** */
        TypeSelfReferential: createFault(211, "Types cannot be self-referential"),
        //# List-related faults
        /** */
        AnonymousInListIntrinsic: createFault(300, "Types contained directly by List-intrinsic types cannot be anonymous.", 4 /* warning */),
        /** */
        ListContractViolation: createFault(301, "The containing list cannot contain children of this type.", 4 /* warning */),
        /** */
        ListIntrinsicExtendingList: createFault(303, "List intrinsic types cannot extend from other lists."),
        /** (This is the same thing as a list dimensionality conflict) */
        ListExtrinsicExtendingNonList: createFault(305, "Lists cannot extend from non-lists."),
        /** */
        ListDimensionalDiscrepancyFault: createFault(307, `A union cannot be created between these two types
			because they are lists of different dimensions.`),
        /** */
        ListAnnotationConflict: createFault(309, `All fragments of this annotation need to have
			a list operator (${"..." /* list */})`),
        //# Pattern-related faults
        /** */
        PatternInvalid: createFault(400, "Invalid pattern."),
        /** */
        PatternWithoutAnnotation: createFault(402, "Pattern has no annotations.", 4 /* warning */),
        /** */
        PatternCanMatchEmpty: createFault(404, "Patterns must not be able to match an empty input."),
        /** */
        PatternMatchingTypesAlreadyExists: createFault(406, `A pattern matching these types has 
			already been defined in this scope.`),
        /** */
        PatternMatchingList: createFault(407, "A pattern cannot match a list type."),
        /** */
        PatternCanMatchWhitespaceOnly: createFault(420, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternAcceptsLeadingWhitespace: createFault(422, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternRequiresLeadingWhitespace: createFault(424, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternAcceptsTrailingWhitespace: createFault(426, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternRequiresTrailingWhitespace: createFault(428, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternNonCovariant: createFault(440, "Pattern does not match it's base types."),
        /** */
        PatternPartialWithCombinator: createFault(442, "Partial patterns cannot explicitly match the comma character."),
        /** */
        PatternsFormDiscrepantUnion: createFault(499, "A union cannot be created between these types because their " +
            "associated patterns conflict with each other."),
        //# Infix related
        /** */
        InfixHasQuantifier: createFault(
        ///0,
        500, `Infixes cannot have quantifiers ${quantifiers} applied to them`),
        /** */
        InfixHasDuplicateIdentifier: createFault(
        ///0,
        501, "Infixes cannot have duplicate identifiers."),
        /** */
        InfixHasSelfReferentialType: createFault(
        ///410,
        503, "Infixes cannot be self-referential."),
        /** */
        InfixNonConvariant: createFault(
        ///412,
        505, "Infixes must be compatible with their bases."),
        /** */
        InfixCannotDefineNewTypes: createFault(
        ///422,
        507, `A type referenced in an infix must be contained
			by the pattern statement directly, or be contained
			by one of it's matched bases.`),
        /** */
        InfixReferencedTypeMustHavePattern: createFault(
        ///414,
        509, "Types applied to an infix must have at least one associated pattern."),
        /** */
        InfixReferencedTypeCannotBeRecursive: createFault(
        ///416,
        511, "Types applied to an infix must not create a recursive structure."),
        /** */
        InfixContractViolation: createFault(
        ///424,
        513, "Infix type annotations must explicitly expand the type as defined by the base."),
        /** */
        InfixPopulationChaining: createFault(
        ///426,
        515, "Population infixes cannot have multiple declarations."),
        /** */
        InfixUsingListOperator: createFault(
        ///0,
        517, `Infix identifiers cannot end with the list operator (${"..." /* list */}).`),
        /** */
        InfixReferencingList: createFault(
        ///428,
        519, "Infixes cannot reference list types."),
        /** */
        PortabilityInfixHasMultipleDefinitions: createFault(
        ///418,
        521, `Portability infixes with compatible types cannot
			be specified more than once.`),
        /** */
        PortabilityInfixHasUnion: createFault(
        ///418,
        523, "Portability infixes with unioned types are not supported at this time."),
        /** */
        PopulationInfixHasMultipleDefinitions: createFault(
        ///0,
        525, `Declarations in a population infix cannot be 
			defined twice in the same pattern`),
        /** */
        NominalInfixMustSubtype: createFault(
        ///430,
        527, "Patterns with nominal infixes require an input that is " +
            "a subtype of the type specified, not the type itself."),
        //# Parse errors
        /** */
        StatementBeginsWithComma: createFault(600, "Statements cannot begin with a comma."),
        /** */
        StatementBeginsWithEllipsis: createFault(602, "Statements cannot begin with an ellipsis (...)."),
        /** */
        StatementBeginsWithEscapedSpace: createFault(604, "Statements cannot begin with an escape character (\\) " +
            "that is followed by a tab or space."),
        /** */
        StatementContainsOnlyEscapeCharacter: createFault(606, "A statement cannot consist of a single escape character (\\)"),
        /** */
        StatementBeginsWithInvalidSequence: createFault(608, "A statement cannot begin with the sequences: /*, /+, or /?"),
        //# Parsing Faults
        /** */
        TabsAndSpaces: createFault(1000, "Statement indent contains a mixture of tabs and spaces.", 4 /* warning */),
        /** */
        DuplicateDeclaration: createFault(1001, "Duplicated declaration."),
        /** */
        UnterminatedCharacterSet: createFault(1002, `Unterminated character set. Pattern has an opening
			"${"[" /* setStart */}" character without a matching
			"${"]" /* setEnd */}" character.`),
        /** */
        UnterminatedGroup: createFault(1004, `Unterminated group. Pattern has an opening
			"${"(" /* groupStart */}" character without a matching
			"${")" /* groupEnd */}" character.`),
        /** */
        DuplicateQuantifier: createFault(1006, `Multiple consecutive quantifiers ${quantifiers} are not allowed.`),
        /** */
        UnterminatedInfix: createFault(1008, `Unterminated infix. Pattern has an opening ${"<" /* start */},
			${"<<" /* nominalStart */}, ${"</" /* patternStart */} delimiter without
			a matching closing delimiter.`),
        /** */
        EmptyPattern: createFault(1010, "Pattern has no matchable content.")
    });
    // Additional safety
    Array.from(Truth.Faults.each()).every(Object.freeze);
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Infinite incremental counter.
     */
    class VersionStamp {
        /** */
        constructor(stamp) {
            this.stamp = stamp;
        }
        /** */
        static next() {
            const createStamp = (stamp) => new VersionStamp(Object.freeze(stamp));
            if (typeof BigInt !== "undefined") {
                if (this.nextStamp === undefined)
                    return createStamp(this.nextStamp = BigInt(1));
                // See: https://github.com/eslint/eslint/issues/10574
                // eslint-disable-next-line valid-typeof
                if (typeof this.nextStamp === "bigint")
                    return createStamp(++this.nextStamp);
            }
            else {
                if (this.nextStamp === undefined) {
                    this.nextStamp = [1];
                    return createStamp(this.nextStamp.slice());
                }
                const ns = this.nextStamp;
                if (Array.isArray(ns)) {
                    // Polyfill infinite number counter for use in the 
                    // absence of a native BigInt implementation.
                    for (let i = ns.length; i-- > 0;) {
                        if (ns[i] === 999999999999) {
                            ns[i] = 0;
                            if (i === 0)
                                ns.unshift(1);
                        }
                        else {
                            ns[i]++;
                            break;
                        }
                    }
                    return createStamp(ns.slice());
                }
            }
            throw Truth.Exception.unknownState();
        }
        /** */
        newerThan(otherStamp) {
            return this.stamp > otherStamp.stamp;
        }
        /** */
        toString() {
            return Array.isArray(this.stamp) ?
                this.stamp.join("") :
                this.stamp.toString();
        }
    }
    Truth.VersionStamp = VersionStamp;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class AlphabetRange {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
    }
    Truth.AlphabetRange = AlphabetRange;
    /**
     * @internal
     */
    class Alphabet {
        /** */
        constructor(...ranges) {
            /** */
            this.ranges = [];
            this.ranges = ranges;
        }
        /**
         * Iterates through each character defined in the alphabet.
         */
        *[Symbol.iterator]() {
            for (const range of this.ranges)
                for (let i = range.from; i <= range.to; i++)
                    yield String.fromCodePoint(i);
        }
        /**
         * Iterates through all defined ranges in the alphabet,
         * excluding the wildcard range.
         */
        *eachRange() {
            if (this.hasWildcard()) {
                for (let rangeIdx = 0; rangeIdx < this.ranges.length - 1;)
                    yield this.ranges[rangeIdx++];
            }
            else
                for (const range of this.ranges)
                    yield range;
        }
        /** */
        has(symbol) {
            if (symbol === Alphabet.wildcard)
                return this.hasWildcard();
            const code = toCharCode(symbol);
            for (const range of this.ranges)
                if (range.from >= code && range.to <= code)
                    return true;
            return false;
        }
        /** */
        hasWildcard() {
            const rng = this.ranges;
            return rng.length > 0 && rng[rng.length - 1] === Alphabet.wildcardRange;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const symbols = [];
            for (const range of this.ranges)
                symbols.push(range.from === range.to ?
                    String.fromCodePoint(range.from) :
                    String.fromCodePoint(range.from) + " - " + String.fromCodePoint(range.to));
            if (this.hasWildcard())
                symbols.push(Alphabet.wildcard);
            return "[" + symbols.join(", ") + "]";
        }
    }
    /**
     * Stores a special token that the system understands to be the
     * wildcard character. The length of the token is longer than any
     * other token that could otherwise be found in the alphabet.
     */
    Alphabet.wildcard = "((wild))";
    /**
     * Stores a range that represents the wildcard character.
     * The range of the wildcard is positive infinity in both directions,
     * to ensure that it's always sorted last in the ranges array.
     */
    Alphabet.wildcardRange = Object.freeze(new AlphabetRange(Infinity, Infinity));
    Truth.Alphabet = Alphabet;
    /**
     * @internal
     * A disposable class for easily creating Alphabet instances
     * (This design avoids introducing mutability into the Alphabet class).
     */
    class AlphabetBuilder {
        /** */
        constructor(...others) {
            /** */
            this.ranges = [];
            for (const item of others) {
                if (item instanceof Alphabet) {
                    const theRanges = Array.from(item.eachRange());
                    for (const range of theRanges)
                        this.ranges.push(range);
                }
                else if (item instanceof AlphabetRange) {
                    this.ranges.push(item);
                }
                else {
                    const code = toCharCode(item);
                    this.ranges.push(new AlphabetRange(code, code));
                }
            }
        }
        /**
         * Adds an entry to the alphabet.
         * If the second parameter is omitted, the entry refers to a
         * single character, rather than a range of characters.
         */
        add(from, to) {
            const toAsNum = to === undefined ? from : to;
            this.ranges.push(new AlphabetRange(toCharCode(from), toCharCode(toAsNum)));
            return this;
        }
        /** */
        addWild() {
            this.ranges.push(Alphabet.wildcardRange);
            return this;
        }
        /**
         * @returns An optimized Alphabet instances composed
         * from the characters and ranges applied to this AlphabetBuilder.
         *
         * @param invert In true, causes the entries in the generated
         * Alphabet to be reversed, such that every character marked
         * as included is excluded, and vice versa.
         */
        toAlphabet(invert) {
            if (this.ranges.length === 0)
                return new Alphabet();
            const ranges = this.ranges
                .slice()
                .sort((a, b) => a.from - b.from);
            // Quick optimization of ranges
            for (let i = 0; i < ranges.length - 1; i++) {
                const thisRange = ranges[i];
                while (i < ranges.length - 1) {
                    const nextRange = ranges[i + 1];
                    // Omit
                    if (thisRange.to >= nextRange.to) {
                        ranges.splice(i + 1, 1);
                    }
                    // Concat
                    else if (thisRange.to + 1 >= nextRange.from) {
                        ranges.splice(i + 1, 1);
                        ranges[i] = new AlphabetRange(thisRange.from, nextRange.to);
                    }
                    // Next
                    else
                        break;
                }
            }
            if (invert) {
                //
                // This alphabet inversion algorithm has to deal with 4 cases,
                // depending on the pattern of the ranges and the spaces.
                // After the ranges are sorted and optimized, the ranges
                // array represents a layout that alternates between ranges
                // and spaces. There are 4 basic layouts (R = Range, S = Space):
                //
                // RSRS - Starts with a range, ends with a space
                // SRSR - Starts with a space, ends with a range
                // RSRSR - Starts with a range, ends with a range
                // SRSRS - Starts with a space, ends with a space
                // 
                // The algorithm deal with any leading or trailing space
                // separately, to make the looping less complicated. 
                // 
                const rangesInv = [];
                const lastRange = ranges[ranges.length - 1];
                const matchesZero = ranges[0].from === 0;
                const matchesMax = lastRange.to === Truth.UnicodeMax;
                if (matchesZero && matchesMax && ranges.length === 1)
                    return new Alphabet();
                if (!matchesZero)
                    rangesInv.push(new AlphabetRange(0, ranges[0].from));
                const endAt = matchesMax ?
                    lastRange.from :
                    Truth.UnicodeMax;
                for (let i = 0; i < ranges.length; i++) {
                    const prevRangeEnd = ranges[i].to;
                    const nextRangeStart = i < ranges.length - 1 ?
                        ranges[i + 1].from :
                        Truth.UnicodeMax + 1;
                    rangesInv.push(new AlphabetRange(prevRangeEnd + 1, nextRangeStart - 1));
                    if (nextRangeStart >= endAt)
                        break;
                }
                if (!matchesMax)
                    rangesInv.push(new AlphabetRange(lastRange.from, Truth.UnicodeMax));
            }
            return new Alphabet(...ranges);
        }
    }
    Truth.AlphabetBuilder = AlphabetBuilder;
    /** */
    function toCharCode(symbol) {
        return typeof symbol === "string" ?
            symbol.charCodeAt(0) :
            symbol;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TransitionMap {
        /** */
        constructor(transitionLiteral) {
            const transitions = new Map();
            if (transitionLiteral) {
                for (const [stateIdText, tslObject] of Object.entries(transitionLiteral)) {
                    const stateId = parseInt(stateIdText, 10);
                    if (stateId !== stateId)
                        throw new TypeError();
                    if (!tslObject || typeof tslObject !== "object")
                        throw new TypeError();
                    const tsl = tslObject;
                    transitions.set(stateId, new Truth.TransitionState(tsl));
                }
            }
            this.transitions = transitions;
        }
        /** */
        *[Symbol.iterator]() {
            for (const [stateId, transitionState] of this.transitions.entries())
                yield [stateId, transitionState];
        }
        /** */
        clone() {
            const out = new TransitionMap({});
            for (const [key, value] of this.transitions)
                out.transitions.set(key, value.clone());
            return out;
        }
        /** */
        has(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                return false;
            if (symbol === undefined)
                return !!transitionState;
            return transitionState.has(symbol);
        }
        get(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                return undefined;
            if (symbol === undefined)
                return transitionState;
            return transitionState.get(symbol);
        }
        acquire(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                throw new Error();
            if (symbol === undefined)
                return transitionState;
            const subStateId = transitionState.get(symbol);
            if (subStateId === undefined)
                throw new Error();
            return subStateId;
        }
        /** */
        *eachStateId() {
            for (const stateId of this.transitions.keys())
                yield stateId;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const out = ["{"];
            for (const [stateId, tState] of this.transitions)
                out.push("\t" + stateId + ": " + tState.toString());
            out.push("}");
            return out.join("\n");
        }
    }
    Truth.TransitionMap = TransitionMap;
    /**
     * @internal
     */
    class MutableTransitionMap extends TransitionMap {
        /** */
        initialize(srcStateId) {
            this.transitions.set(srcStateId, new Truth.TransitionState());
        }
        /** */
        set(srcStateId, symbol, dstStateId) {
            const tState = this.transitions.get(srcStateId);
            if (!tState) {
                const tState = new Truth.TransitionState();
                tState.set(symbol, dstStateId);
                this.transitions.set(srcStateId, tState);
            }
            else {
                tState.set(symbol, dstStateId);
            }
        }
    }
    Truth.MutableTransitionMap = MutableTransitionMap;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TransitionState {
        /** */
        constructor(source) {
            this.stateMap = new Map();
            if (source)
                for (const [symbol, stateId] of Object.entries(source))
                    this.stateMap.set(symbol, stateId);
        }
        /** */
        clone() {
            const cloned = new TransitionState();
            for (const [symbol, stateId] of this.stateMap)
                cloned.stateMap.set(symbol, stateId);
            return cloned;
        }
        /** */
        has(symbol) {
            return this.stateMap.has(symbol);
        }
        /** */
        get(symbol) {
            return this.stateMap.get(symbol);
        }
        /** */
        set(symbol, stateId) {
            this.stateMap.set(symbol, stateId);
        }
        /** */
        *eachSymbol() {
            for (const symbol of this.stateMap.keys())
                yield symbol;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const out = [];
            for (const [symbol, stateId] of this.stateMap)
                out.push("{ " + symbol + ": " + stateId + " }");
            return out.length ? out.join(", ") : "{}";
        }
    }
    Truth.TransitionState = TransitionState;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class Guide {
        /** */
        constructor(from) {
            /** */
            this.hasDst = null;
            /** */
            this.isFrozen = false;
            /** */
            this.arrows = new Map();
            if (from instanceof Guide) {
                this.hasDst = from.hasDst;
                for (const [stateIdSrc, stateIdDst] of from.arrows)
                    this.arrows.set(stateIdSrc, stateIdDst);
            }
            else if (typeof from === "number") {
                this.add(from);
            }
            else if (from) {
                for (const [stateIdSrc, stateIdDst] of from)
                    this.arrows.set(stateIdSrc, stateIdDst);
            }
        }
        /** */
        clone() {
            const cloned = new Guide();
            for (const [stateIdSrc, stateIdDst] of this.arrows)
                cloned.arrows.set(stateIdSrc, stateIdDst);
            return cloned;
        }
        /** */
        has(stateIdSrc) {
            return this.arrows.has(stateIdSrc);
        }
        /** */
        get(stateIdSrc) {
            return this.arrows.get(stateIdSrc);
        }
        /** */
        add(stateIdSrc, stateIdDst = null) {
            if (this.isFrozen)
                throw new TypeError();
            if (this.hasDst === null) {
                this.arrows.set(stateIdSrc, stateIdDst);
            }
            else {
                if (stateIdDst !== stateIdDst)
                    throw new TypeError();
                if (this.hasDst === true && typeof stateIdDst !== "number" ||
                    this.hasDst === false && typeof stateIdDst === "number")
                    throw new Error("Parameters need to be kept consistent across the instance.");
                this.arrows.set(stateIdSrc, stateIdDst);
            }
            this.hasDst = stateIdDst !== null;
        }
        /** */
        append(other) {
            if (this.isFrozen)
                throw new TypeError();
            if (this.hasDst === null) {
                for (const [src, dst] of other.arrows) {
                    this.hasDst = typeof dst === "number";
                    this.arrows.set(src, dst);
                }
            }
            else if (other.hasDst === null) {
                if (other.size !== 0)
                    throw Truth.Exception.unknownState();
            }
            else {
                for (const [src, dst] of other.arrows)
                    this.arrows.set(src, dst);
            }
        }
        /** */
        first() {
            const out = this.arrows.get(0);
            if (out === null || out === undefined)
                throw new Error();
            return out;
        }
        /** */
        *keys() {
            for (const src of this.arrows.keys())
                yield src;
        }
        /** */
        *values() {
            if (this.hasDst === true)
                for (const dst of this.arrows.values())
                    yield Truth.Not.null(dst);
        }
        /** */
        *entries() {
            if (this.hasDst === false)
                throw new Error("Cannot enumerate the full entries of this instance.");
            for (const [stateIdSrc, stateIdDst] of this.arrows)
                yield [stateIdSrc, Truth.Not.null(stateIdDst)];
        }
        /** */
        get size() { return this.arrows.size; }
        /**
         * @returns A boolean value that indicates whether the contents
         * of this guide match the contents of the guide specified in the
         * parameter.
         */
        equals(other) {
            if (this.size !== other.size)
                return false;
            for (const [src, dst] of this.arrows)
                if (other.arrows.get(src) !== dst)
                    return false;
            return true;
        }
        /** */
        freeze() {
            this.isFrozen = true;
            return this;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            if (this.hasDst) {
                const literal = [];
                for (const [stateIdSrc, stateIdDst] of this.arrows)
                    literal.push(stateIdSrc + ": " + stateIdDst);
                return "{ " + literal.join(", ") + " }";
            }
            return "[" + Array.from(this.arrows.keys()).join(", ") + "]";
        }
    }
    Truth.Guide = Guide;
})(Truth || (Truth = {}));
/**
 * This code is a TypeScript conversion of a portion of the the Python
 * project "greenery", from GitHub user "qntm".
 *
 * The greenery project can be found here:
 * https://github.com/qntm/greenery
 *
 * Specifically, the code from where this code drew inspiration is:
 * https://github.com/qntm/greenery/blob/master/greenery/fsm.py
 *
 * Possibly relevant blog post:
 * https://qntm.org/algo
 *
 * The original MIT license from greenery is as follows:
 *
 * Copyright (C) 2012 to 2017 by qntm
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Truth;
/**
 * This code is a TypeScript conversion of a portion of the the Python
 * project "greenery", from GitHub user "qntm".
 *
 * The greenery project can be found here:
 * https://github.com/qntm/greenery
 *
 * Specifically, the code from where this code drew inspiration is:
 * https://github.com/qntm/greenery/blob/master/greenery/fsm.py
 *
 * Possibly relevant blog post:
 * https://qntm.org/algo
 *
 * The original MIT license from greenery is as follows:
 *
 * Copyright (C) 2012 to 2017 by qntm
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function (Truth) {
    /**
     * Oblivion is a Symbol object that is returned while calling crawl() if the Fsm
     * is transitioned to the oblivion state. For example while crawling two Fsms
     * in parallel we may transition to the oblivion state of both Fsms at once.
     * This warrants an out-of-bound signal which will reduce the complexity of
     * the new Fsm's map.
     */
    const Oblivion = Symbol();
    /**
     * @internal
     * A Finite State Machine or Fsm has an alphabet and a set of states. At any
     * given moment, the Fsm is in one state. When passed a symbol from the
     * alphabet, the Fsm jumps to another state (or possibly the same state).
     * A TransitionMap indicates where to jump. One state is nominated as the
     * initial state. Zero or more states are nominated as final states. If, after
     * consuming a string of symbols, the Fsm is in a final state, then it is said
     * to "accept" the string.
     */
    class Fsm {
        /** */
        constructor(
        /**
         * An iterable of symbols the Fsm can be fed.
         */
        alphabet, 
        /**
         * The set of possible states for the Fsm.
         */
        states, 
        /**
         * The initial state of the Fsm.
         */
        initial, 
        /**
         * The set of states that the Fsm accepts.
         */
        finals, 
        /**
         * May be sparse (i.e. it may omit transitions).
         * In the case of omitted transitions, a non-final
         * "oblivion" state is simulated.
         */
        transitions) {
            this.alphabet = alphabet;
            this.states = states;
            this.initial = initial;
            this.finals = finals;
            this.transitions = transitions;
        }
        /**
         * @returns A new Fsm instance that accept
         * no inputs, not even an empty string.
         */
        static empty(alphabet) {
            const tsl = {};
            for (const symbol of alphabet)
                tsl[symbol] = 0;
            return new Fsm(alphabet, new Set([0]), 0, new Set(), new Truth.TransitionMap({ 0: tsl }));
        }
        /**
         * @returns An Fsm that matches only an empty string.
         */
        static epsilon(alphabet) {
            return new Fsm(alphabet, new Set([0]), 0, new Set([0]), new Truth.TransitionMap());
        }
        /**
         * @returns A boolean value that indicates whether the present Fsm
         * accepts the supplied array of symbols. Equivalently, consider this
         * Fsm instance as a possibly-infinite set of strings and test whether
         * the input is a member of it.
         *
         * If the wildcard character is present in the specified alphabet, then
         * any symbol not in the specified alphabet will be assumed to be
         * wildcard.
         */
        accepts(input) {
            const thisHasWild = this.alphabet.hasWildcard();
            let stateId = this.initial;
            for (const char of input) {
                const symbol = thisHasWild && !this.alphabet.has(char) ?
                    Truth.Alphabet.wildcard :
                    char;
                // Missing transition = transition to dead state
                if (!this.transitions.has(stateId, symbol))
                    return false;
                const newStateId = this.transitions.get(stateId, symbol);
                if (newStateId === undefined)
                    throw new ReferenceError();
                stateId = newStateId;
            }
            return this.finals.has(stateId);
        }
        /**
         * @returns A reduced version of the Fsm, down to a minimal finite
         * state machine equivalent.
         *
         * (A result by Brzozowski (1963) shows that a minimal finite state
         * machine equivalent to the original can be obtained by reversing
         * the original twice.)
         */
        reduce() {
            return this.reverse().reverse();
        }
        /**
         * @returns A new Fsm instance that represents the concatenation
         * of the specified series of finite state machines.
         */
        concatenate(...fsms) {
            if (fsms.length === 0)
                throw new RangeError();
            if (fsms.length === 1)
                return fsms[0];
            /**
             * Take a state in the numbered Fsm and return a set containing it,
             * plus (if it's final) the first state from the next Fsm,
             * plus (if that's final) the first state from the next but one Fsm,
             * plus...
             */
            const connectAll = (idx, substateId) => {
                const result = new Truth.Guide();
                result.add(idx, substateId);
                let i = idx;
                let id = substateId;
                while (i < fsms.length - 1 && fsms[i].finals.has(id)) {
                    i++;
                    id = fsms[i].initial;
                    result.add(i, id);
                }
                return result;
            };
            /**
             * Use a superset containing states from all Fsms at once.
             * We start at the start of the first Fsm. If this state is final in the
             * first Fsm, then we are also at the start of the second Fsm. And so on.
             */
            const initial = new Truth.Guide();
            if (fsms.length > 0)
                initial.append(connectAll(0, fsms[0].initial));
            /**
             * If you're in a final state of the final Fsm, it's final.
             */
            const finalFn = (guide) => {
                for (const [i, substateId] of guide.entries())
                    if (i === fsms.length - 1 && fsms[i].finals.has(substateId))
                        return true;
                return false;
            };
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const [i, substateId] of guide.entries()) {
                    const fsm = fsms[i];
                    if (fsm.transitions.has(substateId, symbol)) {
                        const storedValue = fsm.transitions.acquire(substateId, symbol);
                        next.append(connectAll(i, storedValue));
                    }
                }
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            const alphabets = fsms.map(fsm => fsm.alphabet);
            const alphabet = new Truth.AlphabetBuilder(...alphabets).toAlphabet();
            return crawl(alphabet, initial, finalFn, followFn);
        }
        /**
         * Concatenate two finite state machines together.
         * For example, if this accepts "0*" and other accepts "1+(0|1)",
         * will return a finite state machine accepting "0*1+(0|1)".
         * Accomplished by effectively following non-deterministically.
         */
        add(other) {
            return this.concatenate(this, other);
        }
        /**
         * If the present Fsm accepts X, returns an Fsm accepting X*
         * (i.e. 0 or more instances of X). Note that this is not as simple
         * as naively connecting the final states back to the initial state:
         * see (b*ab)* for example.
         */
        star() {
            const initial = new Truth.Guide(this.initial);
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const substateId of guide.keys()) {
                    if (this.transitions.has(substateId, symbol))
                        next.add(this.transitions.acquire(substateId, symbol));
                    // If one of our substates is final, then we can also consider
                    // transitions from the initial state of the original Fsm.
                    if (this.finals.has(substateId) && this.transitions.has(this.initial, symbol))
                        next.add(this.transitions.acquire(this.initial, symbol));
                }
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            /** */
            const finalFn = (guide) => {
                for (const substateId of guide.keys())
                    if (this.finals.has(substateId))
                        return true;
                return false;
            };
            return crawl(this.alphabet, initial, finalFn, followFn).or(Fsm.epsilon(this.alphabet));
        }
        /**
         * Given an Fsm and a multiplication factor, return the multiplied Fsm.
         */
        multiply(factor) {
            if (factor < 0)
                throw new RangeError();
            const initial = new Truth.Guide([[this.initial, 0]]);
            /** */
            const finalFn = (guide) => {
                for (const [substateId, iteration] of guide.entries())
                    if (this.initial === substateId)
                        if (this.finals.has(this.initial) || iteration === factor)
                            return true;
                return false;
            };
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const [substateId, iteration] of guide.entries()) {
                    if (iteration < factor && this.transitions.has(substateId, symbol)) {
                        const num = this.transitions.acquire(substateId, symbol);
                        next.add(num, iteration);
                        if (this.finals.has(num))
                            next.add(this.initial, iteration + 1);
                    }
                }
                if (next.size === 0)
                    return Oblivion;
                return next;
            };
            return crawl(this.alphabet, initial, finalFn, followFn).reduce();
        }
        /**
         * @returns A new Fsm object that presents the union of
         * all supplied Fsm instances.
         */
        union(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.some(val => val));
        }
        /**
         * Performs logical alternation between this Fsm, and the Fsm
         * instance supplied in the argument.
         *
         * @returns A finite state machine which accepts any sequence of
         * symbols that is accepted by either self or other. Note that the set
         * of strings recognised by the two Fsms undergoes a set union.
         */
        or(other) {
            return this.union(other);
        }
        /**
         * @returns A new Fsm object that represents the
         * intersection of all supplied Fsm instances.
         */
        intersection(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.every(val => val));
        }
        /**
         * Treat the Fsms as sets of strings and return the
         * intersection of those sets in the form of a new Fsm.
         */
        and(other) {
            return this.intersection(other);
        }
        /**
         * @returns A new Fsm object that represents the computed
         * symmetric difference of all suppled Fsm instances.
         */
        symmetricDifference(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.filter(val => val).length % 2 === 1);
        }
        /**
         * @returns A new Fsm instances that recognises only the strings
         * recognised by this Fsm, or the Fsm instance supplied in the
         * other argument, but not both.
         */
        xor(other) {
            return this.symmetricDifference(other);
        }
        /**
         * @returns A new Fsm instance that recogizes all inputs that
         * would not be accepted by this Fsm.
         */
        not() {
            const initial = new Truth.Guide([[0, this.initial]]);
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                const first = guide.first();
                if (first !== undefined)
                    if (this.transitions.has(first, symbol))
                        next.add(0, this.transitions.get(first, symbol));
                return next;
            };
            /** */
            const finalFn = (guide) => {
                const first = guide.first();
                return !(first !== undefined && this.finals.has(first));
            };
            return crawl(this.alphabet, initial, finalFn, followFn);
        }
        /**
         * @returns A new Fsm such that for every input that the supplied
         * Fsm accepts, the new Fsm accepts the same input, but reversed.
         */
        reverse() {
            // Start from a composite "state-set" consisting of all final states.
            // If there are no final states, this set is empty and we'll find that
            // no other states get generated.
            const initial = new Truth.Guide();
            for (const stateId of this.finals)
                initial.add(stateId);
            // Find every possible way to reach the current state-set
            // using this symbol.
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const prevStateId of this.transitions.eachStateId())
                    for (const stateId of guide.keys())
                        if (this.transitions.has(prevStateId, symbol))
                            if (this.transitions.get(prevStateId, symbol) === stateId)
                                next.add(prevStateId);
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            /** */
            const finalFn = (guide) => guide.has(this.initial);
            return crawl(this.alphabet, initial, finalFn, followFn);
        }
        /**
         * @returns A boolean value indicating whether this Fsm instance
         * accepts the same set of inputs as the Fsm instance specified
         * in the argument.
         */
        equivalent(other) {
            return this.xor(other).isEmpty();
        }
        /**
         * @returns A boolean value indicating whether this Fsm instance
         * does not accept the same set of inputs as the Fsm instance
         * specified in the argument.
         */
        unequivalent(other) {
            return !this.xor(other).isEmpty();
        }
        /**
         * @returns An Fsm instance which recognises only the inputs
         * recognised by the first Fsm instance in the list, but none of
         * the others.
         */
        difference(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts[0] && accepts.slice(1).every(accepts => !accepts));
        }
        /**
         * @returns A boolean value that indicates whether a final state
         * can be reached from the specified state.
         */
        isStateLive(stateId) {
            const reachable = [stateId];
            for (let i = -1; ++i < reachable.length;) {
                const currentStateId = reachable[i];
                if (this.finals.has(currentStateId))
                    return true;
                if (this.transitions.has(currentStateId)) {
                    const transitionState = this.transitions.acquire(currentStateId);
                    for (const symbol of transitionState.eachSymbol()) {
                        const next = this.transitions.acquire(currentStateId, symbol);
                        if (!reachable.includes(next))
                            reachable.push(next);
                    }
                }
            }
            return false;
        }
        /**
         * An Fsm is empty if it recognises no strings. An Fsm may be arbitrarily
         * complicated and have arbitrarily many final states while still recognising
         * no strings because those final states may all be inaccessible from the
         * initial state. Equally, an Fsm may be non-empty despite having an empty
         * alphabet if the initial state is final.
         */
        isEmpty() {
            return !this.isStateLive(this.initial);
        }
        /**
         * Generate strings (lists of symbols) that this Fsm accepts. Since there may
         * be infinitely many of these we use a generator instead of constructing a
         * static list. Strings will be sorted in order of length and then lexically.
         * This procedure uses arbitrary amounts of memory but is very fast. There
         * may be more efficient ways to do this, that I haven't investigated yet.
         * You can use this in list comprehensions.
         */
        *eachString() {
            "Not implemented";
            debugger;
            yield "";
        }
        /**
         * @returns A boolean value that indicates whether the act of merging
         * this Fsm instance with the Fsm instance supplied in the argument
         * would result in an Fsm instance that accepts no inputs.
         */
        isDiscrepant(other) {
            return this.and(other).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a subset of the inputs accepted by
         * other Fsm instance specified.
         */
        isSubset(other) {
            return this.difference(other).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a proper subset of the inputs
         * accepted by other Fsm instance specified.
         */
        isProperSubset(other) {
            return this.difference(other).isEmpty() && this.unequivalent(other);
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a superset of the inputs accepted
         * by other Fsm instance specified.
         */
        isSuperset(other) {
            return other.difference(this).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a proper superset of the inputs
         * accepted by other Fsm instance specified.
         */
        isProperSuperset(other) {
            return other.difference(this).isEmpty() && other.unequivalent(this);
        }
        /**
         * Compute the Brzozowski derivative of this Fsm with respect to the input
         * string of symbols. <https://en.wikipedia.org/wiki/Brzozowski_derivative>
         * If any of the symbols are not members of the alphabet, that's a KeyError.
         * If you fall into oblivion, then the derivative is an Fsm accepting no
         * strings.
         *
         * @returns A new Fsm instance with the computed characteristics.
         */
        derive(input) {
            let stateId = this.initial;
            for (const char of input) {
                const symbol = (() => {
                    if (this.alphabet.has(char)) {
                        if (!this.alphabet.hasWildcard)
                            throw new Error(char);
                        return Truth.Alphabet.wildcard;
                    }
                    return char;
                })();
                if (!this.transitions.has(stateId, symbol))
                    return Oblivion;
                stateId = this.transitions.acquire(stateId, symbol);
            }
            return new Fsm(this.alphabet, this.states, stateId, this.finals, this.transitions.clone());
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            return [
                "alphabet = " + this.alphabet.toString(),
                "states = " + Array.from(this.states).join(),
                "inital = " + this.initial,
                "finals = " + Array.from(this.finals).join(),
                "transitions = " + this.transitions.toString()
            ].join("\n");
        }
    }
    Truth.Fsm = Fsm;
    /**
     * Utility function to prepend an Fsm instance to an Fsm array.
     */
    function prependFsm(fsm, fsms) {
        return [fsm].concat(...fsms);
    }
    /**
     * Crawl several Fsms in parallel, mapping the states of a larger meta-Fsm.
     * To determine whether a state in the larger Fsm is final, pass all of the
     * finality statuses (e.g. [true, false, false] to testFn.
     */
    function crawlParallel(fsms, testFn) {
        const initial = new Truth.Guide();
        for (const [index, fsm] of fsms.entries())
            initial.add(index, fsm.initial);
        /**
         * Dedicated function accepts a "superset" and returns the next "superset"
         * obtained by following this transition in the new Fsm.
         */
        const followFn = (guide, symbol) => {
            const next = new Truth.Guide();
            for (const [index, fsm] of fsms.entries()) {
                const stateId = guide.get(index);
                if (stateId === null || stateId === undefined)
                    continue;
                const substateId = fsm.transitions.get(stateId);
                if (substateId === undefined)
                    continue;
                const alpha = fsm.alphabet;
                const actualSymbol = alpha.has(symbol) && alpha.hasWildcard() ?
                    Truth.Alphabet.wildcard :
                    symbol;
                if (substateId.has(actualSymbol))
                    next.add(index, fsm.transitions.get(stateId, actualSymbol));
            }
            if (next.size === 0)
                return Oblivion;
            return next;
        };
        /**
         * Determine the "is final?" condition of each substateId, then pass it to the
         * test to determine finality of the overall Fsm.
         */
        const finalFn = (guide) => {
            const accepts = [];
            for (const [idx, fsm] of fsms.entries()) {
                const substateId = guide.get(idx);
                if (substateId !== null && substateId !== undefined)
                    accepts.push(guide.has(idx) && fsm.finals.has(substateId));
            }
            return testFn(accepts);
        };
        const alphabets = fsms.map(fsm => fsm.alphabet);
        const alphabet = new Truth.AlphabetBuilder(...alphabets).toAlphabet();
        return crawl(alphabet, initial, finalFn, followFn).reduce();
    }
    /**
     * Given the above conditions and instructions, crawl a new unknown Fsm,
     * mapping its states, final states and transitions. Return the new Fsm.
     */
    function crawl(alphabet, initial, finalFn, followFn) {
        const debugLines = [];
        const guides = [initial];
        const finals = new Set();
        const transitions = new Truth.MutableTransitionMap();
        // Iterate over a growing list
        for (const [i, guide] of guides.entries()) {
            // Add to finals
            if (finalFn(guide))
                finals.add(i);
            // Compute transitions for this state
            transitions.initialize(i);
            for (const symbol of alphabet) {
                const next = followFn(guide, symbol);
                if (next !== Oblivion) {
                    let nextIdx = guides.findIndex(guide => guide.equals(next));
                    if (nextIdx < 0) {
                        nextIdx = guides.length;
                        guides.push(next);
                    }
                    transitions.set(i, symbol, nextIdx);
                    debugLines.push(next.toString());
                }
            }
        }
        return new Fsm(alphabet, new Set(Array(guides.length).keys()), 0, finals, transitions);
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Translates Pattern instances into a corresponding Fsm.
     */
    class FsmTranslator {
        /** */
        static exec(units) {
            for (const unit of units) {
                if (unit instanceof Truth.RegexSet) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexGroup) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexGrapheme) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexSign) {
                    throw Truth.Exception.notImplemented();
                }
                else
                    throw Truth.Exception.unknownState();
            }
            return null;
        }
        /** */
        static translateSet(set, alpha = null) {
        }
        /** */
        static translateGroup(group, alpha = null) {
            const builder = alpha || new Truth.AlphabetBuilder().addWild();
        }
        /** */
        static createGroupAlphabet(group) {
            const builder = new Truth.AlphabetBuilder();
            builder.addWild();
            for (const element of group.cases) {
                throw Truth.Exception.notImplemented();
            }
        }
        /** */
        static translateGrapheme(grapheme, alpha = null) {
        }
        /** */
        static translateSign(sign, alpha = null) {
        }
    }
    Truth.FsmTranslator = FsmTranslator;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Document {
        /**
         * @internal
         * Internal constructor for Document objects.
         * Document objects are created via a Program
         * object.
         */
        constructor(program, sourceUri, sourceText) {
            this._types = null;
            /**
             * Stores the complete list of the Document's statements,
             * sorted in the order that they appear in the file.
             */
            this.statements = [];
            /**
             * A state variable that stores whether an
             * edit transaction is currently underway.
             */
            this.inEdit = false;
            this._version = Truth.VersionStamp.next();
            if (sourceUri.types.length)
                throw Truth.Exception.invalidArgument();
            this.program = program;
            this._sourceUri = sourceUri;
            if (this.inEdit)
                throw Truth.Exception.doubleTransaction();
            this.statements.length = 0;
            for (const statementText of readLines(sourceText))
                this.statements.push(new Truth.Statement(this, statementText));
            program.on(Truth.CauseDocumentUriChange, data => {
                if (data.document === this) {
                    if (this.inEdit)
                        throw Truth.Exception.invalidWhileInEditTransaction();
                    this._sourceUri = data.newUri;
                }
            });
        }
        /**
         * Queries this document for the root-level types.
         *
         * @param uri The URI of the document to query. If the URI contains
         * a type path, it is factored into the search.
         *
         * @param typePath The type path within the document to search.
         *
         * @returns A fully constructed Type instance that corresponds to
         * the type at the URI specified, or null in the case when no type
         * could be found.
         */
        query(...typePath) {
            return this.program.query(this, ...typePath);
        }
        /**
         * Gets the root-level types that are defined within this document.
         */
        get types() {
            if (this._types)
                return this._types;
            return this._types = Object.freeze(this.program.query(this));
        }
        /**
         * @returns An array of Statement objects that represent
         * ancestry of the specified statement. If the specified
         * statement is not in this document, the returned value
         * is null.
         */
        getAncestry(statement) {
            const smt = this.toStatement(statement);
            // If the statement is root-level, it can't have an ancestry.
            if (smt.indent === 0)
                return [];
            const startingIndex = this.toLineNumber(statement);
            if (startingIndex < 0)
                return null;
            if (startingIndex === 0)
                return [];
            const ancestry = [smt];
            let indentToBeat = smt.indent;
            for (let idx = startingIndex; --idx > -1;) {
                const currentStatement = this.statements[idx];
                if (currentStatement.isNoop)
                    continue;
                if (currentStatement.indent < indentToBeat) {
                    ancestry.unshift(currentStatement);
                    indentToBeat = currentStatement.indent;
                }
                if (currentStatement.indent === 0)
                    break;
            }
            return ancestry.slice(0, -1);
        }
        /**
         * @returns The parent Statement object of the specified
         * Statement. If the statement is top level, a reference to
         * this document object is returned. If the statement is
         * not found in the document, or the specified statement
         * is a no-op, the returned value is null.
         */
        getParent(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return null;
            // If the statement is root-level, it can't have a parent.
            if (smt.indent === 0)
                return this;
            const startingIndex = this.toLineNumber(statement);
            if (startingIndex < 0)
                return null;
            if (startingIndex === 0)
                return this;
            const currentIndent = smt.indent;
            for (let idx = startingIndex; --idx > -1;) {
                const currentStatement = this.statements[idx];
                if (currentStatement.isNoop)
                    continue;
                if (currentStatement.indent < currentIndent)
                    return currentStatement;
            }
            // If a parent statement wasn't found, then the
            // input statement is top-level, and a reference
            // to this Document object is returned.
            return this;
        }
        /**
         * @returns The Statement that would act as the parent
         * if a statement where to be inserted at the specified
         * virtual position in the document. If an inserted
         * statement would be top-level, a reference to this
         * document object is returned.
         */
        getParentFromPosition(virtualLine, virtualOffset) {
            if (virtualLine === 0 || virtualOffset < 1 || this.statements.length === 0)
                return this;
            const line = applyBounds(virtualLine, this.statements.length);
            for (let idx = line; idx--;) {
                const currentStatement = this.statements[idx];
                if (!currentStatement.isNoop && currentStatement.indent < virtualOffset)
                    return currentStatement;
            }
            return this;
        }
        /**
         * @returns The sibling Statement objects of the
         * specified Statement. If the specified statement
         * is not found in the document, or is a no-op, the
         * returned value is null.
         */
        getSiblings(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return null;
            if (smt.indent === 0)
                return this.getChildren(null);
            const parent = this.getParent(smt);
            if (parent === null)
                return null;
            if (parent === this)
                return parent.getChildren(null);
            return this.getChildren(parent);
        }
        /**
         * @returns The child Statement objects of the specified
         * Statement. If the argument is null or omitted, the document's
         * top-level statements are returned. If the specified statement
         * is not found in the document, the returned value is null.
         */
        getChildren(statement = null) {
            const children = [];
            // Stores the indent value that causes the loop
            // to terminate when reached.
            const breakIndent = statement ? statement.indent : -1;
            let childIndent = Number.MAX_SAFE_INTEGER;
            const startIdx = statement ?
                this.getLineNumber(statement) :
                -1;
            if (startIdx >= this.statements.length)
                return [];
            for (let idx = startIdx; ++idx < this.statements.length;) {
                const currentStatement = this.statements[idx];
                if (currentStatement.isNoop)
                    continue;
                // Check if we need to back up the indentation
                // of child statements, in order to deal with bizarre
                // (but unfortunately, valid) indentation.
                if (currentStatement.indent < childIndent)
                    childIndent = currentStatement.indent;
                // If we've reached the end of a series of a
                // statement locality.
                if (currentStatement.indent <= breakIndent)
                    break;
                if (currentStatement.indent <= childIndent)
                    children.push(currentStatement);
            }
            return children;
        }
        /**
         * @returns A boolean value that indicates whether the specified
         * statement, or the statement at the specified index has any
         * descendants. If the argument is null, the returned value is a
         * boolean indicating whether this document has any non-noop
         * statements.
         */
        hasDescendants(statement) {
            if (statement === null) {
                for (let idx = -1; ++idx < this.statements.length;)
                    if (!this.statements[idx].isNoop)
                        return true;
            }
            else {
                const smt = statement instanceof Truth.Statement ?
                    statement :
                    this.statements[statement];
                if (smt.isNoop)
                    return false;
                let idx = statement instanceof Truth.Statement ?
                    this.getLineNumber(statement) :
                    statement;
                while (++idx < this.statements.length) {
                    const currentStatement = this.statements[idx];
                    if (currentStatement.isNoop)
                        continue;
                    return currentStatement.indent > smt.indent;
                }
            }
            return false;
        }
        /**
         * @returns The index of the specified statement in
         * the document, relying on caching when available.
         * If the statement does not exist in the document,
         * the returned value is -1.
         */
        getLineNumber(statement) {
            return this.statements.indexOf(statement);
        }
        /**
         * @returns An array of strings containing the content
         * written in the comments directly above the specified
         * statement. Whitespace lines are ignored. If the specified
         * statement is a no-op, an empty array is returned.
         */
        getNotes(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return [];
            const lineNum = this.getLineNumber(smt);
            if (lineNum < 1)
                return [];
            const commentLines = [];
            const requiredIndent = smt.indent;
            for (let num = lineNum; num--;) {
                const currentStatement = this.statements[num];
                if (currentStatement.isWhitespace)
                    continue;
                const commentText = currentStatement.getCommentText();
                if (commentText === null)
                    break;
                if (currentStatement.indent !== requiredIndent)
                    break;
                commentLines.push(commentText);
            }
            return commentLines;
        }
        /**
         * Enumerates through each statement that is a descendant of the
         * specified statement. If the parameters are null or omitted, all
         * statements in this Document are yielded.
         *
         * The method yields an object that contains the yielded statement,
         * as well as a numeric level value that specifies the difference in
         * the number of nesting levels between the specified initialStatement
         * and the yielded statement.
         *
         * @param initialStatement A reference to the statement object
         * from where the enumeration should begin.
         *
         * @param includeInitial A boolean value indicating whether or
         * not the specified initialStatement should also be returned
         * as an element in the enumeration. If true, initialStatement
         * must be non-null.
         */
        *eachDescendant(initialStatement = null, includeInitial) {
            if (includeInitial) {
                if (!initialStatement)
                    throw Truth.Exception.invalidArgument();
                yield { statement: initialStatement, level: 0 };
            }
            const initialChildren = this.getChildren(initialStatement);
            const self = this;
            // The initial level is 0 if the specified initialStatement is
            // null, because it indicates that the enumeration starts
            // at the root of the document.
            let level = initialStatement ? 1 : 0;
            function* recurse(statement) {
                yield { statement, level };
                level++;
                for (const childStatement of self.getChildren(statement))
                    yield* recurse(childStatement);
                level--;
            }
            for (const statement of initialChildren)
                yield* recurse(statement);
        }
        /**
         * @deprecated
         * Enumerates through each unique URI defined in this document,
         * that are referenced within the descendants of the specified
         * statement. If the parameters are null or omitted, all unique
         * URIs referenced in this document are yielded.
         *
         * @param initialStatement A reference to the statement object
         * from where the enumeration should begin.
         *
         * @param includeInitial A boolean value indicating whether or
         * not the specified initialStatement should also be returned
         * as an element in the enumeration. If true, initialStatement
         * must be non-null.
         */
        *eachUri(initialStatement = null, includeInitial) {
            //
            // NOTE: Although this method is deprecated, if it were
            // to be revived, it would need to support "cruft".
            //
            const yieldedUris = new Set();
            const iter = this.eachDescendant(initialStatement, includeInitial);
            for (const descendant of iter) {
                for (const span of descendant.statement.declarations) {
                    for (const spine of span.factor()) {
                        const uri = Truth.Uri.clone(spine);
                        const uriText = uri.toString();
                        if (!yieldedUris.has(uriText)) {
                            yieldedUris.add(uriText);
                            yield { uri, uriText };
                        }
                    }
                }
            }
        }
        /**
         * Enumerates through each statement in the document,
         * including comments and whitespace-only lines, starting
         * at the specified statement or numeric position.
         *
         * @yields The statements in the order that they appear
         * in the document, excluding whitespace-only statements.
         */
        *eachStatement(statement) {
            const startNum = (() => {
                if (!statement)
                    return 0;
                if (statement instanceof Truth.Statement)
                    return this.getLineNumber(statement);
                return statement;
            })();
            for (let i = startNum - 1; ++i < this.statements.length;)
                yield this.statements[i];
        }
        /**
         * Reads the Statement at the given position.
         * Negative numbers read Statement starting from the end of the document.
         */
        read(lineNumber) {
            const lineBounded = applyBounds(lineNumber, this.statements.length);
            return this.statements[lineBounded];
        }
        /**
         * Convenience method that converts a statement or it's index
         * within this document to a statement object.
         */
        toStatement(statementOrIndex) {
            return statementOrIndex instanceof Truth.Statement ?
                statementOrIndex :
                this.read(statementOrIndex);
        }
        /**
         * Convenience method to quickly turn a value that may be
         * a statement or a statement index, into a bounded statement
         * index.
         */
        toLineNumber(statementOrIndex) {
            return statementOrIndex instanceof Truth.Statement ?
                this.getLineNumber(statementOrIndex) :
                applyBounds(statementOrIndex, this.statements.length);
        }
        /**
         * Starts an edit transaction in the specified callback function.
         * Edit transactions are used to synchronize changes made in
         * an underlying file, typically done by a user in a text editing
         * environment. System-initiated changes such as automated
         * fixes, refactors, or renames do not go through this pathway.
         *
         * @param editFn The callback function in which to perform
         * document mutation operations.
         */
        edit(editFn) {
            if (this.inEdit)
                throw Truth.Exception.doubleTransaction();
            class InsertCall {
                constructor(smt, at) {
                    this.smt = smt;
                    this.at = at;
                }
            }
            class UpdateCall {
                constructor(smt, at) {
                    this.smt = smt;
                    this.at = at;
                }
            }
            class DeleteCall {
                constructor(at, count) {
                    this.at = at;
                    this.count = count;
                }
            }
            const calls = [];
            let hasDelete = false;
            let hasInsert = false;
            let hasUpdate = false;
            this.inEdit = true;
            editFn({
                delete: (at = -1, count = 1) => {
                    if (count > 0) {
                        calls.push(new DeleteCall(at, count));
                        hasDelete = true;
                    }
                },
                insert: (text, at = -1) => {
                    calls.push(new InsertCall(new Truth.Statement(this, text), at));
                    hasInsert = true;
                },
                update: (text, at = -1) => {
                    const boundAt = applyBounds(at, this.statements.length);
                    if (this.read(boundAt).sourceText !== text) {
                        calls.push(new UpdateCall(new Truth.Statement(this, text), at));
                        hasUpdate = true;
                    }
                }
            });
            if (calls.length === 0) {
                this.inEdit = false;
                return;
            }
            // Begin the algorithm that determines the changeset,
            // and runs the appropriate invalidation and revalidation
            // hooks. This is wrapped in an IIFE because we need to
            // perform finalization at the bottom (and there are early
            // return points throughout the algorithm.
            (() => {
                const hasMixed = hasInsert && hasUpdate ||
                    hasInsert && hasDelete ||
                    hasUpdate && hasDelete;
                const boundAt = (call) => applyBounds(call.at, this.statements.length);
                const doDelete = (call) => {
                    const at = boundAt(call);
                    const smts = this.statements.splice(at, call.count);
                    for (const smt of smts)
                        smt.dispose();
                    return smts;
                };
                const doInsert = (call) => {
                    if (call.at >= this.statements.length) {
                        this.statements.push(call.smt);
                    }
                    else {
                        const at = boundAt(call);
                        this.statements.splice(at, 0, call.smt);
                    }
                };
                const doUpdate = (call) => {
                    const at = boundAt(call);
                    this.statements[at].dispose();
                    this.statements[at] = call.smt;
                };
                if (!hasMixed) {
                    // This handles the first optimization, which is the case where
                    // the only kinds of mutations where updates, and no structural
                    // changes occured. This handles typical "user is typing" cases.
                    // Most edits will be caught here.
                    if (hasUpdate) {
                        // Sort the update calls by their index, and prune updates
                        // that would be overridden in a following call.
                        //! Remove this unnecessary variable once we can do that
                        //! without ESLint complaining (unnecessary brackets).
                        const updateCallsTyped = calls;
                        const updateCalls = updateCallsTyped
                            .sort((a, b) => a.at - b.at)
                            .filter((call, i) => i >= calls.length - 1 || call.at !== calls[i + 1].at);
                        const oldStatements = updateCalls.map(c => this.statements[c.at]);
                        const newStatements = updateCalls.map(c => c.smt);
                        const indexes = Object.freeze(updateCalls.map(c => c.at));
                        const noStructuralChanges = oldStatements.every((oldSmt, idx) => {
                            const newSmt = newStatements[idx];
                            return oldSmt.indent === newSmt.indent ||
                                oldSmt.isNoop && newSmt.isNoop;
                        });
                        if (noStructuralChanges) {
                            const hasOpStatements = oldStatements.some(smt => !smt.isNoop) ||
                                newStatements.some(smt => !smt.isNoop);
                            if (hasOpStatements) {
                                // Tell subscribers to blow away all the old statements.
                                this.program.cause(new Truth.CauseInvalidate(this, oldStatements, indexes));
                            }
                            // Run the actual mutations
                            for (const updateCall of updateCalls)
                                doUpdate(updateCall);
                            if (hasOpStatements) {
                                // Tell subscribers what changed
                                this.program.cause(new Truth.CauseRevalidate(this, newStatements, indexes));
                            }
                            return;
                        }
                    }
                    // This handles the second optimization, which is the case where
                    // only deletes occured, and none of the deleted statements have any
                    // descendants. This will handle the majority of "delete a line" cases.
                    if (hasDelete) {
                        const deleteCalls = calls;
                        const deadStatements = [];
                        const deadIndexes = [];
                        let hasOpStatements = false;
                        forCalls: for (const deleteCall of deleteCalls) {
                            for (let i = -1; ++i < deleteCall.count;) {
                                const deadSmt = this.statements[deleteCall.at + i];
                                if (this.hasDescendants(deadSmt)) {
                                    deadStatements.length = 0;
                                    break forCalls;
                                }
                                deadStatements.push(deadSmt);
                                deadIndexes.push(i);
                                if (!deadSmt.isNoop)
                                    hasOpStatements = true;
                            }
                        }
                        if (deadStatements.length > 0) {
                            // Tell subscribers to blow away all the old statements.
                            // An edit transaction can be avoided completely in the case
                            // when the only statements that were deleted were noops.
                            if (hasOpStatements)
                                this.program.cause(new Truth.CauseInvalidate(this, deadStatements, deadIndexes));
                            // Run the actual mutations
                            deleteCalls.forEach(doDelete);
                            // Run an empty revalidation hook, to comply with the
                            // rule that for every invalidation hook, there is always a
                            // corresponding revalidation hook.
                            if (hasOpStatements)
                                this.program.cause(new Truth.CauseRevalidate(this, [], []));
                            return;
                        }
                    }
                    // This handles the third optimization, which is the case
                    // where there are only noop statements being inserted
                    // into the document.
                    if (hasInsert) {
                        const insertCalls = calls;
                        if (insertCalls.every(call => call.smt.isNoop)) {
                            insertCalls.forEach(doInsert);
                            return;
                        }
                    }
                }
                // At this point, the checks to see if we can get away with
                // performing simplistic updates have failed. So we need
                // to resort to invalidating and revalidating larger swaths 
                // of statements.
                // Stores an array of statements whose descendant statements
                // should be invalidated. 
                //const invalidatedParents: { at: number; parent: Statement; }[] = [];
                const invalidatedParents = new Map();
                // Stores a value indicating whether the entire document
                // needs to be invalidated.
                let mustInvalidateDoc = false;
                // The first step is to go through all the statements, and compute the 
                // set of parent statements from where invalidation should originate.
                // In the majority of cases, this will only be one single statement object.
                for (const call of calls) {
                    const atBounded = applyBounds(call.at, this.statements.length);
                    if (call instanceof DeleteCall) {
                        const deletedStatement = this.statements[atBounded];
                        if (deletedStatement.isNoop)
                            continue;
                        const parent = this.getParent(atBounded);
                        if (parent instanceof Truth.Statement) {
                            invalidatedParents.set(call.at, parent);
                        }
                        else if (parent instanceof Document) {
                            mustInvalidateDoc = true;
                            break;
                        }
                        else
                            throw Truth.Exception.unknownState();
                    }
                    else {
                        if (call instanceof InsertCall) {
                            if (call.smt.isNoop)
                                continue;
                        }
                        else if (call instanceof UpdateCall) {
                            const oldStatement = this.statements[atBounded];
                            if (oldStatement.isNoop && call.smt.isNoop)
                                continue;
                        }
                        const parent = this.getParentFromPosition(call.at, call.smt.indent);
                        if (parent instanceof Truth.Statement) {
                            invalidatedParents.set(call.at, parent);
                        }
                        else if (parent === this) {
                            mustInvalidateDoc = true;
                            break;
                        }
                    }
                }
                // Although unclear how this could happen, if there
                // are no invalidated parents, we can safely return.
                if (!mustInvalidateDoc && invalidatedParents.size === 0)
                    return;
                // Prune any redundant parents. A parent is redundant
                // when it's a descendant of another parent in the 
                // invalidation array. The algorithm below compares the
                // statement ancestries of each possible pairs of invalidated
                // parents, and splices invalidated parents out of the 
                // array in the case when the parent is parented by some
                // other invalidated parent in the invalidatedParents array.
                const invalidatedAncestries = [];
                for (const at of invalidatedParents.keys()) {
                    const ancestry = this.getAncestry(at);
                    if (ancestry)
                        invalidatedAncestries.push(ancestry);
                }
                if (invalidatedAncestries.length > 1) {
                    for (let i = invalidatedAncestries.length; i--;) {
                        const ancestryA = invalidatedAncestries[i];
                        for (let n = i; n--;) {
                            const ancestryB = invalidatedAncestries[n];
                            if (ancestryA.length === ancestryB.length)
                                continue;
                            const aLessB = ancestryA.length < ancestryB.length;
                            const ancestryShort = aLessB ? ancestryA : ancestryB;
                            const ancestryLong = aLessB ? ancestryB : ancestryA;
                            if (ancestryShort.every((smt, idx) => smt === ancestryLong[idx]))
                                invalidatedAncestries.splice(aLessB ? n : i, 1);
                        }
                    }
                }
                const parents = mustInvalidateDoc ? [] : Array.from(invalidatedParents.values());
                const indexes = mustInvalidateDoc ? [] : Array.from(invalidatedParents.keys());
                // Notify observers of the Invalidate hook to invalidate the
                // descendants of the specified set of parent statements.
                this.program.cause(new Truth.CauseInvalidate(this, parents, indexes));
                const deletedStatements = [];
                // Perform the document mutations.
                for (const call of calls) {
                    if (call instanceof DeleteCall)
                        deletedStatements.push(...doDelete(call));
                    else if (call instanceof InsertCall)
                        doInsert(call);
                    else if (call instanceof UpdateCall)
                        doUpdate(call);
                }
                // Remove any deleted statements from the invalidatedParents map
                for (const deletedStatement of deletedStatements)
                    for (const [at, parentStatement] of invalidatedParents)
                        if (deletedStatement === parentStatement)
                            invalidatedParents.delete(at);
                // Notify observers of the Revalidate hook to update the
                // descendants of the specified set of parent statements.
                this.program.cause(new Truth.CauseRevalidate(this, Array.from(invalidatedParents.values()), Array.from(invalidatedParents.keys())));
            })();
            // Perform a debug-time check to be sure that there are
            // no disposed statements left hanging around in the document
            // after the edit transaction has completed.
            if ("DEBUG")
                for (const smt of this.statements)
                    if (smt.isDisposed)
                        throw Truth.Exception.unknownState();
            // Clean out any type cache
            this._types = null;
            // Tell subscribers that the edit transaction completed.
            this.program.cause(new Truth.CauseEditComplete(this));
            this._version = Truth.VersionStamp.next();
            this.inEdit = false;
        }
        /**
         * Executes a complete edit transaction, applying the series
         * of edits specified in the `edits` parameter.
         */
        editAtomic(edits) {
            this.edit(statements => {
                for (const editInfo of edits) {
                    if (!editInfo.range)
                        throw new TypeError("No range included.");
                    const startLine = editInfo.range.startLineNumber - 1;
                    const endLine = editInfo.range.endLineNumber - 1;
                    const startChar = editInfo.range.startColumn - 1;
                    const endChar = editInfo.range.endColumn - 1;
                    const startLineText = this.read(startLine).sourceText;
                    const endLineText = this.read(endLine).sourceText;
                    const prefixSegment = startLineText.slice(0, startChar);
                    const suffixSegment = endLineText.slice(endChar);
                    const segments = editInfo.text.split("\n");
                    const pastCount = endLine - startLine + 1;
                    const presentCount = segments.length;
                    const deltaCount = presentCount - pastCount;
                    // Detect the pure update cases
                    if (deltaCount === 0) {
                        if (pastCount === 1) {
                            statements.update(prefixSegment + editInfo.text + suffixSegment, startLine);
                        }
                        else {
                            statements.update(prefixSegment + segments[0], startLine);
                            for (let i = startLine; i <= endLine; i++) {
                                statements.update(prefixSegment + segments[i] + suffixSegment, startLine);
                            }
                            statements.update(segments.slice(-1)[0] + suffixSegment, endLine);
                        }
                        continue;
                    }
                    // Detect the pure delete cases
                    if (deltaCount < 0) {
                        const deleteCount = deltaCount * -1;
                        // Detect a delete ranging from the end of 
                        // one line, to the end of a successive line
                        if (startChar === startLineText.length)
                            if (endChar === endLineText.length) {
                                statements.delete(startLine + 1, deleteCount);
                                continue;
                            }
                        // Detect a delete ranging from the start of
                        // one line to the start of a successive line
                        if (startChar + endChar === 0) {
                            statements.delete(startLine, deleteCount);
                            continue;
                        }
                    }
                    // Detect the pure insert cases
                    if (deltaCount > 0) {
                        // Cursor is at the end of the line, and the first line of the 
                        // inserted content is empty (most likely, enter was pressed)						
                        if (startChar === startLineText.length && segments[0] === "") {
                            for (let i = 0; ++i < segments.length;)
                                statements.insert(segments[i], startLine + i);
                            continue;
                        }
                        // Cursor is at the beginning of the line, and the
                        // last line of the inserted content is empty.
                        if (startChar === 0 && segments.slice(-1)[0] === "") {
                            for (let i = -1; ++i < segments.length - 1;)
                                statements.insert(segments[i], startLine + i);
                            continue;
                        }
                    }
                    // This is the "fallback" behavior -- simply delete everything
                    // that is old, and insert everything that is new.
                    const deleteCount = endLine - startLine + 1;
                    statements.delete(startLine, deleteCount);
                    const insertLines = segments.slice();
                    insertLines[0] = prefixSegment + insertLines[0];
                    insertLines[insertLines.length - 1] += suffixSegment;
                    for (let i = -1; ++i < insertLines.length;)
                        statements.insert(insertLines[i], startLine + i);
                }
            });
        }
        /** Stores the URI from where this document was loaded. */
        get sourceUri() {
            return this._sourceUri;
        }
        /**
         * @internal
         * A rolling version stamp that increments after each edit transaction.
         */
        get version() {
            return this._version;
        }
        /**
         * Returns a formatted version of the Document.
         */
        toString(keepOriginalFormatting) {
            const lines = [];
            if (keepOriginalFormatting) {
                for (const statement of this.statements)
                    lines.push(statement.sourceText);
            }
            else
                for (const { statement, level } of this.eachDescendant()) {
                    const indent = "\t" /* tab */.repeat(level);
                    lines.push(indent + statement.toString());
                }
            return lines.join("\n");
        }
    }
    Truth.Document = Document;
    /**
     * Generator function that yields all statements (unparsed lines)
     * of the given source text.
     */
    function* readLines(source) {
        let cursor = -1;
        let statementStart = 0;
        const char = () => source[cursor];
        for (;;) {
            if (cursor >= source.length - 1)
                return yield source.slice(statementStart);
            cursor++;
            if (char() === "\n" /* terminal */) {
                yield source.slice(statementStart, cursor);
                statementStart = cursor + 1;
            }
        }
    }
    /**
     * Performs the integer bounding and wrapping formula that is
     * common on all positional arguments found in JavaScript array
     * and string methods (such as Array.slice).
     */
    function applyBounds(index, length) {
        if (index === 0 || length === 0)
            return 0;
        if (index > 0)
            return Math.min(index, length - 1);
        if (index < 0)
            return Math.max(length + index, 0);
        throw Truth.Exception.unknownState();
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that stores all the documents loaded into a
     * program, and the inter-dependencies between them.
     */
    class DocumentGraph {
        /** */
        constructor(program) {
            /**
             * An array of functions that should be executed when
             * all outstanding async operations have completed.
             */
            this.waitFns = [];
            /**
             * Counts the number of async operations in progress.
             */
            this.asyncCount = 0;
            /**
             * A map of documents loaded into the graph,
             * indexed by their URIs.
             */
            this.documents = new Map();
            /**
             * A map of each document's dependencies.
             */
            this.dependencies = new Map();
            /**
             * A map of the documents that depend on each document.
             */
            this.dependents = new Map();
            this.program = program;
            program.on(Truth.CauseDocumentUriChange, data => {
                for (const [oldUriText, docEntry] of this.documents) {
                    if (docEntry.document !== data.document)
                        continue;
                    const newUriText = data.newUri.toStoreString();
                    const entry = this.documents.get(oldUriText);
                    if (entry) {
                        this.documents.delete(oldUriText);
                        this.documents.set(newUriText, entry);
                    }
                    return;
                }
            });
            program.on(Truth.CauseRevalidate, data => {
                const docUri = data.document.sourceUri.toString();
                const entry = this.documents.get(docUri);
                const header = entry ? entry.header : null;
                // The header is being re-computed on every document
                // modification. There may be some optimizations here
                // to eliminate recompute in common cases, but it would
                // be a micro-optimization at the time of this writing.
                if (header)
                    header.recompute();
            });
            program.on(Truth.CauseUriReferenceAdd, data => {
                if (data.uri.ext !== ".truth" /* truth */)
                    return;
                const smt = data.statement;
                if (smt)
                    this.tryLink(smt.document, smt, data.uri);
            });
            program.on(Truth.CauseUriReferenceRemove, data => {
                if (data.uri.ext !== ".truth" /* truth */)
                    return;
                const entry = this.documents.get(data.uri.toStoreString());
                if (!entry)
                    return;
                const smt = data.statement;
                if (smt)
                    this.unlink(smt.document, entry.document);
            });
        }
        /**
         * Reads a Document from the specified URI.
         * The document is created and returned, asynchronously.
         */
        async read(uri) {
            const uriParsed = Truth.Uri.tryParse(uri);
            if (!uriParsed)
                throw Truth.Exception.invalidUri();
            const uriAbsolute = uriParsed.toAbsolute();
            if (!uriAbsolute)
                throw Truth.Exception.unknownState();
            const readResult = await Truth.UriReader.tryRead(uriAbsolute);
            if (readResult instanceof Error)
                return readResult;
            return this.create(uriAbsolute, readResult);
        }
        create(param1, param2) {
            const zeroArgs = arguments.length === 0;
            const oneArg = arguments.length === 1;
            const uri = (() => {
                if (zeroArgs || oneArg)
                    return Truth.Uri.createInternal();
                if (!param1)
                    return null;
                if (param1 instanceof Truth.Uri)
                    return param1;
                return Truth.Uri.tryParse(param1);
            })();
            if (!uri)
                throw Truth.Exception.invalidUri();
            const sourceText = zeroArgs ? "" :
                oneArg ? (param1 || "").toString() :
                    param2 || "";
            const document = new Truth.Document(this.program, uri, sourceText);
            const header = new Truth.DocumentHeader(document);
            const entry = { document, header };
            this.documents.set(uri.toStoreString(), entry);
            header.recompute();
            this.program.cause(new Truth.CauseDocumentCreate(document));
            return document;
        }
        /**
         * Blocks execution until all queued IO operations have completed.
         */
        await() {
            return new Promise(resolve => {
                if (this.asyncCount === 0)
                    resolve();
                else
                    this.waitFns.push(resolve);
            });
        }
        /**
         * @returns The document loaded into this graph
         * with the specified URI.
         */
        get(uri) {
            const uriText = typeof uri === "string" ? uri : uri.toStoreString();
            const entry = this.documents.get(uriText);
            return entry ? entry.document : null;
        }
        /**
         * @returns A boolean value that indicates whether
         * the specified Document has been loaded into
         * this DocumentGraph.
         */
        has(param) {
            if (param instanceof Truth.Document) {
                for (const entry of this.documents.values())
                    if (entry.document === param)
                        return true;
                return false;
            }
            return !!this.get(param);
        }
        /**
         * @returns An array containing all documents loaded into this
         * DocumentGraph. The array returned is sorted topologically
         * from left to right, so that forward traversals are guaranteed
         * to not cause dependency conflicts.
         */
        each() {
            // The topological sorting mechanism uses a variant of depth-first search.
            // Algorithm is described here: https://en.wikipedia.org/wiki/Topological_sorting
            const sortedResult = [];
            const docsFinalized = new Set();
            const docsInStack = new Set();
            const allDocs = Array.from(this.documents.values())
                .map(entry => entry.document);
            const recurse = (currentDoc) => {
                if (docsFinalized.has(currentDoc))
                    return;
                // Cycle detected. This condition should never pass because
                // DocumentGraph is supposed to prevent cycles.
                if (docsInStack.has(currentDoc))
                    throw Truth.Exception.unknownState();
                docsInStack.add(currentDoc);
                const deps = this.dependencies.get(currentDoc);
                if (deps)
                    for (const dep of deps)
                        recurse(dep.target);
                docsFinalized.add(currentDoc);
                sortedResult.unshift(currentDoc);
            };
            while (docsFinalized.size < allDocs.length) {
                const nextUnvisited = allDocs.find(d => !docsFinalized.has(d));
                if (!nextUnvisited)
                    throw Truth.Exception.unknownState();
                recurse(nextUnvisited);
            }
            return sortedResult;
        }
        /**
         * Deletes a document that was previously loaded into the compiler.
         * Intended to be called by the host environment when a file changes.
         */
        delete(target) {
            const doc = target instanceof Truth.Document ? target : (() => {
                const entry = this.documents.get(target.toString());
                return entry ? entry.document : null;
            })();
            if (!doc)
                return;
            this.program.cause(new Truth.CauseDocumentCreate(doc));
            // Go through the entire map of dependent documents, 
            // and find documents that have the deleted document 
            // listed as one of it's dependents. These documents are
            // then removed from the array of dependents.
            for (const [refDoc, dependents] of this.dependents) {
                const docIdx = dependents.indexOf(doc);
                if (docIdx > -1)
                    dependents.splice(docIdx, 1);
                if (dependents.length === 0)
                    this.dependents.delete(refDoc);
            }
            // Delete the dependencies of the document
            // after we're done clearing out the dependents.
            this.dependencies.delete(doc);
            // Delete the deleted document last
            this.documents.delete(doc.sourceUri.toString());
        }
        /**
         * Removes all documents from this graph.
         */
        clear() {
            this.documents.clear();
            this.dependencies.clear();
            this.dependents.clear();
        }
        /**
         * @returns An array containing the dependencies
         * associated with the specified document. The returned
         * array is sorted in the order in which the dependencies
         * are defined in the document.
         */
        getDependencies(doc) {
            const dependencies = this.dependencies.get(doc);
            if (!dependencies)
                return [];
            const urisSorted = [];
            const docDependencies = dependencies.map(d => d.target);
            const entry = this.documents.get(doc.sourceUri.toString());
            if (entry === undefined)
                throw Truth.Exception.unknownState();
            for (const statement of doc.eachStatement()) {
                if (statement.isNoop)
                    continue;
                // If a non-noop statement is reached that isn't a part
                // of the header, the end of the header has been reached.
                const refUri = entry.header.getHeaderUri(statement);
                if (!refUri)
                    break;
                urisSorted.push(refUri.toString());
            }
            const depsSorted = urisSorted.map(uriText => Truth.Not.undefined(docDependencies.find(docDep => docDep.sourceUri.toString() === uriText)));
            if (depsSorted.some(d => d === undefined))
                throw Truth.Exception.unknownState();
            return depsSorted;
        }
        /**
         * @returns An array containing the dependents
         * associated with the specified document.
         */
        getDependents(doc) {
            const dependents = this.dependents.get(doc);
            return dependents ?
                dependents.slice() :
                [];
        }
        /**
         * Attempts to add a link from one document to another,
         * via the specified URI. If there is some reason why the
         * link cannot be established, (circular references, bad
         * URIs), no link is added, and a fault is reported.
         */
        tryLink(containingDocument, containingStatement, uri) {
            this.asyncCount++;
            const uriText = uri.toString();
            setTimeout(() => (async () => {
                const refDocument = await (async () => {
                    // Is the document already loaded into the graph?
                    const existingEntry = this.documents.get(uriText);
                    if (existingEntry)
                        return existingEntry.document;
                    // Read the document if it wasn't loaded
                    const result = await this.read(uri);
                    if (result instanceof Error) {
                        const fault = Truth.Faults.UnresolvedResource.create(containingStatement);
                        this.program.faults.reportAsync(fault);
                        return null;
                    }
                    const newEntry = this.documents.get(uriText);
                    if (!newEntry)
                        throw Truth.Exception.unknownState();
                    return newEntry.document;
                })();
                if (!refDocument)
                    return;
                // Bail if a document loaded from HTTP is trying to reference
                // a document located on the file system.
                const srcProto = containingDocument.sourceUri.protocol;
                const dstProto = refDocument.sourceUri.protocol;
                if ((srcProto === Truth.UriProtocol.http || srcProto === Truth.UriProtocol.https) &&
                    dstProto === Truth.UriProtocol.file) {
                    const param = Truth.Faults.InsecureResourceReference.create(containingStatement);
                    this.program.faults.reportAsync(param);
                }
                // Bail if the addition of the reference is going to result in a circular reference.
                if (this.wouldCreateCycles(containingDocument, refDocument)) {
                    const param = Truth.Faults.CircularResourceReference.create(containingStatement);
                    this.program.faults.reportAsync(param);
                }
                else {
                    this.link(containingDocument, refDocument);
                }
                this.asyncCount--;
                if (this.asyncCount < 0)
                    throw Truth.Exception.unknownState();
                if (this.asyncCount === 0) {
                    const waitFns = this.waitFns.slice();
                    this.waitFns.length = 0;
                    waitFns.forEach(fn => fn());
                }
            })(), 0);
        }
        /**
         * Checks to see if the addition of a reference between the two
         * specified documents would result in a document graph with
         * circular relationships.
         *
         * The algorithm used performs a depth-first dependency search,
         * starting at the candidateTo. If the traversal pattern is able to
         * make its way to candidateFrom, it can be concluded that the
         * addition of the proposed reference would result in a cyclical
         * relationship.
         */
        wouldCreateCycles(proposedFrom, proposedTo) {
            const checkForCyclesRecursive = (current) => {
                if (current === proposedFrom)
                    return true;
                const dependencies = (this.dependencies.get(current) || []).map(d => d.target);
                if (dependencies.length === 0)
                    return false;
                if (current === proposedFrom)
                    dependencies.unshift(proposedTo);
                if (dependencies.some(d => checkForCyclesRecursive(d)))
                    return true;
                return false;
            };
            return checkForCyclesRecursive(proposedTo);
        }
        /**
         * Adds a dependency between two documents in the graph.
         * If a dependency between the two documents already exists,
         * the reference count of the dependency is incremented.
         * This method is executed only after other methods have
         * indicated that the addition of the link will not cause conflict.
         */
        link(from, to) {
            const dependencyArray = this.dependencies.get(from);
            if (dependencyArray) {
                const dependency = dependencyArray.find(d => d.target === to);
                if (dependency)
                    dependency.referenceCount++;
                else
                    dependencyArray.push(new Dependency(to));
            }
            else {
                this.dependencies.set(from, [new Dependency(to)]);
            }
            const dependentArray = this.dependents.get(to);
            if (dependentArray) {
                if (!dependentArray.includes(from))
                    dependentArray.push(from);
            }
            else {
                this.dependents.set(to, [from]);
            }
        }
        /**
         * Removes a dependency between two documents in the graph.
         * If the reference count of the dependency is greater than 1, the
         * the reference count is decremented instead of the dependency
         * being removed completely.
         */
        unlink(from, to) {
            const dependencyArray = this.dependencies.get(from);
            if (!dependencyArray)
                return;
            const dependencyIdx = dependencyArray.findIndex(d => d.target === to);
            if (dependencyIdx < 0)
                return;
            const dependency = dependencyArray[dependencyIdx];
            if (dependency.referenceCount > 1) {
                dependency.referenceCount--;
            }
            else {
                dependencyArray.splice(dependencyIdx);
                // Get rid of the entry in the dependencies map
                // completely if the dependency array is now empty.
                if (dependencyArray.length === 0)
                    this.dependencies.delete(from);
            }
            const dependentArray = this.dependents.get(to);
            if (dependentArray) {
                const depIdx = dependentArray.indexOf(from);
                if (depIdx > -1)
                    dependentArray.splice(depIdx, 1);
            }
        }
        /**
         * Converts the contents of this DocumentGraph to a
         * string representation, useful for testing purposes.
         */
        toString() {
            const lines = [];
            for (const [uriText, entry] of this.documents) {
                const uri = Truth.Uri.tryParse(uriText);
                const doc = entry.document;
                if (!uri)
                    throw Truth.Exception.unknownState();
                lines.push(uri.toString());
                lines.push("\tDependencies");
                const docDependencies = this.dependencies.get(doc);
                if (docDependencies) {
                    if (docDependencies.length) {
                        for (const dependency of docDependencies)
                            lines.push("\t\t" + dependency.target.sourceUri.toString());
                    }
                    else
                        lines.push("\t\t(none)");
                }
                else
                    lines.push("\t\t(undefined)");
                lines.push("\tDependents");
                const docDependents = this.dependents.get(doc);
                if (docDependents) {
                    if (docDependents.length) {
                        for (const docDependent of docDependents)
                            lines.push("\t\t" + docDependent.sourceUri.toString());
                    }
                    else
                        lines.push("\t\t(none)");
                }
                else
                    lines.push("\t\t(undefined)");
                lines.push("");
            }
            return lines.slice(0, -1).join("\n");
        }
    }
    Truth.DocumentGraph = DocumentGraph;
    /**
     * A class that stores information about a dependency
     * between documents.
     */
    class Dependency {
        constructor(target) {
            this.target = target;
            this.referenceCount = 0;
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Stores information about a document's header.
     */
    class DocumentHeader {
        /** */
        constructor(document) {
            /**
             * Stores a map of the URIs referenced in the header of this
             * document, which are indexed by the statement in which
             * the URI is found.
             */
            this.uriMap = new Map();
            this.document = document;
        }
        /**
         * Forces the header to be recomputed, by scanning
         * the statements in the underlying document.
         *
         * If the header has changed, the method runs the
         * necessary hooks to notify subscribers of hooks
         * any added or removed.
         */
        recompute() {
            const oldUriMap = this.uriMap;
            const newUriMap = new Map();
            for (const { statement } of this.document.eachDescendant()) {
                // Currently, any statement with an annotation is
                // considered to be a non-header statement. This
                // will change if scoped references become supported.
                // Also, only one URI reference statement per line is
                // accepted. Vaccuous statements break the header.
                if (statement.allAnnotations.length > 0 || statement.allDeclarations.length !== 1)
                    break;
                const decl = statement.allDeclarations[0];
                if (typeof decl.boundary.subject === "string")
                    throw Truth.Exception.unknownState();
                if (!(decl.boundary.subject instanceof Truth.Uri))
                    break;
                const refUri = decl.boundary.subject;
                const docUri = this.document.sourceUri;
                const uriAbsolute = Truth.Not.null(Truth.Uri.tryParse(refUri, docUri));
                newUriMap.set(statement, uriAbsolute);
            }
            if (oldUriMap.size + newUriMap.size === 0)
                return;
            const removedUriMap = new Map();
            const addedUriMap = new Map();
            for (const [statement, oldUri] of oldUriMap)
                if (!newUriMap.has(statement))
                    removedUriMap.set(oldUri, statement);
            for (const [statement, newUri] of newUriMap)
                if (!oldUriMap.has(statement))
                    addedUriMap.set(newUri, statement);
            const program = this.document.program;
            for (const [uri, statement] of removedUriMap)
                program.cause(new Truth.CauseUriReferenceRemove(statement, uri));
            for (const [uri, statement] of addedUriMap)
                program.cause(new Truth.CauseUriReferenceAdd(statement, uri));
            this.uriMap.clear();
            newUriMap.forEach((uri, statement) => this.uriMap.set(statement, uri));
        }
        /**
         * @returns The document reference URI that corresponds
         * to the specified statement. Returns null in the case when
         * the specified statement is not a part of the header.
         */
        getHeaderUri(statement) {
            return this.uriMap.get(statement) || null;
        }
    }
    Truth.DocumentHeader = DocumentHeader;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Parses a single line of Truth code, and returns
     * a Line object that contains information about
     * what was read.
     */
    class LineParser {
        /**
         * Generator function that yields all statements
         * (unparsed lines) of the given source text.
         */
        static *read(fullSource) {
            if (fullSource.length === 0)
                return;
            let cursor = 0;
            let statementStart = 0;
            for (; cursor < fullSource.length; cursor++) {
                if (fullSource[cursor] === "\n" /* terminal */) {
                    yield fullSource.slice(statementStart, cursor);
                    statementStart = cursor + 1;
                }
            }
            if (statementStart < cursor)
                yield fullSource.slice(statementStart);
        }
        /**
         * Main entry point for parsing a single line and producing a
         * RawStatement object.
         *
         * The parsing algorithm is some kind of quasi-recusive descent with
         * lookheads and backtracking in some places to make the logic easier
         * to follow. Technically, it's probably some mash-up of LL(k) & LALR.
         * Maybe if I blew 4 years of my life in some silly Comp Sci program
         * instead of dropping out of high school I could say for sure.
         */
        static parse(lineText, options) {
            const parserOptions = options || {
                readPatterns: true,
                readUris: true
            };
            const parser = new Truth.Parser(lineText);
            const sourceText = lineText;
            const indent = parser.readWhitespace();
            const declarationEntries = [];
            const annotationEntries = [];
            const esc = "\\" /* escapeChar */;
            let flags = Truth.LineFlags.none;
            let jointPosition = -1;
            let sum = "";
            /**
             * Universal function for quickly producing a RawStatement
             * instance using the values of the constructed local variables.
             */
            const ret = (fault = null) => new Truth.Line(sourceText, indent, new Truth.BoundaryGroup(declarationEntries), new Truth.BoundaryGroup(annotationEntries), sum, jointPosition, flags, fault);
            // In the case when the line contains only whitespace characters,
            // this condition will pass, bypassing the entire parsing process
            // and returning an (basically) fresh RawStatement object.
            if (!parser.more()) {
                flags |= Truth.LineFlags.isWhitespace;
                return ret();
            }
            {
                const mark = parser.position;
                if (parser.read("//" /* comment */)) {
                    if (!parser.more() || parser.read(" " /* space */) || parser.read("\t" /* tab */)) {
                        flags |= Truth.LineFlags.isComment;
                        return ret();
                    }
                    parser.position = mark;
                }
            }
            {
                const unparsableFaultType = (() => {
                    if (parser.read("," /* combinator */))
                        return Truth.Faults.StatementBeginsWithComma;
                    if (parser.read("..." /* list */))
                        return Truth.Faults.StatementBeginsWithEllipsis;
                    if (parser.read(esc + " " /* space */) || parser.read(esc + "\t" /* tab */))
                        return Truth.Faults.StatementBeginsWithEscapedSpace;
                    if (parser.readThenTerminal(esc))
                        return Truth.Faults.StatementContainsOnlyEscapeCharacter;
                    return null;
                })();
                if (unparsableFaultType) {
                    flags |= Truth.LineFlags.isCruft;
                    return ret(unparsableFaultType);
                }
            }
            {
                const markBeforeUri = parser.position;
                const uri = maybeReadUri();
                if (uri) {
                    flags |= Truth.LineFlags.hasUri;
                    declarationEntries.push(new Truth.Boundary(markBeforeUri, parser.position, uri));
                    return then();
                }
                const markBeforePattern = parser.position;
                const pattern = maybeReadPattern();
                if (isParseFault(pattern)) {
                    flags |= Truth.LineFlags.isCruft;
                    return ret(pattern);
                }
                if (pattern) {
                    flags |= Truth.LineFlags.hasPattern;
                    flags |= pattern.isTotal ?
                        Truth.LineFlags.hasTotalPattern :
                        Truth.LineFlags.hasPartialPattern;
                    declarationEntries.push(new Truth.Boundary(markBeforePattern, parser.position, pattern));
                    return then();
                }
                for (const boundsEntry of readDeclarations([]))
                    declarationEntries.push(boundsEntry);
                return then();
            }
            function then() {
                jointPosition = maybeReadJoint();
                const readResult = readAnnotations([]);
                sum = readResult.raw.trim();
                for (const boundsEntry of readResult.annotations)
                    annotationEntries.push(boundsEntry);
                if (jointPosition > -1) {
                    const dLen = declarationEntries.length;
                    const aLen = readResult.annotations.length;
                    if (dLen === 0) {
                        declarationEntries.unshift(new Truth.Boundary(jointPosition, jointPosition, new Truth.Anon()));
                        if (aLen === 0)
                            flags |= Truth.LineFlags.isVacuous;
                    }
                    else if (aLen === 0) {
                        flags |= Truth.LineFlags.isRefresh;
                    }
                }
                return ret();
            }
            /**
             * Reads the following series of declarations, which may be
             * either directly contained by a statement, or inside an infix.
             */
            function readDeclarations(quitTokens) {
                const entries = [];
                const until = quitTokens.concat(":" /* joint */);
                while (parser.more()) {
                    const readResult = maybeReadIdentifier(until);
                    if (readResult !== null)
                        entries.push(new Truth.Boundary(readResult.at, parser.position, readResult.identifier));
                    // The following combinator must be eaten before
                    // moving on to another declaration. If this fails,
                    // it's because the parse stream has ended.
                    if (!parser.read("," /* combinator */))
                        break;
                    if (peekJoint())
                        break;
                }
                return entries;
            }
            /**
             * Attempts to read the joint token from the parse stream.
             * Consumes all surrounding whitespace.
             * @returns A boolean value indicating whether the joint
             * token was read.
             */
            function maybeReadJoint() {
                const markBeforeWs = parser.position;
                parser.readWhitespace();
                const markAfterWs = parser.position;
                let foundJointPosition = -1;
                if (parser.read(":" /* joint */ + " " /* space */) ||
                    parser.read(":" /* joint */ + "\t" /* tab */) ||
                    parser.readThenTerminal(":" /* joint */)) {
                    foundJointPosition = markAfterWs;
                    parser.readWhitespace();
                }
                else {
                    parser.position = markBeforeWs;
                }
                return foundJointPosition;
            }
            /**
             * @returns A boolean value that indicates whether the joint
             * is the next logical token to be consumed. True is returned
             * in the case when whitespace characters sit between the
             * cursor and the joint operator.
             */
            function peekJoint() {
                const innerPeekJoint = () => {
                    return parser.peek(":" /* joint */ + " " /* space */) ||
                        parser.peek(":" /* joint */ + "\t" /* tab */) ||
                        parser.peekThenTerminal(":" /* joint */);
                };
                if (innerPeekJoint())
                    return true;
                if (!parser.peek(" " /* space */) && !parser.peek("\t" /* tab */))
                    return false;
                const mark = parser.position;
                parser.readWhitespace();
                const atJoint = innerPeekJoint();
                parser.position = mark;
                return atJoint;
            }
            /**
             *
             */
            function readAnnotations(quitTokens) {
                const annotations = [];
                let raw = "";
                while (parser.more()) {
                    const readResult = maybeReadIdentifier(quitTokens);
                    if (readResult !== null) {
                        annotations.push(new Truth.Boundary(readResult.at, parser.position, readResult.identifier));
                        raw += readResult.raw;
                    }
                    // If the next token is not a combinator, 
                    // the parse stream has ended.
                    if (!parser.read("," /* combinator */))
                        break;
                }
                return {
                    annotations,
                    raw
                };
            }
            /**
             * Attempts to read a raw annotation from the parse stream.
             * If found, the raw string found is returned.
             */
            function maybeReadIdentifier(quitTokens) {
                const until = quitTokens
                    .concat("," /* combinator */)
                    .filter(tok => tok !== ":" /* joint */);
                const shouldQuitOnJoint = quitTokens.includes(":" /* joint */);
                const at = parser.position + parser.readWhitespace();
                let token = "";
                while (parser.more()) {
                    if (until.some(tok => parser.peek(tok)))
                        break;
                    if (shouldQuitOnJoint && peekJoint())
                        break;
                    const g1 = parser.readGrapheme();
                    if (parser.more()) {
                        // The only operators that can be meaningfully escaped at
                        // the identifier level are the joint, the combinator, and the
                        // pattern delimiter. Other occurences of the escape character
                        // append this character to the identifier.
                        if (g1 === esc) {
                            const g2 = parser.readGrapheme();
                            token += g2;
                            continue;
                        }
                    }
                    token += g1;
                }
                const tokenTrimmed = token.trim();
                if (!tokenTrimmed.length)
                    return null;
                return {
                    at,
                    identifier: new Truth.Identifier(tokenTrimmed),
                    raw: token
                };
            }
            /**
             * Attempts to read a URI starting at the current position
             * of the cursor. The position of the cursor is not changed
             * in the case when a valid URI was not read.
             */
            function maybeReadUri() {
                if (!parserOptions.readUris)
                    return null;
                const mark = parser.position;
                const uri = Truth.Uri.tryParse(parser.readUntil());
                if (uri === null)
                    parser.position = mark;
                return uri;
            }
            /**
             * Attempts to read a pattern from the steam.
             */
            function maybeReadPattern(nested = false) {
                if (!nested && !parser.read("/" /* main */))
                    return null;
                if (!parserOptions.readPatterns)
                    return null;
                // These are reserved starting sequences. They're invalid
                // regex syntax, and we may use them in the future to pack
                // in other language features.
                if (parser.peek("+" /* plus */) ||
                    parser.peek("*" /* star */) ||
                    parser.peek("?" /* restrained */))
                    return Truth.Faults.StatementBeginsWithInvalidSequence;
                // TypeScript isn't perfect.
                const units = nested ?
                    readRegexUnits(true) :
                    readRegexUnits(false);
                if (isParseFault(units))
                    return units;
                // Right-trim any trailing whitespace
                while (units.length) {
                    const last = units[units.length - 1];
                    if (!(last instanceof Truth.RegexGrapheme))
                        break;
                    if (last.grapheme !== " " /* space */ && last.grapheme !== "\t" /* tab */)
                        break;
                    units.pop();
                }
                if (units.length === 0)
                    return Truth.Faults.EmptyPattern;
                const last = units[units.length - 1];
                const isTotal = last instanceof Truth.RegexGrapheme &&
                    last.quantifier === null &&
                    last.grapheme === "/" /* main */;
                // Need to pop off the 
                if (isTotal)
                    units.pop();
                // Now read the annotations, in order to compute the Pattern's hash
                const mark = parser.position;
                const foundJointPosition = maybeReadJoint();
                if (foundJointPosition < 0)
                    return new Truth.Pattern(Object.freeze(units), isTotal, "");
                const annos = readAnnotations([]).annotations;
                const annosArrayJoined = Array.from(annos.values())
                    .map(v => v.subject.toString())
                    .join("\n" /* terminal */);
                const hash = Truth.Hash.calculate(annosArrayJoined);
                parser.position = mark;
                return new Truth.Pattern(Object.freeze(units), isTotal, hash);
            }
            function readRegexUnits(nested) {
                const units = [];
                while (parser.more()) {
                    const setOrGroup = maybeReadRegexSet() || maybeReadRegexGroup();
                    if (isParseFault(setOrGroup))
                        return setOrGroup;
                    if (setOrGroup !== null) {
                        const quantifier = maybeReadRegexQuantifier();
                        if (isParseFault(quantifier))
                            return quantifier;
                        units.push(appendQuantifier(setOrGroup, quantifier));
                        continue;
                    }
                    if (nested) {
                        if (parser.peek("|" /* alternator */))
                            break;
                        if (parser.peek(")" /* groupEnd */))
                            break;
                    }
                    else {
                        // Infixes are not supported anywhere other 
                        // than at the top level of the pattern.
                        const infix = maybeReadInfix();
                        if (isParseFault(infix))
                            return infix;
                        if (infix !== null) {
                            const quantifier = maybeReadRegexQuantifier();
                            if (quantifier !== null)
                                return Truth.Faults.InfixHasQuantifier;
                            units.push(infix);
                            continue;
                        }
                        if (peekJoint())
                            break;
                    }
                    const grapheme = maybeReadRegexGrapheme();
                    if (!grapheme)
                        break;
                    // If the grapheme read is in the RegexSyntaxKnownSet
                    // enumeration, we need to convert the grapheme to a
                    // RegexSet instance, and push that on to the units array
                    // instead.
                    const regexKnownSet = (() => {
                        if (grapheme.character === Truth.RegexSyntaxKnownSet.wild && !grapheme.escaped)
                            return Truth.RegexSyntaxKnownSet.wild;
                        if (grapheme.escaped) {
                            const characterWithEscape = esc + grapheme.character;
                            const knownSet = Truth.RegexSyntaxKnownSet.resolve(characterWithEscape);
                            if (knownSet !== null)
                                return knownSet;
                        }
                        return null;
                    })();
                    const quantifier = maybeReadRegexQuantifier();
                    if (isParseFault(quantifier))
                        return quantifier;
                    if (regexKnownSet !== null) {
                        units.push(new Truth.RegexSet([regexKnownSet], [], [], [], false, quantifier));
                        continue;
                    }
                    if (grapheme.unicodeBlockName) {
                        const ubn = grapheme.unicodeBlockName;
                        units.push(new Truth.RegexSet([], [], [ubn], [], false, quantifier));
                        continue;
                    }
                    if (grapheme.escaped) {
                        const sign = Truth.RegexSyntaxSign.resolve(esc + grapheme.character);
                        if (sign !== null) {
                            units.push(new Truth.RegexSign(sign, quantifier));
                            continue;
                        }
                        // If this point is reached, it's because there was a unneccesarily
                        // escaped character found in the parse stream, such as "\a". In
                        // this case, the raw character can just be added as a regex unit.
                    }
                    units.push(new Truth.RegexGrapheme(grapheme.character, quantifier));
                }
                return units;
            }
            /**
             * Attempts to read a character set from the parse stream.
             * Example: [a-z0-9]
             */
            function maybeReadRegexSet() {
                if (!parser.read("[" /* setStart */))
                    return null;
                const rng = "-" /* range */;
                const knowns = [];
                const ranges = [];
                const blocks = [];
                const singles = [];
                const isNegated = !!parser.read("^" /* negate */);
                let closed = false;
                /**
                 * Stores all Graphemes read.
                 */
                const graphemes = [];
                /**
                 * Stores booleans that align with the items in "queue",
                 * that indicate whether or not the queued Grapheme
                 * can participate in a range.
                 */
                const rangableQueue = [];
                for (;;) {
                    const g = maybeReadRegexGrapheme();
                    if (g === null)
                        break;
                    if (!g.escaped && g.character === "]" /* setEnd */) {
                        closed = true;
                        break;
                    }
                    if (g.unicodeBlockName) {
                        blocks.push(g.unicodeBlockName);
                        rangableQueue.push(false);
                        graphemes.push(null);
                        continue;
                    }
                    const gFull = g.escaped ? esc + g.character : g.character;
                    const known = Truth.RegexSyntaxKnownSet.resolve(gFull);
                    if (known !== null) {
                        knowns.push(known);
                        rangableQueue.push(false);
                        graphemes.push(null);
                        continue;
                    }
                    graphemes.push(g);
                    rangableQueue.push(g.character.length > 0 &&
                        g.character !== "\\b" /* boundary */ &&
                        g.character !== "\\B" /* boundaryNon */);
                    if (g.unicodeBlockName)
                        continue;
                    const len = graphemes.length;
                    if (len < 3)
                        continue;
                    const maybeRng = graphemes[len - 2];
                    if (maybeRng !== null && maybeRng.character !== rng)
                        continue;
                    if (!rangableQueue[len - 3])
                        continue;
                    const maybeFrom = graphemes[len - 3];
                    if (maybeFrom === null)
                        throw Truth.Exception.unknownState();
                    // Peel back symbol queue, and add a range
                    // to the alphabet builder if the queue gets into
                    // a state where it's ending with something
                    // looking like: ?-?
                    const from = maybeFrom.character.codePointAt(0) || 0;
                    const to = g.character.codePointAt(0) || 0;
                    ranges.push(new Truth.RegexCharRange(from, to));
                    graphemes.length -= 3;
                    continue;
                }
                if (!closed)
                    return Truth.Faults.UnterminatedCharacterSet;
                for (const g of graphemes)
                    if (g !== null)
                        singles.push(g.character);
                const quantifier = maybeReadRegexQuantifier();
                if (isParseFault(quantifier))
                    return quantifier;
                return new Truth.RegexSet(knowns, ranges, blocks, singles, isNegated, quantifier);
            }
            /**
             * Attempts to read an alternation group from the parse stream.
             * Example: (A|B|C)
             */
            function maybeReadRegexGroup() {
                if (!parser.read("(" /* groupStart */))
                    return null;
                const cases = [];
                let closed = false;
                while (parser.more()) {
                    if (parser.read("|" /* alternator */))
                        continue;
                    if (parser.read(")" /* groupEnd */)) {
                        closed = true;
                        break;
                    }
                    const subUnits = readRegexUnits(true);
                    if (isParseFault(subUnits))
                        return subUnits;
                    // If the call to maybeReadPattern causes the cursor
                    // to reach the end of te parse stream, the expression
                    // is invalid because it would mean the input looks
                    // something like: /(aa|bb
                    if (!parser.more())
                        return Truth.Faults.UnterminatedGroup;
                    // A null subPattern could come back in the case when some
                    // bizarre syntax is found in the pattern such as: (a||b)
                    if (subUnits === null)
                        continue;
                    cases.push(Object.freeze(subUnits));
                }
                if (!closed)
                    return Truth.Faults.UnterminatedGroup;
                const quantifier = maybeReadRegexQuantifier();
                if (isParseFault(quantifier))
                    return quantifier;
                return new Truth.RegexGroup(Object.freeze(cases), quantifier);
            }
            /**
             * Attempts to read a pattern quantifier from the parse stream.
             * Checks for duplicates, which is necessary because the JavaScript
             * regular expression flavor (and others?) cannot parse an expression
             * with two consecutive quantifiers.
             */
            function maybeReadRegexQuantifier() {
                /** */
                function maybeReadQuantifier() {
                    const mark = parser.position;
                    if (parser.read("*" /* star */))
                        return new Truth.RegexQuantifier(0, Infinity, isRestrained());
                    if (parser.read("+" /* plus */))
                        return new Truth.RegexQuantifier(1, Infinity, isRestrained());
                    if (parser.read("?" /* restrained */))
                        return new Truth.RegexQuantifier(0, 1, false);
                    if (!parser.read("{" /* quantifierStart */))
                        return null;
                    const min = maybeReadInteger();
                    if (min !== null) {
                        const quantEnd = "}" /* quantifierEnd */;
                        // {2}
                        if (parser.read(quantEnd))
                            return new Truth.RegexQuantifier(min, min, isRestrained());
                        // {2,} or {2,3} or {2,???
                        if (parser.read("," /* quantifierSeparator */)) {
                            if (parser.read(quantEnd))
                                return new Truth.RegexQuantifier(min, Infinity, isRestrained());
                            const max = maybeReadInteger();
                            if (max !== null && parser.read(quantEnd))
                                return new Truth.RegexQuantifier(min, max, isRestrained());
                        }
                    }
                    parser.position = mark;
                    return null;
                }
                /** */
                function isRestrained() {
                    return !!parser.read("?" /* restrained */);
                }
                const quantifier = maybeReadQuantifier();
                if (quantifier)
                    if (maybeReadQuantifier())
                        return Truth.Faults.DuplicateQuantifier;
                return quantifier;
            }
            /**
             *
             */
            function maybeReadInteger() {
                let integerText = "";
                for (let i = 0; i < 16 && parser.more(); i++) {
                    const digit = (() => {
                        for (let digit = 0; digit <= 9; digit++)
                            if (parser.read(digit.toString()))
                                return digit.toString();
                        return "";
                    })();
                    if (!digit)
                        break;
                    integerText += digit;
                }
                return integerText.length > 0 ?
                    parseInt(integerText, 10) :
                    null;
            }
            /**
             *
             */
            function maybeReadInfix() {
                const mark = parser.position;
                const lhsEntries = [];
                const rhsEntries = [];
                const infixStart = parser.position;
                let infixFlags = Truth.InfixFlags.none;
                let quitToken = ">" /* end */;
                let hasJoint = false;
                if (parser.read("<<" /* nominalStart */)) {
                    infixFlags |= Truth.InfixFlags.nominal;
                    quitToken = ">>" /* nominalEnd */;
                }
                else if (parser.read("</" /* patternStart */)) {
                    infixFlags |= Truth.InfixFlags.pattern;
                    quitToken = "/>" /* patternEnd */;
                }
                else if (parser.read("<" /* start */)) {
                    infixFlags |= Truth.InfixFlags.population;
                    quitToken = ">" /* end */;
                }
                else
                    return null;
                parser.readWhitespace();
                if (parser.read(":" /* joint */)) {
                    infixFlags |= Truth.InfixFlags.portability;
                    parser.readWhitespace();
                    for (const boundsEntry of readAnnotations([quitToken]).annotations)
                        rhsEntries.push(new Truth.Boundary(boundsEntry.offsetStart, parser.position, boundsEntry.subject));
                }
                else {
                    for (const boundsEntry of readDeclarations([quitToken]))
                        lhsEntries.push(boundsEntry);
                    parser.readWhitespace();
                    if (maybeReadJoint() > -1) {
                        hasJoint = true;
                        parser.readWhitespace();
                        for (const boundsEntry of readAnnotations([quitToken]).annotations)
                            rhsEntries.push(new Truth.Boundary(boundsEntry.offsetStart, parser.position, boundsEntry.subject));
                    }
                }
                // Avoid producing an infix in weird cases such as:
                // < : >  </  />  <<:>>
                if (lhsEntries.length + rhsEntries.length === 0) {
                    parser.position = mark;
                    return null;
                }
                if (hasJoint)
                    infixFlags |= Truth.InfixFlags.hasJoint;
                parser.readWhitespace();
                if (!parser.read(quitToken))
                    return Truth.Faults.UnterminatedInfix;
                return new Truth.Infix(infixStart, parser.position, new Truth.BoundaryGroup(lhsEntries), new Truth.BoundaryGroup(rhsEntries), infixFlags);
            }
            /**
             * Attempts to read one single symbol from the parse stream,
             * while respecting unicode escape sequences, and escaped
             * characters.
             *
             * @returns The read string, or an empty string in the case when
             * there are no more characters in the parse stream.
             */
            function maybeReadRegexGrapheme() {
                if (!parser.more())
                    return null;
                const mark = parser.position;
                if (parser.read("\\u{" /* utf16GroupStart */)) {
                    const delim = "}" /* utf16GroupEnd */;
                    const unicodeRef = parser.readUntil(delim);
                    // Make sure the readUntil method stopped because it
                    // actually hit the delimiter, and not because it ran out
                    // of characters.
                    if (parser.more()) {
                        parser.read(delim);
                        if (Truth.UnicodeBlocks.has(unicodeRef.toLowerCase()))
                            return new Grapheme("", unicodeRef, true);
                        const len = unicodeRef.length;
                        if (len >= 1 && len <= 5) {
                            const num = parseInt(unicodeRef, 16);
                            if (num === num) {
                                const char = String.fromCodePoint(num);
                                return new Grapheme(char, "", true);
                            }
                        }
                    }
                    // Something came in that looked like a unicode escape
                    // sequence, but turned out not to be, like: \u
                    parser.position = mark;
                }
                if (parser.read(esc)) {
                    // If the parse stream ends with a backslash, we just
                    // return the actual backslash character as a character.
                    // This covers ridiculous but possible cases where a
                    // an unannotated type is named something like "Thing\".
                    if (!parser.more())
                        return new Grapheme(esc, "", false);
                    const g = parser.readGrapheme();
                    const decoded = Truth.RegexSyntaxSign.unescape(esc + g) || g;
                    return new Grapheme(decoded, "", true);
                }
                return new Grapheme(parser.readGrapheme(), "", false);
            }
            /** */
            function isParseFault(value) {
                return value instanceof Truth.FaultType;
            }
        }
        /** */
        constructor() { }
    }
    Truth.LineParser = LineParser;
    /** */
    class Grapheme {
        constructor(
        /**
         * Stores the character found in the parse stream in
         * their unescaped format. For example, in the case
         * when the field is referring to a unicode character,
         * the field would store "" ... not "\u1F407".
         */
        character, 
        /**
         * Stores the name of the unicode block specified,
         * or an empty string if the grapheme does not refer
         * to a unicode block.
         */
        unicodeBlockName, 
        /**
         * Stores whether the discovered grapheme was
         * escaped in the parse stream. Note that if the
         * grapheme refers to a special character, such
         * as "\d" for all digits, this will be true.
         */
        escaped) {
            this.character = character;
            this.unicodeBlockName = unicodeBlockName;
            this.escaped = escaped;
        }
    }
    /**
     * Slightly awkward hack function to attach a PatternQuantifier
     * to an already existing PatternUnit (without resorting to making
     * quantifier a mutable property.
     */
    function appendQuantifier(unit, quantifier = null) {
        if (quantifier === null)
            return unit;
        if (unit instanceof Truth.RegexSet)
            return new Truth.RegexSet(unit.knowns, unit.ranges, unit.unicodeBlocks, unit.singles, unit.isNegated, quantifier);
        if (unit instanceof Truth.RegexGroup)
            return new Truth.RegexGroup(unit.cases, quantifier);
        if (unit instanceof Truth.RegexGrapheme)
            return new Truth.RegexGrapheme(unit.grapheme, quantifier);
        throw Truth.Exception.notImplemented();
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Placeholder object to mark the position of
     * an anonymous type within a statement.
     */
    class Anon {
        constructor() {
            /**
             * @internal
             * No-op property used for debugging
             * purposes, and also to dodge structural
             * type compatibility bugs in TypeScript.
             */
            this.id = ++nextId;
        }
        /** */
        toString() {
            return `__ANON${this.id}__`;
        }
    }
    Truth.Anon = Anon;
    let nextId = 0;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Stores information about a line, after being parsed.
     * A Line is different from a Statement in that it has no
     * relationship to a Document.
     */
    class Line {
        /*** */
        constructor(sourceText, indent, declarations, annotations, sum, jointPosition, flags, faultType) {
            this.sourceText = sourceText;
            this.indent = indent;
            this.declarations = declarations;
            this.annotations = annotations;
            this.sum = sum;
            this.jointPosition = jointPosition;
            this.flags = flags;
            this.faultType = faultType;
        }
    }
    Truth.Line = Line;
    /**
     * A bit field enumeration used to efficiently store
     * meta data about a Line (or a Statement) object.
     */
    let LineFlags;
    (function (LineFlags) {
        LineFlags[LineFlags["none"] = 0] = "none";
        LineFlags[LineFlags["isRefresh"] = 1] = "isRefresh";
        LineFlags[LineFlags["isVacuous"] = 2] = "isVacuous";
        LineFlags[LineFlags["isComment"] = 4] = "isComment";
        LineFlags[LineFlags["isWhitespace"] = 8] = "isWhitespace";
        LineFlags[LineFlags["isDisposed"] = 16] = "isDisposed";
        LineFlags[LineFlags["isCruft"] = 32] = "isCruft";
        LineFlags[LineFlags["hasUri"] = 64] = "hasUri";
        LineFlags[LineFlags["hasTotalPattern"] = 128] = "hasTotalPattern";
        LineFlags[LineFlags["hasPartialPattern"] = 256] = "hasPartialPattern";
        LineFlags[LineFlags["hasPattern"] = 512] = "hasPattern";
    })(LineFlags = Truth.LineFlags || (Truth.LineFlags = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Stakes out starting and ending character positions
     * of subjects within a given region.
     */
    class BoundaryGroup {
        /** */
        constructor(boundaries) {
            this.entries = Object.freeze(boundaries.slice().sort((entryA, entryB) => {
                return entryA.offsetStart - entryB.offsetStart;
            }));
        }
        /** */
        *[Symbol.iterator]() {
            for (const entry of this.entries)
                yield entry;
        }
        /** */
        *eachSubject() {
            for (const entry of this.entries)
                yield entry.subject;
        }
        /** */
        inspect(offset) {
            for (const entry of this.entries)
                if (offset >= entry.offsetStart && offset <= entry.offsetEnd)
                    return entry.subject;
            return null;
        }
        /** */
        first() {
            for (const entry of this)
                return entry;
            return null;
        }
        /** Gets the number of entries defined in the bounds. */
        get length() {
            return this.entries.length;
        }
    }
    Truth.BoundaryGroup = BoundaryGroup;
    /** */
    class Boundary {
        constructor(offsetStart, offsetEnd, subject) {
            this.offsetStart = offsetStart;
            this.offsetEnd = offsetEnd;
            this.subject = subject;
        }
    }
    Truth.Boundary = Boundary;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Statement {
        /**
         * @internal
         */
        constructor(document, text) {
            /**
             * @internal
             * Logical clock value used to make chronological
             * creation-time comparisons between Statements.
             */
            this.stamp = Truth.VersionStamp.next();
            /** @internal */
            this.flags = Truth.LineFlags.none;
            this._infixSpans = Object.freeze([]);
            const line = Truth.LineParser.parse(text);
            this.document = document;
            this.sourceText = line.sourceText;
            this.sum = line.sum;
            this.indent = line.indent;
            this.flags = line.flags;
            this.jointPosition = line.jointPosition;
            this.allDeclarations = Object.freeze(Array.from(line.declarations)
                .map(boundary => new Truth.Span(this, boundary)));
            this.allAnnotations = Object.freeze(Array.from(line.annotations)
                .map(boundary => new Truth.Span(this, boundary)));
            const faults = [];
            const cruftObjects = new Set();
            if (line.faultType !== null)
                faults.push(new Truth.Fault(line.faultType, this));
            for (const fault of this.eachParseFault()) {
                if (fault.type.severity === 8 /* error */)
                    cruftObjects.add(fault.source);
                faults.push(fault);
            }
            for (const fault of faults)
                // Check needed to support the unit tests, the feed
                // fake document objects into the statement constructor.
                if (document.program && document.program.faults)
                    document.program.faults.report(fault);
            this.cruftObjects = cruftObjects;
            this.faults = Object.freeze(faults);
            this.programStamp = document.program ?
                document.program.version :
                Truth.VersionStamp.next();
        }
        /**
         *
         */
        *eachParseFault() {
            // Check for tabs and spaces mixture
            if (this.indent > 0) {
                let hasTabs = false;
                let hasSpaces = false;
                for (let i = -1; ++i < this.indent;) {
                    const chr = this.sourceText[i];
                    if (chr === "\t" /* tab */)
                        hasTabs = true;
                    if (chr === " " /* space */)
                        hasSpaces = true;
                }
                if (hasTabs && hasSpaces)
                    yield new Truth.Fault(Truth.Faults.TabsAndSpaces, this);
            }
            if (this.allDeclarations.length > 1) {
                const subjects = [];
                for (const span of this.allDeclarations) {
                    const subText = span.toString();
                    if (subjects.includes(subText))
                        yield new Truth.Fault(Truth.Faults.DuplicateDeclaration, span);
                    else
                        subjects.push(subText);
                }
            }
            if (this.allAnnotations.length > 0) {
                // This performs an expedient check for "ListIntrinsicExtendingList",
                // however, full type analysis is required to cover all cases where
                // this fault may be reported.
                const getListSpans = (spans) => spans.filter(span => {
                    const sub = span.boundary.subject;
                    return sub instanceof Truth.Identifier && sub.isList;
                });
                const lhsListSpans = getListSpans(this.allDeclarations);
                const rhsListSpans = getListSpans(this.allAnnotations);
                if (lhsListSpans.length > 0 && rhsListSpans.length > 0)
                    for (const span of rhsListSpans)
                        yield new Truth.Fault(Truth.Faults.ListIntrinsicExtendingList, span);
            }
            const pattern = (() => {
                if (this.allDeclarations.length === 0)
                    return null;
                const hp = Truth.LineFlags.hasPattern;
                if ((this.flags & hp) !== hp)
                    return null;
                const subject = this.allDeclarations[0].boundary.subject;
                return subject instanceof Truth.Pattern ?
                    subject :
                    null;
            })();
            if (pattern === null)
                return;
            if (!pattern.isValid) {
                yield new Truth.Fault(Truth.Faults.PatternInvalid, this);
                return;
            }
            if (this.allAnnotations.length === 0)
                yield new Truth.Fault(Truth.Faults.PatternWithoutAnnotation, this);
            if (pattern.test(""))
                yield new Truth.Fault(Truth.Faults.PatternCanMatchEmpty, this);
            if (!pattern.isTotal)
                for (const unit of pattern.eachUnit())
                    if (unit instanceof Truth.RegexGrapheme)
                        if (unit.grapheme === "," /* combinator */) {
                            yield new Truth.Fault(Truth.Faults.PatternPartialWithCombinator, this);
                            break;
                        }
            const patternSpan = this.allDeclarations[0];
            if (patternSpan.infixes.length === 0)
                return;
            const infixSpans = [];
            for (const infix of patternSpan.infixes) {
                const lhs = Array.from(patternSpan.eachDeclarationForInfix(infix));
                const rhs = Array.from(patternSpan.eachAnnotationForInfix(infix));
                const all = lhs.concat(rhs);
                // This is a bit out of place ... but we need to populate the
                // infixSpans array and this is probably the most efficient
                // place to do that.
                infixSpans.push(...all);
                for (const infixSpan of all)
                    if (infixSpan.boundary.subject.isList)
                        yield new Truth.Fault(Truth.Faults.InfixUsingListOperator, infixSpan);
                yield* dedupInfixSubjects(lhs);
                yield* dedupInfixSubjects(rhs);
                const lhsIdentifiers = lhs.map(nfxSpan => nfxSpan.boundary.subject.toString());
                for (const infixSpan of rhs)
                    if (lhsIdentifiers.includes(infixSpan.boundary.subject.toString()))
                        yield new Truth.Fault(Truth.Faults.InfixHasSelfReferentialType, infixSpan);
                if (infix.isPopulation)
                    for (let idx = 1; idx < lhs.length; idx++)
                        yield new Truth.Fault(Truth.Faults.InfixPopulationChaining, lhs[idx]);
                yield* expedientListCheck(lhs);
                yield* expedientListCheck(rhs);
            }
            for (const infixSpan of dedupInfixesAcrossInfixes(patternSpan, infix => patternSpan.eachDeclarationForInfix(infix))) {
                if (infixSpan.containingInfix.isPopulation)
                    yield new Truth.Fault(Truth.Faults.PopulationInfixHasMultipleDefinitions, infixSpan);
            }
            for (const infixSpan of dedupInfixesAcrossInfixes(patternSpan, infix => patternSpan.eachAnnotationForInfix(infix))) {
                if (infixSpan.containingInfix.isPortability)
                    yield new Truth.Fault(Truth.Faults.PortabilityInfixHasMultipleDefinitions, infixSpan);
            }
            this._infixSpans = Object.freeze(infixSpans);
        }
        /**
         * Gets whether the joint operator exists at the
         * end of the statement, forcing the statement's
         * declarations to be "refresh types".
         */
        get isRefresh() {
            const f = Truth.LineFlags.isRefresh;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement contains nothing
         * other than a single joint operator.
         */
        get isVacuous() {
            const f = Truth.LineFlags.isVacuous;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement is a comment.
         */
        get isComment() {
            const f = Truth.LineFlags.isComment;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement contains
         * no non-whitespace characters.
         */
        get isWhitespace() {
            const f = Truth.LineFlags.isWhitespace;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement is a comment or whitespace.
         */
        get isNoop() {
            return this.isComment || this.isWhitespace;
        }
        /**
         * Gets whether the statement has been removed from it's
         * containing document. Removal occurs after the statement
         * has been invalidated. Therefore, this property will be false
         * before the invalidation phase has occured, even if it will be
         * disposed in the current edit transaction.
         */
        get isDisposed() {
            const f = Truth.LineFlags.isDisposed;
            return (this.flags & f) === f;
        }
        /**
         *
         */
        get isCruft() {
            const f = Truth.LineFlags.isCruft;
            return (this.flags & f) === f;
        }
        /**
         * Gets the line number of this statement in it's containing
         * document, or -1 if the statement is disposed and/or is not
         * in the document.
         */
        get index() {
            if (this.isDisposed)
                return -1;
            return this.document instanceof Truth.Document ?
                this.document.getLineNumber(this) :
                -1;
        }
        /**
         * Gets an array of spans in that represent the declarations
         * of this statement, excluding those that have been marked
         * as object-level cruft.
         */
        get declarations() {
            if (this.cruftObjects.size === 0)
                return this.allDeclarations;
            const out = [];
            for (const span of this.allDeclarations)
                if (!this.cruftObjects.has(span))
                    out.push(span);
            return Object.freeze(out);
        }
        /**
         * Gets a list of all infixes defined in the pattern of this statement.
         */
        get infixSpans() {
            return this._infixSpans;
        }
        /**
         * Gets an array of spans in that represent the annotations
         * of this statement, from left to right, excluding those that
         * have been marked as object-level cruft.
         */
        get annotations() {
            if (this.cruftObjects.size === 0)
                return this.allAnnotations;
            const out = [];
            for (const span of this.allAnnotations)
                if (!this.cruftObjects.has(span))
                    out.push(span);
            return Object.freeze(out);
        }
        /**
         * Gets an array of spans in that represent both the declarations
         * and the annotations of this statement, excluding those that have
         * been marked as object-level cruft.
         */
        get spans() {
            return this.isCruft ?
                [] :
                this.declarations.concat(this.annotations);
        }
        /**
         *
         */
        get allSpans() {
            return this.declarations.concat(this.annotations);
        }
        /**
         * Gets a boolean value indicating whether or not the
         * statement contains a declaration of a pattern.
         */
        get hasPattern() {
            const d = this.allDeclarations;
            return d.length === 1 && d[0].boundary.subject instanceof Truth.Pattern;
        }
        /**
         * @internal
         * Marks the statement as being removed from it's containing document.
         */
        dispose() {
            this.flags = this.flags | Truth.LineFlags.isDisposed;
        }
        /**
         * @returns The kind of StatementRegion that exists
         * at the given character offset within the Statement.
         */
        getRegion(offset) {
            if (this.isComment || offset < this.indent || this.isCruft)
                return StatementRegion.void;
            if (this.isWhitespace)
                return StatementRegion.whitespace;
            if (this.hasPattern) {
                const bnd = this.allDeclarations[0].boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return StatementRegion.pattern;
            }
            if (offset <= this.jointPosition || this.jointPosition < 0) {
                for (const span of this.allDeclarations) {
                    const bnd = span.boundary;
                    if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                        return StatementRegion.declaration;
                }
                return StatementRegion.declarationVoid;
            }
            for (const span of this.allAnnotations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return StatementRegion.annotation;
            }
            return StatementRegion.annotationVoid;
        }
        /**
         *
         */
        getSubject(offset) {
            return this.getDeclaration(offset) || this.getAnnotation(offset);
        }
        /**
         * @returns A span to the declaration subject at the
         * specified offset, or null if there is none was found.
         */
        getDeclaration(offset) {
            for (const span of this.declarations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return span;
            }
            return null;
        }
        /**
         * @returns A span to the annotation subject at the
         * specified offset, or null if there is none was found.
         */
        getAnnotation(offset) {
            for (const span of this.annotations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return span;
            }
            return null;
        }
        /**
         * @returns A string containing the inner comment text of
         * this statement, excluding the comment syntax token.
         * If the statement isn't a comment, an empty string is returned.
         */
        getCommentText() {
            return this.isComment ?
                this.sourceText.slice(this.indent + "//" /* comment */.length).trim() :
                "";
        }
        /**
         * Converts the statement to a formatted string representation.
         */
        toString(includeIndent = false) {
            const serializeSpans = (spans, escStyle) => {
                return spans
                    .filter(sp => !(sp.boundary.subject instanceof Truth.Anon))
                    .map(sp => Truth.SubjectSerializer.forExternal(sp, escStyle))
                    .join("," /* combinator */ + " " /* space */);
            };
            const indent = includeIndent ? "\t" /* tab */.repeat(this.indent) : "";
            if (this.isCruft)
                return indent + "(cruft)";
            if (this.isWhitespace)
                return indent;
            if (this.isVacuous)
                return indent + ":" /* joint */;
            const decls = serializeSpans(this.allDeclarations, 1 /* declaration */);
            const annos = serializeSpans(this.allAnnotations, 2 /* annotation */);
            const joint = annos.length > 0 || this.isRefresh ? ":" /* joint */ : "";
            const jointL = decls.length > 0 && joint !== "" ? " " /* space */ : "";
            const jointR = annos.length > 0 ? " " /* space */ : "";
            return indent + decls + jointL + joint + jointR + annos;
        }
    }
    Truth.Statement = Statement;
    /**
     * Defines the areas of a statement that are significantly
     * different when performing inspection.
     */
    let StatementRegion;
    (function (StatementRegion) {
        /**
         * Refers to the area within a comment statement,
         * or the whitespace preceeding a non-no-op.
         */
        StatementRegion[StatementRegion["void"] = 0] = "void";
        /**
         * Refers to the area in the indentation area.
         */
        StatementRegion[StatementRegion["whitespace"] = 1] = "whitespace";
        /**
         * Refers to the
         */
        StatementRegion[StatementRegion["pattern"] = 2] = "pattern";
        /** */
        StatementRegion[StatementRegion["declaration"] = 3] = "declaration";
        /** */
        StatementRegion[StatementRegion["annotation"] = 4] = "annotation";
        /** */
        StatementRegion[StatementRegion["declarationVoid"] = 5] = "declarationVoid";
        /** */
        StatementRegion[StatementRegion["annotationVoid"] = 6] = "annotationVoid";
    })(StatementRegion = Truth.StatementRegion || (Truth.StatementRegion = {}));
    /**
     * Yields faults on infix spans in the case when an identifier
     * has been re-declared multiple times within the same infix.
     */
    function* dedupInfixSubjects(side) {
        if (side.length === 0)
            return;
        const subjects = [];
        for (const nfxSpan of side) {
            const subText = nfxSpan.boundary.subject.toString();
            if (subjects.includes(subText)) {
                yield new Truth.Fault(Truth.Faults.InfixHasDuplicateIdentifier, nfxSpan);
            }
            else
                subjects.push(subText);
        }
    }
    /**
     * Yields faults on infix spans in the case when an identifier
     * has been re-declared multiple times across the infixes.
     */
    function* dedupInfixesAcrossInfixes(span, infixFn) {
        const identifiers = [];
        for (const infix of span.infixes) {
            const infixSpans = Array.from(infixFn(infix));
            for (const infixSpan of infixSpans) {
                const text = infixSpan.boundary.subject.toString();
                if (identifiers.includes(text)) {
                    yield infixSpan;
                }
                else
                    identifiers.push(text);
            }
        }
    }
    /**
     * Yields when successive equivalent instances are discovered
     * in the specified iterator.
     */
    function* dedup(iterator, equalityFn) {
        const yielded = [];
        for (const item of iterator) {
            if (yielded.includes(item))
                yield item;
            else
                yielded.push(item);
        }
    }
    /**
     * Performs a quick and dirty check to see if the infix is referencing
     * a list, by looking to see if it has the list operator. A full check needs
     * to perform type inspection to see if any of the types that correspond
     * to the identifiers specified are actually lists.
     */
    function* expedientListCheck(side) {
        if (side.length === 0)
            return;
        for (const nfxSpan of side)
            if (nfxSpan.boundary.subject.isList)
                yield new Truth.Fault(Truth.Faults.InfixUsingListOperator, nfxSpan);
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Pattern {
        /** @internal */
        constructor(
        /**
         *
         */
        units, 
        /**
         * Stores whether the pattern is considered to be "Total"
         * or "Partial". Total patterns must match an entire annotation
         * set (the entire strip of content to the right of a joint, after
         * being trimmed). Partial patterns match individually
         * specified subjects (separated by commas).
         */
        isTotal, 
        /**
         * Stores a hash which is computed from the set of
         * annotations specified to the right of the pattern.
         */
        hash) {
            this.units = units;
            this.isTotal = isTotal;
            this.hash = hash;
            /** */
            this.compiledRegExp = null;
            this.compiledRegExp = Truth.PatternPrecompiler.exec(this);
            this.isValid = this.compiledRegExp instanceof RegExp;
        }
        /**
         * Recursively enumerates through this Pattern's unit structure.
         */
        *eachUnit() {
            function* recurse(units) {
                for (const unit of units) {
                    yield unit;
                    if (unit instanceof Truth.RegexGroup)
                        for (const unitCase of unit.cases)
                            recurse(unitCase);
                }
            }
            yield* recurse(this.units);
        }
        /**
         * @returns A boolean value that indicates whether
         * this Pattern has at least one infix, of any type.
         */
        hasInfixes() {
            return this.units.some(u => u instanceof Truth.Infix);
        }
        /**
         * @returns An array containing the infixes of the
         * specified type that are defined in this Pattern.
         * If the argument is omitted, all infixes of any type
         * defined on this Pattern are returned.
         */
        getInfixes(type = Truth.InfixFlags.none) {
            return this.units
                .filter((u) => u instanceof Truth.Infix)
                .filter(nfx => (nfx.flags & type) === type);
        }
        /**
         * Performs an "expedient" test that determines whether the
         * specified input has a chance of being matched by this pattern.
         * The check is considered expedient, rather than thorough,
         * because any infixes that exist in this pattern are replaced
         * with "catch all" regular expression sequence, rather than
         * embedding the pattern associated with the type specified
         * in the infix.
         */
        test(input) {
            const regExp = this.compiledRegExp;
            if (regExp === null)
                return false;
            const inputTrimmed = input.trim();
            if (inputTrimmed === "")
                return false;
            return regExp.test(input);
        }
        /**
         * Executes the pattern (like a function) using the specified
         * string as the input.
         *
         * @returns A ReadonlyMap whose keys align with the infixes
         * contained in this Pattern, and whose values are strings that
         * are the extracted "inputs", found in the place of each infix.
         * If this Pattern has no infixes, an empty map is returned.
         */
        exec(patternParameter) {
            const regExp = this.compiledRegExp;
            if (regExp === null)
                return new Map();
            const result = new Map();
            const infixes = this.getInfixes();
            if (this.getInfixes().length === 0)
                return result;
            const infixCaptureGroupIndexes = (() => {
                const idxArray = [];
                let idx = 0;
                for (const unit of this.eachUnit()) {
                    if (unit instanceof Truth.Infix)
                        idxArray.push(++idx);
                    if (unit instanceof Truth.RegexGroup)
                        idx++;
                }
                ///Make sure the above produces the same behavior before deleting
                ///const recurseUnits = (units: readonly (RegexUnit | Infix>)[]) =>
                ///{
                ///	for (const unit of units)
                ///	{
                ///		if (unit instanceof Infix)
                ///		{
                ///			idxArray.push(++idx);
                ///		}
                ///		else if (unit instanceof RegexGroup)
                ///		{
                ///			++idx;
                ///			for (const unitCase of unit.cases)
                ///				recurseUnits(unitCase);
                ///		}
                ///	}
                ///}
                ///recurseUnits(this.units);
                return idxArray;
            })();
            const reg = new RegExp(regExp.source, regExp.flags);
            const matches = reg.exec(patternParameter);
            if (matches === null)
                return result;
            for (const [idx, infix] of infixes.entries())
                result.set(infix, matches[infixCaptureGroupIndexes[idx]]);
            return result;
        }
        /**
         * Converts this Pattern to a string representation.
         * (Note that the serialized pattern cannot be used
         * as a parameter to a JavaScript RegExp object.)
         *
         * @param includeHashPrefix If true, the Pattern's hash
         * prefix will be prepended to the serialized result.
         */
        toString(includeHashPrefix) {
            const prefix = includeHashPrefix ? escape(this.hash) : "";
            const delim = "/" /* main */.toString();
            return delim + prefix +
                this.units.map(u => u.toString()).join("") +
                (this.isTotal ? delim : "");
        }
    }
    Truth.Pattern = Pattern;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    class PatternPrecompiler {
        /**
         * Compiles the specified pattern into a JS-native
         * RegExp object that can be used to execute regular
         * expression pre-matching (i.e. checks that essentially
         * ignore any infixes that the pattern may have).
         */
        static exec(pattern) {
            const result = [];
            for (const unit of pattern.units) {
                if (unit instanceof Truth.RegexGrapheme) {
                    if (MustEscapeChars.includes(unit.grapheme))
                        result.push("\\" /* escapeChar */ + unit.grapheme);
                    else
                        result.push(unit.grapheme);
                    if (unit.quantifier)
                        result.push(unit.quantifier.toString());
                }
                else if (unit instanceof Truth.Infix) {
                    result.push(ExpedientInfixPattern);
                }
                else {
                    result.push(unit.toString());
                }
            }
            result.unshift("^");
            result.push("$");
            const regText = result.join("");
            try {
                return new RegExp(regText, "u");
            }
            catch (e) {
                return null;
            }
        }
    }
    Truth.PatternPrecompiler = PatternPrecompiler;
    /**
     * Stores the list of characters that must be escaped
     * in order for the Truth regular expression flavor to
     * be compatible with the engine build into JavaScript.
     */
    const MustEscapeChars = ["$", "^", "{", "}"];
    /**
     * Stores the pattern that is fed into a pattern in
     * place of where infixes are, in order to be able to
     * do early tests on the regular expression without
     * doing a full resolution of the types that the infixes
     * reference. The pattern essentially means:
     *
     * "Match one non-whitespace character, or a series
     * of characters, provided that the string of characters
     * don't begin or end with whitespace."
     */
    const ExpedientInfixPattern = "(\\S+(\\s+\\S+)*)";
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Ambient unifier for all PatternUnit instances
     */
    class RegexUnit {
        constructor(quantifier) {
            this.quantifier = quantifier;
        }
    }
    Truth.RegexUnit = RegexUnit;
    /**
     *
     */
    class RegexSet extends RegexUnit {
        /** */
        constructor(knowns, ranges, unicodeBlocks, singles, isNegated, quantifier) {
            super(quantifier);
            this.knowns = knowns;
            this.ranges = ranges;
            this.unicodeBlocks = unicodeBlocks;
            this.singles = singles;
            this.isNegated = isNegated;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const kLen = this.knowns.length;
            const rLen = this.ranges.length;
            const uLen = this.unicodeBlocks.length;
            const cLen = this.singles.length;
            const setText = (() => {
                if (kLen === 1 && rLen + uLen + cLen === 0)
                    return this.knowns[0].toString();
                if (uLen === 1 && kLen + rLen + cLen === 0)
                    return [
                        "[" /* setStart */ +
                            serializeUnicodeBlock(this.unicodeBlocks[0]) +
                            "]" /* setEnd */
                    ].join("");
                if (cLen === 1 && kLen + rLen + uLen === 0)
                    return this.singles[0];
                return [
                    "[" /* setStart */,
                    ...this.knowns,
                    ...this.ranges.map(r => esc(r.from) + "-" + esc(r.to)),
                    ...this.unicodeBlocks.map(serializeUnicodeBlock),
                    ...escMany(this.singles),
                    "]" /* setEnd */
                ].join("");
            })();
            return setText + (this.quantifier ? this.quantifier.toString() : "");
        }
        /**
         * @internal
         */
        toAlphabet() {
            const alphabetBuilder = new Truth.AlphabetBuilder();
            const gt = (char) => char.charCodeAt(0) + 1;
            const lt = (char) => char.charCodeAt(0) - 1;
            for (const known of this.knowns) {
                switch (known) {
                    case Truth.RegexSyntaxKnownSet.digit:
                        alphabetBuilder.add("0", "9");
                        break;
                    case Truth.RegexSyntaxKnownSet.digitNon:
                        alphabetBuilder.add(0, lt("0"));
                        alphabetBuilder.add(gt("9"), Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.alphanumeric:
                        alphabetBuilder.add("0", "9");
                        alphabetBuilder.add("A", "Z");
                        alphabetBuilder.add("a", "z");
                        break;
                    case Truth.RegexSyntaxKnownSet.alphanumericNon:
                        alphabetBuilder.add(0, lt("0"));
                        alphabetBuilder.add(gt("9"), lt("A"));
                        alphabetBuilder.add(gt("Z"), lt("a"));
                        alphabetBuilder.add(gt("z"), Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.whitespace:
                        alphabetBuilder.add(9, 13);
                        alphabetBuilder.add(160);
                        alphabetBuilder.add(5760);
                        alphabetBuilder.add(8192, 8202);
                        alphabetBuilder.add(8232);
                        alphabetBuilder.add(8233);
                        alphabetBuilder.add(8239);
                        alphabetBuilder.add(8287);
                        alphabetBuilder.add(12288);
                        alphabetBuilder.add(65279);
                        break;
                    case Truth.RegexSyntaxKnownSet.whitespaceNon:
                        alphabetBuilder.add(0, 8);
                        alphabetBuilder.add(14, 159);
                        alphabetBuilder.add(161, 5759);
                        alphabetBuilder.add(5761, 8191);
                        alphabetBuilder.add(8203, 8231);
                        alphabetBuilder.add(8232);
                        alphabetBuilder.add(8233);
                        alphabetBuilder.add(8234, 8238);
                        alphabetBuilder.add(8240, 8286);
                        alphabetBuilder.add(8288, 12287);
                        alphabetBuilder.add(12289, 65278);
                        alphabetBuilder.add(65280, Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.wild:
                        alphabetBuilder.addWild();
                        break;
                }
            }
            for (const range of this.ranges)
                alphabetBuilder.add(range.from, range.to);
            for (const single of this.singles)
                alphabetBuilder.add(single);
            return alphabetBuilder.toAlphabet(this.isNegated);
        }
    }
    Truth.RegexSet = RegexSet;
    /**
     *
     */
    class RegexCharRange {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
    }
    Truth.RegexCharRange = RegexCharRange;
    /**
     *
     */
    class RegexGroup extends RegexUnit {
        constructor(
        /**
         *
         */
        cases, quantifier) {
            super(quantifier);
            this.cases = cases;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            if (this.cases.length === 0)
                return "";
            const start = "(" /* groupStart */;
            const mid = this.cases
                .map(ca => ca.map(unit => esc(unit.toString())).join(""))
                .join("|" /* alternator */);
            const end = ")" /* groupEnd */;
            const quant = this.quantifier ? this.quantifier.toString() : "";
            return start + mid + end + quant;
        }
    }
    Truth.RegexGroup = RegexGroup;
    /**
     * A pattern "grapheme" is a pattern unit class that
     * represents:
     *
     * a) A "Literal", which is a single unicode-aware character,
     * with possible representations being an ascii character,
     * a unicode character, or an ascii or unicode escape
     * sequence.
     *
     * or b) A "Special", which is a sequence that matches
     * something other than the character specified,
     * such as . \b \s
     */
    class RegexGrapheme extends RegexUnit {
        constructor(grapheme, quantifier) {
            super(quantifier);
            this.grapheme = grapheme;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const q = this.quantifier;
            const qEsc = q === null ? "" : esc(q.toString());
            const g = this.grapheme.toString();
            return escapableGraphemes.includes(g) ?
                "\\" + g + qEsc :
                g + qEsc;
        }
    }
    Truth.RegexGrapheme = RegexGrapheme;
    /** */
    const escapableGraphemes = [
        "*" /* star */,
        "+" /* plus */,
        "^" /* negate */,
        "?" /* restrained */,
        "(" /* groupStart */,
        ")" /* groupEnd */,
        "|" /* alternator */,
        "[" /* setStart */,
        "]" /* setEnd */,
        "{" /* quantifierStart */,
        "}" /* quantifierEnd */
    ];
    /**
     * A Regex "Sign" refers to an escape sequence that refers
     * to one other character, as opposed to that character
     * being written directly in the parse stream.
     */
    class RegexSign extends RegexUnit {
        constructor(sign, quantifier) {
            super(quantifier);
            this.sign = sign;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const q = this.quantifier;
            return this.sign.toString() + (q === null ? "" : esc(q.toString()));
        }
    }
    Truth.RegexSign = RegexSign;
    /**
     * A pattern unit class that represents +, *,
     * and explicit quantifiers such as {1,2}.
     */
    class RegexQuantifier {
        constructor(
        /**
         * Stores the lower bound of the quantifier,
         * or the fewest number of graphemes to be matched.
         */
        min = 0, 
        /**
         * Stores the upper bound of the quantifier,
         * or the most number of graphemes to be matched.
         */
        max = Infinity, 
        /**
         * Stores whether the the quantifier is restrained,
         * in that it matches the fewest possible number
         * of characters.
         *
         * (Some regular expression flavours awkwardly
         * refer to this as "non-greedy".)
         */
        restrained) {
            this.min = min;
            this.max = max;
            this.restrained = restrained;
        }
        /**
         * Converts the regex quantifier to an optimized string.
         */
        toString() {
            const rst = this.restrained ? "?" /* restrained */ : "";
            if (this.min === 0 && this.max === Infinity)
                return "*" /* star */ + rst;
            if (this.min === 1 && this.max === Infinity)
                return "+" /* plus */ + rst;
            if (this.min === 0 && this.max === 1)
                return "?" /* restrained */;
            const qs = "{" /* quantifierStart */;
            const qp = "," /* quantifierSeparator */;
            const qe = "}" /* quantifierEnd */;
            return this.min === this.max ?
                qs + this.min + qe :
                qs + this.min + qp + (this.max === Infinity ? "" : this.max.toString()) + qe;
        }
    }
    Truth.RegexQuantifier = RegexQuantifier;
    /**
     * Utility function that returns a double escape
     * if the passed value is a backslash.
     */
    function esc(maybeBackslash) {
        if (maybeBackslash === 92 || maybeBackslash === "\\")
            return "\\\\";
        if (typeof maybeBackslash === "number")
            return String.fromCodePoint(maybeBackslash);
        return maybeBackslash;
    }
    /**
     *
     */
    function escMany(array) {
        return array.map(esc).join("");
    }
    /**
     *
     */
    function serializeUnicodeBlock(blockName) {
        const block = Truth.UnicodeBlocks.get(blockName.toLowerCase());
        if (block === undefined)
            throw Truth.Exception.unknownState();
        const rng = "-" /* range */;
        const from = block[0].toString(16);
        const to = block[1].toString(16);
        return `\\u{${from}}${rng}\\u{${to}}`;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a portion of the content
     * within an Infix that spans a type reference.
     */
    class Infix {
        constructor(
        /**
         * Stores the left-most character position of the Infix
         * (before the delimiter), relative to the containing statement.
         */
        offsetStart, 
        /**
         * Stores the left-most character position of the Infix
         * (after the delimiter), relative to the containing statement.
         */
        offsetEnd, 
        /**
         * Stores the Bounds object that marks out the positions
         * of the identifiers in the Infix that are located before
         * any Joint operator.
         */
        lhs, 
        /**
         * Stores the Bounds object that marks out the positions
         * of the identifiers in the Infix that are located after
         * any Joint operator.
         */
        rhs, 
        /** */
        flags) {
            this.offsetStart = offsetStart;
            this.offsetEnd = offsetEnd;
            this.lhs = lhs;
            this.rhs = rhs;
            this.flags = flags;
        }
        /**
         * Gets whether this Infix is of the "pattern" variety.
         */
        get isPattern() {
            return (this.flags & InfixFlags.pattern) === InfixFlags.pattern;
        }
        /**
         * Gets whether this Infix is of the "portability" variety.
         */
        get isPortability() {
            return (this.flags & InfixFlags.portability) === InfixFlags.portability;
        }
        /**
         * Gets whether this Infix is of the "population" variety.
         */
        get isPopulation() {
            return (this.flags & InfixFlags.population) === InfixFlags.population;
        }
        /**
         * Gets whether this Infix has the "nominal" option set.
         */
        get isNominal() {
            return (this.flags & InfixFlags.nominal) === InfixFlags.nominal;
        }
        /** */
        toString() {
            const delimL = this.isPattern ? "</" /* patternStart */ :
                this.isNominal ? "<<" /* nominalStart */ :
                    this.isPortability ? "<" /* start */ + " " /* space */ + ":" /* joint */ + " " /* space */ :
                        "<" /* start */;
            const delimR = this.isPattern ? "/>" /* patternEnd */ :
                this.isNominal ? ">>" /* nominalEnd */ :
                    ">" /* end */;
            const join = (spans) => Array.from(spans)
                .map(entry => entry.subject)
                .join("," /* combinator */ + " " /* space */);
            if (this.isPortability)
                return join(this.rhs);
            if (this.isPattern)
                return join(this.lhs);
            const joint = this.rhs.length > 0 ?
                " " /* space */ + ":" /* joint */ + " " /* space */ :
                "";
            return delimL + join(this.lhs) + joint + join(this.rhs) + delimR;
        }
    }
    Truth.Infix = Infix;
    /**
     *
     */
    let InfixFlags;
    (function (InfixFlags) {
        InfixFlags[InfixFlags["none"] = 0] = "none";
        /**
         * Indicates that the joint was specified within
         * the infix. Can be used to determine if the infix
         * contains some (erroneous) syntax resembing
         * a refresh type, eg - /<Type : >/
         */
        InfixFlags[InfixFlags["hasJoint"] = 1] = "hasJoint";
        /**
         * Indicates that the </Pattern/> syntax was
         * used to embed the patterns associated
         * with a specified type.
         */
        InfixFlags[InfixFlags["pattern"] = 2] = "pattern";
        /**
         * Indicates that the infix is of the "portabiity"
         * variety, using the syntax < : Type>
         */
        InfixFlags[InfixFlags["portability"] = 4] = "portability";
        /**
         * Indicates that the infix is of the "popuation"
         * variety, using the syntax <Declaration : Annotation>
         * or <Declaration>
         */
        InfixFlags[InfixFlags["population"] = 8] = "population";
        /**
         * Indicates that the <<Double>> angle bracket
         * syntax was used to only match named types,
         * rather than aliases.
         */
        InfixFlags[InfixFlags["nominal"] = 16] = "nominal";
    })(InfixFlags = Truth.InfixFlags || (Truth.InfixFlags = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a single subject in a Statement.
     * Consumers of this class should not expect Subject objects
     * to be long-lived, as they are discarded regularly after edit
     * transactions complete.
     */
    class Identifier {
        /** */
        constructor(text) {
            const listTok = "..." /* list */;
            const tokLen = listTok.length;
            this.isList = text.length > tokLen + 1 && text.slice(-tokLen) === listTok;
            this.fullName = text;
            this.typeName = this.isList ? text.slice(0, -tokLen) : text;
        }
        /**
         * Converts this Subject to it's string representation.
         * @param escape If true, preserves any necessary
         * escaping required to ensure the identifier string
         * is in a parsable format.
         */
        toString(escape = 0 /* none */) {
            const val = (() => {
                switch (escape) {
                    case 0 /* none */:
                        return this.typeName;
                    case 1 /* declaration */:
                        {
                            // Regex delimiters are escaped if and only if 
                            // they're the first character in an Identifier.
                            const dlmReg = new RegExp("^" + "/" /* main */);
                            const jntRegS = new RegExp(":" /* joint */ + " " /* space */);
                            const jntRegT = new RegExp(":" /* joint */ + "\t" /* tab */);
                            const cmbReg = new RegExp("," /* combinator */);
                            return this.typeName
                                .replace(dlmReg, "\\" /* escapeChar */ + "/" /* main */)
                                .replace(jntRegS, "\\" /* escapeChar */ + ":" /* joint */ + " " /* space */)
                                .replace(jntRegT, "\\" /* escapeChar */ + ":" /* joint */ + "\t" /* tab */)
                                .replace(cmbReg, "\\" /* escapeChar */ + "," /* combinator */);
                        }
                    case 2 /* annotation */:
                        {
                            const reg = new RegExp("," /* combinator */);
                            const rep = "\\" /* escapeChar */ + "," /* combinator */;
                            return this.typeName.replace(reg, rep);
                        }
                }
            })();
            return val + (this.isList ? "..." /* list */ : "");
        }
    }
    Truth.Identifier = Identifier;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a position in a statement.
     */
    class Span {
        /**
         * @internal
         */
        constructor(
        /**
         * Stores a reference to the Statement that contains this Span.
         */
        statement, 
        /**
         * Stores the subject, and the location of it in the document.
         */
        boundary) {
            this.statement = statement;
            this.boundary = boundary;
            /**
             * @internal
             * Logical clock value used to make chronological
             * creation-time comparisons between Spans.
             */
            this.stamp = Truth.VersionStamp.next();
            this._infixes = null;
            /** */
            this.infixSpanTable = new Map();
            this._ancestry = null;
            /**  */
            this.factoredSpines = null;
            this.name =
                Truth.SubjectSerializer.forInternal(boundary) +
                    ` (${boundary.offsetStart}, ${boundary.offsetEnd})`;
        }
        /**
         * Gets the Infixes stored within this Span, in the case when
         * the Span corresponds to a Pattern. In other cases, and
         * empty array is returned.
         */
        get infixes() {
            return this._infixes || (this._infixes = Object.freeze((() => {
                return this.boundary.subject instanceof Truth.Pattern ?
                    Array.from(this.boundary.subject.getInfixes()) :
                    [];
            })()));
        }
        /** */
        *eachDeclarationForInfix(infix) {
            if (!this.infixes.includes(infix))
                throw Truth.Exception.invalidCall();
            const { lhs } = this.queryInfixSpanTable(infix);
            for (const infixSpan of lhs)
                yield infixSpan;
        }
        /** */
        *eachAnnotationForInfix(infix) {
            if (!this.infixes.includes(infix))
                throw Truth.Exception.invalidCall();
            const { rhs } = this.queryInfixSpanTable(infix);
            for (const infixSpan of rhs)
                yield infixSpan;
        }
        /** */
        queryInfixSpanTable(infix) {
            return this.infixSpanTable.get(infix) || (() => {
                const lhs = [];
                const rhs = [];
                for (const boundary of infix.lhs)
                    lhs.push(new Truth.InfixSpan(this, infix, boundary));
                for (const boundary of infix.rhs)
                    rhs.push(new Truth.InfixSpan(this, infix, boundary));
                return { lhs, rhs };
            })();
        }
        /**
         * Gets an array of statements that represent the statement
         * containment progression, all the way back to the containing
         * document.
         */
        get ancestry() {
            if (this._ancestry)
                if (this._ancestry.every(smt => !smt.isDisposed))
                    return this._ancestry;
            // If the ancestry has no yet been computed, or it has, but at least of
            // it's statements have been disposed, then it must be recomputed.
            this._ancestry = this.statement.document.getAncestry(this.statement);
            if (!this._ancestry)
                throw Truth.Exception.unknownState();
            return this._ancestry;
        }
        /**
         * Splits apart the groups subjects specified in the containing
         * statement's ancestry, and generates a series of spines,
         * each indicating a separate pathway of declarations through
         * the ancestry that reach the location in the document
         * referenced by this global span object.
         *
         * The generated spines are referentially opaque. Running this
         * method on the same Span object always returns the same
         * Spine instance.
         */
        factor() {
            if (this.factoredSpines)
                return this.factoredSpines;
            if (this.isCruft || this.statement.isCruft)
                return this.factoredSpines = Object.freeze([]);
            if (this.ancestry.length === 0)
                return this.factoredSpines = Object.freeze([new Truth.Spine([this])]);
            // We need to factor the ancestry. This means we're taking the
            // specified ancestry path, and splitting where any has-a side unions
            // exist, in effect creating all possible paths to the specified tip.
            // It's possible to have statements in the span path in the case
            // when the statement has been deemed as cruft, and therefore,
            // is impossible to extract any spans from it.
            const factoredSpanPaths = [];
            // An array of arrays. The first dimension corresponds to a statement. 
            // The second dimension stores the declaration spans themselves.
            const ancestryMatrix = this.ancestry.map(smt => Array.from(smt.declarations));
            // An array that stores the number of declaration spans in each statement.
            const ancestryLengths = ancestryMatrix.map(span => span.length);
            // Multiplying together the number of spans in each statement will
            // give the total number of unique spines that will be produced.
            const numSpines = ancestryLengths.reduce((a, b) => a * b, 1);
            // Start with an array of 0's, whose length matches the number
            // of statements in the ancestry. Each number in this array will be 
            // incremented by 1, from right to left, each number maxing out at
            // the number of declarations in the ancestor. After each incrementation,
            // the progression of numbers will run through all indexes required to
            // perform a full factorization of the terms in the ancestry. This array
            // tells the algorithm which indexes in ancestryMatrix to pull when
            // constructing a spine.
            const cherryPickIndexes = ancestryLengths.map(() => 0);
            // Stores the position in cherryPickIndexes that we're currently
            // incrementing. Moves backward when the number at 
            // the target position is >= the number of terms at that position.
            let targetIncLevel = 0;
            for (let i = -1; ++i < numSpines;) {
                // Do an insertion at the indexes specified by insertionIndexes
                const spanPath = [];
                // Cherry pick a series of terms from the ancestry terms,
                // according to the index set we're currently on.
                for (let level = -1; ++level < this.ancestry.length;) {
                    const statement = this.ancestry[level];
                    if (statement.isCruft) {
                        spanPath.push(statement);
                        continue;
                    }
                    const spansForStatement = ancestryMatrix[level];
                    const spanIndex = cherryPickIndexes[level];
                    const span = spansForStatement[spanIndex];
                    if (!span)
                        throw Truth.Exception.unknownState();
                    spanPath.push(span);
                }
                // The tip span specified in the method arguments
                // is added at the end of all generated span paths.
                spanPath.push(this);
                factoredSpanPaths.push(spanPath);
                // Bump up the current cherry pick index, 
                // or if we hit the roof, move to the next level,
                // and keep doing this until we find a number
                // to increment.
                while (cherryPickIndexes[targetIncLevel] >= ancestryLengths[targetIncLevel] - 1)
                    targetIncLevel++;
                cherryPickIndexes[targetIncLevel]++;
            }
            return this.factoredSpines =
                Object.freeze(factoredSpanPaths.map(spanPath => new Truth.Spine(spanPath)));
        }
        /**
         * Gets a boolean value that indicates whether this Span is considered
         * object-level cruft, and should therefore be ignored during type analysis.
         */
        get isCruft() {
            return this.statement.cruftObjects.has(this);
        }
        /**
         * Converts this Span to a string representation.
         *
         * @param includeHashPrefix If the subject inside this Span is a
         * Pattern, and this argument is true, the Pattern's hash prefix
         * will be prepended to the serialized result.
         */
        toString(includeHashPrefix) {
            const sub = this.boundary.subject;
            return sub instanceof Truth.Pattern ?
                sub.toString(!!includeHashPrefix) :
                sub.toString();
        }
    }
    Truth.Span = Span;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages an array of Span objects that
     * represent a specific spine of declarations, starting at
     * a document, passing through a series of spans,
     * and ending at a tip span.
     */
    class Spine {
        /** */
        constructor(vertebrae) {
            /** Stores an array of the Spans that compose the Spine. */
            this.vertebrae = [];
            if (vertebrae.length === 0)
                throw Truth.Exception.invalidCall();
            this.vertebrae = vertebrae.map(v => {
                if (v instanceof Truth.Span)
                    return v;
                const existCruftMarker = CruftMarkers.get(v);
                if (existCruftMarker !== undefined)
                    return existCruftMarker;
                const newCruftMarker = new CruftMarker(v);
                CruftMarkers.set(v, newCruftMarker);
                return newCruftMarker;
            });
            const tip = this.vertebrae[vertebrae.length - 1];
            if (tip instanceof CruftMarker)
                throw Truth.Exception.invalidCall();
            this.tip = tip;
        }
        /** */
        get statement() { return this.tip.statement; }
        /** Gets a reference to the document that sits at the top of the spine. */
        get document() { return this.statement.document; }
    }
    Truth.Spine = Spine;
    /**
     * A class that acts as a stand-in for a statement that has been
     * marked as cruft, suitable for usage in a Spine.
     */
    class CruftMarker {
        /** @internal */
        constructor(statement) {
            this.statement = statement;
        }
        /**
         * Converts this cruft marker to a string representation,
         * which is derived from a hash calculated from this
         * marker's underlying statement.
         */
        toString() {
            return "" + Truth.Hash.calculate(this.statement.sourceText);
        }
    }
    Truth.CruftMarker = CruftMarker;
    const CruftMarkers = new WeakMap();
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    class SubjectSerializer {
        /**
         * Universal method for serializing a subject to a string,
         * useful for debugging and supporting tests.
         */
        static forExternal(target, escapeStyle = 0 /* none */) {
            const subject = this.resolveSubject(target);
            return this.serialize(subject, escapeStyle, false);
        }
        /**
         * Serializes a subject, or a known subject containing object for internal use.
         */
        static forInternal(target) {
            const subject = this.resolveSubject(target);
            return this.serialize(subject, 0 /* none */, true);
        }
        /** */
        static resolveSubject(target) {
            return target instanceof Truth.Boundary ? target.subject :
                target instanceof Truth.Span ? target.boundary.subject :
                    target instanceof Truth.InfixSpan ? target.boundary.subject :
                        target;
        }
        /** */
        static serialize(subject, escapeStyle, includeHash) {
            if (subject instanceof Truth.Identifier)
                return subject.toString(escapeStyle);
            else if (subject instanceof Truth.Pattern)
                return subject.toString(includeHash);
            else if (subject instanceof Truth.Uri)
                return subject.toString();
            else if (subject instanceof Truth.Anon)
                return subject.toString();
            throw Truth.Exception.unknownState();
        }
    }
    Truth.SubjectSerializer = SubjectSerializer;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class HyperGraph {
        /** @internal */
        constructor(program) {
            this.program = program;
            /**
             * Stores a GraphTransaction instance in the case
             * when an edit transaction is underway.
             */
            this.activeTransactions = new Map();
            this.nodeIndex = new Truth.NodeIndex(this.program);
            if (HyperGraph.disabled)
                return;
            program.documents.each()
                .forEach(this.include.bind(this));
            program.on(Truth.CauseDocumentCreate, data => {
                this.include(data.document);
            });
            program.on(Truth.CauseDocumentDelete, data => {
                this.exclude(data.document);
            });
            program.on(Truth.CauseInvalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        this.exclude(smt);
                }
                else
                    this.exclude(data.document);
            });
            program.on(Truth.CauseRevalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        this.include(smt);
                }
                else
                    this.include(data.document);
            });
        }
        /**
         * Reads a root Node with the specified
         * name out of the specified document.
         */
        read(document, name) {
            const uriText = document.sourceUri
                .extendType(name)
                .toString();
            return this.nodeIndex.getNodeByUri(uriText) || null;
        }
        /**
         * @returns An array containing the node objects
         * that are defined at the root level of the specified
         * document.
         */
        *readRoots(document) {
            for (const node of this.nodeIndex.eachNode())
                if (node.container === null)
                    if (node.document === document)
                        yield node;
        }
        /**
         * Handles a document-level exclusion, which is the removal
         * of a section of Spans within a document, or possibly the
         * entire document itself.
         */
        exclude(root) {
            const { document, iterator } = this.methodSetup(root);
            const txn = new GraphTransaction();
            ///const maybeDestabilizedEdges: HyperEdge[] = [];
            for (const { statement } of iterator) {
                for (const declaration of statement.declarations) {
                    const associatedNodes = new Set(declaration
                        .factor()
                        .map(spine => Truth.Uri.clone(spine))
                        .map(uri => this.nodeIndex.getNodeByUri(uri))
                        .filter((n) => n instanceof Truth.Node));
                    for (const associatedNode of associatedNodes) {
                        associatedNode.removeDeclaration(declaration);
                        if (associatedNode.declarations.size === 0)
                            txn.destabilizedNodes.push(associatedNode);
                        for (const ob of associatedNode.outbounds)
                            if (ob.fragments.length === 0)
                                txn.destablizedEdges.push(ob);
                        ///for (const ib of associatedNode.inbounds)
                        ///	maybeDestabilizedEdges.push(ib);
                    }
                }
            }
            ///for (const edge of maybeDestabilizedEdges)
            ///	if (edge.successors.every(scsr => txn.destabilizedNodes.includes(scsr.node)))
            ///		txn.destablizedEdges.push(edge);
            this.activeTransactions.set(document, txn);
        }
        /**
         * Performs a revalidation of the Nodes that correspond to the
         * input argument.
         *
         * @param root The root object under which which revalidation
         * should occur. In the case when a Document instance is passed,
         * all Nodes present within the document are revalidated. In the
         * case when a Statement instance is passed, the Nodes that
         * correspond to the Statement, and all of it's contents are
         * revalidated.
         */
        include(root) {
            const { document, iterator } = this.methodSetup(root);
            const txn = this.activeTransactions.get(document);
            // Stores all the nodes that have been affected by a new
            // fragment either being added or removed from it.
            const affectedNodes = [];
            // Stores a subset of the affectedNodes array. Contains
            // only the nodes that are at the highest level of depth
            // within the node set (not necessarily the document root).
            const affectedNodesApexes = [];
            /**
             * @returns The containing node that
             * corresponds to the specified URI.
             */
            const findNode = (uri) => {
                if (uri.types.length === 0)
                    throw Truth.Exception.invalidArgument();
                const existingNode = affectedNodes.find(node => node.uri.equals(uri, true));
                if (existingNode)
                    return existingNode;
                const cachedNode = this.nodeIndex.getNodeByUri(uri);
                if (cachedNode)
                    return cachedNode;
                return null;
            };
            const breadthFirstOrganizer = [];
            for (const { level, statement } of iterator) {
                // Possibly append a bunch of empty multi-maps
                // at the end of the organizer, so that we don't
                // access an uninitialized index down below.
                while (breadthFirstOrganizer.length < level + 1)
                    breadthFirstOrganizer.push(new Truth.MultiMap());
                // In the case when the current statement has been deemed
                // as cruft, it's OK to just continue, because the breadth-first
                // organizer will end up with an empty multi-map in the case
                // when the portion of the hierarchy being traversed looks 
                // like:
                // 
                // Foo
                // 	[Cruft]    <=== Will correspond to an empty multi-map
                // 		Bar
                //
                // Or, it will end up with a populated multi-map in the case
                // when there is another statement at [Cruft]'s level of depth.
                // Either way, there are no spans that need to be added from
                // statements marked as cruft. The traversal will still reach
                // the crufty statement's contents, causing the spines to still
                // be computed.
                if (statement.isCruft)
                    continue;
                const multiMap = breadthFirstOrganizer[level];
                for (const decl of statement.declarations) {
                    for (const spine of decl.factor()) {
                        const uri = Truth.Uri.clone(spine);
                        const typeNames = spine.vertebrae.map(v => v.toString(true));
                        multiMap.add(typeNames.join("\n" /* terminal */), { uri, declaration: decl });
                        // If the declaration has population infixes, these
                        // need to be added to the map as though they
                        // were regular declarations.
                        const popInfixes = decl.infixes.filter(nfx => nfx.isPopulation);
                        if (popInfixes.length === 0)
                            continue;
                        for (const infix of popInfixes) {
                            for (const infixSpan of decl.eachDeclarationForInfix(infix)) {
                                const nfxText = Truth.SubjectSerializer.forInternal(infixSpan);
                                const infixSpineParts = typeNames.concat(nfxText);
                                multiMap.add(infixSpineParts.join("\n" /* terminal */), {
                                    uri: uri.extendType(nfxText),
                                    declaration: infixSpan
                                });
                            }
                        }
                    }
                }
            }
            // The following block populates the appropriate Nodes
            // in the graph with the new Span objects that were sent
            // in through the "root" parameter. New Node objects
            // are created if necessary.
            for (const multiMap of breadthFirstOrganizer)
                for (const entry of multiMap.values())
                    for (const { uri, declaration } of entry) {
                        const nodeAtUri = findNode(uri);
                        if (nodeAtUri) {
                            affectedNodes.push(nodeAtUri);
                            nodeAtUri.addDeclaration(declaration);
                            continue;
                        }
                        const container = uri.types.length > 1 ?
                            findNode(uri.retractType(1)) :
                            null;
                        if (uri.types.length > 1 && container === null)
                            throw Truth.Exception.unknownState();
                        // Note that when creating a Node, it's
                        // automatically bound to it's container.
                        const newNode = new Truth.Node(container, declaration);
                        affectedNodes.push(newNode);
                        // Populate the topMostAffectedNodes array, 
                        // which is needed to find the nodes that are
                        // affected by the change, but are not located
                        // directly within the patch.
                        if (affectedNodesApexes.length === 0) {
                            affectedNodesApexes.push(newNode);
                        }
                        else {
                            // If we've encountered a node that is higher
                            // than the level of depth defined in the nodes currently
                            // in the affectedNodesApexes array.
                            const highestDepth = affectedNodes[0].uri.types.length;
                            const nodeDepth = newNode.uri.types.length;
                            if (nodeDepth < highestDepth)
                                affectedNodesApexes.length = 0;
                            if (nodeDepth <= highestDepth)
                                affectedNodesApexes.push(newNode);
                        }
                    }
            // Add or update all new HyperEdges by feeding in all
            // annotation spans for each declaration span.
            // This needs to happen in a second pass because
            // all new nodes need to be created and positioned
            // in the graph before new "HyperEdge spans" can be added,
            // because doing this causes resolution to occur.
            for (const node of affectedNodes)
                for (const declaration of node.declarations) {
                    if (declaration instanceof Truth.Span) {
                        for (const annotation of declaration.statement.annotations)
                            node.addEdgeFragment(annotation);
                    }
                    else {
                        const nfx = declaration.containingInfix;
                        for (const boundary of nfx.rhs) {
                            node.addEdgeFragment(new Truth.InfixSpan(declaration.containingSpan, nfx, boundary));
                        }
                    }
                }
            // This is doing the reverse of what the above affectedNodes
            // loop is doing ... this is connecting other nodes to the affected
            // nodes, whereas the loop above is connecting affectedNodes
            // to others.
            if (affectedNodesApexes.length > 0) {
                // Stores the series of containers that any of the newly discovered
                // possibly affected nodes must have in their containment list
                // in order to be included in the "affectedNodes" array.
                const apexContainers = affectedNodesApexes
                    .map(node => node.container)
                    .filter((node) => node !== null)
                    .filter((v, i, a) => a.indexOf(v) === i);
                const checkRoot = apexContainers.length === 0;
                const isBelowAnApexContainer = (node) => node.containment.some(n => apexContainers.includes(n));
                for (const scsrNode of affectedNodesApexes) {
                    // Pattern and URI resolution doesn't occur in the
                    // Node graph, so when the node's subject isn't 
                    // an identifier, we don't add any edges to it.
                    if (!(scsrNode.subject instanceof Truth.Identifier))
                        continue;
                    const idents = this.nodeIndex.getAssociatedIdentifiers(scsrNode);
                    for (const ident of idents) {
                        const predecessors = this.nodeIndex.getNodesByIdentifier(ident);
                        for (const predecessor of predecessors)
                            if (checkRoot || isBelowAnApexContainer(predecessor))
                                predecessor.addEdgeSuccessor(scsrNode);
                    }
                }
            }
            // If there's no active transaction the corresponds to the input
            // document, the most likely reason is that an entire document
            // is being included for the first time.
            if (txn) {
                for (const maybeDeadEdge of txn.destablizedEdges)
                    if (maybeDeadEdge.fragments.length > 0)
                        maybeDeadEdge.predecessor.disposeEdge(maybeDeadEdge);
                for (const maybeDeadNode of txn.destabilizedNodes)
                    if (maybeDeadNode.declarations.size === 0) {
                        maybeDeadNode.dispose();
                        this.nodeIndex.delete(maybeDeadNode);
                    }
            }
            // Populate nodeCache with any newly created nodes.
            for (const affectedNode of affectedNodes) {
                affectedNode.sortOutbounds();
                const affectedUri = affectedNode.uri.toString();
                const cachedNode = this.nodeIndex.getNodeByUri(affectedUri);
                if (cachedNode) {
                    if (cachedNode !== affectedNode)
                        throw Truth.Exception.unknownState();
                    this.nodeIndex.update(affectedNode);
                }
                else {
                    this.nodeIndex.set(affectedUri, affectedNode);
                }
                this.sanitize(affectedNode);
            }
        }
        /** */
        log() {
            console.log("---- INTERNAL GRAPH REPRESENTATION ----");
            for (const node of this.nodeIndex.eachNode())
                console.log(node.toString(true));
        }
        /**
         * Performs setup for the invalidate and revalidate methods.
         */
        methodSetup(root) {
            const document = root instanceof Truth.Document ?
                root :
                root.document;
            const iterator = root instanceof Truth.Document ?
                document.eachDescendant() :
                document.eachDescendant(root, true);
            return { document, iterator };
        }
        /**
         * Reports any Node-level faults detected.
         */
        sanitize(node) {
            // Check for faulty refresh types
            // This can only happen on non-infix spans
            if (!(node.declarations.values().next().value instanceof Truth.Span))
                return;
            const smts = node.statements;
            const smtsRefresh = smts.filter(smt => smt.isRefresh);
            const smtsAnnotated = smts.filter(smt => smt.allAnnotations.length > 0);
            if (smtsRefresh.length > 0 && smtsAnnotated.length > 0)
                for (const smt of smtsRefresh)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.TypeCannotBeRefreshed, smt));
        }
        /**
         * Serializes the Graph into a format suitable
         * for debugging and comparing against baselines.
         */
        toString() {
            return this.nodeIndex.toString();
        }
    }
    Truth.HyperGraph = HyperGraph;
    /**
     *
     */
    class GraphTransaction {
        constructor() {
            /**
             * Stores an array of Nodes that no longer have any
             * underlying Span objects, due to their removal in
             * the invalidation phase.
             */
            this.destabilizedNodes = [];
            /**
             * Stores an array of Fans that no longer have any
             * underlying Span objects, due to their removal in
             * the invalidation phase.
             */
            this.destablizedEdges = [];
        }
    }
    /**
     * @internal
     * Debug utility.
     */
    function serializeNodes(nodes) {
        return "\n" + nodes.map(node => node.toString(true)).join("\n");
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a single Node contained within
     * the Program's Graph. Nodes are long-lived, referentially
     * significant objects that persist between edit frames.
     *
     * Nodes are connected in a graph not by edges, but by
     * HyperEdges. A HyperEdge (from graph theory) is similar
     * to a directed edge in that it has a single predecessor,
     * but differs in that it has multiple successors.
     *
     * It is necessary for Nodes to be connected to each other
     * in this way, in order for further phases in the pipeline
     * to execute the various kinds of polymorphic type
     * resolution.
     */
    class Node {
        /** @internal */
        constructor(container, declaration) {
            this.lastUri = null;
            this._contents = new Map();
            this._portabilityTargets = null;
            this._inbounds = new Set();
            this._outbounds = [];
            this._containment = null;
            const span = declaration instanceof Truth.Span ?
                declaration :
                declaration.containingSpan;
            this.container = container;
            this.document = span.statement.document;
            this.stamp = this.document.version;
            this._declarations = new Set([declaration]);
            this.subject = declaration.boundary.subject;
            this.name = Truth.SubjectSerializer.forInternal(this.subject);
            this.isListIntrinsic =
                this.subject instanceof Truth.Identifier &&
                    this.subject.isList;
            const containerTypePath = container !== null ?
                this.containment.slice().reverse().map(n => n.name) :
                [];
            this.typePath = containerTypePath.concat(this.name);
            if (this.declarations.size === 0)
                throw Truth.Exception.unknownState();
            if (!this.container) {
                this.addRootNode(this);
                return this;
            }
            this.container._contents.set(this.name, this);
            ///if (!(declaration instanceof Span))
            ///	return this;
            ///
            ///const identifier = declaration.boundary.subject;
            ///
            ///if (!(identifier instanceof Identifier))
            ///	return this;
            ///
            ///const containerPattern = (() =>
            ///{
            ///	for (const decl of this.container.declarations)
            ///		if (decl.boundary.subject instanceof Pattern)
            ///			return decl.boundary.subject;
            ///})();
            ///
            ///if (!containerPattern)
            ///	return this;
            ///
            ///for (const nfx of containerPattern.getInfixes(InfixFlags.population))
            ///	for (const ident of nfx.lhs.eachSubject())
            ///		if (ident.fullName === identifier.fullName)
            ///			//return (this.containerInfix = nfx), this;
            ///			return this;
        }
        /**
         * Removes this Node, and all its contents from the graph.
         */
        dispose() {
            if (this.container === null) {
                const map = Node.rootNodes.get(this.document);
                if (map)
                    map.delete(this.name);
            }
            else
                this.container._contents.delete(this.name);
            for (const ib of this._inbounds)
                ib.removeSuccessor(this);
            function recurse(node) {
                for (const edge of node._outbounds)
                    node.disposeEdge(edge);
                for (const containedNode of node._contents.values())
                    recurse(containedNode);
                // Manual memory management going on here.
                // Clearing out the Sets is probably unnecessary
                // because the GC would catch it anyways, but
                // these calls are here just to be safe.
                // It's still required that we clear out the inbounds
                // from the nodes to which this one is connected.
                node._declarations.clear();
                node._inbounds.clear();
            }
            recurse(this);
        }
        /**
         * Removes the specified HyperEdge from this Node's
         * set of outbounds.
         *
         * @throws In the case when the specified HyperEdge is
         * not owned by this Node.
         */
        disposeEdge(edge) {
            if (edge.predecessor !== this)
                throw Truth.Exception.invalidArgument();
            const idx = this._outbounds.indexOf(edge);
            this._outbounds.splice(idx, 1);
            for (const scsr of edge.successors)
                scsr.node._inbounds.delete(edge);
            edge.clearFragments();
        }
        /**
         * In the case when this node is a direct descendent of a
         * pattern node, and that pattern has population infixes,
         * and this node directly corresponds to one of those infixes,
         * this property gets a reference to said corresponding infix.
         */
        get containerInfix() {
            const flag = Truth.InfixFlags.population;
            if (this.container !== null)
                if (this.container.subject instanceof Truth.Pattern)
                    for (const nfx of this.container.subject.getInfixes(flag))
                        for (const ident of nfx.lhs.eachSubject())
                            return nfx;
            return null;
        }
        /** */
        get uri() {
            // Because the URI of the document can change, we need to 
            // make sure it's not hard coded into the node instance.
            const outUri = this.document.sourceUri.extendType(this.typePath);
            if (this.lastUri !== null)
                if (outUri.equals(this.lastUri))
                    return this.lastUri;
            return this.lastUri = outUri;
        }
        /**
         * Gets whether this Node has been explicitly defined as a list
         * extrinsic. It is worth noting that this property in and of itself is
         * not sufficient to determine whether any corresponding type is
         * actually a list (full type analysis is required to make this conclusion).
         */
        get isListExtrinsic() {
            for (const ob of this.outbounds)
                for (const source of ob.fragments)
                    if (source.boundary.subject instanceof Truth.Identifier)
                        if (source.boundary.subject.isList)
                            return true;
            return false;
        }
        /**
         * Gets a reference to the "opposite side of the list".
         *
         * If this Node represents a list intrinsic type, this property gets
         * a reference to the Node that represents the corresponding
         * extrinsic side.
         *
         * If this Node represents anything that *isn't* a list intrinsic type,
         * the property gets a reference to the Node that represents the
         * corresponding intrinsic side (whether the node is a list or not).
         *
         * Gets null in the case when there is no corresponding list intrinsic
         * or extrinsic Node to connect.
         */
        get intrinsicExtrinsicBridge() {
            if (this.subject instanceof Truth.Identifier)
                for (const adjacent of this.adjacents.values())
                    if (adjacent.subject instanceof Truth.Identifier)
                        if (adjacent.subject.typeName === this.subject.typeName)
                            if (adjacent.subject.isList !== this.isListIntrinsic)
                                return adjacent;
            return null;
        }
        /**
         * Stores the set of declaration-side Span instances that
         * compose this Node. If this the size of this set were to
         * reach zero, the Node would be marked for deletion.
         * (Node cleanup uses a reference counted collection
         * mechanism that uses the size of this set as it's guide).
         *
         * Note that although the type of this field is defined as
         * "Set<Span | InfixSpan>", in practice, it is either a set
         * of Span instances, or a set containing one single
         * InfixSpan instance. This is because it's possible to have
         * fragments of a type declared in multiple places in
         * a document, however, InfixSpans can only exist in one
         * place.
         */
        get declarations() {
            return this._declarations;
        }
        /** */
        addDeclaration(span) {
            this._declarations.add(span);
        }
        /** */
        removeDeclaration(span) {
            const wasDeleted = this._declarations.delete(span);
            if (wasDeleted) {
                // Remove all of the annotations that exist on the same
                // statement as the one that contains the declaration that
                // was removed. Note that this won't mess up fragmented
                // types. For example, consider the situation when the first
                // statement is removed from the following document:
                // 
                // A, B : X, Y
                // A, C : X, Y
                // 
                // Statements are removed atomically, so when the statement
                // is removed, this will result in 2 calls to this method: one for
                // the first "A", and one for the "B". When the second call is made,
                // the associated annotations will already have been removed.
                for (let i = this._outbounds.length; i-- > 0;) {
                    const ob = this._outbounds[i];
                    for (const anno of span.statement.allAnnotations)
                        ob.removeFragment(anno);
                    if (ob.fragments.length === 0)
                        this._outbounds.splice(i, 1);
                }
            }
        }
        /**
         * Gets an array containing the statements that
         * contain this Node.
         */
        get statements() {
            return Object.freeze(Array.from(this.declarations)
                .map(decl => decl.statement)
                .filter((v, i, a) => a.indexOf(v) === i));
        }
        /**
         * Gets a readonly map of Nodes that are contained
         * by this node in the containment hierarchy.
         */
        get contents() {
            return this._contents;
        }
        /**
         * Gets a readonly name of Nodes that are adjacent
         * to this Node in the containment hierarchy.
         */
        get adjacents() {
            const adjacentNodes = this.container ?
                this.container.contents :
                this.getRootNodes();
            // Filter this node out of the result set, because
            // Nodes cannot be adjacent to themselves.
            const out = new Map();
            for (const [name, node] of adjacentNodes)
                if (node !== this)
                    out.set(name, node);
            return out;
        }
        /**
         * Gets a 2-dimensional array containing the names of
         * the portability infixes that have been defined within
         * this node, with the first dimension corresponding to
         * a unique portability infix, and the second dimension
         * corresponding to the names defined within that infix.
         *
         * For example, given the following pattern:
         * /< : A, B, C>< : D, E, F> : ???
         *
         * The following result would be produced:
         * [["A", "B", "C"], ["D", "E", "F"]]
         */
        get portabilityTargets() {
            if (this._portabilityTargets !== null)
                return this._portabilityTargets;
            if (!(this.subject instanceof Truth.Pattern))
                return this._portabilityTargets = [];
            const identifierArrays = this.subject
                .getInfixes(Truth.InfixFlags.portability)
                .map(nfx => Object.freeze(Array.from(nfx.rhs.eachSubject())
                .map(ident => ident.typeName)));
            return this._portabilityTargets = Object.freeze(identifierArrays);
        }
        /**
         * @returns A set of nodes that are matched by
         * patterns of adjacent nodes.
         *
         * (Note that this is possible because annotations
         * that have been applied to a pattern cannot be
         * polymorphic)
         */
        getPatternNodesMatching(nodes) {
            const outNodes = [];
            //
            // This doesn't work because we don't know if
            // a node has been marked as cruft at this point.
            // This method may return junk results in the
            // case when one of the required nodes has
            // been marked as cruft (but then, wouldn't the
            // incoming node also be cruft?)
            //
            for (const node of this.adjacents.values()) {
                if (node.subject instanceof Truth.Pattern) {
                    const unorphaned = node.outbounds
                        .filter(ob => ob.successors.length > 0)
                        .map(ob => ob.successors[0].node);
                    if (unorphaned.length === 0)
                        continue;
                    if (unorphaned.length === nodes.length)
                        if (unorphaned.every(node => nodes.includes(node)))
                            outNodes.push(...unorphaned);
                }
            }
            return outNodes;
        }
        /**
         * Gets an immutable set of HyperEdges from adjacent
         * or contained Nodes that reference this Node.
         *
         * (The ordering of inbounds isn't important, as
         * they have no physical representation in the
         * document, which is why they're stored in a Set
         * rather than an array.)
         */
        get inbounds() {
            return this._inbounds;
        }
        /**
         * Gets an array of HyperEdges that connect this Node to
         * others, being either adjacents, or Nodes that
         * exists somewhere in the containment hierarchy.
         */
        get outbounds() {
            return this._outbounds;
        }
        /**
         * @internal
         * Sorts the outbound HyperEdges, so that they're ordering
         * is consistent with the way their corresponding
         * annotations appear in the underlying document.
         */
        sortOutbounds() {
            if (this._outbounds.length === 0)
                return;
            if (this._outbounds.length === 1) {
                const edge = this._outbounds[0];
                if (edge.fragments.length === 1)
                    return;
            }
            const edgeLookup = new Map();
            for (const edge of this._outbounds) {
                for (const src of edge.fragments.values()) {
                    const smt = src.statement;
                    const lineNum = smt.document.getLineNumber(smt);
                    const existingTuple = edgeLookup.get(edge);
                    if (existingTuple !== undefined) {
                        const existingStmt = existingTuple[0];
                        const existingStmtIdx = existingTuple[1];
                        if (lineNum < existingStmtIdx) {
                            existingTuple[0] = existingStmt;
                            existingTuple[1] = existingStmtIdx;
                        }
                    }
                    else {
                        edgeLookup.set(edge, [smt, lineNum]);
                    }
                }
            }
            // Sort the output edges in the array, so that the sorting of
            // the array aligns with the appearance of the underlying
            // spans in the document.
            this._outbounds.sort((edgeA, edgeB) => {
                const tupleA = edgeLookup.get(edgeA);
                const tupleB = edgeLookup.get(edgeB);
                const obs = this._outbounds;
                if (tupleA === undefined || tupleB === undefined)
                    throw Truth.Exception.unknownState();
                const [smtA, smtIdxA] = tupleA;
                const [smtB, smtIdxB] = tupleB;
                // If the top-most span of the predecessors of
                // the edges are located in different statements,
                // a simple comparison of the statement indexes
                // is possible.
                if (smtIdxA < smtIdxB)
                    return -1;
                if (smtIdxB < smtIdxA)
                    return 1;
                // At this point, statement A and statement B 
                // are actually equal.
                if (smtA !== smtB) {
                    throw Truth.Exception.unknownState();
                }
                const annos = smtA.annotations;
                const findMinIndex = (edge) => {
                    let minIdx = Infinity;
                    for (const src of edge.fragments) {
                        if (src instanceof Truth.InfixSpan)
                            throw Truth.Exception.unknownState();
                        const idx = annos.indexOf(src);
                        if (idx < minIdx)
                            minIdx = idx;
                    }
                    if (minIdx === Infinity)
                        throw Truth.Exception.unknownState();
                    return minIdx;
                };
                const edgeAIdx = findMinIndex(edgeA);
                const edgeBIdx = findMinIndex(edgeB);
                return edgeAIdx - edgeBIdx;
            });
        }
        /**
         * @internal
         * Adds a new edge to the node, or updates an existing one with
         * a new fragment.
         *
         * If no edge exists for the new fragment, a new one is created.
         */
        addEdgeFragment(fragment) {
            const identifier = fragment.boundary.subject;
            if (!(identifier instanceof Truth.Identifier))
                throw Truth.Exception.unknownState();
            // If the input source is "alone", it means that it refers to
            // a statement-level annotation that has no other annotations
            // beside it (e.g. in an annotation structure looking like "D: A1, A2")
            // This is relevant, because if the source is alone, it also needs
            // to be compared against any visible total patterns.
            const sourceIsAlone = fragment instanceof Truth.Span &&
                fragment.statement.annotations.length === 1;
            /**
             * Adds a edge to it's two applicable successor nodes.
             */
            const append = (edge) => {
                this._outbounds.push(edge);
                for (const suc of edge.successors)
                    suc.node._inbounds.add(edge);
            };
            // If there is already an existing outbound HyperEdge, we can
            // add the new Span to the edge's list of Spans, and quit.
            // This works whether the edge is for a type or pattern.
            const existingEdge = this._outbounds.find(edge => {
                return edge.identifier.typeName === identifier.typeName;
            });
            if (existingEdge) {
                existingEdge.addFragment(fragment);
            }
            else {
                const successors = [];
                for (const level of this.enumerateContainment()) {
                    const successorNode = level.container !== null &&
                        level.container !== this &&
                        level.container.name === identifier.typeName ?
                        level.container :
                        level.adjacents.get(identifier.typeName);
                    if (successorNode !== undefined) {
                        successors.push(new Truth.Successor(successorNode, level.longitudeDelta));
                        // There should only ever be a single successor in the case when
                        // the node is a pattern node, because the annotations (which
                        // are eventually become bases) of these nodes do not have
                        // polymorphic behavior.
                        if (this.subject instanceof Truth.Pattern)
                            break;
                    }
                }
                append(new Truth.HyperEdge(this, fragment, successors));
            }
            // 
            // Refresh the sums before quitting.
            // 
            ///const sumEdgeForInputSpanIdx = this._outbounds.findIndex(edge => 
            ///{
            ///	if (edge.kind === HyperEdgeKind.summation)
            ///		for (const src of edge.sources)
            ///			return src.statement === smt;
            ///	
            ///	return false;
            ///});
            ///
            ///if (sumEdgeForInputSpanIdx > -1)
            ///	this._outbounds.splice(sumEdgeForInputSpanIdx, 1);
            ///
            ///if (!sourceIsAlone)
            ///	for (const { longitudeDelta, adjacents } of this.enumerateContainment())
            ///		for (const adjacentNode of adjacents.values())
            ///			if (adjacentNode.subject instanceof Pattern)
            ///				if (adjacentNode.subject.isTotal)
            ///					if (adjacentNode.subject.test(smt.sum))
            ///						append(new HyperEdge(
            ///							this,
            ///							smt.sum,
            ///							[new Successor(
            ///								adjacentNode,
            ///								longitudeDelta)],
            ///							HyperEdgeKind.summation));
        }
        /**
         *
         */
        addEdgeSuccessor(successorNode) {
            const identifier = successorNode.subject;
            if (!(identifier instanceof Truth.Identifier))
                throw Truth.Exception.unknownState();
            for (const ob of this.outbounds) {
                if (ob.identifier.typeName !== successorNode.name)
                    continue;
                const scsrLong = successorNode.uri.types.length;
                const predLong = ob.predecessor.uri.types.length;
                ob.addSuccessor(successorNode, predLong - scsrLong);
                successorNode._inbounds.add(ob);
            }
        }
        /**
         *
         */
        enumerateOutbounds() {
            ///const recurse = (node: Node) =>
            ///{
            ///	for (const edge of node.outbounds)
            ///		for (const successor of edge.successors)
            ///			//yield { node: 
            ///}
            ///
            ///yield *recurse(this);
        }
        /**
         * Enumerates upwards through the containment
         * hierarchy of the Nodes present in this Node's
         * containing document, yielding the adjacents at
         * every level, and then continues through to the
         * root level adjacents of each of the document's
         * dependencies.
         */
        *enumerateContainment() {
            const doc = this.document;
            const program = doc.program;
            const deps = program.documents.getDependencies(doc);
            let currentLevel = this;
            let longitudeCount = 0;
            do {
                yield {
                    sourceDocument: doc,
                    container: currentLevel,
                    adjacents: currentLevel.adjacents,
                    longitudeDelta: longitudeCount++
                };
            } while ((currentLevel = currentLevel.container) !== null);
            // NOTE: This is broken. It needs to be recursive.
            for (let i = deps.length; --i > 0;) {
                const sourceDocument = deps[i];
                yield {
                    sourceDocument,
                    container: null,
                    adjacents: this.getRootNodes(sourceDocument),
                    longitudeDelta: longitudeCount
                };
            }
        }
        /**
         * @returns An array that stores the containment hierarchy
         * of the Nodes present in this Node's containing document,
         * yielding each containerof this Node.
         */
        get containment() {
            if (this._containment !== null)
                return this._containment;
            const nodes = [];
            let currentLevel = this;
            while ((currentLevel = currentLevel.container) !== null)
                nodes.push(currentLevel);
            return this._containment = Object.freeze(nodes);
        }
        /** */
        removeEdgeSource(src) {
            for (let i = this._outbounds.length; --i > 0;)
                this._outbounds[i].removeFragment(src);
        }
        /** */
        toString(includePath = true) {
            const decls = Array.from(this.declarations);
            const spans = decls.filter((s) => s instanceof Truth.Span);
            const anchors = decls.filter((a) => a instanceof Truth.InfixSpan);
            const spansText = spans.map(s => Truth.SubjectSerializer.forInternal(s)).join(", ");
            const anchorText = anchors.map(a => Truth.SubjectSerializer.forInternal(a)).join(", ");
            const ob = this.outbounds.length;
            const ib = this.inbounds.size;
            const path = includePath ? this.uri.types.join("/") + " " : "";
            const simple = [
                path,
                spansText.length ? "spans=" + spansText : "",
                anchorText.length ? "anchor=" + anchorText : "",
                "out=" + ob,
                "in=" + ib
            ].filter(s => s.trim()).join(", ");
            const fmt = (str) => str.split("\n").map(s => "\t\t" + s).join("\n");
            const obsVerbose = this.outbounds
                .map(ob => fmt(ob.toString()));
            const ibsVerbose = Array.from(this.inbounds.values())
                .map(ib => fmt(ib.toString()));
            const verbose = "\n\tOuts:\n" + obsVerbose.join("\n\n") +
                "\n\tIns:\n" + ibsVerbose.join("\n\n");
            return simple + verbose;
        }
        /** */
        addRootNode(node) {
            const existingSet = Node.rootNodes.get(node.document);
            if (existingSet) {
                existingSet.set(node.name, node);
            }
            else {
                const map = new Map();
                map.set(node.name, node);
                Node.rootNodes.set(node.document, map);
            }
        }
        /** */
        removeRootNode(node) {
            const existingSet = Node.rootNodes.get(node.document);
            if (existingSet) {
                existingSet.delete(node.name);
                // This is somewhat redundant as the set
                // is likely going to be GC'd away anyway in
                // this case. It's here for completeness sake.
                if (existingSet.size === 0)
                    Node.rootNodes.delete(node.document);
            }
        }
        /** */
        getRootNodes(fromDocument) {
            const fromDoc = fromDocument || this.document;
            const out = Node.rootNodes.get(fromDoc) || new Map();
            return Truth.HigherOrder.copy(out);
        }
    }
    /** */
    Node.rootNodes = new WeakMap();
    Truth.Node = Node;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class NodeIndex {
        /** */
        constructor(program) {
            /**
             * Stores a map of all nodes that have been loaded into the program,
             * indexed by a string representation of it's URI.
             */
            this.uriToNodeMap = new Map();
            /**
             * Stores a map which is indexed by a unique identifier, and which as
             * values that are the nodes that use that identifier, either as a declaration
             * or an annotation.
             *
             * The purpose of this cache is to get a quick answer to the question:
             * "We added a new identifier at position X ... what nodes might possibly
             * have been affected by this?"
             */
            this.identifierToNodesMap = new Map();
            /**
             * Stores a map which is essentially a reverse of identifierToNodesMap.
             * This is so that when nodes need to be deleted or updated, we can
             * quickly find the place in identifierToNodesMap where the node has
             * been referenced.
             */
            this.nodesToIdentifiersMap = new WeakMap();
            program.on(Truth.CauseDocumentUriChange, data => {
                // Update the entire cache when the URI of any document changes.
                const newUriStore = data.newUri.retractTypeTo(0);
                const entries = Array.from(this.uriToNodeMap.entries());
                for (const [oldUriText, node] of entries) {
                    if (node.document !== data.document)
                        continue;
                    const oldUri = Truth.Not.null(Truth.Uri.tryParse(oldUriText));
                    const newUriText = newUriStore
                        .extendType(oldUri.types.map(t => t.value))
                        .toString();
                    this.uriToNodeMap.delete(oldUriText);
                    this.uriToNodeMap.set(newUriText, node);
                }
            });
        }
        /**
         * Enumerates through all Node instances stored
         * in the index.
         */
        *eachNode() {
            for (const node of this.uriToNodeMap.values())
                yield node;
        }
        /**
         * Gets the number of nodes stored in the index.
         */
        get count() {
            return this.uriToNodeMap.size;
        }
        /**
         * Updates the index, establishing a cached relationship
         * between the specified uri and the specified node.
         */
        set(uri, node) {
            const uriText = typeof uri === "string" ? uri : uri.toString();
            this.uriToNodeMap.set(uriText, node);
            this.update(node);
        }
        /**
         * Updates the index by refreshing in the set of identifiers
         * that are associated with the specified node.
         */
        update(node) {
            const pastIdentifiers = this.nodesToIdentifiersMap.get(node);
            const presentIdentifiers = this.getAssociatedIdentifiers(node);
            if (pastIdentifiers !== undefined) {
                for (const [idx, ident] of pastIdentifiers.entries()) {
                    if (presentIdentifiers.includes(ident))
                        continue;
                    pastIdentifiers.splice(idx, 1);
                    const map = this.identifierToNodesMap.get(ident);
                    if (map === undefined)
                        continue;
                    map.delete(node);
                    if (map.size === 0)
                        this.identifierToNodesMap.delete(ident);
                }
            }
            for (const identifier of presentIdentifiers) {
                const nodesForIdent = this.identifierToNodesMap.get(identifier) || (() => {
                    const out = new Set();
                    this.identifierToNodesMap.set(identifier, out);
                    return out;
                })();
                nodesForIdent.add(node);
            }
            this.nodesToIdentifiersMap.set(node, presentIdentifiers);
        }
        /** */
        getNodeByUri(uri) {
            const uriText = typeof uri === "string" ? uri : uri.toString();
            return this.uriToNodeMap.get(uriText);
        }
        /**
         * @returns An array that contains the nodes that are associated
         * with the specified identifier that exist at or below the specified
         * depth. "Associated" means that the identifier is either equivalent
         * to the Node's main subject, or it is referenced in one of it's edges.
         */
        getNodesByIdentifier(identifer) {
            const out = this.identifierToNodesMap.get(identifer);
            return out ? Array.from(out) : [];
        }
        /**
         * Removes the specified node from the index, if it exists.
         */
        delete(deadNode) {
            for (const [uri, node] of this.uriToNodeMap)
                if (node === deadNode)
                    this.uriToNodeMap.delete(uri);
            const existingIdentifiers = this.nodesToIdentifiersMap.get(deadNode);
            if (existingIdentifiers === undefined)
                return;
            for (const identifier of existingIdentifiers) {
                const nodes = this.identifierToNodesMap.get(identifier);
                if (nodes === undefined)
                    continue;
                nodes.delete(deadNode);
                if (nodes.size === 0)
                    this.identifierToNodesMap.delete(identifier);
            }
            this.nodesToIdentifiersMap.delete(deadNode);
        }
        /**
         * @returns An array that contains the identifiers associated with
         * the specified Node.
         */
        getAssociatedIdentifiers(node) {
            const identifiers = [];
            if (node.subject instanceof Truth.Identifier)
                identifiers.push(node.subject.typeName);
            for (const smt of node.statements)
                for (const anno of smt.allAnnotations)
                    if (anno.boundary.subject instanceof Truth.Identifier)
                        identifiers.push(anno.boundary.subject.typeName);
            return identifiers;
        }
        /**
         * Serializes the index into a format suitable
         * for debugging and comparing against baselines.
         */
        toString() {
            if (this.uriToNodeMap.size === 0)
                return "(empty)";
            const out = [];
            const keys = Array.from(this.uriToNodeMap.keys()).map(s => {
                const uri = Truth.Uri.tryParse(s);
                return uri ? uri.toString() : s;
            });
            const values = Array.from(this.uriToNodeMap.values());
            for (let i = -1; ++i < keys.length;) {
                const key = keys[i];
                const value = values[i].toString(false);
                out.push(`${key}\n\t${value}\n`);
            }
            out.push("(Identifier Cache)");
            for (const [identifier, nodes] of this.identifierToNodesMap) {
                out.push("\t" + identifier);
                out.push("\t\t: " + Array.from(nodes)
                    .map(node => node.uri.toTypeString())
                    .join(", "));
            }
            return out.join("\n").trim();
        }
    }
    Truth.NodeIndex = NodeIndex;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A HyperEdge connects an origin predecessor Node to a series of
     * successor Nodes. From graph theory, a "hyper edge" is different
     * from an "edge" in that it can have many successors:
     * https://en.wikipedia.org/wiki/Hypergraph
     */
    class HyperEdge {
        constructor(
        /**
         * The Node from where the HyperEdge connection begins.
         * For example, given the following document:
         *
         * Foo
         * 	Bar : Foo
         *
         * Two Node objects would be created, one for the first instance
         * of "Foo", and another for the instance of "Bar". A HyperEdge
         * would be created between "Bar" and "Foo", and it's
         * precedessor would refer to the Node representing the
         * occurence of "Bar".
         */
        predecessor, source, successors) {
            this.predecessor = predecessor;
            if (!(source.boundary.subject instanceof Truth.Identifier))
                throw Truth.Exception.unknownState();
            const successorNodes = successors
                .map(scsr => scsr.node)
                .filter((v, i, a) => a.indexOf(v) === i);
            if (successorNodes.length !== successors.length)
                throw Truth.Exception.unknownState();
            this.identifier = source.boundary.subject;
            this.fragmentsMutable = [source];
            this.successorsMutable = successors.slice();
        }
        /**
         * Attempts to add another fragment to the HyperEdge.
         * Reports a fault instead in the case when there is a
         * list conflict between the source provided and the
         * existing sources. (I.e. one of the sources is defined
         * as a list, and another is not).
         */
        addFragment(fragment) {
            ///const isPattern = this.predecessor.subject instanceof Pattern;
            ///const isInfix = source instanceof InfixSpan;
            ///if (isPattern !== isInfix)
            ///	throw Exception.invalidCall();
            if (this.fragmentsMutable.includes(fragment))
                return;
            //! The ordering of the sources is not being handled here.
            this.fragmentsMutable.push(fragment);
        }
        /**
         * Removes the specified annotation-side Span or InfixSpan
         * from this edge.
         */
        removeFragment(fragment) {
            const fragPos = this.fragmentsMutable.indexOf(fragment);
            if (fragPos >= 0)
                this.fragmentsMutable.splice(fragPos, 1);
        }
        /** */
        clearFragments() {
            this.fragmentsMutable.length = 0;
        }
        /**
         * Gets the set of annotation-side Spans or annotation-side
         * InfixSpans that are responsible for the conception of this
         * HyperEdge.
         *
         * The array contains either Span instances or InfixSpan instances,
         * but never both. In the case when the array stores Span instances,
         * the location of those Spans are potentially scattered across many
         * statements.
         */
        get fragments() {
            return this.fragmentsMutable;
        }
        /**
         *
         */
        addSuccessor(node, longitude) {
            if (!this.successorsMutable.find(scsr => scsr.node === node))
                this.successorsMutable.push(new Successor(node, longitude));
        }
        /**
         *
         */
        removeSuccessor(node) {
            for (let i = this.successorsMutable.length; i-- > 0;)
                if (this.successorsMutable[i].node === node)
                    this.successorsMutable.splice(i, 1);
        }
        /**
         * Stores all possible success Nodes to which the predecessor
         * Node is preemptively connected via this HyperEdge. The
         * connection is said to be preemptive, because the connection
         * might be ignored during polymorphic name resolution.
         */
        get successors() {
            return this.successorsMutable;
        }
        /**
         * Gets whether this HyperEdge has no immediately resolvable
         * successors. This means that the subject being referred to by
         * this HyperEdge is either a type alias which will be matched by
         * a pattern, or just a plain old fault.
         */
        get isDangling() {
            return this.successors.length === 0;
        }
        /**
         * Gets a value that indicates whether the sources of the edge
         * causes incrementation of the list dimensionality of the type
         * that corresponnds to this HyperEdge's predecessor Node.
         *
         * (Note that all sources need to agree on this value, and the
         * necessary faults are generated to ensure that this is always
         * the case.)
         */
        get isList() {
            for (const source of this.fragments) {
                const sub = source.boundary.subject;
                return sub instanceof Truth.Identifier && sub.isList;
            }
            return false;
        }
        /**
         * Gets a value that indicates the specific part of the
         * predecessor where this HyperEdge begins.
         */
        get predecessorOrigin() {
            //! Is this still necessary?
            if (this.fragmentsMutable.length === 0)
                throw Truth.Exception.unknownState();
            const src = this.fragmentsMutable[0];
            if (src instanceof Truth.Span)
                return HyperEdgeOrigin.statement;
            if (src.containingInfix.isPortability)
                return HyperEdgeOrigin.portabilityInfix;
            if (src.containingInfix.isPopulation)
                return HyperEdgeOrigin.populationInfix;
            if (src.containingInfix.isPattern)
                return HyperEdgeOrigin.patternInfix;
            throw Truth.Exception.unknownState();
        }
        /**
         * @returns A string representation of this HyperEdge,
         * suitable for debugging and testing purposes.
         */
        toString() {
            return [
                "Value=" + this.identifier,
                "Predecessors=" + this.predecessor.name,
                "Successors=" + this.successors
                    .map(n => n.node.name + " << " + n.longitude)
                    .join(", "),
                "Sources=" + Array.from(this.fragments)
                    .map(src => src.boundary.subject).join(", "),
                "---"
            ].join("\n");
        }
    }
    Truth.HyperEdge = HyperEdge;
    /**
     *
     */
    class Successor {
        constructor(node, 
        /**
         * The the number of levels of depth in the containment
         * hierarchy that need to be crossed in order for the containing
         * HyperEdge to be established between the predecessor and
         * this successor.
         */
        longitude) {
            this.node = node;
            this.longitude = longitude;
            this.stamp = Truth.VersionStamp.next();
        }
    }
    Truth.Successor = Successor;
    /**
     * Indicates the place in a statement where a HyperEdge starts.
     * (HyperEdges can start either at the statement level, or within
     * various kinds of infixes.)
     */
    let HyperEdgeOrigin;
    (function (HyperEdgeOrigin) {
        HyperEdgeOrigin[HyperEdgeOrigin["statement"] = 0] = "statement";
        HyperEdgeOrigin[HyperEdgeOrigin["populationInfix"] = 1] = "populationInfix";
        HyperEdgeOrigin[HyperEdgeOrigin["portabilityInfix"] = 2] = "portabilityInfix";
        HyperEdgeOrigin[HyperEdgeOrigin["patternInfix"] = 3] = "patternInfix";
    })(HyperEdgeOrigin = Truth.HyperEdgeOrigin || (Truth.HyperEdgeOrigin = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that marks out the location of an infix Identifer within
     * it's containing Infix, it's containing Span, and then it's containing
     * Statement, Document, and Program.
     */
    class InfixSpan {
        constructor(containingSpan, containingInfix, boundary) {
            this.containingSpan = containingSpan;
            this.containingInfix = containingInfix;
            this.boundary = boundary;
        }
        /**
         * Gets the Statement that contains this Anchor.
         */
        get statement() {
            return this.containingSpan.statement;
        }
        /**
         * Gets a boolean value that indicates whether this InfixSpan
         * is considered object-level cruft, and should therefore be
         * ignored during type analysis.
         */
        get isCruft() {
            return this.containingSpan.statement.cruftObjects.has(this);
        }
    }
    Truth.InfixSpan = InfixSpan;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A worker class that handles the construction of networks
     * of Parallel instances, which are eventually transformed
     * into type objects.
     */
    class ConstructionWorker {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.excavated = new WeakSet();
            /** A call queue used to prevent circular drilling. */
            this.drillQueue = [];
            /**
             * Used for safety purposes to catch unexpected behavior.
             */
            this.handledHyperEdges = new WeakSet();
            /** */
            this.parallels = new Truth.ParallelCache();
            /**
             * Stores the set of Parallel instances that have been "raked",
             * which means that that have gone through the process of
             * having their requested bases applied.
             *
             * This set may include both pattern and non-patterns Parallels,
             * (even though their raking processes are completely different).
             */
            this.rakedParallels = new WeakSet();
            this.cruft = new Truth.CruftCache(this.program);
        }
        /**
         * Constructs the corresponding Parallel instances for
         * all specified types that exist within the provided Document,
         * or below the provided SpecifiedParallel.
         */
        excavate(from) {
            if (this.excavated.has(from))
                return;
            this.excavated.add(from);
            const queue = [];
            const processNodes = (iterator) => {
                for (const node of iterator) {
                    const drilledParallel = this.drillFromNode(node);
                    if (drilledParallel !== null)
                        queue.push(drilledParallel);
                }
            };
            if (from instanceof Truth.Document)
                processNodes(this.program.graph.readRoots(from));
            else
                queue.push(from);
            for (const currentParallel of queue)
                processNodes(currentParallel.node.contents.values());
        }
        /**
         * Constructs the fewest possible Parallel instances
         * to arrive at the type specified by the directive.
         */
        drill(directive) {
            const result = this.drillFromUri(directive);
            this.drillQueue.length = 0;
            return result;
        }
        /** */
        drillFromUri(directive) {
            if (this.parallels.has(directive))
                return Truth.Not.undefined(this.parallels.get(directive));
            const typePath = directive.types.slice().map(t => t.value);
            if (typePath.length === 0)
                throw Truth.Exception.invalidArgument();
            const sourceDoc = this.program.documents.get(directive);
            if (sourceDoc === null)
                throw Truth.Exception.documentNotLoaded();
            const surfaceNode = this.program.graph.read(sourceDoc, typePath[0]);
            if (surfaceNode === null)
                return null;
            let typeIdx = 0;
            let lastSeed = this.parallels.get(directive.retractTypeTo(1)) ||
                this.rake(this.parallels.create(surfaceNode, this.cruft));
            // We can pass by any Parallel instances that have already
            // been constructed. The real work begins when we get to
            // the first point in the URI where there is no constructed
            // Parallel instance.
            for (;;) {
                const uri = directive.retractTypeTo(typeIdx + 1);
                if (!this.parallels.has(uri))
                    break;
                lastSeed = Truth.Not.undefined(this.parallels.get(uri));
                if (++typeIdx >= typePath.length)
                    return lastSeed;
            }
            do {
                const typeName = typePath[typeIdx];
                const descended = this.descend(lastSeed, typeName);
                if (descended === null)
                    return null;
                lastSeed = this.rake(descended);
            } while (++typeIdx < typePath.length);
            return lastSeed;
        }
        /**
         * An entrypoint into the drill function that operates
         * on a Node instead of a Uri. Essentially, this method
         * calls "drillFromUri()" safely (meaning that it detects
         * circular invokations, and returns null in these cases).
         */
        drillFromNode(node) {
            // Circular drilling is only a problem if we're
            // drilling on the same level.
            const q = this.drillQueue;
            if (q.length === 0) {
                q.push(node);
            }
            else if (q[0].container === node.container) {
                if (q.includes(node))
                    return null;
            }
            else {
                q.length = 0;
                q.push(node);
            }
            const drillResult = this.drillFromUri(node.uri);
            if (drillResult === null)
                throw Truth.Exception.unknownState();
            if (!(drillResult instanceof Truth.SpecifiedParallel))
                throw Truth.Exception.unknownState();
            return drillResult;
        }
        /**
         * "Raking" a Parallel is the process of deeply traversing it's
         * Parallel Graph (depth first), and for each visited Parallel,
         * deeply traversing it's Base Graph as well (also depth first).
         * Through this double-traversal process, the Parallel's edges
         * are constructed into a traversable graph.
         */
        rake(seed) {
            // If the seed's container is null, this means that the seed
            // is root-level, and so it cannot have any Parallel types.
            // It may however have Base types, and these need to be
            // handled.
            if (seed.container === null) {
                if (!(seed instanceof Truth.SpecifiedParallel))
                    throw Truth.Exception.unknownState();
                this.rakeSpecifiedParallel(seed);
            }
            else
                this.rakeParallelGraph(seed);
            return seed;
        }
        /**
         * Recursive function that digs through the parallel graph,
         * and rakes all SpecifiedParallels that are discovered.
         */
        rakeParallelGraph(par) {
            for (const edgePar of par.getParallels())
                this.rakeParallelGraph(edgePar);
            if (par instanceof Truth.SpecifiedParallel)
                this.rakeSpecifiedParallel(par);
        }
        /**
         * Splitter method that rakes both a pattern and a non-pattern
         * containing SpecifiedParallel.
         */
        rakeSpecifiedParallel(par) {
            if (this.rakedParallels.has(par))
                return par;
            this.rakedParallels.add(par);
            if (par.pattern)
                this.rakePatternBases(par);
            else
                this.rakeBaseGraph(par);
        }
        /**
         * Recursively follows the bases of the specified source Node.
         * Parallel instances are created for any visited Node instance
         * that does not have one already created.
         * Although the algorithm is careful to avoid circular bases, it's
         * too early in the processing pipeline to report these circular
         * bases as faults. This is because polymorphic name resolution
         * needs to take place before the system can be sure that a
         * seemingly-circular base structure is in fact what it seems.
         * True circular base detection is therefore handled at a future
         * point in the pipeline.
         */
        rakeBaseGraph(srcParallel) {
            if (srcParallel.pattern)
                throw Truth.Exception.unknownState();
            for (const hyperEdge of srcParallel.node.outbounds) {
                if (this.cruft.has(hyperEdge))
                    continue;
                const possibilities = hyperEdge.successors
                    .filter(scsr => !this.cruft.has(scsr.node))
                    .sort((a, b) => a.longitude - b.longitude);
                if (possibilities.length > 0) {
                    // This is where the polymorphic name resolution algorithm
                    // takes place. The algorithm operates by working it's way
                    // up the list of nodes (aka the scope chain), looking for
                    // a possible resolution target where the act of applying the
                    // associated Parallel as a base, causes at least one of the 
                    // conditions on the contract to be satisfied. Or, in the case
                    // when there are no conditions on the contract, the node
                    // that is the closest ancestor is used.
                    for (const possibleScsr of possibilities) {
                        const possibleNode = possibleScsr.node;
                        const baseParallel = this.drillFromNode(possibleNode);
                        // baseParallel will be null in the case when a circular
                        // relationship has been detected (and quitting is
                        // required here in order to avoid a stack overflow).
                        if (baseParallel === null)
                            continue;
                        this.rakeSpecifiedParallel(baseParallel);
                        // There are cases when an entire parallel needs to be
                        // "excavated", meaning that the Parallel's entire subtree
                        // of contents needs to be analyzed and converted into
                        // parallels. This is necessary because a fully defined set
                        // of parallels is required in order to detect discrepant
                        // unions (and therefore, report the attempt at a type
                        // union as faulty).
                        if (srcParallel.baseCount > 0) {
                            if (srcParallel.baseCount === 1)
                                this.excavate(srcParallel.firstBase);
                            this.excavate(baseParallel);
                        }
                        if (!srcParallel.tryAddLiteralBase(baseParallel, hyperEdge))
                            continue;
                        if (this.handledHyperEdges.has(hyperEdge))
                            throw Truth.Exception.unknownState();
                        this.handledHyperEdges.add(hyperEdge);
                        continue;
                    }
                }
                else {
                    // At this point, we've discovered an annotation that we're
                    // going to try to resolve as an alias. If this doesn't work,
                    // the edge will be marked as cruft. Possibly a future version
                    // of this compiler will allow other agents to hook into this
                    // process and augment the resolution strategy.
                    const candidatePatternPars = [];
                    for (const { patternParallel } of this.ascend(srcParallel)) {
                        this.rakePatternBases(patternParallel);
                        candidatePatternPars.push(patternParallel);
                    }
                    if (candidatePatternPars.length > 0) {
                        const identifiers = hyperEdge.fragments
                            .map(src => src.boundary.subject)
                            .filter((s) => s instanceof Truth.Identifier);
                        if (identifiers.length === 0)
                            continue;
                        const alias = identifiers[0].fullName;
                        if (srcParallel.tryAddAliasedBase(candidatePatternPars, hyperEdge, alias)) {
                            this.handledHyperEdges.add(hyperEdge);
                            continue;
                        }
                    }
                    if (!this.handledHyperEdges.has(hyperEdge))
                        this.cruft.add(hyperEdge, Truth.Faults.UnresolvedAnnotation);
                }
            }
            if (!srcParallel.isContractSatisfied)
                for (const smt of srcParallel.node.statements)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.ContractViolation, smt));
            return srcParallel;
        }
        /**
         * Finds the set of bases that should be applied to the provided
         * pattern-containing SpecifiedParallel instance, and attempts
         * to have them applied.
         */
        rakePatternBases(patternParallel) {
            if (!patternParallel.pattern)
                throw Truth.Exception.unknownState();
            const bases = new Map();
            const obs = patternParallel.node.outbounds;
            const nameOf = (edge) => Truth.SubjectSerializer.forInternal(edge.fragments[0]);
            for (let i = -1; ++i < obs.length;) {
                const hyperEdge = obs[i];
                if (this.cruft.has(hyperEdge))
                    continue;
                const len = hyperEdge.successors.length;
                // Because resolving pattern bases has non-polymorphic behavior, 
                // we can get away with checking for these faults here without going
                // through the whole drilling process.
                if (len === 0) {
                    this.cruft.add(hyperEdge, Truth.Faults.UnresolvedAnnotation);
                    continue;
                }
                if (obs.findIndex(e => nameOf(e) === nameOf(hyperEdge)) !== i) {
                    this.cruft.add(hyperEdge, Truth.Faults.IgnoredAnnotation);
                    continue;
                }
                if (len > 1)
                    throw Truth.Exception.unknownState();
                const baseNode = hyperEdge.successors[0].node;
                const baseParallel = this.drillFromNode(baseNode);
                if (baseParallel !== null)
                    bases.set(baseParallel, hyperEdge);
            }
            // Circular bases still need to be checked. It's unclear how and
            // where to actually do this, while factoring in the constraint
            // that these can be caused through the use of aliases.
            // Anything that is a list (with any dimensionality) needs to be
            // cut off, because these bases can't be applied to patterns.
            for (const [base, via] of bases)
                if (base.getListDimensionality() > 0)
                    this.cruft.add(via, Truth.Faults.PatternMatchingList);
            // Now we need to determine if any of these bases are redundant.
            // This is done by checking to see if any of the bases are specified
            // somewhere in the base graph of all others.
            for (const [baseA] of bases)
                for (const [baseB, via] of bases)
                    if (baseA !== baseB)
                        if (baseA.hasBase(baseB))
                            this.cruft.add(via, Truth.Faults.IgnoredAnnotation);
            const pattern = patternParallel.node.subject;
            const span = patternParallel.node.declarations.values().next().value;
            const portInfixes = pattern.getInfixes(Truth.InfixFlags.portability);
            if (portInfixes.length > 0) {
                const validPortabilityInfixes = [];
                for (const portInfix of portInfixes) {
                    const nfxAnnosIter = span.eachAnnotationForInfix(portInfix);
                    const nfxAnnos = Array.from(nfxAnnosIter);
                    if (nfxAnnos.length === 0)
                        throw Truth.Exception.unknownState();
                    // At this time, we're currently generating a fault in the case when
                    // a portability infix has multiple definitions. Although the parser
                    // and the Graph-level infrastructure supports this, more study is
                    // required in order to determine if this is a characteristic of Truth.
                    if (nfxAnnos.length > 1) {
                        for (const nfx of nfxAnnos.slice(1))
                            this.cruft.add(nfx, Truth.Faults.PortabilityInfixHasUnion);
                    }
                    else
                        validPortabilityInfixes.push(portInfix);
                }
                // This code checks for overlapping types. The algorithm used here is
                // similar to the redundant bases check used above. However, in the case
                // of infixes, these aren't just redundant, they would be problematic if
                // left in. To explain why, try to figure out how a String type would draw
                // it's data out of an alias matching the following pattern:
                // 	/< : Email>< : String> : Type
                // (hint: it doesn't work)
                //! Not implemented
            }
            // TODO: Check for use of lists within any kind of infix.
            // It's possible for no collected bases to be returned
            // in the case when there were actually annotations
            // specified within the file, but they were all found to
            // be cruft.
            if (bases.size === 0)
                return;
            patternParallel.tryApplyPatternBases(bases);
        }
        /**
         * A generator function that works its way upwards, starting at the
         * provided SpecifiedParallel. The function yields the series of
         * Parallels that contain Patterns that are visible to the provided
         * srcParallel. The bases of these parallels have not necessarily
         * been applied.
         *
         * The ordering of the Parallels yielded is relevant. The instances
         * that were yielded closer to the beginning take prescedence over
         * the ones yielded at the end.
         */
        *ascend(srcParallel) {
            const discoveredPatternNodes = new Set();
            const yieldable = (patternNode) => {
                discoveredPatternNodes.add(patternNode);
                return Truth.Not.null(this.parallels.get(patternNode) ||
                    this.parallels.create(patternNode, this.cruft));
            };
            function* recurse(current) {
                for (const { base } of current.eachBase())
                    yield* recurse(base);
                if (current instanceof Truth.SpecifiedParallel)
                    for (const node of current.node.contents.values())
                        if (node.subject instanceof Truth.Pattern)
                            if (!discoveredPatternNodes.has(node))
                                yield {
                                    pattern: node.subject,
                                    patternParallel: yieldable(node)
                                };
            }
            // The process starts at the container of the current parallel,
            // even though this function needs to yield other parallels that
            // are adjacent to srcParallel, because we reach back into the
            // adjacents from the container.
            for (let current = srcParallel.container; current instanceof Truth.SpecifiedParallel;) {
                yield* recurse(current);
                current = current.container;
            }
            for (const root of this.program.graph.readRoots(srcParallel.node.document))
                if (root.subject instanceof Truth.Pattern)
                    if (!discoveredPatternNodes.has(root))
                        yield {
                            pattern: root.subject,
                            patternParallel: yieldable(root)
                        };
        }
        /**
         * Constructs and returns a new seed Parallel from the specified
         * zenith Parallel, navigating downwards to the specified type name.
         */
        descend(zenith, typeName) {
            /**
             * @returns A new Parallel (either being a SpecifiedParallel
             * or an UnspecifiedParallel instance), that corresponds to
             * the specified zenith parallel.
             */
            const descendOne = (zenith) => {
                if (zenith instanceof Truth.SpecifiedParallel) {
                    const nextNode = zenith.node.contents.get(typeName);
                    if (nextNode) {
                        const out = this.parallels.get(nextNode) ||
                            this.parallels.create(nextNode, this.cruft);
                        this.verifyDescend(zenith, out);
                        return out;
                    }
                }
                const nextUri = zenith.uri.extendType(typeName);
                return (this.parallels.get(nextUri) ||
                    this.parallels.create(nextUri));
            };
            /**
             * @returns A boolean value that indicates whether the act
             * of descending from the specified Parallel to the typeName
             * passed to the containing method is going to result in a
             * SpecifiedParallel instance.
             */
            function canDescendToSpecified(parallel) {
                return (parallel instanceof Truth.SpecifiedParallel &&
                    parallel.node.contents.has(typeName));
            }
            //
            // TODO: These functions can probably be replaced with
            // a call to Misc.reduceRecursive()
            //
            function* recurseParallels(par) {
                for (const parEdge of par.getParallels())
                    yield* recurseParallels(parEdge);
                yield par;
            }
            function* recurseBases(par) {
                for (const { base } of par.eachBase())
                    yield* recurseBases(base);
                yield par;
            }
            function* recurse(par) {
                for (const parallelEdge of recurseParallels(par)) {
                    if (parallelEdge instanceof Truth.SpecifiedParallel)
                        for (const baseEdge of recurseBases(parallelEdge))
                            yield baseEdge;
                    yield parallelEdge;
                }
            }
            // The following algorithm performs a recursive reduction on
            // the zenith, and produces a set of Parallels to prune from the
            // descension process. The Parallels that end up getting pruned
            // are the ones that, if unpruned, would result in a layer that
            // has UnspecifiedParallels that shouldn't actually exist. For
            // example, consider the following document:
            //
            // Class
            // 
            // SubClass : Class
            // 	Child
            // 
            // "Class" should not have an UnspecifiedParallel called "Child",
            // because that was introduced in the derived "SubClass" type.
            // And so this algorithm stakes out cut off points so that we don't
            // blindly just descend all Parallels in the layer.
            const prunedParallels = new Set();
            const pruneParallelsFollowFn = (par) => {
                const upperParallels = par.getParallels().slice();
                if (par instanceof Truth.SpecifiedParallel)
                    for (const { base } of par.eachBase())
                        upperParallels.push(base);
                return upperParallels;
            };
            const hasSpecifiedContents = Truth.Misc.reduceRecursive(zenith, pruneParallelsFollowFn, (current, results) => {
                const prune = results.every(result => !result) &&
                    !canDescendToSpecified(current);
                if (prune)
                    prunedParallels.add(current);
                return !prune;
            });
            // In the case when the method is attempting to descend
            // to a level where there are no nodes whose name match
            // the type name specified (i.e. the whole layer would be 
            // unspecified parallels), null is returned because a descend
            // wouldn't make sense.
            if (!hasSpecifiedContents)
                return null;
            const descendParallelsFollowFn = (par) => {
                if (!(par instanceof Truth.SpecifiedParallel))
                    return [];
                const bases = Array.from(par.eachBase())
                    .map(entry => entry.base)
                    .slice();
                const result = bases
                    .concat(par.getParallels())
                    .filter(par => !prunedParallels.has(par));
                return result;
            };
            const seed = Truth.Misc.reduceRecursive(zenith, descendParallelsFollowFn, (current, nested) => {
                const nextPar = descendOne(current);
                for (const edge of nested)
                    nextPar.addParallel(edge);
                return nextPar;
            });
            return seed;
        }
        /**
         * Performs verification on the descend operation.
         * Reports any faults that can occur during this process.
         */
        verifyDescend(zenithParallel, descendParallel) {
            if (descendParallel.node.subject instanceof Truth.Anon)
                if (zenithParallel.isListIntrinsic)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.AnonymousInListIntrinsic, descendParallel.node.statements[0]));
        }
    }
    Truth.ConstructionWorker = ConstructionWorker;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(uri, container) {
            this.uri = uri;
            this.container = container;
            /**
             * Stores a version number for this instance,
             * useful for debugging purposes.
             */
            this.version = Truth.VersionStamp.next();
            this._contents = new Map();
            this._parallels = [];
            this.name = uri.toTypeString();
            if (this.name.startsWith("/"))
                this.name = unescape(this.name);
            if (container !== null)
                container._contents.set(uri.types.slice(-1)[0].value, this);
        }
        /**
         *
         */
        get contents() {
            return this._contents;
        }
        /** */
        getParallels() {
            return Object.freeze(this._parallels.slice());
        }
        /** */
        get hasParallels() {
            return this._parallels.length > 0;
        }
        /** */
        addParallel(parallel) {
            if (!this._parallels.includes(parallel))
                this._parallels.push(parallel);
        }
    }
    Truth.Parallel = Parallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class SpecifiedParallel extends Truth.Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(node, container, cruft) {
            super(node.uri, container);
            this._contract = null;
            this._bases = new Map();
            this._intrinsicExtrinsicBridge = null;
            /**
             * Stores a string representation of the compiled regular expression
             * associated with this instance, in the case when this instance is
             * a pattern parallel.
             *
             * This string representation should have any infixes compiled away,
             * and should be passable to a JavaScript RegExp, or to the Fsm system.
             */
            this.compiledExpression = null;
            this.node = node;
            this.cruft = cruft;
            node.document.program.faults.inform(node);
        }
        /** */
        get isContractSatisfied() {
            return this.contract.unsatisfiedConditions.size === 0;
        }
        /** */
        get contract() {
            // It's important that this contract is computed lazily, because
            // if you try to compute it in the constructor, the Parallel graph
            // won't be constructed, and you'll end up with an empty contract.
            if (this._contract === null)
                this._contract = new Truth.Contract(this);
            return this._contract;
        }
        /**
         * Gets the first base contained by this instance.
         * @throws In the case when this instance contains no bases.
         */
        get firstBase() {
            for (const baseEntry of this._bases.values())
                return baseEntry.parallels[0];
            throw Truth.Exception.unknownState();
        }
        /**
         * Performs a shallow traversal on the non-cruft bases
         * defined directly on this Parallel.
         */
        *eachBase() {
            for (const [edge, baseEntry] of this._bases)
                if (!this.cruft.has(edge))
                    for (const base of baseEntry.parallels)
                        yield { base, edge, aliased: baseEntry.aliased };
        }
        /**
         *
         */
        addBaseEntry(base, edge, aliased) {
            const existing = this._bases.get(edge);
            if (existing)
                existing.parallels.push(base);
            else
                this._bases.set(edge, { parallels: [base], aliased });
        }
        /**
         * Performs a deep traversal on the non-cruft bases
         * defined on this Parallel.
         */
        *eachBaseDeep() {
            const queue = Array.from(this.eachBase()).map(e => e.base);
            for (let i = -1; ++i < queue.length;) {
                const current = queue[i];
                yield current;
                for (const { base } of current.eachBase())
                    if (!queue.includes(base))
                        queue.push(base);
            }
        }
        /**
         * @returns A boolean value that indicates whether the provided
         * SpecifiedParallel instance exists somewhere, possibly nested,
         * in the base graph of this instance.
         */
        hasBase(testBase) {
            const queue = Array.from(this.eachBase()).map(e => e.base);
            for (let i = -1; ++i < queue.length;) {
                const current = queue[i];
                if (current === testBase)
                    return true;
                for (const { base } of current.eachBase())
                    if (!queue.includes(base))
                        queue.push(base);
            }
            return false;
        }
        /**
         * Attempts to add the provided SpecifiedParallel as a base of
         * this instance. If the addition of the new base would not generate
         * any critical faults, it is added. Otherwise, it's marked as cruft.
         *
         * @returns A boolean value that indicates whether the base
         * was added successfully.
         */
        tryAddLiteralBase(base, via) {
            if (this._bases.has(via))
                throw Truth.Exception.unknownState();
            // Just as a reminder -- pattern-containing parallels 
            // don't come into this method. Bases are applied to
            // patterns in tryApplyPatternBases.
            if (this.pattern)
                throw Truth.Exception.unknownState();
            const numSatisfied = this.contract.trySatisfyCondition(base);
            if (numSatisfied === 0 && this.contract.hasConditions)
                return false;
            const sanitizer = new Truth.Sanitizer(this, base, via, this.cruft);
            // In this case, we only need to do a 
            // shallow check for circular inheritance.
            if (sanitizer.detectCircularReferences())
                return false;
            if (sanitizer.detectListFragmentConflicts())
                return false;
            if (this.baseCount > 0) {
                if (sanitizer.detectListDimensionalityConflict())
                    return false;
            }
            this.addBaseEntry(base, via, false);
            return true;
        }
        /**
         * Attempts to indirectly apply a base to this SpecifiedParallel via an alias
         * and edge.
         *
         * @param patternParallelCandidates The pattern-containing
         * SpecifiedParallel instance whose bases should be applied to this
         * SpecifiedParallel, if the provided alias is a match.
         *
         * @param viaEdge The HyperEdge in which the alias was found.
         *
         * @param viaAlias The string to test against the parallel embedded
         * within patternParallelCandidates.
         *
         * @returns A boolean value that indicates whether a base was added
         * successfully.
         */
        tryAddAliasedBase(patternParallelCandidates, viaEdge, viaAlias) {
            if (this._bases.has(viaEdge))
                throw Truth.Exception.unknownState();
            const chosenParallels = patternParallelCandidates.slice();
            const conditions = this.contract.unsatisfiedConditions;
            const beganWithConditions = conditions.size > 0;
            if (beganWithConditions) {
                let maxMatchCount = 1;
                nextCandidate: for (const candidate of patternParallelCandidates) {
                    const entries = Array.from(candidate._bases.values());
                    const candidateBases = entries
                        .map(e => e.parallels)
                        .reduce((a, b) => a.concat(b), []);
                    if (candidateBases.length < maxMatchCount)
                        continue;
                    for (const candidateBase of candidateBases)
                        if (!conditions.has(candidateBase))
                            continue nextCandidate;
                    chosenParallels.push(candidate);
                    maxMatchCount = candidateBases.length;
                }
                if (chosenParallels.length === 0)
                    return false;
            }
            let wasAdded = false;
            for (const chosenParallel of chosenParallels) {
                // Just as a reminder -- pattern-containing parallels don't come
                // into this method ... only the aliases that might match them.
                if (this.pattern || !chosenParallel.pattern)
                    throw Truth.Exception.unknownState();
                // If the targetPattern has no infixes, we can get away with a simple
                // check to see if the alias matches the regular expression.
                if (!chosenParallel.pattern.hasInfixes()) {
                    if (!chosenParallel.pattern.test(viaAlias))
                        continue;
                    if (beganWithConditions)
                        if (this.contract.trySatisfyCondition(chosenParallel) === 0)
                            continue;
                    this.addBaseEntry(chosenParallel, viaEdge, true);
                    wasAdded = true;
                }
            }
            // Not implemented, but we shouldn't throw an exception here yet.
            return wasAdded;
        }
        /**
         * Attempts to apply a set of bases to a pattern-containing parallel.
         *
         * @example
         * /pattern : This, Function, Adds, These
         */
        tryApplyPatternBases(baseTable) {
            const bases = Array.from(baseTable.keys());
            // Non-Pattern nodes should never come to this method.
            if (!this.pattern)
                throw Truth.Exception.unknownState();
            const basesDeep = bases
                .map(b => Array.from(b.eachBaseDeep()))
                .reduce((a, b) => a.concat(b), [])
                .filter((v, i, a) => a.indexOf(v) === i);
            // Reminder: the SpecifiedParallels in the basesDeep array
            // are expected to be fully processed by the time we get to
            // this method. It should be safe to touch them.
            if (basesDeep.length > 0) {
                const basesNodes = bases.map(b => b.node);
                // Finds all pattern nodes that have an edge that points
                // to at least one of the bases in the basesDeep array.
                const basesDeepSprawl = basesDeep
                    .map(b => Array.from(b.node.inbounds))
                    .reduce((a, b) => a.concat(b), [])
                    .map(inb => inb.predecessor)
                    .filter((v, i, a) => a.indexOf(v) === i)
                    .filter(node => node.subject instanceof Truth.Pattern)
                    .filter(node => node.outbounds
                    .filter(ob => ob.successors.length === 0)
                    .map(ob => ob.successors[0].node)
                    .every(node => basesNodes.includes(node)));
                const basesDeepSprawlPatterns = basesDeepSprawl
                    .map(n => n.subject)
                    .filter((s) => s instanceof Truth.Pattern);
                /**
                 * At this point, we need to test every single one of the
                 * patterns in basesDeepSprawlPatterns against this
                 * this.node.subject to make sure the two patterns are
                 * compliant.
                 *
                 * If they're not compliant, we need to start marking
                 * bases as cruft until they are.
                 *
                 * There is also a recursive infix embed process that
                 * needs to happen here, but maybe we should just
                 * put this off until the basic pattern functionality
                 * is working?
                 */
            }
            /**
             * This also needs to take into account any other patterns
             * that are applied to any of the bases defined directly
             * inline.
             */
            // Here we're just adding all the bases regardless of whether
            // or not any of the associated edges were marked as cruft.
            // The other enumerators skip over cruft edges, so this likely
            // isn't a problem, and it keeps it consistent with the way the
            // rest of the system works.
            for (const [base, via] of baseTable)
                this.addBaseEntry(base, via, false);
        }
        /**
         * Gets the number of bases that have
         * been explicitly applied to this Parallel.
         */
        get baseCount() {
            return this._bases.size;
        }
        /** */
        get isListIntrinsic() {
            return this.node.isListIntrinsic;
        }
        /** */
        get intrinsicExtrinsicBridge() {
            return this._intrinsicExtrinsicBridge;
        }
        /**
         * Establishes a bridge between this SpecifiedParallel and the
         * one provided.
         */
        createIntrinsicExtrinsicBridge(parallel) {
            if (this._intrinsicExtrinsicBridge !== null)
                throw Truth.Exception.unknownState();
            if (parallel._intrinsicExtrinsicBridge !== null)
                throw Truth.Exception.unknownState();
            if (parallel.node.isListIntrinsic === this.node.isListIntrinsic)
                throw Truth.Exception.unknownState();
            this._intrinsicExtrinsicBridge = parallel;
            parallel._intrinsicExtrinsicBridge = this;
        }
        /** */
        getListDimensionality() {
            // NOTE: This actually needs to be "each base inferred"
            // This is purposely only returning the dimensionality of
            // the first base. There is a guarantee that all dimensionalities
            // will be the same here.
            for (const { base, edge } of this.eachBase()) {
                const initialDim = base.getListDimensionality();
                return edge.isList ? initialDim + 1 : initialDim;
            }
            return 0;
        }
        /**
         *
         */
        comparePatternTo(other) {
        }
        /**
         *
         */
        maybeCompilePattern() {
            ///if (!this.pattern)
            ///	return;
            ///if (!pattern.hasInfixes())
            ///	this.compiledExpression = pattern.
        }
        /**
         * Gets the Pattern instance that resides inside this SpecifiedParallel,
         * or null in the case when this SpecifiedParallel does not have an
         * inner Pattern.
         */
        get pattern() {
            return this.node.subject instanceof Truth.Pattern ?
                this.node.subject :
                null;
        }
    }
    Truth.SpecifiedParallel = SpecifiedParallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class UnspecifiedParallel extends Truth.Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(uri, container) {
            super(uri, container);
        }
    }
    Truth.UnspecifiedParallel = UnspecifiedParallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A simple class for handling objects marked as cruft.
     */
    class CruftCache {
        /** */
        constructor(program) {
            this.program = program;
            /** Stores a set of objects that have been marked as cruft. */
            this.cruft = new Set();
        }
        /**
         * Adds a fault of the specified type to the internal set,
         * marks all relevant objects as cruft, and reports the
         * relevant fault type.
         */
        add(cruft, relevantFaultType) {
            const faultSources = cruft instanceof Truth.Node ? cruft.statements :
                cruft instanceof Truth.HyperEdge ? cruft.fragments :
                    [cruft];
            for (const faultSrc of faultSources) {
                const fault = new Truth.Fault(relevantFaultType, faultSrc);
                this.program.faults.report(fault);
                this.cruft.add(faultSrc);
            }
            this.cruft.add(cruft);
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified object has been marked as cruft.
         */
        has(source) {
            return this.cruft.has(source);
        }
    }
    Truth.CruftCache = CruftCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class ParallelCache {
        constructor() {
            /**
             * Stores a map of all Parallel instances that have been
             * constructed by this object.
             */
            this.parallels = new Map();
        }
        create(key, cruft) {
            if (this.has(key))
                throw Truth.Exception.unknownState();
            const save = (par) => {
                const keyVal = this.getKeyVal(key);
                this.parallels.set(keyVal, par);
                return par;
            };
            const container = (() => {
                if (key instanceof Truth.Node)
                    return key.container !== null ?
                        Truth.Not.undefined(this.get(key.container)) :
                        null;
                return key.types.length > 1 ?
                    Truth.Not.undefined(this.get(key.retractType(1))) :
                    null;
            })();
            if (key instanceof Truth.Uri)
                return save(new Truth.UnspecifiedParallel(key, container));
            if (!(container instanceof Truth.SpecifiedParallel) && container !== null)
                throw Truth.Exception.unknownState();
            if (cruft === undefined)
                throw Truth.Exception.unknownState();
            const outPar = new Truth.SpecifiedParallel(key, container, cruft);
            if (key.intrinsicExtrinsicBridge === null)
                return save(outPar);
            if (this.has(key.intrinsicExtrinsicBridge))
                throw Truth.Exception.unknownState();
            const bridgePar = new Truth.SpecifiedParallel(key.intrinsicExtrinsicBridge, container, cruft);
            outPar.createIntrinsicExtrinsicBridge(bridgePar);
            return save(outPar);
        }
        get(key) {
            const keyVal = this.getKeyVal(key);
            const out = this.parallels.get(keyVal);
            if (key instanceof Truth.Node)
                if (out !== undefined)
                    if (!(out instanceof Truth.SpecifiedParallel))
                        throw Truth.Exception.unknownState();
            return out;
        }
        /** */
        has(key) {
            return this.parallels.has(this.getKeyVal(key));
        }
        /** */
        getKeyVal(key) {
            const uri = key instanceof Truth.Node ? key.uri : key;
            return uri.toString();
        }
        /** */
        get debug() {
            const text = [];
            for (const [key, value] of this.parallels)
                text.push(value.name);
            return text.join("\n");
        }
    }
    Truth.ParallelCache = ParallelCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Contract {
        /** */
        constructor(sourceParallel) {
            this._unsatisfiedConditions = new Set();
            const recurse = (srcParallel) => {
                if (srcParallel instanceof Truth.UnspecifiedParallel) {
                    for (const nestedParallel of srcParallel.getParallels())
                        recurse(nestedParallel);
                }
                else if (srcParallel instanceof Truth.SpecifiedParallel) {
                    for (const { base } of srcParallel.eachBase())
                        this._unsatisfiedConditions.add(base);
                }
            };
            for (const higherParallel of sourceParallel.getParallels())
                recurse(higherParallel);
            this.allConditions = Object.freeze(Array.from(this._unsatisfiedConditions));
        }
        /**
         * Computes whether the input SpecifiedParallel is a more derived
         * type of the SpecifiedParallel that corresponds to this Contract.
         *
         * @returns A number that indicates the number of conditions that
         * were satisfied as a result of adding the provided SpecifiedParallel
         * to the Contract.
         */
        trySatisfyCondition(foreignParallel) {
            if (this.allConditions.length === 0)
                return 0;
            const foreignParallelBases = new Set();
            foreignParallelBases.add(foreignParallel);
            let satisfied = 0;
            const addForeignParallelBases = (srcParallel) => {
                for (const { base } of srcParallel.eachBase())
                    addForeignParallelBases(base);
                foreignParallelBases.add(srcParallel);
            };
            for (const { base } of foreignParallel.eachBase())
                addForeignParallelBases(base);
            for (const foreignBase of foreignParallelBases)
                for (const condition of this.allConditions)
                    if (foreignBase === condition)
                        satisfied += this._unsatisfiedConditions.delete(condition) ? 1 : 0;
            return satisfied;
        }
        /** */
        get hasConditions() {
            return this.allConditions.length > 0;
        }
        /** */
        get unsatisfiedConditions() {
            return this._unsatisfiedConditions;
        }
    }
    Truth.Contract = Contract;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that encapsulates the actual fault detection behavior,
     * with facilities to perform analysis on Parallel instances, before
     * the actual base has been applied to it.
     */
    class Sanitizer {
        /** */
        constructor(targetParallel, proposedBase, proposedEdge, cruft) {
            this.targetParallel = targetParallel;
            this.proposedBase = proposedBase;
            this.proposedEdge = proposedEdge;
            this.cruft = cruft;
            this._foundCruft = false;
        }
        /**
         * Detects list operartor conflicts between the fragments of an
         * annotation. For example, conflicts of the following type are
         * caught here:
         *
         * List : Item
         * List : Item...
         */
        detectListFragmentConflicts() {
            const sources = this.proposedEdge.fragments;
            if (sources.length === 0)
                return false;
            const spans = sources.filter((src) => src instanceof Truth.Span);
            const identifiers = spans
                .map(f => f.boundary.subject)
                .filter((sub) => sub instanceof Truth.Identifier);
            const identifiersList = identifiers.filter(id => id.isList);
            const identifiersNonList = identifiers.filter(id => !id.isList);
            if (identifiersList.length > 0 && identifiersNonList.length > 0)
                for (const span of spans)
                    this.addFault(span, Truth.Faults.ListAnnotationConflict);
            return this.foundCruft;
        }
        /** */
        detectCircularReferences() {
            const circularEdgePaths = [];
            const recurse = (srcBase, path) => {
                for (const { base, edge } of this.basesOf(srcBase)) {
                    if (path.includes(edge))
                        circularEdgePaths.push(path.slice());
                    else
                        recurse(base, path.concat(edge));
                }
            };
            for (const { base, edge } of this.basesOf(this.targetParallel))
                recurse(base, []);
            for (const item of circularEdgePaths)
                for (const circularEdge of item)
                    this.addFault(circularEdge, Truth.Faults.CircularTypeReference);
            return this.foundCruft;
        }
        /** */
        detectListDimensionalityConflict() {
            const targetDim = this.targetParallel.getListDimensionality();
            const proposedDim = this.proposedBase.getListDimensionality() +
                (this.proposedEdge.isList ? 1 : 0);
            if (targetDim !== proposedDim)
                this.addFault(this.proposedEdge, Truth.Faults.ListDimensionalDiscrepancyFault);
            return this.foundCruft;
        }
        /** Gets a boolean value that indicates whether a fault has been reported. */
        get foundCruft() {
            return this._foundCruft;
        }
        /** */
        *basesOf(par) {
            for (const { base, edge } of par.eachBase())
                yield { base, edge };
            if (this.targetParallel === par)
                yield { base: this.proposedBase, edge: this.proposedEdge };
        }
        /** */
        addFault(source, relevantFaultType) {
            this._foundCruft = true;
            this.cruft.add(source, relevantFaultType);
        }
    }
    Truth.Sanitizer = Sanitizer;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a fully constructed type within the program.
     */
    class Type {
        /**
         *
         */
        constructor(seed, container, program) {
            /**
             * Stores whether this type represents the intrinsic
             * side of a list.
             */
            this.isListIntrinsic = false;
            /**
             * Stores whether this type represents the extrinsic
             * side of a list.
             */
            this.isListExtrinsic = false;
            /**
             * Stores whether this Type instance has no annotations applied to it.
             */
            this.isFresh = false;
            /**
             * Stores a value that indicates if this Type was directly specified
             * in the document, or if it's existence was inferred.
             */
            this.isSpecified = false;
            /** */
            this.isAnonymous = false;
            /** */
            this.isPattern = false;
            /** */
            this.isUri = false;
            /** */
            this.isList = false;
            this.private = new TypePrivate(program, seed);
            this.name = seed.uri.types[seed.uri.types.length - 1].value;
            this.uri = seed.uri;
            this.container = container;
            this.private.parallels = new Truth.TypeProxyArray(seed.getParallels().map(edge => new Truth.TypeProxy(edge.uri, program)));
            const getBases = (sp) => {
                const bases = Array.from(sp.eachBase());
                return bases.map(entry => new Truth.TypeProxy(entry.base.node.uri, program));
            };
            if (seed instanceof Truth.SpecifiedParallel) {
                this.private.bases = new Truth.TypeProxyArray(getBases(seed));
            }
            else if (seed instanceof Truth.UnspecifiedParallel) {
                const queue = [seed];
                const specifiedParallels = [];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    if (current instanceof Truth.UnspecifiedParallel)
                        queue.push(...current.getParallels());
                    else if (current instanceof Truth.SpecifiedParallel)
                        specifiedParallels.push(current);
                }
                const bases = specifiedParallels
                    .map(par => getBases(par))
                    .reduce((a, b) => a.concat(b), [])
                    .filter((v, i, a) => a.indexOf(v) === i);
                this.private.bases = new Truth.TypeProxyArray(bases);
            }
            this.isList = false;
            if (seed instanceof Truth.SpecifiedParallel) {
                const sub = seed.node.subject;
                this.isPattern = sub instanceof Truth.Pattern;
                this.isUri = sub instanceof Truth.Uri;
                this.isAnonymous = sub instanceof Truth.Anon;
                this.isSpecified = true;
                this.isFresh = seed.getParallels().length === 0;
            }
        }
        static construct(param, program) {
            const uri = Truth.Uri.clone(param);
            if (uri.types.length === 0)
                return null;
            if (Truth.TypeCache.has(uri, program)) {
                const cached = Truth.TypeCache.get(uri, program);
                // If the cached type exists, but hasn't been compiled yet,
                // we can't return it, we need to compile it first.
                if (cached === null || cached instanceof Type)
                    return cached;
            }
            const worker = (() => {
                const stored = this.parallelContextMap.get(program);
                if (stored === undefined) {
                    const newStored = {
                        version: program.version,
                        worker: new Truth.ConstructionWorker(program)
                    };
                    this.parallelContextMap.set(program, newStored);
                    return newStored.worker;
                }
                else if (program.version.newerThan(stored.version)) {
                    stored.version = program.version;
                    stored.worker = new Truth.ConstructionWorker(program);
                }
                return stored.worker;
            })();
            const parallel = worker.drill(uri);
            if (parallel === null) {
                Truth.TypeCache.set(uri, program, null);
                return null;
            }
            const parallelLineage = [parallel];
            for (let currentParallel = parallel.container; currentParallel !== null;) {
                parallelLineage.unshift(currentParallel);
                currentParallel = currentParallel.container;
            }
            let lastType = null;
            for (const currentParallel of parallelLineage) {
                if (Truth.TypeCache.has(currentParallel.uri, program)) {
                    const existingType = Truth.TypeCache.get(currentParallel.uri, program);
                    if (existingType instanceof Truth.TypeProxy)
                        throw Truth.Exception.unknownState();
                    if (existingType === null)
                        throw Truth.Exception.unknownState();
                    lastType = existingType;
                }
                else {
                    const type = new Type(currentParallel, lastType, program);
                    Truth.TypeCache.set(currentParallel.uri, program, type);
                    lastType = type;
                }
            }
            return lastType;
        }
        /**
         * @internal
         * Constructs the invisible root-level Type object that corresponds
         * to the specified document.
         */
        static constructRoots(document) {
            const program = document.program;
            const roots = [];
            for (const node of program.graph.readRoots(document)) {
                const type = this.construct(node.uri, program);
                if (type !== null)
                    roots.push(type);
            }
            return Object.freeze(roots);
        }
        /**
         * Stores a reference to the type, as it's defined in it's
         * next most applicable type.
         */
        get parallels() {
            this.private.throwOnDirty();
            return Truth.Not.null(this.private.parallels).maybeCompile();
        }
        /**
         * Stores a reference to the parallel roots of this type.
         * The parallel roots are the endpoints found when
         * traversing upward through the parallel graph.
         */
        get parallelRoots() {
            this.private.throwOnDirty();
            if (this.private.parallelRoots !== null)
                return this.private.parallelRoots;
            const roots = [];
            for (const { type } of this.iterate(t => t.parallels))
                if (type !== this && type.parallels.length === 0)
                    roots.push(type);
            return this.private.parallelRoots = Object.freeze(roots);
        }
        /**
         * Stores the array of types that are contained directly by this
         * one. In the case when this type is a list type, this array does
         * not include the list's intrinsic types.
         */
        get contents() {
            if (this.private.contents !== null)
                return this.private.contents;
            this.private.throwOnDirty();
            const containedNames = [];
            // Dig through the parallel graph recursively, and at each parallel,
            // dig through the base graph recursively, and collect all the names
            // that are found.
            for (const { type: parallelType } of this.iterate(t => t.parallels, true))
                for (const { type: baseType } of parallelType.iterate(t => t.bases, true))
                    if (baseType.private.seed instanceof Truth.SpecifiedParallel)
                        for (const name of baseType.private.seed.node.contents.keys())
                            if (!containedNames.includes(name))
                                containedNames.push(name);
            const contents = containedNames
                .map(containedName => {
                const maybeContainedUri = this.uri.extendType(containedName);
                return Type.construct(maybeContainedUri, this.private.program);
            })
                .filter((t) => t !== null);
            return this.private.contents = Object.freeze(contents);
        }
        /**
         * @internal
         * Stores the array of types that are contained directly by this
         * one. In the case when this type is not a list type, this array
         * is empty.
         */
        get contentsIntrinsic() {
            if (this.private.contentsIntrinsic !== null)
                return this.private.contentsIntrinsic;
            if (!this.isList)
                return this.private.contentsIntrinsic = Object.freeze([]);
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
        }
        /**
         * Stores the array of types from which this type extends.
         * If this Type extends from a pattern, it is included in this
         * array.
         */
        get bases() {
            this.private.throwOnDirty();
            if (this.private.bases === null)
                throw Truth.Exception.unknownState();
            return this.private.bases.maybeCompile();
        }
        /**
         * @internal
         * Not implemented.
         */
        get superordinates() {
            if (this.private.superordinates !== null)
                return this.private.superordinates;
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
            // eslint-disable-next-line no-unreachable
            return this.private.superordinates = Object.freeze([]);
        }
        /**
         * @internal
         */
        get subordinates() {
            if (this.private.subordinates !== null)
                return this.private.subordinates;
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
            // eslint-disable-next-line no-unreachable
            return this.private.subordinates = Object.freeze([]);
        }
        /**
         * Gets an array that contains the types that derive from the
         * this Type instance.
         *
         * The types that derive from this one as a result of the use of
         * an alias are excluded from this array.
         */
        get derivations() {
            if (this.private.derivations !== null)
                return this.private.derivations;
            this.private.throwOnDirty();
            if (!(this.private.seed instanceof Truth.SpecifiedParallel))
                return this.private.derivations = Object.freeze([]);
            const derivations = Array.from(this.private.seed.node.inbounds)
                .map(ib => ib.predecessor.uri)
                .map(uri => Type.construct(uri, this.private.program))
                .filter((t) => t instanceof Type)
                .filter(type => type.bases.includes(this));
            return this.private.derivations = Object.freeze(derivations);
        }
        /**
         * Gets an array that contains the that share the same containing
         * type as this one.
         */
        get adjacents() {
            if (this.private.adjacents !== null)
                return this.private.adjacents;
            this.private.throwOnDirty();
            if (this.container)
                return this.private.adjacents = this.container.contents.filter(t => t !== this);
            const program = this.private.program;
            const document = Truth.Not.null(program.documents.get(this.uri));
            const roots = Array.from(this.private.program.graph.readRoots(document));
            const adjacents = roots
                .map(node => Type.construct(node.uri, program))
                .filter((t) => t !== null && t !== this);
            return this.private.adjacents = Object.freeze(adjacents);
        }
        /**
         * Gets an array that contains the patterns that resolve to this type.
         */
        get patterns() {
            if (this.private.patterns !== null)
                return this.private.patterns;
            this.private.throwOnDirty();
            // Stores a map whose keys are a concatenation of the Uris of all
            // the bases that are matched by a particular pattern, and whose
            // values are the type object containing that pattern. This map
            // provides an easy way to determine if there is already a pattern
            // that matches a particular set of types in the type scope.
            const patternMap = new Map();
            for (const { type } of this.iterate(t => t.container)) {
                const applicablePatternTypes = type.adjacents
                    .filter(t => t.isPattern)
                    .filter(t => t.bases.includes(type));
                const applicablePatternsBasesLabels = applicablePatternTypes.map(p => p.bases
                    .map(b => b.uri.toString())
                    .join("\n" /* terminal */));
                for (let i = -1; ++i < applicablePatternTypes.length;) {
                    const baseLabel = applicablePatternsBasesLabels[i];
                    if (!patternMap.has(baseLabel))
                        patternMap.set(baseLabel, applicablePatternTypes[i]);
                }
            }
            const out = Array.from(patternMap.values());
            return this.private.patterns = Object.freeze(out);
        }
        /**
         * Gets an array that contains the raw string values representing
         * the type aliases with which this type has been annotated.
         *
         * If this type is unspecified, the parallel graph is searched,
         * and any applicable type aliases will be present in the returned
         * array.
         */
        get aliases() {
            if (this.private.aliases !== null)
                return this.private.aliases;
            this.private.throwOnDirty();
            const aliases = [];
            const extractAlias = (sp) => {
                for (const { edge, aliased } of sp.eachBase())
                    if (aliased)
                        aliases.push(edge.identifier.toString());
            };
            if (this.private.seed instanceof Truth.SpecifiedParallel) {
                extractAlias(this.private.seed);
            }
            else if (this.private.seed instanceof Truth.UnspecifiedParallel) {
                const queue = [this.private.seed];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    for (const parallel of current.getParallels()) {
                        if (parallel instanceof Truth.SpecifiedParallel)
                            extractAlias(parallel);
                        else if (parallel instanceof Truth.UnspecifiedParallel)
                            queue.push(parallel);
                    }
                }
            }
            return this.private.aliases = aliases;
        }
        /**
         *
         */
        get values() {
            if (this.private.values !== null)
                return this.private.values;
            this.private.throwOnDirty();
            const values = [];
            const extractType = (sp) => {
                for (const { edge } of sp.eachBase())
                    values.push({
                        value: edge.identifier.toString(),
                        base: Type.construct(edge.predecessor.uri, this.private.program)
                    });
            };
            if (this.private.seed instanceof Truth.SpecifiedParallel) {
                extractType(this.private.seed);
            }
            else if (this.private.seed instanceof Truth.UnspecifiedParallel) {
                const queue = [this.private.seed];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    for (const parallel of current.getParallels()) {
                        if (parallel instanceof Truth.SpecifiedParallel)
                            extractType(parallel);
                        else if (parallel instanceof Truth.UnspecifiedParallel)
                            queue.push(parallel);
                    }
                }
            }
            return this.private.values = values;
        }
        /**
         * Gets the first alias stored in the .values array, or null if the
         * values array is empty.
         */
        get value() {
            return this.aliases.length > 0 ? this.aliases[0] : null;
        }
        /** */
        get isOverride() { return this.parallels.length > 0; }
        /** */
        get isIntroduction() { return this.parallels.length === 0; }
        /**
         * Gets a boolean value that indicates whether this Type
         * instance was created from a previous edit frame, and
         * should no longer be used.
         */
        get isDirty() {
            return this.private.program.version.newerThan(this.private.stamp);
        }
        /**
         * Performs an arbitrary recursive, breadth-first traversal
         * that begins at this Type instance. Ensures that no types
         * types are yielded multiple times.
         *
         * @param nextFn A function that returns a type, or an
         * iterable of types that are to be visited next.
         * @param reverse An optional boolean value that indicates
         * whether types in the returned array should be sorted
         * with the most deeply visited nodes occuring first.
         *
         * @returns An array that stores the list of types that were
         * visited.
         */
        visit(nextFn, reverse) {
            return Array.from(this.iterate(nextFn, reverse)).map(entry => entry.type);
        }
        /**
         * Performs an arbitrary recursive, breadth-first iteration
         * that begins at this Type instance. Ensures that no types
         * types are yielded multiple times.
         *
         * @param nextFn A function that returns a type, or an iterable
         * of types that are to be visited next.
         * @param reverse An optional boolean value that indicates
         * whether the iterator should yield types starting with the
         * most deeply nested types first.
         *
         * @yields An object that contains a `type` property that is the
         * the Type being visited, and a `via` property that is the Type
         * that was returned in the previous call to `nextFn`.
         */
        *iterate(nextFn, reverse) {
            const yielded = [];
            function* recurse(type, via) {
                if (yielded.includes(type))
                    return;
                if (!reverse) {
                    yielded.push(type);
                    yield { type, via };
                }
                const reduced = nextFn(type);
                if (reduced !== null && reduced !== undefined) {
                    if (reduced instanceof Type)
                        return yield* recurse(reduced, type);
                    for (const nextType of reduced)
                        if (nextType instanceof Type)
                            yield* recurse(nextType, type);
                }
                if (reverse) {
                    yielded.push(type);
                    yield { type, via };
                }
            }
            yield* recurse(this, null);
        }
        /**
         * Queries for a Type that is nested underneath this Type,
         * at the specified type path.
         */
        query(...typePath) {
            let currentType = null;
            for (const typeName of typePath) {
                const nextType = this.contents.find(type => type.name === typeName);
                if (!nextType)
                    break;
                currentType = nextType;
            }
            return currentType;
        }
        /**
         * Checks whether this Type has the specified type
         * somewhere in it's base graph.
         */
        is(baseType) {
            for (const { type } of this.iterate(t => t.bases))
                if (type === baseType)
                    return true;
            return false;
        }
        /**
         * Checks whether the specified type is in this Type's
         * `.contents` property, either directly, or indirectly via
         * the parallel graphs of the `.contents` Types.
         */
        has(type) {
            if (this.contents.includes(type))
                return true;
            for (const containedType of this.contents)
                if (type.name === containedType.name)
                    for (const parallel of containedType.iterate(t => t.parallels))
                        if (parallel.type === type)
                            return true;
            return false;
        }
    }
    /** */
    Type.parallelContextMap = new WeakMap();
    Truth.Type = Type;
    /**
     * @internal
     * A hidden class that stores the private information of
     * a Type instance, used to mitigate the risk of low-rank
     * developers from getting themselves into trouble.
     */
    class TypePrivate {
        constructor(program, seed) {
            this.program = program;
            this.seed = seed;
            /** */
            this.contents = null;
            /** */
            this.contentsIntrinsic = null;
            /** */
            this.bases = null;
            /** */
            this.parallels = null;
            /** */
            this.parallelRoots = null;
            /** */
            this.patterns = null;
            /** */
            this.aliases = null;
            /** */
            this.values = null;
            /** */
            this.superordinates = null;
            /** */
            this.subordinates = null;
            /** */
            this.derivations = null;
            /** */
            this.adjacents = null;
            this.stamp = program.version;
        }
        /** */
        throwOnDirty() {
            if (this.program.version.newerThan(this.stamp))
                throw Truth.Exception.objectDirty();
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeProxy {
        /** */
        constructor(uri, program) {
            this.uri = uri;
            this.program = program;
            /** */
            this.compiledType = undefined;
        }
        /** */
        maybeCompile() {
            if (this.compiledType !== undefined)
                return this.compiledType;
            return this.compiledType = Truth.Type.construct(this.uri, this.program);
        }
    }
    Truth.TypeProxy = TypeProxy;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeProxyArray {
        /**
         *
         */
        constructor(array) {
            this.array = array;
            this.compiledArray = undefined;
        }
        /**
         *
         */
        maybeCompile() {
            if (this.compiledArray !== undefined)
                return this.compiledArray;
            const out = this.array
                .map(lazy => lazy.maybeCompile())
                .filter((type) => type !== null);
            return this.compiledArray = Object.freeze(out);
        }
    }
    Truth.TypeProxyArray = TypeProxyArray;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeCache {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.map = new Map();
            this.version = program.version;
        }
        /** */
        static has(uri, program) {
            const cache = this.getCache(program);
            const uriText = uri.toString();
            return cache.map.has(uriText);
        }
        /** */
        static get(uri, program) {
            const cache = this.getCache(program);
            const uriText = uri.toString();
            if (cache.map.has(uriText))
                return Truth.Not.undefined(cache.map.get(uriText));
            const proxy = new Truth.TypeProxy(uri, program);
            this.set(uri, program, proxy);
            return proxy;
        }
        /** */
        static set(uri, program, type) {
            const cache = this.getCache(program);
            const uriText = uri.toString();
            cache.map.set(uriText, type);
            return type;
        }
        /** */
        static getCache(program) {
            const cache = this.allCaches.get(program) || (() => {
                const cache = new TypeCache(program);
                this.allCaches.set(program, cache);
                return cache;
            })();
            cache.maybeClear();
            return cache;
        }
        /** */
        maybeClear() {
            if (this.program.version.newerThan(this.version)) {
                this.map.clear();
                this.version = this.program.version;
            }
        }
    }
    /**
     *
     */
    TypeCache.allCaches = new WeakMap();
    Truth.TypeCache = TypeCache;
})(Truth || (Truth = {}));
// Util
/// <reference path="./Util/Helpers.ts" />
/// <reference path="./Util/MultiMap.ts" />
/// <reference path="./Util/Fs.ts" />
/// <reference path="./Util/Fetch.ts" />
/// <reference path="./Util/Hash.ts" />
/// <reference path="./Util/HigherOrder.ts" />
/// <reference path="./Util/Not.ts" />
/// <reference path="./Util/Parser.ts" />
/// <reference path="./Util/UnicodeBlocks.ts" />
/// <reference path="./Util/Misc.ts" />
// System
/// <reference path="./System/Program.ts" />
/// <reference path="./System/AgentCache.ts" />
/// <reference path="./System/Cause.ts" />
/// <reference path="./System/Exception.ts" />
/// <reference path="./System/Uri.ts" />
/// <reference path="./System/UriProtocol.ts" />
/// <reference path="./System/UriParser.ts" />
/// <reference path="./System/UriComponent.ts" />
/// <reference path="./System/UriReader.ts" />
/// <reference path="./System/Syntax.ts" />
/// <reference path="./System/FaultService.ts" />
/// <reference path="./System/Faults.ts" />
/// <reference path="./System/VersionStamp.ts" />
// Finite State Machine
/// <reference path="./fsm/Alphabet.ts" />
/// <reference path="./fsm/TransitionMap.ts" />
/// <reference path="./fsm/TransitionState.ts" />
/// <reference path="./fsm/Guide.ts" />
/// <reference path="./fsm/Fsm.ts" />
/// <reference path="./fsm/FsmTranslator.ts" />
// Phases/File
/// <reference path="./Phases/File/Document.ts" />
/// <reference path="./Phases/File/DocumentGraph.ts" />
/// <reference path="./Phases/File/DocumentHeader.ts" />
/// <reference path="./Phases/File/LineParser.ts" />
/// <reference path="./Phases/File/Anon.ts" />
/// <reference path="./Phases/File/Line.ts" />
/// <reference path="./Phases/File/Bounds.ts" />
/// <reference path="./Phases/File/Statement.ts" />
/// <reference path="./Phases/File/Pattern.ts" />
/// <reference path="./Phases/File/PatternPrecompiler.ts" />
/// <reference path="./Phases/File/RegexTypes.ts" />
/// <reference path="./Phases/File/Infix.ts" />
/// <reference path="./Phases/File/Identifier.ts" />
/// <reference path="./Phases/File/Span.ts" />
/// <reference path="./Phases/File/Spine.ts" />
/// <reference path="./Phases/File/Subject.ts" />
// Phases/Graph
/// <reference path="./Phases/Graph/HyperGraph.ts" />
/// <reference path="./Phases/Graph/Node.ts" />
/// <reference path="./Phases/Graph/NodeIndex.ts" />
/// <reference path="./Phases/Graph/HyperEdge.ts" />
/// <reference path="./Phases/Graph/InfixSpan.ts" />
// Phases/Parallel
/// <reference path="./Phases/Parallel/ConstructionWorker.ts" />
/// <reference path="./Phases/Parallel/Parallel.ts" />
/// <reference path="./Phases/Parallel/SpecifiedParallel.ts" />
/// <reference path="./Phases/Parallel/UnspecifiedParallel.ts" />
/// <reference path="./Phases/Parallel/CruftCache.ts" />
/// <reference path="./Phases/Parallel/ParallelCache.ts" />
/// <reference path="./Phases/Parallel/Contract.ts" />
/// <reference path="./Phases/Parallel/Sanitizer.ts" />
// Phases/Type
/// <reference path="./Phases/Type/Type.ts" />
/// <reference path="./Phases/Type/TypeProxy.ts" />
/// <reference path="./Phases/Type/TypeProxyArray.ts" />
/// <reference path="./Phases/Type/TypeCache.ts" />
var Truth;
(function (Truth) {
    /**
     * @internal
     * (Not implemented)
     * A class that specifies behavior around the recognition
     * of patterns found within documents.
     */
    class Recognition {
        /** */
        constructor() {
            /** Whether File URIs should be recognized in statements. */
            this.fileUris = 0 /* on */;
            /** Whether HTTP URIs should be recognized in statements. */
            this.httpUris = 0 /* on */;
            /** Whether regular expressions should be recognized in statements. */
            this.regularExpressions = 0 /* on */;
            /** Whether comments should be recognized in statements. */
            this.comments = 0 /* on */;
        }
    }
    Truth.Recognition = Recognition;
})(Truth || (Truth = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1dGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zb3VyY2UvVXRpbC9IZWxwZXJzLnRzIiwiLi4vc291cmNlL1V0aWwvTXVsdGlNYXAudHMiLCIuLi9zb3VyY2UvVXRpbC9Gcy50cyIsIi4uL3NvdXJjZS9VdGlsL0ZldGNoLnRzIiwiLi4vc291cmNlL1V0aWwvSGFzaC50cyIsIi4uL3NvdXJjZS9VdGlsL0hpZ2hlck9yZGVyLnRzIiwiLi4vc291cmNlL1V0aWwvTm90LnRzIiwiLi4vc291cmNlL1V0aWwvUGFyc2VyLnRzIiwiLi4vc291cmNlL1V0aWwvVW5pY29kZUJsb2Nrcy50cyIsIi4uL3NvdXJjZS9VdGlsL01pc2MudHMiLCIuLi9zb3VyY2UvU3lzdGVtL1Byb2dyYW0udHMiLCIuLi9zb3VyY2UvU3lzdGVtL0FnZW50Q2FjaGUudHMiLCIuLi9zb3VyY2UvU3lzdGVtL0NhdXNlLnRzIiwiLi4vc291cmNlL1N5c3RlbS9FeGNlcHRpb24udHMiLCIuLi9zb3VyY2UvU3lzdGVtL1VyaS50cyIsIi4uL3NvdXJjZS9TeXN0ZW0vVXJpUHJvdG9jb2wudHMiLCIuLi9zb3VyY2UvU3lzdGVtL1VyaVBhcnNlci50cyIsIi4uL3NvdXJjZS9TeXN0ZW0vVXJpQ29tcG9uZW50LnRzIiwiLi4vc291cmNlL1N5c3RlbS9VcmlSZWFkZXIudHMiLCIuLi9zb3VyY2UvU3lzdGVtL1N5bnRheC50cyIsIi4uL3NvdXJjZS9TeXN0ZW0vRmF1bHRTZXJ2aWNlLnRzIiwiLi4vc291cmNlL1N5c3RlbS9GYXVsdHMudHMiLCIuLi9zb3VyY2UvU3lzdGVtL1ZlcnNpb25TdGFtcC50cyIsIi4uL3NvdXJjZS9mc20vQWxwaGFiZXQudHMiLCIuLi9zb3VyY2UvZnNtL1RyYW5zaXRpb25NYXAudHMiLCIuLi9zb3VyY2UvZnNtL1RyYW5zaXRpb25TdGF0ZS50cyIsIi4uL3NvdXJjZS9mc20vR3VpZGUudHMiLCIuLi9zb3VyY2UvZnNtL0ZzbS50cyIsIi4uL3NvdXJjZS9mc20vRnNtVHJhbnNsYXRvci50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9Eb2N1bWVudC50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9Eb2N1bWVudEdyYXBoLnRzIiwiLi4vc291cmNlL1BoYXNlcy9GaWxlL0RvY3VtZW50SGVhZGVyLnRzIiwiLi4vc291cmNlL1BoYXNlcy9GaWxlL0xpbmVQYXJzZXIudHMiLCIuLi9zb3VyY2UvUGhhc2VzL0ZpbGUvQW5vbi50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9MaW5lLnRzIiwiLi4vc291cmNlL1BoYXNlcy9GaWxlL0JvdW5kcy50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9TdGF0ZW1lbnQudHMiLCIuLi9zb3VyY2UvUGhhc2VzL0ZpbGUvUGF0dGVybi50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9QYXR0ZXJuUHJlY29tcGlsZXIudHMiLCIuLi9zb3VyY2UvUGhhc2VzL0ZpbGUvUmVnZXhUeXBlcy50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9JbmZpeC50cyIsIi4uL3NvdXJjZS9QaGFzZXMvRmlsZS9JZGVudGlmaWVyLnRzIiwiLi4vc291cmNlL1BoYXNlcy9GaWxlL1NwYW4udHMiLCIuLi9zb3VyY2UvUGhhc2VzL0ZpbGUvU3BpbmUudHMiLCIuLi9zb3VyY2UvUGhhc2VzL0ZpbGUvU3ViamVjdC50cyIsIi4uL3NvdXJjZS9QaGFzZXMvR3JhcGgvSHlwZXJHcmFwaC50cyIsIi4uL3NvdXJjZS9QaGFzZXMvR3JhcGgvTm9kZS50cyIsIi4uL3NvdXJjZS9QaGFzZXMvR3JhcGgvTm9kZUluZGV4LnRzIiwiLi4vc291cmNlL1BoYXNlcy9HcmFwaC9IeXBlckVkZ2UudHMiLCIuLi9zb3VyY2UvUGhhc2VzL0dyYXBoL0luZml4U3Bhbi50cyIsIi4uL3NvdXJjZS9QaGFzZXMvUGFyYWxsZWwvQ29uc3RydWN0aW9uV29ya2VyLnRzIiwiLi4vc291cmNlL1BoYXNlcy9QYXJhbGxlbC9QYXJhbGxlbC50cyIsIi4uL3NvdXJjZS9QaGFzZXMvUGFyYWxsZWwvU3BlY2lmaWVkUGFyYWxsZWwudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1BhcmFsbGVsL1Vuc3BlY2lmaWVkUGFyYWxsZWwudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1BhcmFsbGVsL0NydWZ0Q2FjaGUudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1BhcmFsbGVsL1BhcmFsbGVsQ2FjaGUudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1BhcmFsbGVsL0NvbnRyYWN0LnRzIiwiLi4vc291cmNlL1BoYXNlcy9QYXJhbGxlbC9TYW5pdGl6ZXIudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1R5cGUvVHlwZS50cyIsIi4uL3NvdXJjZS9QaGFzZXMvVHlwZS9UeXBlUHJveHkudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1R5cGUvVHlwZVByb3h5QXJyYXkudHMiLCIuLi9zb3VyY2UvUGhhc2VzL1R5cGUvVHlwZUNhY2hlLnRzIiwiLi4vc291cmNlLyEudHMiLCIuLi9zb3VyY2Uvc3lzdGVtL1JlY29nbml0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxJQUFVLEtBQUssQ0EwQmQ7QUExQkQsV0FBVSxLQUFLO0lBRWQ7Ozs7Ozs7T0FPRztJQUNJLEtBQUssVUFBVSxJQUFJLENBQUMsa0JBQTBCO1FBRXBELE1BQU0sT0FBTyxHQUFHLElBQUksTUFBQSxPQUFPLEVBQUUsQ0FBQztRQUM5QixPQUFPLE1BQU0sT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBSnFCLFVBQUksT0FJekIsQ0FBQTtJQUVEOzs7O09BSUc7SUFDSSxLQUFLLFVBQVUsS0FBSyxDQUFDLFlBQW9CO1FBRS9DLE1BQU0sT0FBTyxHQUFHLElBQUksTUFBQSxPQUFPLEVBQUUsQ0FBQztRQUM5QixPQUFPLE1BQU0sT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUpxQixXQUFLLFFBSTFCLENBQUE7QUFDRixDQUFDLEVBMUJTLEtBQUss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RUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDcEMsVUFBVSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUM1QixxQkFBcUIsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDdkMsVUFBVSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUM1QixRQUFRLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQzFCLFFBQVEsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDMUIsUUFBUSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMxQixtQkFBbUIsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDckMsUUFBUSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMxQixLQUFLLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3ZCLFdBQVcsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDN0IsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMzQixtQkFBbUIsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDckMsbUJBQW1CLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3JDLFlBQVksRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDOUIsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMzQixVQUFVLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQzVCLFVBQVUsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDNUIsT0FBTyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUN6QixPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3pCLFFBQVEsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDMUIsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMzQixXQUFXLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQzdCLFNBQVMsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDM0IsTUFBTSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUN4QixLQUFLLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3ZCLFNBQVMsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDM0IsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMzQixVQUFVLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQzVCLGFBQWEsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDL0IsVUFBVSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUM1QixxQkFBcUIsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDdkMsVUFBVSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUM1Qix1Q0FBdUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDekQsT0FBTyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUN6QixPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3pCLFNBQVMsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDM0IsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUMzQixPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ3pCLFVBQVUsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7UUFDNUIsT0FBTyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUN6QixXQUFXLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQzdCLGdEQUFnRCxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztRQUNsRSxPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFB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blx0ICogQXN5bmNocm9ub3VzbHkgcmVhZHMgYSB0cnV0aCBkb2N1bWVudCwgYW5kIGFsbCBkb2N1bWVudHNcblx0ICogaXQgcmVmZXJlbmNlcyBmcm9tIHRoZSBzcGVjaWZpZWQgZmlsZSBzeXN0ZW0gb3IgSFRUUChzKSBwYXRoLlxuXHQgKiBGaWxlIHN5c3RlbSBwYXRocyBhcmUgb25seSBzdXBwb3J0ZWQgaWYgdGhpcyBjb2RlIGlzIHJ1bm5pbmdcblx0ICogd2l0aGluIGEgTm9kZS5qcy1jb21wYXRpYmxlIGVudmlyb25tZW50LlxuXHQgKiBcblx0ICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHJlYWQsIG9yIGFuIEVycm9yLlxuXHQgKi9cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWQodHJ1dGhGaWxlUGF0aE9yVXJpOiBzdHJpbmcpXG5cdHtcblx0XHRjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oKTtcblx0XHRyZXR1cm4gYXdhaXQgcHJvZ3JhbS5kb2N1bWVudHMucmVhZCh0cnV0aEZpbGVQYXRoT3JVcmkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgc3BlY2lmaWVkIHRydXRoIGNvbnRlbnQgaW50byBhIG5ldyBUcnV0aCBwcm9ncmFtLlxuXHQgKiBcblx0ICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIHBhcnNlZCBkb2N1bWVudC5cblx0ICovXG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZSh0cnV0aENvbnRlbnQ6IHN0cmluZylcblx0e1xuXHRcdGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbSgpO1xuXHRcdHJldHVybiBhd2FpdCBwcm9ncmFtLmRvY3VtZW50cy5jcmVhdGUodHJ1dGhDb250ZW50KTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIE1hcCBvZiB0aGUgZ2VuZXJpYyBrZXkgYW5kIHZhbHVlIHR5cGVzLlxuXHQgKiBTdXBwb3J0cyBrZXlzIHRoYXQgcmVmZXIgdG8gbXVsdGlwbGUgdmFsdWVzLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIE11bHRpTWFwPFRLZXksIFRWYWw+XG5cdHtcblx0XHQvKiogKi9cblx0XHQqW1N5bWJvbC5pdGVyYXRvcl0oKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApXG5cdFx0XHRcdHlpZWxkIGVudHJ5O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRlbnRyaWVzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAuZW50cmllcygpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQoa2V5OiBUS2V5KVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzKGtleTogVEtleSwgdmFsdWU/OiBUVmFsKVxuXHRcdHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0KGtleSk7XG5cdFx0XHRpZiAoIXZhbHVlcylcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuIHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGQoa2V5OiBUS2V5LCB2YWx1ZTogVFZhbClcblx0XHR7XG5cdFx0XHRpZiAodmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0KGtleSk7XG5cdFx0XHRcdGlmICh2YWx1ZXMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5tYXAuc2V0KGtleSwgW3ZhbHVlXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGRlbGV0ZShrZXk6IFRLZXksIHZhbHVlPzogVFZhbClcblx0XHR7XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuICEhdGhpcy5tYXAuZGVsZXRlKGtleSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0b3JlZFZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuXHRcdFx0aWYgKHN0b3JlZFZhbHVlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChzdG9yZWRWYWx1ZXMubGVuZ3RoID09PSAxICYmIHN0b3JlZFZhbHVlc1swXSA9PT0gdmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgdmFsdWVJZHggPSBzdG9yZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRpZiAodmFsdWVJZHggPCAwKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHN0b3JlZFZhbHVlcy5zcGxpY2UodmFsdWVJZHgsIDEpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHZhbHVlcygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwLnZhbHVlcygpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIG1hcCA9IG5ldyBNYXA8VEtleSwgVFZhbFtdPigpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHRkZWNsYXJlIGNvbnN0IE5vZGVGczogdHlwZW9mIGltcG9ydChcImZzXCIpO1xuXHRcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBFeHBvc2VzIHRoZSBcImZzXCIgbW9kdWxlIHVzZWQgYnkgdGhlIGNvbXBpbGVyLCBcblx0ICogYXMgd2VsbCBhcyB0aGUgYWJpbGl0eSB0byBjaGFuZ2UgdGhlIG1vZHVsZSB1c2VkXG5cdCAqIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRnNcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEFzc2lnbnMgYSBuZXcgaW1wbGVtZW50YXRpb24gb2YgdGhlIG5vZGUgXCJmc1wiIG1vZHVsZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgb3ZlcnJpZGUobW9kdWxlOiB0eXBlb2YgTm9kZUZzKVxuXHRcdHtcblx0XHRcdHRoaXMuX21vZHVsZSA9IG1vZHVsZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGdldCBtb2R1bGUoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9tb2R1bGUpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9tb2R1bGU7XG5cdFx0XHRcblx0XHRcdHRoaXMuX21vZHVsZSA9IHJlcXVpcmUoXCJmc1wiKTtcblx0XHRcdHJldHVybiBOb3QubnVsbCh0aGlzLl9tb2R1bGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyBfbW9kdWxlOiB0eXBlb2YgTm9kZUZzIHwgbnVsbCA9IG51bGw7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBjbGFzcyB0aGF0IHByb3ZpZGVzIGJyb3dzZXItc3R5bGUgZmV0Y2ggZnVuY3Rpb25hbGl0eSxcblx0ICogYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gY2hhbmdlIHRoaXMgZnVuY3Rpb25zIGJlaGF2aW9yXG5cdCAqIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRmV0Y2hcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHN0YXRpYyBhc3luYyBleGVjKHVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBFcnJvcj5cblx0XHR7XG5cdFx0XHRjb25zdCB1cmkgPSBVcmkudHJ5UGFyc2UodXJsKTtcblx0XHRcdGlmICghdXJpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZFVyaSh1cmwpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHRyeVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMClcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBGZXRjaEVycm9yKFxuXHRcdFx0XHRcdFx0cmVzcG9uc2Uuc3RhdHVzLFxuXHRcdFx0XHRcdFx0cmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKFwiVW5rbm93biBlcnJvci5cIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGUgSHR0cEdldCA9IHR5cGVvZiBpbXBvcnQoXCJodHRwXCIpLmdldDtcblx0XHRcdFx0dHlwZSBIdHRwc0dldCA9IHR5cGVvZiBpbXBvcnQoXCJodHRwc1wiKS5nZXQ7XG5cdFx0XHRcdHR5cGUgR2V0Rm4gPSBIdHRwR2V0IHwgSHR0cHNHZXQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBnZXRGbjogR2V0Rm4gPSBcblx0XHRcdFx0XHR1cmkucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmh0dHBzID8gcmVxdWlyZShcImh0dHBzXCIpLmdldCA6XG5cdFx0XHRcdFx0dXJpLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5odHRwID8gcmVxdWlyZShcImh0dHBcIikuZ2V0IDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGdldEZuID09PSBudWxsKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkVXJpKHVybCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gYXdhaXQgbmV3IFByb21pc2U8c3RyaW5nIHwgRXJyb3I+KHJlc29sdmUgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGdldEZuKHVybCwgcmVzcG9uc2UgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5vbihcImRhdGFcIiwgY2h1bmsgPT5cblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsgOlxuXHRcdFx0XHRcdFx0XHRcdGNodW5rLnRvU3RyaW5nKFwidXRmOFwiKSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmVzcG9uc2Uub24oXCJlcnJvclwiLCBlcnJvciA9PlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKGVycm9yKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKGRhdGEuam9pbihcIlwiKSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRocm93IEV4Y2VwdGlvbi51bnN1cHBvcnRlZFBsYXRmb3JtKCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHN0YXR1c0NvZGU6IG51bWJlcixcblx0XHRcdHJlYWRvbmx5IHN0YXR1c1RleHQ6IHN0cmluZylcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdGRlY2xhcmUgZnVuY3Rpb24gZmV0Y2goLi4uYXJnczogdW5rbm93bltdKTogYW55O1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCBlbmNhcHN1bGF0ZXMgc3RyaW5nIGhhc2hpbmcgZnVuY3Rpb25hbGl0eS5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBIYXNoID0gbmV3IGNsYXNzIEhhc2hcblx0e1xuXHRcdC8qKiBTdG9yZXMgdGhlIGNvbnN0YW50IG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIGEgcmV0dXJuZWQgaGFzaC4gKi9cblx0XHRyZWFkb25seSBsZW5ndGggPSA4O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENhbGN1bGF0ZXMgYSBoYXNoIGNvZGUgZnJvbSB0aGUgc3BlY2lmaWVkIHN0cmluZy5cblx0XHQgKi9cblx0XHRjYWxjdWxhdGUodGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGlmICh0ZXh0Lmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFwiMFwiLnJlcGVhdCg4KTtcblx0XHRcdFxuXHRcdFx0bGV0IGhhc2ggPSAwO1xuXHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCB0ZXh0Lmxlbmd0aDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGNoYXIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaGFyO1xuXHRcdFx0XHRoYXNoICU9IDIgKiogMzI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiAoaGFzaCArIE1hdGgucG93KDIsIDMxKSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXHR9KCk7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHByb3ZpZGVzIHZhcmlvdXMgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uc1xuXHQgKiBhY3Jvc3MgZGF0YSBzdHJ1Y3R1cmVzLlxuXHQgKi9cblx0ZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhpZ2hlck9yZGVyXG5cdHtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHJlYWRvbmx5IGNvcHkgb2YgdGhlIHNwZWNpZmllZCBhcnJheSwgc2V0LCBvciBsaXN0LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBjb3B5PFQ+KGFycmF5OiByZWFkb25seSBUW10pOiByZWFkb25seSBUW107XG5cdFx0c3RhdGljIGNvcHk8VD4oc2V0OiBSZWFkb25seVNldDxUPik6IFJlYWRvbmx5U2V0PFQ+O1xuXHRcdHN0YXRpYyBjb3B5PEssIFY+KG1hcDogUmVhZG9ubHlNYXA8SywgVj4pOiBSZWFkb25seU1hcDxLLCBWPjtcblx0XHRzdGF0aWMgY29weShwYXJhbTogb2JqZWN0KTogb2JqZWN0XG5cdFx0e1xuXHRcdFx0aWYgKHBhcmFtIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHBhcmFtLnNsaWNlKCkpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGFyYW0gaW5zdGFuY2VvZiBTZXQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgcGFyYW0pXG5cdFx0XHRcdFx0c2V0LmFkZCh2YWx1ZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShzZXQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocGFyYW0gaW5zdGFuY2VvZiBNYXApXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtKVxuXHRcdFx0XHRcdG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShtYXApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0fVxuXHRcdFxuXHRcdHByaXZhdGUgY29uc3RydWN0b3IoKSB7IH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFV0aWxpdHkgY2xhc3MgZm9yIHBlcmZvcm1pbmcgYmFzaWMgZ3VhcmRpbmcuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTm90XG5cdHtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgYXJndW1lbnQgYXMgc3BlY2lmaWVkLCBidXQgdGhyb3dzIGFuXG5cdFx0ICogZXhjZXB0aW9uIGluIHRoZSBjYXNlIHdoZW4gaXQncyBzdHJpY3RseSBlcXVhbCB0byBudWxsLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBudWxsPFQ+KHBhcmFtOiBUKTogTm90TnVsbDxUPlxuXHRcdHtcblx0XHRcdGlmIChwYXJhbSA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0ZGVidWdnZXI7XG5cdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gPE5vdE51bGw8VD4+cGFyYW07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBhcmd1bWVudCBhcyBzcGVjaWZpZWQsIGJ1dCB0aHJvd3MgYW5cblx0XHQgKiBleGNlcHRpb24gaW4gdGhlIGNhc2Ugd2hlbiBpdCdzIHN0cmljdGx5IGVxdWFsIHRvIHVuZGVmaW5lZC5cblx0XHQgKi9cblx0XHRzdGF0aWMgdW5kZWZpbmVkPFQ+KHBhcmFtOiBUKTogTm90VW5kZWZpbmVkPFQ+XG5cdFx0e1xuXHRcdFx0aWYgKHBhcmFtID09PSB1bmRlZmluZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGRlYnVnZ2VyO1xuXHRcdFx0XHR0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIDxOb3RVbmRlZmluZWQ8VD4+cGFyYW07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBhcmd1bWVudCBhcyBzcGVjaWZpZWQsIGJ1dCB0aHJvd3MgYW5cblx0XHQgKiBleGNlcHRpb24gaW4gdGhlIGNhc2Ugd2hlbiBpdCdzIG51bGwgb3IgdW5kZWZpbmVkLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBudWxsYWJsZTxUPihwYXJhbTogVCk6IE5vdE51bGw8VD4gfCBOb3RVbmRlZmluZWQ8VD5cblx0XHR7XG5cdFx0XHRpZiAocGFyYW0gPT09IG51bGwgfHwgcGFyYW0gPT09IHVuZGVmaW5lZClcblx0XHRcdHtcblx0XHRcdFx0ZGVidWdnZXI7XG5cdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gPE5vdE51bGw8VD4gfCBOb3RVbmRlZmluZWQ8VD4+cGFyYW07XG5cdFx0fVxuXHR9XG5cblx0dHlwZSBOb3ROdWxsPFQ+ID0gVCBleHRlbmRzIG51bGwgPyBuZXZlciA6IFQ7XG5cdHR5cGUgTm90VW5kZWZpbmVkPFQ+ID0gVCBleHRlbmRzIHVuZGVmaW5lZCA/IG5ldmVyIDogVDtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGdlbmVyYWwgcGFyc2luZyB1dGlsaXR5IGNsYXNzIHRoYXQgcHJvdmlkZXMgY29uc3VtcHRpb25cblx0ICogbWV0aG9kcyB0aGF0IG9wZXJhdGUgb3ZlciBhIGdpdmVuIGlucHV0LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFBhcnNlclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQ29uc3RydWN0cyBhIG5ldyBQYXJzZXIgb2JqZWN0IHRoYXQgb3BlcmF0ZXMgb3ZlclxuXHRcdCAqIHRoZSBzcGVjaWZpZWQgaW5wdXQgc3RyaW5nLCBvcHRpb25hbGx5IHN0YXJ0aW5nIGF0IHRoZVxuXHRcdCAqIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3RvcihpbnB1dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHRoaXMuaW5wdXQgPSBpbnB1dC5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCB0aGUgc3BlY2lmaWVkIHRva2VuIGltbWVkaWF0ZWx5IFxuXHRcdCAqIGZvbGxvd2luZyB0aGUgY3Vyc29yLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIFRoZSBjb250ZW50IHJlYWQuIEluIHRoZSBjYXNlIHdoZW4gbm9cblx0XHQgKiBtYXRjaCBjb3VsZCBiZSBmb3VuZCwgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdHJlYWQodG9rZW4/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKCF0b2tlbilcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwb3MgPSB0aGlzLl9wb3NpdGlvbjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaW5wdXQuc3Vic3RyKHBvcywgdG9rZW4ubGVuZ3RoKSA9PT0gdG9rZW4pXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uICs9IHRva2VuLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgYW55IHdoaXRlc3BhY2UgY2hhcmFjdGVycyBhbmQgZmxvYXRpbmdcblx0XHQgKiBlc2NhcGUgY2hhcmFjdGVycy5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdCAqIHJlYWQuXG5cdFx0ICovXG5cdFx0cmVhZFdoaXRlc3BhY2UoKVxuXHRcdHtcblx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRcblx0XHRcdHdoaWxlICh0aGlzLm1vcmUoKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYyA9IGNvdW50O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMucmVhZChTeW50YXgudGFiKSlcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMucmVhZChTeW50YXguc3BhY2UpKVxuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5yZWFkKFN5bnRheC5lc2NhcGVDaGFyICsgU3ludGF4LnNwYWNlKSlcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMucmVhZChTeW50YXguZXNjYXBlQ2hhciArIFN5bnRheC50YWIpKVxuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYyA9PT0gY291bnQpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBhIHNpbmdsZSBzdHJlYW0tbGV2ZWwgZ3JhcGhlbWUgZnJvbSB0aGVcblx0XHQgKiBwYXJzZSBzdHJlYW0sIHVzaW5nIHVuaWNvZGUtYXdhcmUgZXh0cmFjdGlvbiBtZXRob2QuXG5cdFx0ICogSWYgdGhlIHBhcnNlIHN0cmVhbSBzcGVjaWZpZXMgYSB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZSxcblx0XHQgKiBzdWNoIGFzIFxcdUZGRkYsIHRoZXNlIGFyZSBzZWVuIGFzIDYgaW5kaXZpZHVhbCBncmFwaGVtZXMuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgVGhlIHJlYWQgZ3JhcGhlbWUsIG9yIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgY2FzZVxuXHRcdCAqIHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0ICovXG5cdFx0cmVhZEdyYXBoZW1lKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fcG9zaXRpb24gPj0gdGhpcy5pbnB1dC5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb2RlQXRDdXJzb3IgPSB0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuX3Bvc2l0aW9uKSB8fCAtMTtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uICs9IGNvZGVBdEN1cnNvciA+IDB4RkZGRiA/IDIgOiAxO1xuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVBdEN1cnNvcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlYWRzIGdyYXBoZW1lcyBmcm9tIHRoZSBwYXJzZSBzdHJlYW0sIHVudGlsIGVpdGhlclxuXHRcdCAqIHRoZSBjdXJzb3IgcmVhY2hlcyBvbmUgb2YgdGhlIHNwZWNpZmllZCBxdWl0IHRva2Vucyxcblx0XHQgKiBvciB0aGUgcGFyc2Ugc3RyZWFtIHRlcm1pbmF0ZXMuXG5cdFx0ICovXG5cdFx0cmVhZFVudGlsKC4uLnF1aXRUb2tlbnM6IHN0cmluZ1tdKVxuXHRcdHtcblx0XHRcdGxldCBzdHJlYW0gPSBcIlwiO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAodGhpcy5tb3JlKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChxdWl0VG9rZW5zLnNvbWUodCA9PiB0aGlzLnBlZWsodCkpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0c3RyZWFtICs9IHRoaXMucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdHJlYW07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgdGhlIHNwZWNpZmllZCB0b2tlbiBmcm9tIHRoZSBwYXJzZSBzdHJlYW0sXG5cdFx0ICogaWYgYW5kIG9ubHkgaWYgaXQncyBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0ICovXG5cdFx0cmVhZFRoZW5UZXJtaW5hbCh0b2tlbjogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnBlZWsodG9rZW4pICYmIHRoaXMuX3Bvc2l0aW9uID09PSB0aGlzLmlucHV0Lmxlbmd0aCAtIHRva2VuLmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gKz0gdG9rZW4ubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcblx0XHQgKiBzcGVjaWZpZWQgc3RyaW5nIGV4aXN0cyBpbW1lZGlhdGVseSBhdCB0aGUgcG9zaXRpb24gb2Zcblx0XHQgKiB0aGUgY3Vyc29yLlxuXHRcdCAqL1xuXHRcdHBlZWsodG9rZW46IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5fcG9zaXRpb24sIHRva2VuLmxlbmd0aCkgPT09IHRva2VuO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcblx0XHQgKiBzcGVjaWZpZWQgc3RyaW5nIGV4aXN0cyBpbW1lZGlhdGVseSBhdCB0aGUgcG9zaXRpb24gb2Zcblx0XHQgKiB0aGUgY3Vyc29yLCBhbmQgZm9sbG93aW5nIHRoaXMgdG9rZW4gaXMgdGhlIGVuZCBvZiB0aGVcblx0XHQgKiBwYXJzZSBzdHJlYW0uXG5cdFx0ICovXG5cdFx0cGVla1RoZW5UZXJtaW5hbCh0b2tlbjogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uID09PSB0aGlzLmlucHV0Lmxlbmd0aCAtIHRva2VuLmxlbmd0aCAmJlxuXHRcdFx0XHR0aGlzLmlucHV0LnN1YnN0cih0aGlzLl9wb3NpdGlvbiwgdG9rZW4ubGVuZ3RoKSA9PT0gdG9rZW4pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlclxuXHRcdCAqIHRoZXJlIGFyZSBtb3JlIGNoYXJhY3RlcnMgdG8gcmVhZCBpbiB0aGUgaW5wdXQuXG5cdFx0ICovXG5cdFx0bW9yZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uIDwgdGhpcy5pbnB1dC5sZW5ndGg7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgb3Igc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnNvciBmcm9tIHdoZXJlXG5cdFx0ICogcmVhZGluZyB0YWtlcyBwbGFjZSBpbiB0aGUgY3Vyc29yLlxuXHRcdCAqL1xuXHRcdGdldCBwb3NpdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuXHRcdH1cblx0XHRzZXQgcG9zaXRpb24odmFsdWU6IG51bWJlcilcblx0XHR7XG5cdFx0XHRpZiAodmFsdWUgPCAwKVxuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHZhbHVlO1xuXHRcdH1cblx0XHRwcml2YXRlIF9wb3NpdGlvbiA9IDA7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBpbnB1dDogc3RyaW5nO1xuXHRcdFxuXHRcdFxuXHRcdC8vXG5cdFx0Ly8gREVBRFxuXHRcdC8vXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBhdFJlYWxCYWNrc2xhc2goKVxuXHRcdHtcblx0XHRcdGNvbnN0IGVzYyA9IFN5bnRheC5lc2NhcGVDaGFyO1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuX3Bvc2l0aW9uLCAyKSA9PT0gZXNjICsgZXNjO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGFuXG5cdFx0ICogZXNjYXBlIGNoYXJhY3RlciBleGlzdHMgYmVoaW5kIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cblx0XHQgKiBUaGUgYWxnb3JpdGhtIHVzZWQgaXMgcmVzcGVjdGl2ZSBvZiBzZXF1ZW5jZXMgb2Zcblx0XHQgKiBtdWx0aXBsZSBlc2NhcGUgY2hhcmFjdGVycy5cblx0XHQgKi9cblx0XHRwcml2YXRlIGVzY2FwZWQoKVxuXHRcdHtcblx0XHRcdGxldCBlc2NhcGVkID0gZmFsc2U7XG5cdFx0XHRsZXQgYmFja3RyYWNrUG9zID0gdGhpcy5fcG9zaXRpb247XG5cdFx0XHRcblx0XHRcdHdoaWxlICgtLWJhY2t0cmFja1BvcyA+PSAwKVxuXHRcdFx0XHRpZiAodGhpcy5pbnB1dFtiYWNrdHJhY2tQb3NdID09PSBTeW50YXguZXNjYXBlQ2hhcilcblx0XHRcdFx0XHRlc2NhcGVkID0gIWVzY2FwZWQ7XG5cdFx0XHRcblx0XHRcdHJldHVybiBlc2NhcGVkO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0dHlwZSBUID0gW251bWJlciwgbnVtYmVyXTtcblx0dHlwZSBUVW5pY29kZUJsb2NrcyA9IHsgW2Jsb2NrTmFtZTogc3RyaW5nXTogVCB9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgbmFtZXMgaW4gdGhlIFVuaWNvZGVCbG9ja3Mgb2JqZWN0XG5cdCAqIHRvIGEgbWFwIHdpdGggbG93ZXIgY2FzZSBrZXlzLCBmb3IgZWFzeSBsb29rdXAuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b01hcChibG9ja3M6IFRVbmljb2RlQmxvY2tzKVxuXHR7XG5cdFx0Y29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGJsb2Nrcyk7XG5cdFx0Y29uc3QgZW50cmllc0ZtdCA9IGVudHJpZXMubWFwKGVudHJ5ID0+IDxbc3RyaW5nLCBUXT5bZW50cnlbMF0udG9Mb3dlckNhc2UoKSwgZW50cnlbMV1dKTtcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgTWFwPHN0cmluZywgVD4oZW50cmllc0ZtdCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgbWF4aW11bSBjaGFyYWN0ZXIgY29kZSBpbiB0aGUgdW5pY29kZSBzZXQuXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgVW5pY29kZU1heCA9IDY1NTM2O1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgYSBtYXAgb2YgdGhlIG5hbWVzIG9mIGFsbCB1bmljb2RlIGJsb2Nrcyxcblx0ICogYW5kIHRoZWlyIGNoYXJhY3RlciByYW5nZXMuXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgVW5pY29kZUJsb2NrcyA9IHRvTWFwKDxUVW5pY29kZUJsb2Nrcz57XG5cdFx0XCJDb250cm9sIGNoYXJhY3RlclwiOiBbMHgwMDAwLCAweDAwMUZdLFxuXHRcdFwiQmFzaWMgTGF0aW5cIjogWzB4MDAyMCwgMHgwMDdGXSxcblx0XHRcIkxhdGluLTEgU3VwcGxlbWVudFwiOiBbMHgwMDgwLCAweDAwRkZdLFxuXHRcdFwiTGF0aW4gRXh0ZW5kZWQtQVwiOiBbMHgwMTAwLCAweDAxN0ZdLFxuXHRcdFwiTGF0aW4gRXh0ZW5kZWQtQlwiOiBbMHgwMTgwLCAweDAyNEZdLFxuXHRcdFwiSVBBIEV4dGVuc2lvbnNcIjogWzB4MDI1MCwgMHgwMkFGXSxcblx0XHRcIlNwYWNpbmcgTW9kaWZpZXIgTGV0dGVyc1wiOiBbMHgwMkIwLCAweDAyRkZdLFxuXHRcdFwiQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzXCI6IFsweDAzMDAsIDB4MDM2Rl0sXG5cdFx0XCJHcmVlayBhbmQgQ29wdGljXCI6IFsweDAzNzAsIDB4MDNGRl0sXG5cdFx0XCJDeXJpbGxpY1wiOiBbMHgwNDAwLCAweDA0RkZdLFxuXHRcdFwiQ3lyaWxsaWMgU3VwcGxlbWVudFwiOiBbMHgwNTAwLCAweDA1MkZdLFxuXHRcdFwiQXJtZW5pYW5cIjogWzB4MDUzMCwgMHgwNThGXSxcblx0XHRcIkhlYnJld1wiOiBbMHgwNTkwLCAweDA1RkZdLFxuXHRcdFwiQXJhYmljXCI6IFsweDA2MDAsIDB4MDZGRl0sXG5cdFx0XCJTeXJpYWNcIjogWzB4MDcwMCwgMHgwNzRGXSxcblx0XHRcIkFyYWJpYyBTdXBwbGVtZW50XCI6IFsweDA3NTAsIDB4MDc3Rl0sXG5cdFx0XCJUaGFhbmFcIjogWzB4MDc4MCwgMHgwN0JGXSxcblx0XHRcIk5Lb1wiOiBbMHgwN0MwLCAweDA3RkZdLFxuXHRcdFwiU2FtYXJpdGFuXCI6IFsweDA4MDAsIDB4MDgzRl0sXG5cdFx0XCJNYW5kYWljXCI6IFsweDA4NDAsIDB4MDg1Rl0sXG5cdFx0XCJTeXJpYWMgU3VwcGxlbWVudFwiOiBbMHgwODYwLCAweDA4NkZdLFxuXHRcdFwiQXJhYmljIEV4dGVuZGVkLUFcIjogWzB4MDhBMCwgMHgwOEZGXSxcblx0XHRcIkRldmFuYWdhcmlcIjogWzB4MDkwMCwgMHgwOTdGXSxcblx0XHRcIkJlbmdhbGlcIjogWzB4MDk4MCwgMHgwOUZGXSxcblx0XHRcIkd1cm11a2hpXCI6IFsweDBBMDAsIDB4MEE3Rl0sXG5cdFx0XCJHdWphcmF0aVwiOiBbMHgwQTgwLCAweDBBRkZdLFxuXHRcdFwiT3JpeWFcIjogWzB4MEIwMCwgMHgwQjdGXSxcblx0XHRcIlRhbWlsXCI6IFsweDBCODAsIDB4MEJGRl0sXG5cdFx0XCJUZWx1Z3VcIjogWzB4MEMwMCwgMHgwQzdGXSxcblx0XHRcIkthbm5hZGFcIjogWzB4MEM4MCwgMHgwQ0ZGXSxcblx0XHRcIk1hbGF5YWxhbVwiOiBbMHgwRDAwLCAweDBEN0ZdLFxuXHRcdFwiU2luaGFsYVwiOiBbMHgwRDgwLCAweDBERkZdLFxuXHRcdFwiVGhhaVwiOiBbMHgwRTAwLCAweDBFN0ZdLFxuXHRcdFwiTGFvXCI6IFsweDBFODAsIDB4MEVGRl0sXG5cdFx0XCJUaWJldGFuXCI6IFsweDBGMDAsIDB4MEZGRl0sXG5cdFx0XCJNeWFubWFyXCI6IFsweDEwMDAsIDB4MTA5Rl0sXG5cdFx0XCJHZW9yZ2lhblwiOiBbMHgxMEEwLCAweDEwRkZdLFxuXHRcdFwiSGFuZ3VsIEphbW9cIjogWzB4MTEwMCwgMHgxMUZGXSxcblx0XHRcIkV0aGlvcGljXCI6IFsweDEyMDAsIDB4MTM3Rl0sXG5cdFx0XCJFdGhpb3BpYyBTdXBwbGVtZW50XCI6IFsweDEzODAsIDB4MTM5Rl0sXG5cdFx0XCJDaGVyb2tlZVwiOiBbMHgxM0EwLCAweDEzRkZdLFxuXHRcdFwiVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljc1wiOiBbMHgxNDAwLCAweDE2N0ZdLFxuXHRcdFwiT2doYW1cIjogWzB4MTY4MCwgMHgxNjlGXSxcblx0XHRcIlJ1bmljXCI6IFsweDE2QTAsIDB4MTZGRl0sXG5cdFx0XCJUYWdhbG9nXCI6IFsweDE3MDAsIDB4MTcxRl0sXG5cdFx0XCJIYW51bm9vXCI6IFsweDE3MjAsIDB4MTczRl0sXG5cdFx0XCJCdWhpZFwiOiBbMHgxNzQwLCAweDE3NUZdLFxuXHRcdFwiVGFnYmFud2FcIjogWzB4MTc2MCwgMHgxNzdGXSxcblx0XHRcIktobWVyXCI6IFsweDE3ODAsIDB4MTdGRl0sXG5cdFx0XCJNb25nb2xpYW5cIjogWzB4MTgwMCwgMHgxOEFGXSxcblx0XHRcIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3MgRXh0ZW5kZWRcIjogWzB4MThCMCwgMHgxOEZGXSxcblx0XHRcIkxpbWJ1XCI6IFsweDE5MDAsIDB4MTk0Rl0sXG5cdFx0XCJUYWkgTGVcIjogWzB4MTk1MCwgMHgxOTdGXSxcblx0XHRcIk5ldyBUYWkgTHVlXCI6IFsweDE5ODAsIDB4MTlERl0sXG5cdFx0XCJLaG1lciBTeW1ib2xzXCI6IFsweDE5RTAsIDB4MTlGRl0sXG5cdFx0XCJCdWdpbmVzZVwiOiBbMHgxQTAwLCAweDFBMUZdLFxuXHRcdFwiVGFpIFRoYW1cIjogWzB4MUEyMCwgMHgxQUFGXSxcblx0XHRcIkNvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrcyBFeHRlbmRlZFwiOiBbMHgxQUIwLCAweDFBRkZdLFxuXHRcdFwiQmFsaW5lc2VcIjogWzB4MUIwMCwgMHgxQjdGXSxcblx0XHRcIlN1bmRhbmVzZVwiOiBbMHgxQjgwLCAweDFCQkZdLFxuXHRcdFwiQmF0YWtcIjogWzB4MUJDMCwgMHgxQkZGXSxcblx0XHRcIkxlcGNoYVwiOiBbMHgxQzAwLCAweDFDNEZdLFxuXHRcdFwiT2wgQ2hpa2lcIjogWzB4MUM1MCwgMHgxQzdGXSxcblx0XHRcIkN5cmlsbGljIEV4dGVuZGVkIENcIjogWzB4MUM4MCwgMHgxQzhGXSxcblx0XHRcIlN1bmRhbmVzZSBTdXBwbGVtZW50XCI6IFsweDFDQzAsIDB4MUNDRl0sXG5cdFx0XCJWZWRpYyBFeHRlbnNpb25zXCI6IFsweDFDRDAsIDB4MUNGRl0sXG5cdFx0XCJQaG9uZXRpYyBFeHRlbnNpb25zXCI6IFsweDFEMDAsIDB4MUQ3Rl0sXG5cdFx0XCJQaG9uZXRpYyBFeHRlbnNpb25zIFN1cHBsZW1lbnRcIjogWzB4MUQ4MCwgMHgxREJGXSxcblx0XHRcIkNvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrcyBTdXBwbGVtZW50XCI6IFsweDFEQzAsIDB4MURGRl0sXG5cdFx0XCJMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsXCI6IFsweDFFMDAsIDB4MUVGRl0sXG5cdFx0XCJHcmVlayBFeHRlbmRlZFwiOiBbMHgxRjAwLCAweDFGRkZdLFxuXHRcdFwiR2VuZXJhbCBQdW5jdHVhdGlvblwiOiBbMHgyMDAwLCAweDIwNkZdLFxuXHRcdFwiU3VwZXJzY3JpcHRzIGFuZCBTdWJzY3JpcHRzXCI6IFsweDIwNzAsIDB4MjA5Rl0sXG5cdFx0XCJDdXJyZW5jeSBTeW1ib2xzXCI6IFsweDIwQTAsIDB4MjBDRl0sXG5cdFx0XCJDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgZm9yIFN5bWJvbHNcIjogWzB4MjBEMCwgMHgyMEZGXSxcblx0XHRcIkxldHRlcmxpa2UgU3ltYm9sc1wiOiBbMHgyMTAwLCAweDIxNEZdLFxuXHRcdFwiTnVtYmVyIEZvcm1zXCI6IFsweDIxNTAsIDB4MjE4Rl0sXG5cdFx0XCJBcnJvd3NcIjogWzB4MjE5MCwgMHgyMUZGXSxcblx0XHRcIk1hdGhlbWF0aWNhbCBPcGVyYXRvcnNcIjogWzB4MjIwMCwgMHgyMkZGXSxcblx0XHRcIk1pc2NlbGxhbmVvdXMgVGVjaG5pY2FsXCI6IFsweDIzMDAsIDB4MjNGRl0sXG5cdFx0XCJDb250cm9sIFBpY3R1cmVzXCI6IFsweDI0MDAsIDB4MjQzRl0sXG5cdFx0XCJPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblwiOiBbMHgyNDQwLCAweDI0NUZdLFxuXHRcdFwiRW5jbG9zZWQgQWxwaGFudW1lcmljc1wiOiBbMHgyNDYwLCAweDI0RkZdLFxuXHRcdFwiQm94IERyYXdpbmdcIjogWzB4MjUwMCwgMHgyNTdGXSxcblx0XHRcIkJsb2NrIEVsZW1lbnRzXCI6IFsweDI1ODAsIDB4MjU5Rl0sXG5cdFx0XCJHZW9tZXRyaWMgU2hhcGVzXCI6IFsweDI1QTAsIDB4MjVGRl0sXG5cdFx0XCJNaXNjZWxsYW5lb3VzIFN5bWJvbHNcIjogWzB4MjYwMCwgMHgyNkZGXSxcblx0XHRcIkRpbmdiYXRzXCI6IFsweDI3MDAsIDB4MjdCRl0sXG5cdFx0XCJNaXNjZWxsYW5lb3VzIE1hdGhlbWF0aWNhbCBTeW1ib2xzLUFcIjogWzB4MjdDMCwgMHgyN0VGXSxcblx0XHRcIlN1cHBsZW1lbnRhbCBBcnJvd3MtQVwiOiBbMHgyN0YwLCAweDI3RkZdLFxuXHRcdFwiQnJhaWxsZSBQYXR0ZXJuc1wiOiBbMHgyODAwLCAweDI4RkZdLFxuXHRcdFwiU3VwcGxlbWVudGFsIEFycm93cy1CXCI6IFsweDI5MDAsIDB4Mjk3Rl0sXG5cdFx0XCJNaXNjZWxsYW5lb3VzIE1hdGhlbWF0aWNhbCBTeW1ib2xzLUJcIjogWzB4Mjk4MCwgMHgyOUZGXSxcblx0XHRcIlN1cHBsZW1lbnRhbCBNYXRoZW1hdGljYWwgT3BlcmF0b3JzXCI6IFsweDJBMDAsIDB4MkFGRl0sXG5cdFx0XCJNaXNjZWxsYW5lb3VzIFN5bWJvbHMgYW5kIEFycm93c1wiOiBbMHgyQjAwLCAweDJCRkZdLFxuXHRcdFwiR2xhZ29saXRpY1wiOiBbMHgyQzAwLCAweDJDNUZdLFxuXHRcdFwiTGF0aW4gRXh0ZW5kZWQtQ1wiOiBbMHgyQzYwLCAweDJDN0ZdLFxuXHRcdFwiQ29wdGljXCI6IFsweDJDODAsIDB4MkNGRl0sXG5cdFx0XCJHZW9yZ2lhbiBTdXBwbGVtZW50XCI6IFsweDJEMDAsIDB4MkQyRl0sXG5cdFx0XCJUaWZpbmFnaFwiOiBbMHgyRDMwLCAweDJEN0ZdLFxuXHRcdFwiRXRoaW9waWMgRXh0ZW5kZWRcIjogWzB4MkQ4MCwgMHgyRERGXSxcblx0XHRcIkN5cmlsbGljIEV4dGVuZGVkLUFcIjogWzB4MkRFMCwgMHgyREZGXSxcblx0XHRcIlN1cHBsZW1lbnRhbCBQdW5jdHVhdGlvblwiOiBbMHgyRTAwLCAweDJFN0ZdLFxuXHRcdFwiQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcIjogWzB4MkU4MCwgMHgyRUZGXSxcblx0XHRcIkthbmd4aSBSYWRpY2Fsc1wiOiBbMHgyRjAwLCAweDJGREZdLFxuXHRcdFwiSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1wiOiBbMHgyRkYwLCAweDJGRkZdLFxuXHRcdFwiQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXCI6IFsweDMwMDAsIDB4MzAzRl0sXG5cdFx0XCJIaXJhZ2FuYVwiOiBbMHgzMDQwLCAweDMwOUZdLFxuXHRcdFwiS2F0YWthbmFcIjogWzB4MzBBMCwgMHgzMEZGXSxcblx0XHRcIkJvcG9tb2ZvXCI6IFsweDMxMDAsIDB4MzEyRl0sXG5cdFx0XCJIYW5ndWwgQ29tcGF0aWJpbGl0eSBKYW1vXCI6IFsweDMxMzAsIDB4MzE4Rl0sXG5cdFx0XCJLYW5idW5cIjogWzB4MzE5MCwgMHgzMTlGXSxcblx0XHRcIkJvcG9tb2ZvIEV4dGVuZGVkXCI6IFsweDMxQTAsIDB4MzFCRl0sXG5cdFx0XCJDSksgU3Ryb2tlc1wiOiBbMHgzMUMwLCAweDMxRUZdLFxuXHRcdFwiS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1wiOiBbMHgzMUYwLCAweDMxRkZdLFxuXHRcdFwiRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1wiOiBbMHgzMjAwLCAweDMyRkZdLFxuXHRcdFwiQ0pLIENvbXBhdGliaWxpdHlcIjogWzB4MzMwMCwgMHgzM0ZGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcIjogWzB4MzQwMCwgMHg0REJGXSxcblx0XHRcIllpamluZyBIZXhhZ3JhbSBTeW1ib2xzXCI6IFsweDREQzAsIDB4NERGRl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCI6IFsweDRFMDAsIDB4OUZGRl0sXG5cdFx0XCJZaSBTeWxsYWJsZXNcIjogWzB4QTAwMCwgMHhBNDhGXSxcblx0XHRcIllpIFJhZGljYWxzXCI6IFsweEE0OTAsIDB4QTRDRl0sXG5cdFx0XCJMaXN1XCI6IFsweEE0RDAsIDB4QTRGRl0sXG5cdFx0XCJWYWlcIjogWzB4QTUwMCwgMHhBNjNGXSxcblx0XHRcIkN5cmlsbGljIEV4dGVuZGVkLUJcIjogWzB4QTY0MCwgMHhBNjlGXSxcblx0XHRcIkJhbXVtXCI6IFsweEE2QTAsIDB4QTZGRl0sXG5cdFx0XCJNb2RpZmllciBUb25lIExldHRlcnNcIjogWzB4QTcwMCwgMHhBNzFGXSxcblx0XHRcIkxhdGluIEV4dGVuZGVkLURcIjogWzB4QTcyMCwgMHhBN0ZGXSxcblx0XHRcIlN5bG90aSBOYWdyaVwiOiBbMHhBODAwLCAweEE4MkZdLFxuXHRcdFwiQ29tbW9uIEluZGljIE51bWJlciBGb3Jtc1wiOiBbMHhBODMwLCAweEE4M0ZdLFxuXHRcdFwiUGhhZ3MtcGFcIjogWzB4QTg0MCwgMHhBODdGXSxcblx0XHRcIlNhdXJhc2h0cmFcIjogWzB4QTg4MCwgMHhBOERGXSxcblx0XHRcIkRldmFuYWdhcmkgRXh0ZW5kZWRcIjogWzB4QThFMCwgMHhBOEZGXSxcblx0XHRcIktheWFoIExpXCI6IFsweEE5MDAsIDB4QTkyRl0sXG5cdFx0XCJSZWphbmdcIjogWzB4QTkzMCwgMHhBOTVGXSxcblx0XHRcIkhhbmd1bCBKYW1vIEV4dGVuZGVkLUFcIjogWzB4QTk2MCwgMHhBOTdGXSxcblx0XHRcIkphdmFuZXNlXCI6IFsweEE5ODAsIDB4QTlERl0sXG5cdFx0XCJNeWFubWFyIEV4dGVuZGVkLUJcIjogWzB4QTlFMCwgMHhBOUZGXSxcblx0XHRcIkNoYW1cIjogWzB4QUEwMCwgMHhBQTVGXSxcblx0XHRcIk15YW5tYXIgRXh0ZW5kZWQtQVwiOiBbMHhBQTYwLCAweEFBN0ZdLFxuXHRcdFwiVGFpIFZpZXRcIjogWzB4QUE4MCwgMHhBQURGXSxcblx0XHRcIk1lZXRlaSBNYXllayBFeHRlbnNpb25zXCI6IFsweEFBRTAsIDB4QUFGRl0sXG5cdFx0XCJFdGhpb3BpYyBFeHRlbmRlZC1BXCI6IFsweEFCMDAsIDB4QUIyRl0sXG5cdFx0XCJMYXRpbiBFeHRlbmRlZC1FXCI6IFsweEFCMzAsIDB4QUI2Rl0sXG5cdFx0XCJDaGVyb2tlZSBTdXBwbGVtZW50XCI6IFsweEFCNzAsIDB4QUJCRl0sXG5cdFx0XCJNZWV0ZWkgTWF5ZWtcIjogWzB4QUJDMCwgMHhBQkZGXSxcblx0XHRcIkhhbmd1bCBTeWxsYWJsZXNcIjogWzB4QUMwMCwgMHhEN0FGXSxcblx0XHRcIkhhbmd1bCBKYW1vIEV4dGVuZGVkLUJcIjogWzB4RDdCMCwgMHhEN0ZGXSxcblx0XHRcIkhpZ2ggU3Vycm9nYXRlc1wiOiBbMHhEODAwLCAweERCN0ZdLFxuXHRcdFwiSGlnaCBQcml2YXRlIFVzZSBTdXJyb2dhdGVzXCI6IFsweERCODAsIDB4REJGRl0sXG5cdFx0XCJMb3cgU3Vycm9nYXRlc1wiOiBbMHhEQzAwLCAweERGRkZdLFxuXHRcdFwiUHJpdmF0ZSBVc2UgQXJlYVwiOiBbMHhFMDAwLCAweEY4RkZdLFxuXHRcdFwiQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1wiOiBbMHhGOTAwLCAweEZBRkZdLFxuXHRcdFwiQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcIjogWzB4RkIwMCwgMHhGQjRGXSxcblx0XHRcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVwiOiBbMHhGQjUwLCAweEZERkZdLFxuXHRcdFwiVmFyaWF0aW9uIFNlbGVjdG9yc1wiOiBbMHhGRTAwLCAweEZFMEZdLFxuXHRcdFwiVmVydGljYWwgRm9ybXNcIjogWzB4RkUxMCwgMHhGRTFGXSxcblx0XHRcIkNvbWJpbmluZyBIYWxmIE1hcmtzXCI6IFsweEZFMjAsIDB4RkUyRl0sXG5cdFx0XCJDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1wiOiBbMHhGRTMwLCAweEZFNEZdLFxuXHRcdFwiU21hbGwgRm9ybSBWYXJpYW50c1wiOiBbMHhGRTUwLCAweEZFNkZdLFxuXHRcdFwiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1CXCI6IFsweEZFNzAsIDB4RkVGRl0sXG5cdFx0XCJIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1wiOiBbMHhGRjAwLCAweEZGRUZdLFxuXHRcdFwiU3BlY2lhbHNcIjogWzB4RkZGMCwgMHhGRkZGXSxcblx0XHRcIkxpbmVhciBCIFN5bGxhYmFyeVwiOiBbMHgxMDAwMCwgMHgxMDA3Rl0sXG5cdFx0XCJMaW5lYXIgQiBJZGVvZ3JhbXNcIjogWzB4MTAwODAsIDB4MTAwRkZdLFxuXHRcdFwiQWVnZWFuIE51bWJlcnNcIjogWzB4MTAxMDAsIDB4MTAxM0ZdLFxuXHRcdFwiQW5jaWVudCBHcmVlayBOdW1iZXJzXCI6IFsweDEwMTQwLCAweDEwMThGXSxcblx0XHRcIkFuY2llbnQgU3ltYm9sc1wiOiBbMHgxMDE5MCwgMHgxMDFDRl0sXG5cdFx0XCJQaGFpc3RvcyBEaXNjXCI6IFsweDEwMUQwLCAweDEwMUZGXSxcblx0XHRcIkx5Y2lhblwiOiBbMHgxMDI4MCwgMHgxMDI5Rl0sXG5cdFx0XCJDYXJpYW5cIjogWzB4MTAyQTAsIDB4MTAyREZdLFxuXHRcdFwiQ29wdGljIEVwYWN0IE51bWJlcnNcIjogWzB4MTAyRTAsIDB4MTAyRkZdLFxuXHRcdFwiT2xkIEl0YWxpY1wiOiBbMHgxMDMwMCwgMHgxMDMyRl0sXG5cdFx0XCJHb3RoaWNcIjogWzB4MTAzMzAsIDB4MTAzNEZdLFxuXHRcdFwiT2xkIFBlcm1pY1wiOiBbMHgxMDM1MCwgMHgxMDM3Rl0sXG5cdFx0XCJVZ2FyaXRpY1wiOiBbMHgxMDM4MCwgMHgxMDM5Rl0sXG5cdFx0XCJPbGQgUGVyc2lhblwiOiBbMHgxMDNBMCwgMHgxMDNERl0sXG5cdFx0XCJEZXNlcmV0XCI6IFsweDEwNDAwLCAweDEwNDRGXSxcblx0XHRcIlNoYXZpYW5cIjogWzB4MTA0NTAsIDB4MTA0N0ZdLFxuXHRcdFwiT3NtYW55YVwiOiBbMHgxMDQ4MCwgMHgxMDRBRl0sXG5cdFx0XCJPc2FnZVwiOiBbMHgxMDRCMCwgMHgxMDRGRl0sXG5cdFx0XCJFbGJhc2FuXCI6IFsweDEwNTAwLCAweDEwNTJGXSxcblx0XHRcIkNhdWNhc2lhbiBBbGJhbmlhblwiOiBbMHgxMDUzMCwgMHgxMDU2Rl0sXG5cdFx0XCJMaW5lYXIgQVwiOiBbMHgxMDYwMCwgMHgxMDc3Rl0sXG5cdFx0XCJDeXByaW90IFN5bGxhYmFyeVwiOiBbMHgxMDgwMCwgMHgxMDgzRl0sXG5cdFx0XCJJbXBlcmlhbCBBcmFtYWljXCI6IFsweDEwODQwLCAweDEwODVGXSxcblx0XHRcIlBhbG15cmVuZVwiOiBbMHgxMDg2MCwgMHgxMDg3Rl0sXG5cdFx0XCJOYWJhdGFlYW5cIjogWzB4MTA4ODAsIDB4MTA4QUZdLFxuXHRcdFwiSGF0cmFuXCI6IFsweDEwOEUwLCAweDEwOEZGXSxcblx0XHRcIlBob2VuaWNpYW5cIjogWzB4MTA5MDAsIDB4MTA5MUZdLFxuXHRcdFwiTHlkaWFuXCI6IFsweDEwOTIwLCAweDEwOTNGXSxcblx0XHRcIk1lcm9pdGljIEhpZXJvZ2x5cGhzXCI6IFsweDEwOTgwLCAweDEwOTlGXSxcblx0XHRcIk1lcm9pdGljIEN1cnNpdmVcIjogWzB4MTA5QTAsIDB4MTA5RkZdLFxuXHRcdFwiS2hhcm9zaHRoaVwiOiBbMHgxMEEwMCwgMHgxMEE1Rl0sXG5cdFx0XCJPbGQgU291dGggQXJhYmlhblwiOiBbMHgxMEE2MCwgMHgxMEE3Rl0sXG5cdFx0XCJPbGQgTm9ydGggQXJhYmlhblwiOiBbMHgxMEE4MCwgMHgxMEE5Rl0sXG5cdFx0XCJNYW5pY2hhZWFuXCI6IFsweDEwQUMwLCAweDEwQUZGXSxcblx0XHRcIkF2ZXN0YW5cIjogWzB4MTBCMDAsIDB4MTBCM0ZdLFxuXHRcdFwiSW5zY3JpcHRpb25hbCBQYXJ0aGlhblwiOiBbMHgxMEI0MCwgMHgxMEI1Rl0sXG5cdFx0XCJJbnNjcmlwdGlvbmFsIFBhaGxhdmlcIjogWzB4MTBCNjAsIDB4MTBCN0ZdLFxuXHRcdFwiUHNhbHRlciBQYWhsYXZpXCI6IFsweDEwQjgwLCAweDEwQkFGXSxcblx0XHRcIk9sZCBUdXJraWNcIjogWzB4MTBDMDAsIDB4MTBDNEZdLFxuXHRcdFwiT2xkIEh1bmdhcmlhblwiOiBbMHgxMEM4MCwgMHgxMENGRl0sXG5cdFx0XCJSdW1pIE51bWVyYWwgU3ltYm9sc1wiOiBbMHgxMEU2MCwgMHgxMEU3Rl0sXG5cdFx0XCJCcmFobWlcIjogWzB4MTEwMDAsIDB4MTEwN0ZdLFxuXHRcdFwiS2FpdGhpXCI6IFsweDExMDgwLCAweDExMENGXSxcblx0XHRcIlNvcmEgU29tcGVuZ1wiOiBbMHgxMTBEMCwgMHgxMTBGRl0sXG5cdFx0XCJDaGFrbWFcIjogWzB4MTExMDAsIDB4MTExNEZdLFxuXHRcdFwiTWFoYWphbmlcIjogWzB4MTExNTAsIDB4MTExN0ZdLFxuXHRcdFwiU2hhcmFkYVwiOiBbMHgxMTE4MCwgMHgxMTFERl0sXG5cdFx0XCJTaW5oYWxhIEFyY2hhaWMgTnVtYmVyc1wiOiBbMHgxMTFFMCwgMHgxMTFGRl0sXG5cdFx0XCJLaG9qa2lcIjogWzB4MTEyMDAsIDB4MTEyNEZdLFxuXHRcdFwiTXVsdGFuaVwiOiBbMHgxMTI4MCwgMHgxMTJBRl0sXG5cdFx0XCJLaHVkYXdhZGlcIjogWzB4MTEyQjAsIDB4MTEyRkZdLFxuXHRcdFwiR3JhbnRoYVwiOiBbMHgxMTMwMCwgMHgxMTM3Rl0sXG5cdFx0XCJOZXdhXCI6IFsweDExNDAwLCAweDExNDdGXSxcblx0XHRcIlRpcmh1dGFcIjogWzB4MTE0ODAsIDB4MTE0REZdLFxuXHRcdFwiU2lkZGhhbVwiOiBbMHgxMTU4MCwgMHgxMTVGRl0sXG5cdFx0XCJNb2RpXCI6IFsweDExNjAwLCAweDExNjVGXSxcblx0XHRcIk1vbmdvbGlhbiBTdXBwbGVtZW50XCI6IFsweDExNjYwLCAweDExNjdGXSxcblx0XHRcIlRha3JpXCI6IFsweDExNjgwLCAweDExNkNGXSxcblx0XHRcIkFob21cIjogWzB4MTE3MDAsIDB4MTE3M0ZdLFxuXHRcdFwiV2FyYW5nIENpdGlcIjogWzB4MTE4QTAsIDB4MTE4RkZdLFxuXHRcdFwiWmFuYWJhemFyIFNxdWFyZVwiOiBbMHgxMUEwMCwgMHgxMUE0Rl0sXG5cdFx0XCJTb3lvbWJvXCI6IFsweDExQTUwLCAweDExQUFGXSxcblx0XHRcIlBhdSBDaW4gSGF1XCI6IFsweDExQUMwLCAweDExQUZGXSxcblx0XHRcIkJoYWlrc3VraVwiOiBbMHgxMUMwMCwgMHgxMUM2Rl0sXG5cdFx0XCJNYXJjaGVuXCI6IFsweDExQzcwLCAweDExQ0JGXSxcblx0XHRcIk1hc2FyYW0gR29uZGlcIjogWzB4MTFEMDAsIDB4MTFENUZdLFxuXHRcdFwiQ3VuZWlmb3JtXCI6IFsweDEyMDAwLCAweDEyM0ZGXSxcblx0XHRcIkN1bmVpZm9ybSBOdW1iZXJzIGFuZCBQdW5jdHVhdGlvblwiOiBbMHgxMjQwMCwgMHgxMjQ3Rl0sXG5cdFx0XCJFYXJseSBEeW5hc3RpYyBDdW5laWZvcm1cIjogWzB4MTI0ODAsIDB4MTI1NEZdLFxuXHRcdFwiRWd5cHRpYW4gSGllcm9nbHlwaHNcIjogWzB4MTMwMDAsIDB4MTM0MkZdLFxuXHRcdFwiQW5hdG9saWFuIEhpZXJvZ2x5cGhzXCI6IFsweDE0NDAwLCAweDE0NjdGXSxcblx0XHRcIkJhbXVtIFN1cHBsZW1lbnRcIjogWzB4MTY4MDAsIDB4MTZBM0ZdLFxuXHRcdFwiTXJvXCI6IFsweDE2QTQwLCAweDE2QTZGXSxcblx0XHRcIkJhc3NhIFZhaFwiOiBbMHgxNkFEMCwgMHgxNkFGRl0sXG5cdFx0XCJQYWhhd2ggSG1vbmdcIjogWzB4MTZCMDAsIDB4MTZCOEZdLFxuXHRcdFwiTWlhb1wiOiBbMHgxNkYwMCwgMHgxNkY5Rl0sXG5cdFx0XCJJZGVvZ3JhcGhpYyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiOiBbMHgxNkZFMCwgMHgxNkZGRl0sXG5cdFx0XCJUYW5ndXRcIjogWzB4MTcwMDAsIDB4MTg3RkZdLFxuXHRcdFwiVGFuZ3V0IENvbXBvbmVudHNcIjogWzB4MTg4MDAsIDB4MThBRkZdLFxuXHRcdFwiS2FuYSBTdXBwbGVtZW50XCI6IFsweDFCMDAwLCAweDFCMEZGXSxcblx0XHRcIkthbmEgRXh0ZW5kZWQtQVwiOiBbMHgxQjEwMCwgMHgxQjEyRl0sXG5cdFx0XCJOdXNodVwiOiBbMHgxQjE3MCwgMHgxQjJGRl0sXG5cdFx0XCJEdXBsb3lhblwiOiBbMHgxQkMwMCwgMHgxQkM5Rl0sXG5cdFx0XCJTaG9ydGhhbmQgRm9ybWF0IENvbnRyb2xzXCI6IFsweDFCQ0EwLCAweDFCQ0FGXSxcblx0XHRcIkJ5emFudGluZSBNdXNpY2FsIFN5bWJvbHNcIjogWzB4MUQwMDAsIDB4MUQwRkZdLFxuXHRcdFwiTXVzaWNhbCBTeW1ib2xzXCI6IFsweDFEMTAwLCAweDFEMUZGXSxcblx0XHRcIkFuY2llbnQgR3JlZWsgTXVzaWNhbCBOb3RhdGlvblwiOiBbMHgxRDIwMCwgMHgxRDI0Rl0sXG5cdFx0XCJUYWkgWHVhbiBKaW5nIFN5bWJvbHNcIjogWzB4MUQzMDAsIDB4MUQzNUZdLFxuXHRcdFwiQ291bnRpbmcgUm9kIE51bWVyYWxzXCI6IFsweDFEMzYwLCAweDFEMzdGXSxcblx0XHRcIk1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9sc1wiOiBbMHgxRDQwMCwgMHgxRDdGRl0sXG5cdFx0XCJTdXR0b24gU2lnbldyaXRpbmdcIjogWzB4MUQ4MDAsIDB4MURBQUZdLFxuXHRcdFwiR2xhZ29saXRpYyBTdXBwbGVtZW50XCI6IFsweDFFMDAwLCAweDFFMDJGXSxcblx0XHRcIk1lbmRlIEtpa2FrdWlcIjogWzB4MUU4MDAsIDB4MUU4REZdLFxuXHRcdFwiQWRsYW1cIjogWzB4MUU5MDAsIDB4MUU5NUZdLFxuXHRcdFwiQXJhYmljIE1hdGhlbWF0aWNhbCBBbHBoYWJldGljIFN5bWJvbHNcIjogWzB4MUVFMDAsIDB4MUVFRkZdLFxuXHRcdFwiTWFoam9uZyBUaWxlc1wiOiBbMHgxRjAwMCwgMHgxRjAyRl0sXG5cdFx0XCJEb21pbm8gVGlsZXNcIjogWzB4MUYwMzAsIDB4MUYwOUZdLFxuXHRcdFwiUGxheWluZyBDYXJkc1wiOiBbMHgxRjBBMCwgMHgxRjBGRl0sXG5cdFx0XCJFbmNsb3NlZCBBbHBoYW51bWVyaWMgU3VwcGxlbWVudFwiOiBbMHgxRjEwMCwgMHgxRjFGRl0sXG5cdFx0XCJFbmNsb3NlZCBJZGVvZ3JhcGhpYyBTdXBwbGVtZW50XCI6IFsweDFGMjAwLCAweDFGMkZGXSxcblx0XHRcIk1pc2NlbGxhbmVvdXMgU3ltYm9scyBhbmQgUGljdG9ncmFwaHNcIjogWzB4MUYzMDAsIDB4MUY1RkZdLFxuXHRcdFwiRW1vamlcIjogWzB4MUY2MDAsIDB4MUY2NEZdLFxuXHRcdFwiT3JuYW1lbnRhbCBEaW5nYmF0c1wiOiBbMHgxRjY1MCwgMHgxRjY3Rl0sXG5cdFx0XCJUcmFuc3BvcnQgYW5kIE1hcCBTeW1ib2xzXCI6IFsweDFGNjgwLCAweDFGNkZGXSxcblx0XHRcIkFsY2hlbWljYWwgU3ltYm9sc1wiOiBbMHgxRjcwMCwgMHgxRjc3Rl0sXG5cdFx0XCJHZW9tZXRyaWMgU2hhcGVzIEV4dGVuZGVkXCI6IFsweDFGNzgwLCAweDFGN0ZGXSxcblx0XHRcIlN1cHBsZW1lbnRhbCBBcnJvd3MtQ1wiOiBbMHgxRjgwMCwgMHgxRjhGRl0sXG5cdFx0XCJTdXBwbGVtZW50YWwgU3ltYm9scyBhbmQgUGljdG9ncmFwaHNcIjogWzB4MUY5MDAsIDB4MUY5RkZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQlwiOiBbMHgyMDAwMCwgMHgyQTZERl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBDXCI6IFsweDJBNzAwLCAweDJCNzNGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIERcIjogWzB4MkI3NDAsIDB4MkI4MUZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gRVwiOiBbMHgyQjgyMCwgMHgyQ0VBRl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBGXCI6IFsweDJDRUIwLCAweDJFQkVGXSxcblx0XHRcIkNKSyBDb21wYXRpYmlsaXR5IElkZW9ncmFwaHMgU3VwcGxlbWVudFwiOiBbMHgyRjgwMCwgMHgyRkExRl0sXG5cdFx0XCJUYWdzXCI6IFsweEUwMDAwLCAweEUwMDdGXSxcblx0XHRcIlZhcmlhdGlvbiBTZWxlY3RvcnMgU3VwcGxlbWVudFwiOiBbMHhFMDEwMCwgMHhFMDFFRl1cblx0fSk7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFN0b3JlcyB1bnNvcnRlZCBnZW5lcmFsIHV0aWxpdHkgbWV0aG9kcy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBNaXNjXG5cdHtcblx0XHQvKipcblx0XHQgKiBDb3VudHMgaW5jcmVtZW50YWxseSB0aHJvdWdoIG51bWJlcnMsIHVzaW5nIHRoZSBzcGVjaWZpZWRcblx0XHQgKiByYWRpeCBzZXF1ZW5jZS4gRm9yIGV4YW1wbGUsIGlmIHRoZSByYWRpeGVzIFsyLCAyLCAyXSB3ZXJlIHRvXG5cdFx0ICogYmUgc3BlY2lmaWVkLCB0aGlzIHdvdWxkIHJlc3VsdCBpbiBiaW5hcnkgY291bnRpbmcgc3RhcnRpbmcgYXRcblx0XHQgKiBbMCwgMCwgMF0gYW5kIGVuZGluZyBhdCBbMSwgMSwgMV0uXG5cdFx0ICovXG5cdFx0c3RhdGljICp2YXJpYWJsZVJhZGl4Q291bnRlcihyYWRpeGVzOiBudW1iZXJbXSlcblx0XHR7XG5cdFx0XHRpZiAocmFkaXhlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWYgKHJhZGl4ZXMubGVuZ3RoID09PSAxKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHJhZGl4ZXNbMF07KVxuXHRcdFx0XHRcdHlpZWxkIFtpXTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgdG90YWwgPSByYWRpeGVzLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuXHRcdFx0Y29uc3QgZGlnaXRzID0gcmFkaXhlcy5tYXAoKCkgPT4gMCk7XG5cdFx0XHRjb25zdCBkaXZpZGVGYWN0b3JzID0gWzFdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBiYXNlSWR4ID0gcmFkaXhlcy5sZW5ndGggLSAxOyAtLWJhc2VJZHggPj0gMDspXG5cdFx0XHRcdGRpdmlkZUZhY3RvcnMudW5zaGlmdChyYWRpeGVzLnNsaWNlKGJhc2VJZHggKyAxKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKSk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGNvdW50ID0gLTE7ICsrY291bnQgPCB0b3RhbDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHNlcXVlbmNlOiBudW1iZXJbXSA9IFtdO1xuXHRcdFx0XHRsZXQgcmVtYWluZGVyID0gY291bnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBkaWdpdElkeCA9IC0xOyArK2RpZ2l0SWR4IDwgZGlnaXRzLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkaXYgPSBkaXZpZGVGYWN0b3JzW2RpZ2l0SWR4XTtcblx0XHRcdFx0XHRzZXF1ZW5jZS5wdXNoKHJlbWFpbmRlciAvIGRpdiB8IDApO1xuXHRcdFx0XHRcdHJlbWFpbmRlciAlPSBkaXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHlpZWxkIHNlcXVlbmNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRzdGF0aWMgY2FsY3VsYXRlUG93ZXJzZXQ8VD4oYXJyYXk6IFRbXSk6IFRbXVtdXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVzdWx0OiBUW11bXSA9IFtbXV07XG5cdFx0XHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRmb3IgKGxldCBuID0gMDsgbiA8IHJlc3VsdC5sZW5ndGg7IG4rKylcblx0XHRcdFx0XHRyZXN1bHQucHVzaChyZXN1bHRbbl0uY29uY2F0KGFycmF5W2ldKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGl0ZW1zIG9mIHRoZSBmaXJzdCBzZXQgb2JqZWN0IGZvcm1cblx0XHQgKiBhIHN1YnNldCAobm90IGEgcHJvcGVyIHN1YnNldCkgb2YgdGhlIGl0ZW1zIG9mIHRoZSBzZWNvbmRcblx0XHQgKiBzZXQuXG5cdFx0ICovXG5cdFx0c3RhdGljIGlzU3Vic2V0KFxuXHRcdFx0c291cmNlU2V0OiBSZWFkb25seVNldDx1bmtub3duPixcblx0XHRcdHBvc3NpYmxlU3Vic2V0OiBSZWFkb25seVNldDx1bmtub3duPilcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgcG9zc2libGVTdWJzZXQpXG5cdFx0XHRcdGlmICghc291cmNlU2V0LmhhcyhpdGVtKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBpdGVtcyBvZiB0aGUgZmlyc3Qgc2V0IG9iamVjdCBmb3JtXG5cdFx0ICogYSBzdXBlcnNldCAobm90IGEgcHJvcGVyIHN1cGVyc2V0KSBvZiB0aGUgaXRlbXMgb2YgdGhlXG5cdFx0ICogc2Vjb25kIHNldC5cblx0XHQgKi9cblx0XHRzdGF0aWMgaXNTdXBlcnNldChcblx0XHRcdHNvdXJjZVNldDogUmVhZG9ubHlTZXQ8dW5rbm93bj4sXG5cdFx0XHRwb3NzaWJsZVN1cGVyc2V0OiBSZWFkb25seVNldDx1bmtub3duPilcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2Ygc291cmNlU2V0KVxuXHRcdFx0XHRpZiAoIXBvc3NpYmxlU3VwZXJzZXQuaGFzKGl0ZW0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBhcmUgbWlzc2luZ1xuXHRcdCAqIGZyb20gdGhlIHNlY29uZCBzZXQgdGhhdCBleGlzdCBpbiB0aGUgZmlyc3Qgc2V0LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBjb21wdXRlU3Vic2V0RmFjdG9yKFxuXHRcdFx0YTogcmVhZG9ubHkgdW5rbm93bltdLFxuXHRcdFx0YjogcmVhZG9ubHkgdW5rbm93bltdKVxuXHRcdHtcblx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBhKVxuXHRcdFx0XHRjb3VudCArPSBiLmluY2x1ZGVzKGl0ZW0pID8gMCA6IDE7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgYSByZWN1cnNpdmUgcmVkdWN0aW9uIG9wZXJhdGlvbiBvbiBhbiBpbml0aWFsIG9iamVjdFxuXHRcdCAqIHRoYXQgcmVwcmVzZW50cyBzb21lIGFic3RyYWN0IG5vZGUgb2YgYSBncmFwaC4gVGhlIHRyYXZlcnNhbFxuXHRcdCAqIGFsZ29yaXRobSB1c2VkIGVuc3VyZXMgYWxsIHByb3ZpZGVkIG5vZGVzIGFyZSBvbmx5IHZpc2l0ZWRcblx0XHQgKiBvbmNlLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyByZWR1Y2VSZWN1cnNpdmU8VFJldCwgVD4oXG5cdFx0XHRpbml0aWFsT2JqZWN0OiBULFxuXHRcdFx0Zm9sbG93Rm46IChmcm9tOiBUKSA9PiBJdGVyYWJsZTxUPixcblx0XHRcdHJlZHVjZUZuOiAoY3VycmVudDogVCwgbmVzdGVkUmVzdWx0czogcmVhZG9ubHkgVFJldFtdKSA9PiBUUmV0XG5cdFx0KTogVFJldFxuXHRcdHtcblx0XHRcdGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PFQ+KCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlY3Vyc2UgPSAob2JqZWN0OiBUKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR2aXNpdGVkLmFkZChvYmplY3QpO1xuXHRcdFx0XHRjb25zdCByZWR1Y2VSZXN1bHQ6IFRSZXRbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBuZXh0IG9mIGZvbGxvd0ZuKG9iamVjdCkpXG5cdFx0XHRcdFx0aWYgKCF2aXNpdGVkLmhhcyhuZXh0KSlcblx0XHRcdFx0XHRcdHJlZHVjZVJlc3VsdC5wdXNoKHJlY3Vyc2UobmV4dCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJlZHVjZUZuKG9iamVjdCwgT2JqZWN0LmZyZWV6ZShyZWR1Y2VSZXN1bHQpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiByZWN1cnNlKGluaXRpYWxPYmplY3QpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHByb3h5IG9mIHRoZSBzcGVjaWZpZWQgb2JqZWN0LCB3aG9zZSBtZW1iZXJzXG5cdFx0ICogaGF2ZSBiZWVuIHBhdGNoZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHBhdGNoIG9iamVjdC5cblx0XHQgKi9cblx0XHRzdGF0aWMgcGF0Y2g8VCBleHRlbmRzIG9iamVjdD4oc291cmNlOiBULCBwYXRjaDogUGFydGlhbDxUPilcblx0XHR7XG5cdFx0XHR0eXBlIEsgPSByZWFkb25seSAoa2V5b2YgVClbXTtcblx0XHRcdGNvbnN0IHBhdGNoS2V5cyA9IDxLPk9iamVjdC5mcmVlemUoT2JqZWN0LmtleXMocGF0Y2gpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBQcm94eShzb3VyY2UsIHtcblx0XHRcdFx0Z2V0KHRhcmdldDogVCwga2V5OiBrZXlvZiBUKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdGNoS2V5cy5pbmNsdWRlcyhrZXkpID9cblx0XHRcdFx0XHRcdHBhdGNoW2tleV0gOlxuXHRcdFx0XHRcdFx0c291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTYWZlbHkgcGFyc2VzIGEgSlNPTiBvYmplY3QsIHNpbGVuY2luZyBhbnkgdGhyb3duIHBhcnNlIGV4Y2VwdGlvbnMuXG5cdFx0ICovXG5cdFx0c3RhdGljIHRyeVBhcnNlSnNvbihqc29uVGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHRyeVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShqc29uVGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSlcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogVGhlIHRvcC1sZXZlbCBvYmplY3QgdGhhdCBtYW5hZ2VzIFRydXRoIGRvY3VtZW50cy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQcm9ncmFtXG5cdHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFByb2dyYW0sIGludG8gd2hpY2ggRG9jdW1lbnRzIG1heVxuXHRcdCAqIGJlIGFkZGVkLCBhbmQgdmVyaWZpZWQuXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoKVxuXHRcdHtcblx0XHRcdHRoaXMuX3ZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgb3JkZXJpbmcgb2YgdGhlc2UgaW5zdGFudGF0aW9ucyBpcyByZWxldmFudCxcblx0XHRcdC8vIGJlY2F1c2UgaXQgcmVmbGVjdHMgdGhlIG9yZGVyIGluIHdoaWNoIGVhY2ggb2Zcblx0XHRcdC8vIHRoZXNlIHNlcnZpY2VzIGFyZSBnb2luZyB0byBwcm9jZXNzIGhvb2tzLlxuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlRG9jdW1lbnRDcmVhdGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy51bnZlcmlmaWVkRG9jdW1lbnRzLnB1c2goZGF0YS5kb2N1bWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5vbihDYXVzZURvY3VtZW50RGVsZXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGlkeCA9IHRoaXMudW52ZXJpZmllZERvY3VtZW50cy5pbmRleE9mKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0XHRpZiAoaWR4ID4gLTEpXG5cdFx0XHRcdFx0dGhpcy51bnZlcmlmaWVkRG9jdW1lbnRzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VEb2N1bWVudFVyaUNoYW5nZSwgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fdmVyc2lvbiA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5vbihDYXVzZUFnZW50RGV0YWNoLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW2NhdXNlLCBhdHRhY2htZW50c10gb2YgdGhpcy5jYXVzZXMpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKVxuXHRcdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQudXJpICYmIGF0dGFjaG1lbnQudXJpLmVxdWFscyhkYXRhLnVyaSkpXG5cdFx0XHRcdFx0XHRcdHRoaXMuY2F1c2VzLmRlbGV0ZShjYXVzZSwgYXR0YWNobWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hZ2VudENhY2hlID0gbmV3IEFnZW50Q2FjaGUodGhpcyk7XG5cdFx0XHR0aGlzLmRvY3VtZW50cyA9IG5ldyBEb2N1bWVudEdyYXBoKHRoaXMpO1xuXHRcdFx0dGhpcy5ncmFwaCA9IG5ldyBIeXBlckdyYXBoKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlUmV2YWxpZGF0ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCBpID0gdGhpcy51bnZlcmlmaWVkU3RhdGVtZW50cy5sZW5ndGg7IGktLSA+IDA7KVxuXHRcdFx0XHRcdGlmICh0aGlzLnVudmVyaWZpZWRTdGF0ZW1lbnRzW2ldLmlzRGlzcG9zZWQpXG5cdFx0XHRcdFx0XHR0aGlzLnVudmVyaWZpZWRTdGF0ZW1lbnRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRpZiAoIXN0YXRlbWVudC5pc0NydWZ0KVxuXHRcdFx0XHRcdFx0dGhpcy51bnZlcmlmaWVkU3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5mYXVsdHMgPSBuZXcgRmF1bHRTZXJ2aWNlKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlRWRpdENvbXBsZXRlLCAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBhZ2VudENhY2hlOiBBZ2VudENhY2hlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGRvY3VtZW50czogRG9jdW1lbnRHcmFwaDtcblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cmVhZG9ubHkgZ3JhcGg6IEh5cGVyR3JhcGg7XG5cdFx0XG5cdFx0LyoqICAqL1xuXHRcdHJlYWRvbmx5IGZhdWx0czogRmF1bHRTZXJ2aWNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCB2ZXJzaW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmVyc2lvbjtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfdmVyc2lvbjogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb2JlcyB0aGUgcHJvZ3JhbSBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGluZm9ybWF0aW9uXG5cdFx0ICogYWJvdXQgdGhlIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGlmIGEgY2F1c2Ugb2YgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHR5cGUgaXMgYnJvYWRjYXN0ZWQuIEVzc2VudGlhbGx5LCB0aGlzIG1ldGhvZCBhbnN3ZXJzIHRoZSBxdWVzdGlvbiwgXG5cdFx0ICogXCJXaG8gaXMgbGlzdGVuaW5nIGZvciBDYXVzZXMgb2YgdHlwZSBYP1wiLlxuXHRcdCAqIFxuXHRcdCAqIElmIG5vIGFnZW50cyBoYXZlIGF0dGFjaGVkIHRvIHRoZSBzcGVjaWZpZWQgdHlwZSwgYW4gZW1wdHkgYXJyYXlcblx0XHQgKiBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRwcm9iZShjYXVzZVR5cGU6IG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueSwgc2NvcGU6IEF0dGFjaG1lbnRTY29wZSA9IHRoaXMpXG5cdFx0e1xuXHRcdFx0aWYgKHNjb3BlIGluc3RhbmNlb2YgVHlwZSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlc3VsdHM6IHsgdXJpOiBVcmkgfCBudWxsOyBzY29wZTogQXR0YWNobWVudFNjb3BlIH1bXSA9IFtdO1xuXHRcdFx0Y29uc3QgcHVzaCA9IChjYTogQ2F1c2VBdHRhY2htZW50KSA9PlxuXHRcdFx0XHRyZXN1bHRzLnB1c2goeyB1cmk6IGNhLnVyaSwgc2NvcGU6IGNhLnNjb3BlIH0pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtjYXVzZVR5cGVLZXksIGF0dGFjaG1lbnRzXSBvZiB0aGlzLmNhdXNlcylcblx0XHRcdFx0aWYgKGNhdXNlVHlwZSA9PT0gY2F1c2VUeXBlS2V5KVxuXHRcdFx0XHRcdGZvciAoY29uc3QgY2Egb2YgYXR0YWNobWVudHMpXG5cdFx0XHRcdFx0XHRpZiAoc2NvcGUgPT09IGNhLnNjb3BlIHx8IFxuXHRcdFx0XHRcdFx0XHRzY29wZSBpbnN0YW5jZW9mIFByb2dyYW0gJiYgY2Euc2NvcGUgaW5zdGFuY2VvZiBEb2N1bWVudClcblx0XHRcdFx0XHRcdFx0cHVzaChjYSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRvbjxUIGV4dGVuZHMgQ2F1c2U8YW55Pj4oXG5cdFx0XHRjYXVzZVR5cGU6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFQsXG5cdFx0XHRmbjogKGRhdGE6IFRDYXVzZURhdGE8VD4pID0+IFRDYXVzZVJldHVybjxUPixcblx0XHRcdHNjb3BlPzogRG9jdW1lbnQgfCBUeXBlKTogdm9pZFxuXHRcdHtcblx0XHRcdGNvbnN0IGluZm8gPSBnZXRIb2xkZXJJbmZvKHRoaXMpO1xuXHRcdFx0Y29uc3QgdXNpbmdTY29wZTogQXR0YWNobWVudFNjb3BlID0gc2NvcGUgfHwgaW5mby5zY29wZSB8fCB0aGlzO1xuXHRcdFx0Y29uc3QgY2EgPSBuZXcgQ2F1c2VBdHRhY2htZW50KGluZm8udXJpLCBmbiwgdXNpbmdTY29wZSk7XG5cdFx0XHR0aGlzLmNhdXNlcy5hZGQoY2F1c2VUeXBlLCBjYSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb2dhdGVzIHRoZSBzcGVjaWZpZWQgQ2F1c2Ugb2JqZWN0IHRvIGFsbCBzdWJzY3JpYmVycyB0aGF0XG5cdFx0ICogYXJlIGxpc3RlbmluZyBmb3IgY2F1c2VzIG9mIG9iamVjdCdzIHR5cGUuIFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBjYXVzZSBBIHJlZmVyZW5jZSB0byB0aGUgQ2F1c2UgaW5zdGFuY2UgdG8gYnJvYWRjYXN0LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBmaWx0ZXIgQW4gb3B0aW9uYWwgYXJyYXkgb2YgVXJpIGluc3RhbmNlcyB0aGF0XG5cdFx0ICogc3BlY2lmeSB0aGUgb3JpZ2luIGZyb20gd2hlcmUgYW4gYWdlbnQgdGhhdCBpcyBhdHRhY2hlZFxuXHRcdCAqIHRvIHRoZSBjYXVzZSBtdXN0IGxvYWRlZCBpbiBvcmRlciB0byBiZSBkZWxpdmVyZWQgdGhlXG5cdFx0ICogY2F1c2UgaW5zdGFuY2UuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQW4gb2JqZWN0IHRoYXQgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuXHRcdCAqIGNhdXNlIHJlc3VsdHMgdGhhdCB3ZXJlIHJldHVybmVkLCBhbmQgdGhlIFVSSSBvZiB0aGUgXG5cdFx0ICogYWdlbnQgdGhhdCBwcm9kdWNlZCB0aGUgcmVzdWx0LiBJbiB0aGUgY2FzZSB3aGVuIHRoZVxuXHRcdCAqIGFnZW50IHdhcyBhdHRhY2hlZCBwcm9ncmFtbWF0aWNhbGx5LCB0aGUgVVJJIHZhbHVlIFxuXHRcdCAqIHdpbGwgYmUgbnVsbC5cblx0XHQgKi9cblx0XHRjYXVzZTxSPihjYXVzZTogQ2F1c2U8Uj4sIC4uLmZpbHRlcnM6IFVyaVtdKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNhdXNlVHlwZSA9IDx0eXBlb2YgQ2F1c2U+Y2F1c2UuY29uc3RydWN0b3I7XG5cdFx0XHRjb25zdCBhdHRhY2htZW50c0FsbCA9IHRoaXMuY2F1c2VzLmdldChjYXVzZVR5cGUpIHx8IFtdO1xuXHRcdFx0Y29uc3QgYXR0YWNobWVudHMgPSBhdHRhY2htZW50c0FsbC5maWx0ZXIoYXR0YWNobWVudCA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZmlsdGVycy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBvdGhlclVyaSA9IGF0dGFjaG1lbnQudXJpO1xuXHRcdFx0XHRpZiAob3RoZXJVcmkgPT09IG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZmlsdGVycy5maW5kKHVyaSA9PiB1cmkuZXF1YWxzKG90aGVyVXJpKSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGF0dGFjaG1lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByZXN1bHQ6IHsgZnJvbTogVXJpIHwgbnVsbDsgcmV0dXJuZWQ6IFIgfVtdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmV0dXJuZWQ6IFIgPSBhdHRhY2htZW50LmNhbGxiYWNrKGNhdXNlKTtcblx0XHRcdFx0aWYgKHJldHVybmVkICE9PSBudWxsICYmIHJldHVybmVkICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goeyBmcm9tOiBhdHRhY2htZW50LnVyaSwgcmV0dXJuZWQgfSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGNhdXNlcyA9IG5ldyBNdWx0aU1hcDx0eXBlb2YgQ2F1c2UsIENhdXNlQXR0YWNobWVudD4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBdWdtZW50cyB0aGUgZ2xvYmFsIHNjb3BlIG9mIHRoZSBhZ2VudHMgYXR0YWNoZWQgdG8gdGhpc1xuXHRcdCAqIHByb2dyYW0gd2l0aCBhIHZhcmlhYmxlIHdob3NlIG5hbWUgYW5kIHZhbHVlIGFyZSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kLiAoTm90ZSB0aGF0IHRoaXMgb25seSBhZmZlY3RzXG5cdFx0ICogYWdlbnRzIHRoYXQgYXJlIGF0dGFjaGVkICphZnRlciogdGhpcyBjYWxsIGhhcyBiZWVuIG1hZGUuKVxuXHRcdCAqL1xuXHRcdGF1Z21lbnQobmFtZTogc3RyaW5nLCB2YWx1ZTogb2JqZWN0KVxuXHRcdHtcblx0XHRcdHRoaXMuYWdlbnRDYWNoZS5hdWdtZW50KG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0YXR0YWNoKGFnZW50VXJpOiBVcmkpOiBQcm9taXNlPEVycm9yIHwgdm9pZD5cblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0ZGV0YWNoKGFnZW50VXJpOiBVcmkpXG5cdFx0e1xuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhlIHByb2dyYW0gZm9yIHRoZSByb290LWxldmVsIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluXG5cdFx0ICogdGhlIHNwZWNpZmllZCBkb2N1bWVudC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHF1ZXJ5LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRvcC1sZXZlbCB0eXBlcyB0aGF0IGFyZVxuXHRcdCAqIGRlZmluZWQgd2l0aGluIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cXVlcnkoZG9jdW1lbnQ6IERvY3VtZW50KTogVHlwZVtdO1xuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhlIHByb2dyYW0gZm9yIHRoZSB0eXBlcyB0aGF0IGV4aXN0IHdpdGhpblxuXHRcdCAqIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQsIGF0IHRoZSBzcGVjaWZpZWQgdHlwZSBwYXRoLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcXVlcnkuXG5cdFx0ICogQHBhcmFtIHR5cGVQYXRoIFRoZSB0eXBlIHBhdGggd2l0aGluIHRoZSBkb2N1bWVudCB0byBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBmdWxseSBjb25zdHJ1Y3RlZCBUeXBlIGluc3RhbmNlIHRoYXQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiB0aGUgdHlwZSBhdCB0aGUgVVJJIHNwZWNpZmllZCwgb3IgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIG5vIHR5cGVcblx0XHQgKiBjb3VsZCBiZSBmb3VuZC5cblx0XHQgKi9cblx0XHRxdWVyeShkb2N1bWVudDogRG9jdW1lbnQsIC4uLnR5cGVQYXRoOiBzdHJpbmdbXSk6IFR5cGUgfCBudWxsO1xuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhlIHByb2dyYW0gZm9yIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluIHRoaXMgcHJvZ3JhbSxcblx0XHQgKiBhdCB0aGUgc3BlY2lmaWVkIHR5cGUgVVJJLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB1cmkgVGhlIFVSSSBvZiB0aGUgZG9jdW1lbnQgdG8gcXVlcnkuIElmIHRoZSBVUkkgY29udGFpbnNcblx0XHQgKiBhIHR5cGUgcGF0aCwgaXQgaXMgZmFjdG9yZWQgaW50byB0aGUgc2VhcmNoLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRvcC1sZXZlbCB0eXBlcyB0aGF0IGFyZVxuXHRcdCAqIGRlZmluZWQgd2l0aGluIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuIElmIHRoZSBzcGVjaWZpZWQgVVJJIGhhcyBhXG5cdFx0ICogdHlwZSBwYXRoLCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb250YWluIGEgc2luZ2xlIFR5cGUgaW5zdGFuY2Vcblx0XHQgKiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBUeXBlIGZvdW5kLiBJbiB0aGUgY2FzZSB3aGVuIG5vIHR5cGVcblx0XHQgKiBjb3VsZCBiZSBmb3VuZCBhdCB0aGUgdHlwZSBwYXRoLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRxdWVyeSh1cmk6IFVyaSk6IFR5cGVbXTtcblx0XHQvKipcblx0XHQgKiBRdWVyaWVzIHRoZSBwcm9ncmFtIGZvciB0eXBlcyB0aGF0IGV4aXN0IHdpdGhpbiB0aGlzIHByb2dyYW0sXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBVUkkgYW5kIHR5cGUgcGF0aC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gdXJpIFRoZSBVUkkgb2YgdGhlIGRvY3VtZW50IHRvIHF1ZXJ5LiBJZiB0aGUgVVJJIGNvbnRhaW5zXG5cdFx0ICogYSB0eXBlIHBhdGgsIGl0IGlzIGZhY3RvcmVkIGludG8gdGhlIHNlYXJjaC5cblx0XHQgKiBAcGFyYW0gdHlwZVBhdGggVGhlIHR5cGUgcGF0aCB3aXRoaW4gdGhlIGRvY3VtZW50IHRvIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZ1bGx5IGNvbnN0cnVjdGVkIFR5cGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0b1xuXHRcdCAqIHRoZSB0eXBlIGF0IHRoZSBVUkkgc3BlY2lmaWVkLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gbm8gdHlwZVxuXHRcdCAqIGNvdWxkIGJlIGZvdW5kLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KHVyaTogVXJpLCAuLi50eXBlUGF0aDogc3RyaW5nW10pOiBUeXBlIHwgbnVsbDtcblx0XHQvKipcblx0XHQgKiBRdWVyaWVzIHRoZSBwcm9ncmFtIGZvciB0eXBlcyB0aGF0IGV4aXN0IHdpdGhpbiB0aGlzIGRvY3VtZW50LFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgVVJJLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB1cmkgVGhlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBVUkkgb2YgdGhlIGRvY3VtZW50XG5cdFx0ICogdG8gcXVlcnkuIElmIHRoZSBVUkkgY29udGFpbnMgYSB0eXBlIHBhdGgsIGl0IGlzIGZhY3RvcmVkIGludG8gdGhlIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSB0b3AtbGV2ZWwgdHlwZXMgdGhhdCBhcmVcblx0XHQgKiBkZWZpbmVkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LiBJZiB0aGUgc3BlY2lmaWVkIFVSSSBoYXMgYVxuXHRcdCAqIHR5cGUgcGF0aCwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29udGFpbiBhIHNpbmdsZSBUeXBlIGluc3RhbmNlXG5cdFx0ICogdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgVHlwZSBmb3VuZC4gSW4gdGhlIGNhc2Ugd2hlbiBubyB0eXBlXG5cdFx0ICogY291bGQgYmUgZm91bmQgYXQgdGhlIHR5cGUgcGF0aCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0cXVlcnkodXJpOiBzdHJpbmcpOiBUeXBlW107XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGUgcHJvZ3JhbSBmb3IgdHlwZXMgdGhhdCBleGlzdCB3aXRoaW4gdGhpcyBwcm9ncmFtLFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgVVJJIGFuZCB0eXBlIHBhdGguXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHVyaSBUaGUgVVJJIG9mIHRoZSBkb2N1bWVudCB0byBxdWVyeS4gSWYgdGhlIFVSSSBjb250YWluc1xuXHRcdCAqIGEgdHlwZSBwYXRoLCBpdCBpcyBmYWN0b3JlZCBpbnRvIHRoZSBzZWFyY2guXG5cdFx0ICogQHBhcmFtIHR5cGVQYXRoIFRoZSB0eXBlIHBhdGggd2l0aGluIHRoZSBkb2N1bWVudCB0byBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBmdWxseSBjb25zdHJ1Y3RlZCBUeXBlIGluc3RhbmNlIHRoYXQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiB0aGUgdHlwZSBhdCB0aGUgVVJJIHNwZWNpZmllZCwgb3IgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIG5vIHR5cGVcblx0XHQgKiBjb3VsZCBiZSBmb3VuZC5cblx0XHQgKi9cblx0XHRxdWVyeSh1cmk6IHN0cmluZywgLi4udHlwZVBhdGg6IHN0cmluZ1tdKTogVHlwZSB8IG51bGw7XG5cdFx0cXVlcnkocm9vdDogRG9jdW1lbnQgfCBVcmkgfCBzdHJpbmcsIC4uLnR5cGVQYXRoOiBzdHJpbmdbXSk6IFxuXHRcdFx0cmVhZG9ubHkgVHlwZVtdIHwgVHlwZSB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZVBhdGgubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ucGFzc2VkQXJyYXlDYW5ub3RCZUVtcHR5KFwidHlwZVBhdGhcIik7XG5cdFx0XHRcblx0XHRcdGlmIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnQpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0eXBlUGF0aC5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIFR5cGUuY29uc3RydWN0Um9vdHMocm9vdCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCB1cmkgPSByb290LnNvdXJjZVVyaS5leHRlbmRUeXBlKHR5cGVQYXRoKTtcblx0XHRcdFx0cmV0dXJuIFR5cGUuY29uc3RydWN0KHVyaSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRvY1VyaSA9IFVyaS5tYXliZVBhcnNlKHJvb3QpO1xuXHRcdFx0aWYgKGRvY1VyaSA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmFic29sdXRlVXJpRXhwZWN0ZWQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZG9jID0gdGhpcy5kb2N1bWVudHMuZ2V0KHJvb3QpO1xuXHRcdFx0aWYgKCFkb2MpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB0eXBlcyA9IGRvY1VyaS50eXBlcy5tYXAodCA9PiB0LnRvU3RyaW5nKCkpLmNvbmNhdCh0eXBlUGF0aCk7XG5cdFx0XHRpZiAodHlwZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gVHlwZS5jb25zdHJ1Y3RSb290cyhkb2MpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBmdWxsVXJpID0gZG9jVXJpLmV4dGVuZFR5cGUodHlwZVBhdGgpO1xuXHRcdFx0Y29uc3QgY29uc3RydWN0ZWQgPSBUeXBlLmNvbnN0cnVjdChmdWxsVXJpLCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVQYXRoLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIGNvbnN0cnVjdGVkID9cblx0XHRcdFx0XHRPYmplY3QuZnJlZXplKFtjb25zdHJ1Y3RlZF0pIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNvbnN0cnVjdGVkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBCZWdpbiBpbnNwZWN0aW5nIGEgZG9jdW1lbnQgbG9hZGVkXG5cdFx0ICogaW50byB0aGlzIHByb2dyYW0sIGEgc3BlY2lmaWMgbG9jYXRpb24uXG5cdFx0ICovXG5cdFx0aW5zcGVjdChcblx0XHRcdGRvY3VtZW50OiBEb2N1bWVudCxcblx0XHRcdGxpbmU6IG51bWJlcixcblx0XHRcdG9mZnNldDogbnVtYmVyKTogUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHRcblx0XHR7XG5cdFx0XHRjb25zdCBzdGF0ZW1lbnQgPSBkb2N1bWVudC5yZWFkKGxpbmUpO1xuXHRcdFx0Y29uc3QgcmVnaW9uID0gc3RhdGVtZW50LmdldFJlZ2lvbihvZmZzZXQpO1xuXHRcdFx0XG5cdFx0XHRzd2l0Y2ggKHJlZ2lvbilcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSBTdGF0ZW1lbnRSZWdpb24udm9pZDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KG51bGwsIHN0YXRlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSB0eXBlcyBpbiB0aGUgZGVjbGFyYXRpb24gc2lkZSBvZiB0aGUgcGFyZW50LlxuXHRcdFx0XHRjYXNlIFN0YXRlbWVudFJlZ2lvbi53aGl0ZXNwYWNlOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0UGFyZW50RnJvbVBvc2l0aW9uKGxpbmUsIG9mZnNldCk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdChwYXJlbnQsIHN0YXRlbWVudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgdHlwZXMgPSBwYXJlbnQuZGVjbGFyYXRpb25zXG5cdFx0XHRcdFx0XHQubWFwKGRlY2wgPT4gZGVjbC5mYWN0b3IoKSlcblx0XHRcdFx0XHRcdC5yZWR1Y2UoKHNwaW5lcywgcykgPT4gc3BpbmVzLmNvbmNhdChzKSwgW10pXG5cdFx0XHRcdFx0XHQubWFwKHNwaW5lID0+IFR5cGUuY29uc3RydWN0KHNwaW5lLCB0aGlzKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdCh0eXBlcywgc3RhdGVtZW50LCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL1xuXHRcdFx0XHRjYXNlIFN0YXRlbWVudFJlZ2lvbi5wYXR0ZXJuOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gVE9ETzogVGhpcyBzaG91bGQgbm90IGJlIHJldHVybmluZyBhIFBhdHRlcm5MaXRlcmFsLFxuXHRcdFx0XHRcdC8vIGJ1dCByYXRoZXIgYSBmdWxseSBjb25zdHJ1Y3RlZCBJUGF0dGVybiBvYmplY3QuIFRoaXNcblx0XHRcdFx0XHQvLyBjb2RlIGlzIG9ubHkgaGVyZSBhcyBhIHNoaW0uXG5cdFx0XHRcdFx0Y29uc3QgcGF0dGVyblR5cGVzOiBUeXBlW10gPSBbXTtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KHBhdHRlcm5UeXBlcywgc3RhdGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSB0eXBlcyByZWxhdGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjbGFyYXRpb24uXG5cdFx0XHRcdGNhc2UgU3RhdGVtZW50UmVnaW9uLmRlY2xhcmF0aW9uOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZGVjbCA9IHN0YXRlbWVudC5nZXREZWNsYXJhdGlvbihvZmZzZXQpO1xuXHRcdFx0XHRcdGlmICghZGVjbClcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0eXBlcyA9IGRlY2xcblx0XHRcdFx0XHRcdC5mYWN0b3IoKVxuXHRcdFx0XHRcdFx0Lm1hcChzcGluZSA9PiBUeXBlLmNvbnN0cnVjdChzcGluZSwgdGhpcykpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQodHlwZXMsIHN0YXRlbWVudCwgZGVjbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gXG5cdFx0XHRcdGNhc2UgU3RhdGVtZW50UmVnaW9uLmFubm90YXRpb246XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBhbm5vID0gc3RhdGVtZW50LmdldEFubm90YXRpb24ob2Zmc2V0KTtcblx0XHRcdFx0XHRpZiAoIWFubm8pXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3BpbmUgPSBzdGF0ZW1lbnQuZGVjbGFyYXRpb25zWzBdLmZhY3RvcigpWzBdO1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBUeXBlLmNvbnN0cnVjdChzcGluZSwgdGhpcyk7XG5cdFx0XHRcdFx0Y29uc3QgYW5ub1RleHQgPSBhbm5vLmJvdW5kYXJ5LnN1YmplY3QudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRjb25zdCBiYXNlID0gdHlwZS5iYXNlcy5maW5kKGIgPT4gYi5uYW1lID09PSBhbm5vVGV4dCk7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZXMgPSBiYXNlID8gW2Jhc2VdIDogbnVsbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KGJhc2VzLCBzdGF0ZW1lbnQsIGFubm8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQobnVsbCwgc3RhdGVtZW50LCBudWxsKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgYSBmdWxsIHZlcmlmaWNhdGlvbiBvZiBhbGwgZG9jdW1lbnRzIGxvYWRlZCBpbnRvIHRoZSBwcm9ncmFtLlxuXHRcdCAqIFRoaXMgUHJvZ3JhbSdzIC5mYXVsdHMgZmllbGQgaXMgcG9wdWxhdGVkIHdpdGggYW55IGZhdWx0cyBnZW5lcmF0ZWQgYXNcblx0XHQgKiBhIHJlc3VsdCBvZiB0aGUgdmVyaWZpY2F0aW9uLiBJZiBubyBkb2N1bWVudHMgbG9hZGVkIGludG8gdGhpcyBwcm9ncmFtXG5cdFx0ICogaGFzIGJlZW4gZWRpdGVkIHNpbmNlIHRoZSBsYXN0IHZlcmlmaWNhdGlvbiwgdmVyaWZpY2F0aW9uIGlzIG5vdCByZS1hdHRlbXB0ZWQuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQW4gZW50cnlwb2ludCBpbnRvIHBlcmZvcm1pbmcgYW5hbHlzaXMgb2YgdGhlIFR5cGVzIHRoYXRcblx0XHQgKiBoYXZlIGJlZW4gZGVmaW5lZCBpbiB0aGlzIHByb2dyYW0uXG5cdFx0ICovXG5cdFx0dmVyaWZ5KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGRvYyBvZiB0aGlzLmRvY3VtZW50cy5lYWNoKCkpXG5cdFx0XHRcdGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBkb2MuZWFjaERlc2NlbmRhbnQoKSlcblx0XHRcdFx0XHR0aGlzLnZlcmlmeUFzc29jaWF0ZWREZWNsYXJhdGlvbnMoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZmluYWxpemVWZXJpZmljYXRpb24oKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgdmVyaWZpY2F0aW9uIG9uIHRoZSBwYXJ0cyBvZiB0aGUgZG9jdW1lbnQgdGhhdCBoYXZlXG5cdFx0ICogbm90IGJlZW4gdmVyaWZpZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIG1ldGhvZC4gT25jZSB0aGlzXG5cdFx0ICogbWV0aG9kIGhhcyBjb21wbGV0ZWQsIGFueSBkZXRlY3RlZCBmYXVsdHMgd2lsbCBiZSBhdmFpbGFibGVcblx0XHQgKiBieSB1c2luZyB0aGUgbWV0aG9kcyBsb2NhdGVkIGluIHRoZSBgLmZhdWx0c2AgcHJvcGVydHkgb2YgdGhpc1xuXHRcdCAqIGluc3RhbmNlLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHZlcmlmaWNhdGlvblxuXHRcdCAqIGNvbXBsZXRlZCB3aXRob3V0IGRldGVjdGluZyBhbnkgZmF1bHRzIGluIHRoaXMgUHJvZ3JhbS5cblx0XHQgKi9cblx0XHRyZXZlcmlmeSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBkb2Mgb2YgdGhpcy51bnZlcmlmaWVkRG9jdW1lbnRzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHsgc3RhdGVtZW50IH0gb2YgZG9jLmVhY2hEZXNjZW5kYW50KCkpXG5cdFx0XHRcdFx0dGhpcy52ZXJpZnlBc3NvY2lhdGVkRGVjbGFyYXRpb25zKHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc210IG9mIHRoaXMudW52ZXJpZmllZFN0YXRlbWVudHMpXG5cdFx0XHRcdHRoaXMudmVyaWZ5QXNzb2NpYXRlZERlY2xhcmF0aW9ucyhzbXQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5hbGl6ZVZlcmlmaWNhdGlvbigpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHZlcmlmeUFzc29jaWF0ZWREZWNsYXJhdGlvbnMoc3RhdGVtZW50OiBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0aWYgKCFzdGF0ZW1lbnQuaXNEaXNwb3NlZClcblx0XHRcdFx0Zm9yIChjb25zdCBkZWNsIG9mIHN0YXRlbWVudC5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdFx0ZGVjbC5mYWN0b3IoKS5tYXAoc3BpbmUgPT4gXG5cdFx0XHRcdFx0XHRUeXBlLmNvbnN0cnVjdChzcGluZSwgdGhpcykpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGZpbmFsaXplVmVyaWZpY2F0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLmZhdWx0cy5yZWZyZXNoKCk7XG5cdFx0XHR0aGlzLnVudmVyaWZpZWREb2N1bWVudHMubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMudW52ZXJpZmllZFN0YXRlbWVudHMubGVuZ3RoID0gMDtcblx0XHRcdHJldHVybiB0aGlzLmZhdWx0cy5jb3VudCA9PT0gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1bnZlcmlmaWVkU3RhdGVtZW50czogU3RhdGVtZW50W10gPSBbXTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHVudmVyaWZpZWREb2N1bWVudHM6IERvY3VtZW50W10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFnZW50IHRoYXQgaG9sZHMgdGhlIHJlZmVyZW5jZVxuXHRcdCAqIHRvIHRoaXMgUHJvZ3JhbSBpbnN0YW5jZS4gVGhlIHByb3BlcnR5IGlzIHVuZGVmaW5lZCBpbiB0aGVcblx0XHQgKiBjYXNlIHdoZW4gdGhlIGluc3RhbmNlIGlzIG5vdCBoZWxkIGJ5IGFuIGFnZW50LlxuXHRcdCAqIFxuXHRcdCAqIFRoaXMgdmFsdWUgaXMgYXBwbGllZCB0aHJvdWdoIHRoZSBNaXNjLnBhdGNoKCkgZnVuY3Rpb24sIHdoaWNoXG5cdFx0ICogdXNlcyBhIFByb3h5IG9iamVjdCB0byBwcm92aWRlIFxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGluc3RhbmNlSG9sZGVyPzoge1xuXHRcdFx0dXJpOiBVcmk7XG5cdFx0XHRzY29wZTogQXR0YWNobWVudFNjb3BlO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCB0aGF0IGhvbGRzIFxuXHQgKiB0aGUgc3BlY2lmaWVkIFByb2dyYW0gaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRIb2xkZXJJbmZvKHByb2dyYW06IFByb2dyYW0pXG5cdHtcblx0XHRjb25zdCBpaCA9IHByb2dyYW0uaW5zdGFuY2VIb2xkZXI7XG5cdFx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdHVyaTogPFVyaSB8IG51bGw+KGloID8gaWgudXJpIDogbnVsbCksXG5cdFx0XHRzY29wZTogPEF0dGFjaG1lbnRTY29wZT4oaWggPyBpaC5zY29wZSA6IHByb2dyYW0pXG5cdFx0fTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGF0dGFjaG1lbnRcblx0ICogb2YgYSBjYXVzZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGNsYXNzIENhdXNlQXR0YWNobWVudFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSB1cmk6IFVyaSB8IG51bGwsXG5cdFx0XHRyZWFkb25seSBjYWxsYmFjazogKGRhdGE6IGFueSkgPT4gYW55LFxuXHRcdFx0cmVhZG9ubHkgc2NvcGU6IEF0dGFjaG1lbnRTY29wZSlcblx0XHR7IH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIERlc2NyaWJlcyBhIHBsYWNlIGluIHRoZSBwcm9ncmFtIHdoZXJlIGEgQ2F1c2UgaXMgYXR0YWNoZWQuXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBBdHRhY2htZW50U2NvcGUgPSBQcm9ncmFtIHwgRG9jdW1lbnQgfCBUeXBlO1xuXG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgZGV0YWlscyBhYm91dCBhIHByZWNpc2UgbG9jYXRpb24gaW4gYSBEb2N1bWVudC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdFxuXHR7XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIGNvbXBpbGF0aW9uIG9iamVjdCB0aGF0IG1vc3QgY2xvc2VseSByZXByZXNlbnRzXG5cdFx0XHQgKiB3aGF0IHdhcyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLiBTdG9yZXMgbnVsbCBpbiB0aGVcblx0XHRcdCAqIGNhc2Ugd2hlbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIGNvbnRhaW5zIGFuIG9iamVjdCB0aGF0XG5cdFx0XHQgKiBoYXMgYmVlbiBtYXJrZWQgYXMgY3J1ZnQgKHRoZSBzdGF0ZW1lbnQgYW5kIHNwYW4gZmllbGRzXG5cdFx0XHQgKiBhcmUgc3RpbGwgcG9wdWxhdGVkIGluIHRoaXMgY2FzZSkuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGZvdW5kT2JqZWN0OiBEb2N1bWVudCB8IFR5cGVbXSB8IG51bGwsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBTdGF0ZW1lbnQgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgc3RhdGVtZW50OiBTdGF0ZW1lbnQsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBTcGFuIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24sIG9yXG5cdFx0XHQgKiBudWxsIGluIHRoZSBjYXNlIHdoZW4gbm8gU3BhbiB3YXMgZm91bmQsIHN1Y2ggYXMgaWZcblx0XHRcdCAqIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gaXMgd2hpdGVzcGFjZSBvciBhIGNvbW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHNwYW46IFNwYW4gfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShmb3VuZE9iamVjdCkgJiYgZm91bmRPYmplY3QubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aGlzLmZvdW5kT2JqZWN0ID0gbnVsbDtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBjYWNoZSB0aGF0IHN0b3JlcyBhZ2VudCBidWlsZCBmdW5jdGlvbiBsb2FkZWQgYnkgYSBzaW5nbGUgcHJvZ3JhbSBpbnN0YW5jZS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBBZ2VudENhY2hlXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVVyaVJlZmVyZW5jZUFkZCwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZGF0YS51cmkuZXh0ID09PSBVcmlFeHRlbnNpb24uanMpXG5cdFx0XHRcdFx0dGhpcy5hdHRhY2hBZ2VudChkYXRhLnVyaSwgZGF0YS5zdGF0ZW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VVcmlSZWZlcmVuY2VSZW1vdmUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGRhdGEudXJpLmV4dCA9PT0gVXJpRXh0ZW5zaW9uLmpzKVxuXHRcdFx0XHRcdHRoaXMuZGV0YWNoQWdlbnQoZGF0YS51cmksIGRhdGEuc3RhdGVtZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGFzeW5jIGF0dGFjaEFnZW50KHVyaTogVXJpLCBzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHVyaS50b1N0b3JlU3RyaW5nKCk7XG5cdFx0XHRjb25zdCBleGlzdGluZ0NhY2hlU2V0ID0gdGhpcy5jYWNoZS5nZXQodXJpVGV4dCk7XG5cdFx0XHRjb25zdCByZWZlcmVuY2UgPSBzdGF0ZW1lbnQgfHwgdGhpcy5wcm9ncmFtO1xuXHRcdFx0XG5cdFx0XHRpZiAoZXhpc3RpbmdDYWNoZVNldClcblx0XHRcdHtcblx0XHRcdFx0ZXhpc3RpbmdDYWNoZVNldC5hZGQocmVmZXJlbmNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBzY29wZSA9IHN0YXRlbWVudCBpbnN0YW5jZW9mIFN0YXRlbWVudCA/XG5cdFx0XHRcdHN0YXRlbWVudC5kb2N1bWVudCA6XG5cdFx0XHRcdHRoaXMucHJvZ3JhbTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlUmF3ID0gYXdhaXQgVXJpUmVhZGVyLnRyeVJlYWQodXJpKTtcblx0XHRcdGlmIChzb3VyY2VSYXcgaW5zdGFuY2VvZiBFcnJvcilcblx0XHRcdFx0cmV0dXJuIHNvdXJjZVJhdztcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlID0gdGhpcy5tYXliZUFkanVzdFNvdXJjZU1hcCh1cmksIHNvdXJjZVJhdyk7XG5cdFx0XHRjb25zdCBwYXRjaGVkUHJvZ3JhbSA9IE1pc2MucGF0Y2godGhpcy5wcm9ncmFtLCB7XG5cdFx0XHRcdGluc3RhbmNlSG9sZGVyOiB7IHVyaSwgc2NvcGUgfVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhcmFtcyA9IFtcblx0XHRcdFx0XCJwcm9ncmFtXCIsXG5cdFx0XHRcdFwiVHJ1dGhcIixcblx0XHRcdFx0XCJyZXF1aXJlXCIsXG5cdFx0XHRcdC4uLnRoaXMuYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMua2V5cygpLFxuXHRcdFx0XHRzb3VyY2Vcblx0XHRcdF07XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFyZ3MgPSBbXG5cdFx0XHRcdHBhdGNoZWRQcm9ncmFtLFxuXHRcdFx0XHRUcnV0aCxcblx0XHRcdFx0QWdlbnRDYWNoZS5oaWphY2tlZFJlcXVpcmVGbixcblx0XHRcdFx0Li4udGhpcy5hZ2VudEZ1bmN0aW9uUGFyYW1ldGVycy52YWx1ZXMoKVxuXHRcdFx0XTtcblx0XHRcdFxuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGZuID0gT2JqZWN0LmZyZWV6ZShGdW5jdGlvbi5hcHBseShGdW5jdGlvbiwgcGFyYW1zKSk7XG5cdFx0XHRcdGF3YWl0IGZuLmFwcGx5KGZuLCA8YW55PmFyZ3MpO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMucmVwb3J0VXNlckxhbmRFcnJvcihlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlQWdlbnRBdHRhY2godXJpLCBzY29wZSkpO1xuXHRcdFx0Y29uc3Qgc2V0ID0gbmV3IFNldDxTdGF0ZW1lbnQgfCBQcm9ncmFtPihbcmVmZXJlbmNlXSk7XG5cdFx0XHR0aGlzLmNhY2hlLnNldCh1cmlUZXh0LCBzZXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGRldGFjaEFnZW50KHVyaTogVXJpLCBzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHVyaS50b1N0b3JlU3RyaW5nKCk7XG5cdFx0XHRjb25zdCBleGlzdGluZ0NhY2hlU2V0ID0gdGhpcy5jYWNoZS5nZXQodXJpVGV4dCk7XG5cdFx0XHRpZiAoIWV4aXN0aW5nQ2FjaGVTZXQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0ZXhpc3RpbmdDYWNoZVNldC5kZWxldGUoc3RhdGVtZW50IHx8IHRoaXMucHJvZ3JhbSk7XG5cdFx0XHRpZiAoZXhpc3RpbmdDYWNoZVNldC5zaXplID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmNhY2hlLmRlbGV0ZSh1cmlUZXh0KTtcblx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZUFnZW50RGV0YWNoKHVyaSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiAoQ2FsbGVkIGJ5IFByb2dyYW0pXG5cdFx0ICovXG5cdFx0YXVnbWVudChuYW1lOiBzdHJpbmcsIHZhbHVlOiBvYmplY3QpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMuaGFzKG5hbWUpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uY2F1c2VQYXJhbWV0ZXJOYW1lSW5Vc2UobmFtZSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMuc2V0KFxuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHR2YWx1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgYWdlbnRGdW5jdGlvblBhcmFtZXRlcnMgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkanVzdHMgdGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZW1hcCBpbiB0aGUgc3BlY2lmaWVkIHNvdXJjZSBjb2RlIFxuXHRcdCAqIGZpbGUsIHRvIGFjY291bnQgZm9yIHRoZSBkaXNjcmVwZW5jaWVzIGludHJvZHVjZWQgYnkgd3JhcHBpbmcgSmF2YVNjcmlwdFxuXHRcdCAqIHNvdXJjZSBjb2RlIGluIGEgbmV3IEZ1bmN0aW9uKCkgY29uc3RydWN0b3IuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBtYXliZUFkanVzdFNvdXJjZU1hcChzb3VyY2VVcmk6IFVyaSwgc291cmNlQ29kZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdC8vIFdlIGNhbid0IGRvIGFueSBvZiB0aGlzIHNvdXJjZSBtYXAgbXV0YXRpb24gd2l0aG91dCBOb2RlLkpTXG5cdFx0XHQvLyBhY2Nlc3MgcmlnaHQgbm93LiBNYXliZSB0aGlzIHdpbGwgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cdFx0XHRpZiAodHlwZW9mIHJlcXVpcmUgIT09IFwiZnVuY3Rpb25cIilcblx0XHRcdFx0cmV0dXJuIHNvdXJjZUNvZGU7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGxhc3RMaW5lU3RhcnQgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IHNvdXJjZUNvZGUubGVuZ3RoOyBpLS0gPiAxOylcblx0XHRcdFx0XHRpZiAoc291cmNlQ29kZVtpIC0gMV0gPT09IFwiXFxuXCIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGlmIChsYXN0TGluZVN0YXJ0IDwgMClcblx0XHRcdFx0cmV0dXJuIHNvdXJjZUNvZGU7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNvdXJjZU1hcFVybCA9IFtcIi8vXCIsIFwiI1wiLCBcIiBzb3VyY2VcIiwgXCJNYXBwaW5nVVJMPVwiXS5qb2luKFwiXCIpO1xuXHRcdFx0aWYgKHNvdXJjZUNvZGUuc3Vic3RyKGxhc3RMaW5lU3RhcnQsIHNvdXJjZU1hcFVybC5sZW5ndGgpICE9PSBzb3VyY2VNYXBVcmwpXG5cdFx0XHRcdHJldHVybiBzb3VyY2VDb2RlO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdGFydFBvcyA9IGxhc3RMaW5lU3RhcnQgKyBzb3VyY2VNYXBVcmwubGVuZ3RoO1xuXHRcdFx0Y29uc3QgZW5kaW5nID0gXCI7YmFzZTY0LFwiO1xuXHRcdFx0Y29uc3QgZW5kUG9zID0gc291cmNlQ29kZS5pbmRleE9mKGVuZGluZywgc3RhcnRQb3MpICsgZW5kaW5nLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0Ly8gVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBmb3JtYXQuXG5cdFx0XHRpZiAoZW5kUG9zIDwgZW5kaW5nLmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIHNvdXJjZUNvZGU7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNvdXJjZU1hcFJhdyA9IHRoaXMuZnJvbUJhc2U2NChzb3VyY2VDb2RlLnNsaWNlKGVuZFBvcykpO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGVyZSdzIHByb2JhYmx5IHNvbWUgZXJyb3IgaW4gdGhlIHNvdXJjZSBtYXBcblx0XHRcdGlmICghc291cmNlTWFwUmF3KVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIHNvdXJjZSBtYXAgaXNuJ3QgcGFyc2luZyBhcyBhIEpTT04gb2JqZWN0IC4uLiBwcm9iYWJseSBicm9rZW4gc29tZWhvd1xuXHRcdFx0Y29uc3Qgc291cmNlTWFwOiBJU291cmNlTWFwID0gTWlzYy50cnlQYXJzZUpzb24oc291cmNlTWFwUmF3KTtcblx0XHRcdGlmICghc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Ly8gVW5zdXBwb3J0ZWQgc291cmNlIG1hcCB2ZXJzaW9uXG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZU1hcC5tYXBwaW5ncyAhPT0gXCJzdHJpbmdcIilcblx0XHRcdFx0cmV0dXJuIHNvdXJjZUNvZGU7XG5cdFx0XHRcblx0XHRcdC8vIFBsYWNpbmcgYSA7IGluIHRoZSBcIm1hcHBpbmdzXCIgcHJvcGVydHkgb2YgdGhlIHNvdXJjZSBtYXAgb2JqZWN0XG5cdFx0XHQvLyBzaGlmdHMgdGhlIGxpbmVzIGRvd24gYnkgMS4gSXQgbmVlZHMgdG8gYmUgKyAxLCBiZWNhdXNlIHdlIHdyYXBcblx0XHRcdC8vIHRoZSBjb2RlIGluIG91ciBvd24gc2V0VGltZW91dCgpIGJsb2NrLlxuXHRcdFx0Y29uc3QgcHJlZml4ID0gXCI7XCIucmVwZWF0KHRoaXMuc291cmNlTWFwTGluZU9mZnNldCArIDEpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXRoTW9kdWxlID0gPHR5cGVvZiBpbXBvcnQoXCJwYXRoXCIpPnJlcXVpcmUoXCJwYXRoXCIpO1xuXHRcdFx0Y29uc3QgYmFzZVBhdGggPSBzb3VyY2VVcmkudG9TdG9yZVN0cmluZyh0cnVlKTtcblx0XHRcdHNvdXJjZU1hcC5tYXBwaW5ncyA9IHByZWZpeCArIHNvdXJjZU1hcC5tYXBwaW5ncztcblx0XHRcdFxuXHRcdFx0aWYgKHNvdXJjZU1hcC5zb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRcdHNvdXJjZU1hcC5zb3VyY2VzID0gc291cmNlTWFwLnNvdXJjZXMubWFwKHMgPT4gXG5cdFx0XHRcdFx0cGF0aE1vZHVsZS5qb2luKGJhc2VQYXRoLCBzKSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG5ld1NvdXJjZU1hcCA9IHRoaXMudG9CYXNlNjQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSk7XG5cdFx0XHRjb25zdCBuZXdTb3VyY2VDb2RlID0gc291cmNlQ29kZS5zbGljZSgwLCBsYXN0TGluZVN0YXJ0KTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIHNvdXJjZSBjb2RlIGlzIHdyYXBwZWQgaW4gYSBzZXRUaW1lb3V0IGluIG9yZGVyXG5cdFx0XHQvLyB0byBnaXZlIGFueSBhdHRhY2hlZCBkZWJ1Z2dlcnMgYSBjaGFuY2UgdG8gY29ubmVjdC5cblx0XHRcdGNvbnN0IHZhck5hbWUgPSBcIiQkX19SRVNPTFZFX0ZVTkNUSU9OX18kJFwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBuZXdTb3VyY2VDb2RlRGVsYXllZCA9IFxuXHRcdFx0XHRgcmV0dXJuIG5ldyBQcm9taXNlKCR7dmFyTmFtZX0gPT4gc2V0VGltZW91dCgoKSA9PiB7XFxuYCArIFxuXHRcdFx0XHRuZXdTb3VyY2VDb2RlICsgXG5cdFx0XHRcdGA7ICR7dmFyTmFtZX0oKTsgfSwgMSkpXFxuYDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbmV3UHJlZml4ID0gc291cmNlQ29kZS5zbGljZShsYXN0TGluZVN0YXJ0LCBlbmRQb3MpO1xuXHRcdFx0cmV0dXJuIG5ld1NvdXJjZUNvZGVEZWxheWVkICsgbmV3UHJlZml4ICsgbmV3U291cmNlTWFwO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlcG9ydFVzZXJMYW5kRXJyb3IoZTogRXJyb3IpXG5cdFx0e1xuXHRcdFx0Ly8gTk9URTogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgcmVwb3J0aW5nIHRoZSBlcnJvclxuXHRcdFx0Ly8gc29tZXdoZXJlIHdoZXJlIGl0J3MgdmlzaWJsZS5cblx0XHRcdGRlYnVnZ2VyO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSB0b0Jhc2U2NChwbGFpbjogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdFx0YnRvYShwbGFpbikgOlxuXHRcdFx0XHRCdWZmZXIuZnJvbShwbGFpbiwgXCJhc2NpaVwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBmcm9tQmFzZTY0KGVuY29kZWQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGF0b2IgPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRcdGF0b2IoZW5jb2RlZCkgOlxuXHRcdFx0XHRCdWZmZXIuZnJvbShlbmNvZGVkLCBcImJhc2U2NFwiKS50b1N0cmluZyhcImFzY2lpXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgcmVxdWlyZSgpIGZ1bmN0aW9uIGlzIG5vdCBhdmFpbGFibGUgd2l0aGluIHRoZSBjb250ZXh0IG9mIGFuXG5cdFx0ICogYWdlbnQgZm9yIG51bWVyb3VzIChhbmQgbm9uLW9idmlvdXMpIHJlYXNvbnMuIFRoaXMgZnVuY3Rpb25cblx0XHQgKiBpcyBmZWQgaW50byBhbGwgYWdlbnQgZnVuY3Rpb25zIHRvIHByZXZlbnQgYW55IG90aGVyd2lzZSBhdmFpbGFibGVcblx0XHQgKiByZXF1aXJlKCkgZnVuY3Rpb24gZnJvbSBiZWluZyBhY2Nlc3NlZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBoaWphY2tlZFJlcXVpcmVGbiA9IE9iamVjdC5mcmVlemUoKHNwZWNpZmllcjogc3RyaW5nKSA9PlxuXHRcdHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJUaGUgcmVxdWlyZSgpIGZ1bmN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBjb250ZXh0LiBcIiArXG5cdFx0XHRcdFwiTXVsdGktZmlsZSBhZ2VudHMgc2hvdWxkIGJlIGJ1bmRsZWQgd2l0aCBhIGJ1bmRsZXIgXCIgKyBcblx0XHRcdFx0XCJzdWNoIGFzIFJvbGx1cEpTLlwiKTtcblx0XHR9KTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIG51bWJlciBvZiBsaW5lcyB0aGF0IGFyZSBpbnRyb2R1Y2VkIGJ5IHRoZSBzY3JpcHRcblx0XHQgKiBlbmdpbmUgd2hlbiBhIGNvZGUgYmxvY2sgaXMgd3JhcHBlZCBpbiBhIG5ldyBGdW5jdGlvbigpXG5cdFx0ICogYmxvY2ssIHdoaWNoIGlzIHRoZW4gdG9TdHJpbmcoKSdkLiBUaGlzIGlzIHVzZWQgaW4gb3JkZXIgdG8gY2FsY3VsYXRlXG5cdFx0ICogc291cmNlIG1hcCBsaW5lIG9mZnNldHMgKHdoaWNoIHZhcmllcyBieSBlbmdpbmUpLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgc291cmNlTWFwTGluZU9mZnNldCA9ICgoKSA9PlxuXHRcdHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuXHRcdFx0Y29uc3QgdGVzdEZuID0gbmV3IEZ1bmN0aW9uKFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiO1wiKTtcblx0XHRcdGNvbnN0IGxpbmVDb3VudCA9IHRlc3RGbi50b1N0cmluZygpLnNwbGl0KFwiXFxuXCIpLmxlbmd0aDtcblx0XHRcdHJldHVybiBsaW5lQ291bnQgLSAyOyBcblx0XHR9KSgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCB3aG9zZSBrZXlzIGFyZSBhZ2VudCBVUklzLCBhbmQgd2hvc2UgdmFsdWVzXG5cdFx0ICogYXJlIGEgc2V0IG9mIFN0YXRlbWVudCBpbnN0YW5jZXMgdGhhdCByZWZlcmVuY2UgdGhlIGFnZW50LFxuXHRcdCAqIG9yLCBpbiB0aGUgY2FzZSB3aGVuIHRoZSBhZ2VudCBpcyBhZGRlZCB0byB0aGUgcHJvZ3JhbVxuXHRcdCAqIHRocm91Z2ggYW5vdGhlciBtZWFucyAoc3VjaCBhcyBwcm9ncmFtbWF0aWNhbGx5KSxcblx0XHQgKiBhIHJlZmVyZW5jZSB0byB0aGUgcHJvZ3JhbSBpcyBzdG9yZWQgaW5zdGVhZC5cblx0XHQgKiBcblx0XHQgKiBUZWNobmljYWxseSBhbiBhZ2VudCBzaG91bGQgYmUgYXR0YWNoZWQgaW4gb25seSBvbmUgcGxhY2Vcblx0XHQgKiBpbiB0aGUgcHJvZ3JhbSwgaG93ZXZlciwgdGhpcyBtYXkgbm90IGFsd2F5cyBiZSB0aGUgY2FzZSxcblx0XHQgKiBhbmQgdGhlIHN5c3RlbSBuZWVkcyB0byBiZSBhYmxlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVuXG5cdFx0ICogaXQgaXNuJ3QuXG5cdFx0ICogXG5cdFx0ICogVGhpcyBhcnJheSBpcyB1c2VkIHRvIHJlZmVyZW5jZSBjb3VudCAvIGdhcmJhZ2UgY29sbGVjdFxuXHRcdCAqIHRoZSBhdHRhY2hlZCBhZ2VudHMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8U3RhdGVtZW50IHwgUHJvZ3JhbT4+KCk7XG5cdH1cblxuXHRkZWNsYXJlIGZ1bmN0aW9uIGF0b2IoaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcblx0ZGVjbGFyZSBmdW5jdGlvbiBidG9hKGlucHV0OiBzdHJpbmcpOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIHR5cGUgZGVmaW5pdGlvbiBmb3IgYSBWMyBzb3VyY2UgbWFwIG9iamVjdC5cblx0ICovXG5cdGludGVyZmFjZSBJU291cmNlTWFwXG5cdHtcblx0XHR2ZXJzaW9uOiAzO1xuXHRcdGZpbGU/OiBzdHJpbmc7XG5cdFx0c291cmNlUm9vdD86IHN0cmluZztcblx0XHRzb3VyY2VzPzogc3RyaW5nW107XG5cdFx0bmFtZXM/OiBzdHJpbmdbXTtcblx0XHRtYXBwaW5nczogc3RyaW5nO1xuXHRcdHNvdXJjZXNDb250ZW50Pzogc3RyaW5nW107XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgQ2F1c2VzIGRlZmluZWQgYm90aCB3aXRoaW5cblx0ICogdGhlIGNvbXBpbGVyIGNvcmUsIGFuZCBpbiB1c2VyIGNvZGUuXG5cdCAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2F1c2U8UiA9IHZvaWQ+XG5cdHtcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBDYXVzZSwgaWYgYW55LiBJbiBhIGNhdXNlIGNhbGxiYWNrIGZ1bmN0aW9uLFxuXHRcdCAqIHRoaXMgcHJvcGVydHkgZXhpc3RzIGFzIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gcmV0dXJuZWRcblx0XHQgKiBmcm9tIG90aGVyIGNhdXNlIGFpZHMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgcmV0dXJuczogUiA9IG51bGwhO1xuXHR9XG5cblxuXHQvKipcblx0ICogRXh0cmFjdHMgdGhlICpSZXN1bHQqIHR5cGUgcGFyYW1ldGVyIG9mIGEgQ2F1c2UuXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBUQ2F1c2VSZXR1cm48VD4gPSBUIGV4dGVuZHMgeyByZXR1cm5zOiBpbmZlciBSIH0gPyBSIDogbmV2ZXI7XG5cblxuXHQvKipcblx0ICogTWFwcyBhIENhdXNlIHR5cGUgb3ZlciB0byBpdCdzIGNvcnJlc3BvbmRpbmcgb2JqZWN0XG5cdCAqIHRoYXQgaXMgZmVkIGludG8gYWxsIGNhdXNlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cblx0ICovXG5cdGV4cG9ydCB0eXBlIFRDYXVzZURhdGE8VD4gPSB7XG5cdFx0W1AgaW4ga2V5b2YgVF06IFAgZXh0ZW5kcyBcInJldHVybnNcIiA/XG5cdFx0XHRyZWFkb25seSBUW1BdW10gOiBcblx0XHRcdFRbUF07XG5cdH07XG5cblxuXHQvLyBcblx0Ly8gQ2F1c2VzXG5cdC8vIFxuXG5cblx0LyoqICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUFnZW50QXR0YWNoIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIFVSSSBmcm9tIHdoZXJlIHRoZSBhZ2VudCB3YXMgbG9hZGVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSB1cmk6IFVyaSxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHNjb3BlIG9mIHdoZXJlIHRoZSBhZ2VudFxuXHRcdFx0ICogYXBwbGllcy5cblx0XHRcdCAqIFxuXHRcdFx0ICogSWYgdGhlIHZhbHVlIGlzIGBpbnN0YW5jZW9mIFByb2dyYW1gLCB0aGlzIGluZGljYXRlcyB0aGF0XG5cdFx0XHQgKiB0aGUgYWdlbnQncyBjYXVzZXMgYXJlIHNjb3BlZCB0byBhIHBhcnRpY3VsYXIgcHJvZ3JhbSAod2hpY2hcblx0XHRcdCAqIGlzIGVmZmVjdGl2ZWx5IFwidW5zY29wZWRcIikuXG5cdFx0XHQgKiBcblx0XHRcdCAqIElmIHRoZSB2YWx1ZSBpcyBgaW5zdGFuY2VvZiBEb2N1bWVudGAsIHRoaXMgaW5kaWNhdGVzIHRoYXRcblx0XHRcdCAqIHRoZSBhZ2VudCdzIGNhdXNlcyBhcmUgc2NvcGVkIHRvIHRoZSBjYXVzZXMgdGhhdCBjYW5cblx0XHRcdCAqIG9yaWdpbmF0ZSBmcm9tIGEgc2luZ2xlIGRvY3VtZW50LlxuXHRcdFx0ICogXG5cdFx0XHQgKiAoTm90IGltcGxlbWVudGVkKS4gSWYgdGhlIHZhbHVlIGlzIGBpbnN0YW5jZW9mIFR5cGVgLCB0aGlzIFxuXHRcdFx0ICogaW5kaWNhdGVzIHRoYXQgdGhlIGFnZW50J3MgY2F1c2VzIGFyZSBzY29wZWQgdG8gdGhlIGNhdXNlc1xuXHRcdFx0ICogdGhhdCBjYW4gb3JpZ2luYXRlIGZyb20gYSBzaW5nbGUgdHlwZS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgc2NvcGU6IFByb2dyYW0gfCBEb2N1bWVudCB8IFR5cGUpXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cblxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlQWdlbnREZXRhY2ggZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgdXJpOiBVcmkpIHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIGltbWVkaWF0ZWx5IGFmdGVyIGEgZG9jdW1lbnQgaGFzIGJlZW4gY3JlYXRlZC4gKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlRG9jdW1lbnRDcmVhdGUgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50KSB7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyBpbW1lZGlhdGVseSBiZWZvcmUgYSBkb2N1bWVudCBpcyByZW1vdmVkIGZyb20gdGhlIHByb2dyYW0uICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZURvY3VtZW50RGVsZXRlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHJlYWRvbmx5IGRvY3VtZW50OiBEb2N1bWVudCkgeyBzdXBlcigpOyB9XG5cdH1cblxuXHQvKiogQSBjYXVzZSB0aGF0IHJ1bnMgd2hlbiBhIGRvY3VtZW50J3MgZmlsZSBuYW1lIGNoYW5nZXMuICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZURvY3VtZW50VXJpQ2hhbmdlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50LFxuXHRcdFx0cmVhZG9ubHkgbmV3VXJpOiBVcmkpXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cblxuXHQvKiogQWJzdHJhY3QgY2F1c2UgY2xhc3MgZm9yIHRoZSByZXNvbHV0aW9uIGNhdXNlcyAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2F1c2VSZXNvbHZlIGV4dGVuZHMgQ2F1c2U8SVJlc29sdXRpb25SZXR1cm4+XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0sXG5cdFx0XHRyZWFkb25seSBzcGluZTogU3BpbmUpXG5cdFx0eyBzdXBlcigpOyB9XG5cdH1cblxuXHQvKiogT3V0cHV0IGZvciByZXNvbHV0aW9uIGhvb2tzICovXG5cdGV4cG9ydCBpbnRlcmZhY2UgSVJlc29sdXRpb25SZXR1cm5cblx0e1xuXHRcdHJlYWRvbmx5IHJlc29sdmVzOiBib29sZWFuO1xuXHR9XG5cblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIGJlZm9yZSB0aGUgY29tcGlsZXIgaXMgYWJvdXQgdG8gcmVzb2x2ZSBhIHRlcm0uICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUJlZm9yZVJlc29sdmUgZXh0ZW5kcyBDYXVzZVJlc29sdmUgeyB9XG5cblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIGFmdGVyIHRoZSBjb21waWxlciBoYXMgcmVzb2x2ZWQgYSB0ZXJtLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VBZnRlclJlc29sdmUgZXh0ZW5kcyBDYXVzZVJlc29sdmUgeyB9XG5cblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIHdoZW4gdGhlIGNvbXBpbGVyIGlzIHVuYWJsZSB0byByZXNvbHZlIGEgdGVybS4gKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlTm90UmVzb2x2ZWQgZXh0ZW5kcyBDYXVzZVJlc29sdmUgeyB9XG5cblx0LyoqICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUludmFsaWRhdGUgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBEb2N1bWVudCBvYmplY3QgaW4gd2hpY2ggdGhlIEludmFsaWRhdGlvbiBvY2N1cmVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGFycmF5IG9mIHN0YXRlbWVudHMgd2hvc2UgZGVzY2VuZGFudHMgc2hvdWxkIGJlIGludmFsaWRhdGVkLlxuXHRcdFx0ICogSWYgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGUgZW50aXJlIGRvY3VtZW50IHNob3VsZCBiZSBpbnZhbGlkYXRlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcGFyZW50czogcmVhZG9ubHkgU3RhdGVtZW50W10sXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGFycmF5IG9mIGluZGV4ZXMgd2hvc2UgbGVuZ3RoIGlzIHRoZSBzYW1lIGFzIHRoZSBwYXJlbnRzIGZpZWxkLFxuXHRcdFx0ICogdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiBlYWNoIHBhcmVudCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBpbmRleGVzOiByZWFkb25seSBudW1iZXJbXSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VSZXZhbGlkYXRlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnQgb2JqZWN0IGluIHdoaWNoIHRoZSBSZXZhbGlkYXRpb24gd2lsbCBvY2N1ci5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHdob3NlIGRlc2NlbmRhbnRzIHNob3VsZCBiZSByZXZhbGlkYXRlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcGFyZW50czogcmVhZG9ubHkgU3RhdGVtZW50W10sXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGFycmF5IG9mIGluZGV4ZXMgd2hvc2UgbGVuZ3RoIGlzIHRoZSBzYW1lIGFzIHRoZSBwYXJlbnRzIGZpZWxkLFxuXHRcdFx0ICogdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiBlYWNoIHBhcmVudCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBpbmRleGVzOiByZWFkb25seSBudW1iZXJbXSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyB3aGVuIGEgZG9jdW1lbnQgZWRpdCB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VFZGl0Q29tcGxldGUgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50KSB7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2F1c2VVcmlSZWZlcmVuY2UgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBTdGF0ZW1lbnQgaW5zdGFuY2UgdGhhdCByZWZlcmVuY2VzXG5cdFx0XHQgKiB0aGlzIFVSSSwgb3IgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIHRoZSBwcm9ncmFtIGl0c2VsZlxuXHRcdFx0ICogcmVmZXJlbmNlcyB0aGUgVVJJIGJ5IGFub3RoZXIgbWVhbnMuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVsbCxcblx0XHRcdHJlYWRvbmx5IHVyaTogVXJpKSBcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBIGhvb2sgdGhhdCBydW5zIHdoZW4gYSBVUkkgcmVmZXJlbmNlIGlzIGFkZGVkIHRvIGEgZG9jdW1lbnQsIFxuXHQgKiBidXQgYmVmb3JlIGl0IHJlc29sdmVzIHRvIGEgcmVzb3VyY2UuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VVcmlSZWZlcmVuY2VBZGQgZXh0ZW5kcyBDYXVzZVVyaVJlZmVyZW5jZSB7IH1cblxuXHQvKipcblx0ICogQSBob29rIHRoYXQgcnVucyB3aGVuIGEgVVJJIHJlZmVyZW5jZSBpcyByZW1vdmVkIGZyb20gYSBkb2N1bWVudC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZVVyaVJlZmVyZW5jZVJlbW92ZSBleHRlbmRzIENhdXNlVXJpUmVmZXJlbmNlIHsgfVxuXG5cdC8qKlxuXHQgKiBBIGhvb2sgdGhhdCBydW5zIHdoZW4gdGhlIHNldCBvZiBmYXVsdHMgdGhhdCBhcmUgZGV0ZWN0ZWRcblx0ICogd2l0aGluIHRoZSBkb2N1bWVudCBoYXZlIGNoYW5nZWQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VGYXVsdENoYW5nZSBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGZhdWx0c0FkZGVkOiBGYXVsdFtdLFxuXHRcdFx0cmVhZG9ubHkgZmF1bHRzUmVtb3ZlZDogRmF1bHRbXSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqIEBpbnRlcm5hbCAqL1xuXHRleHBvcnQgY2xhc3MgRXhjZXB0aW9uXG5cdHtcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgb2JqZWN0RGlydHkoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdENhbm5vdCBjYWxsIHRoaXMgbWV0aG9kIG9yIGFjY2VzcyB0aGlzIHByb3BlcnR5LFxuXHRcdFx0XHRiZWNhdXNlIHRoZSBkb2N1bWVudCBoYXMgY2hhbmdlZCBzaW5jZSBpdFxuXHRcdFx0XHR3YXMgY3JlYXRlZC5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRBcmd1bWVudCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiSW52YWxpZCBhcmd1bWVudC5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBwYXNzZWRBcnJheUNhbm5vdEJlRW1wdHkocGFyYW1OYW1lOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiQXJyYXkgY2Fubm90IGJlIGVtcHR5IGZvciBwYXJhbWV0ZXI6IFwiICsgcGFyYW1OYW1lKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHVua25vd25TdGF0ZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiQW4gdW5rbm93biBzdGF0ZSBoYXMgYmVlbiByZWFjaGVkIGluIHRoZSBwcm9ncmFtLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRDYWxsKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJDYW5ub3QgY2FsbCB0aGlzIG1ldGhvZCBnaXZlbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcHJvZ3JhbS5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBub3RJbXBsZW1lbnRlZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGFnZW50Tm90UmVhZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0Q2Fubm90IGluc3RhbnRpYXRlIGFuIGFnZW50IG9mIHRoaXMgdHlwZSxcblx0XHRcdFx0YWRkZWQuIFNlZSBhZ2VudHMuYWRkLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgYWdlbnRNaXNzaW5nKHJhd1VyaTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgQ291bGQgbm90IGxvYWQgYW4gYWdlbnQgZnJvbSB0aGUgVVJJICR7cmF3VXJpfWApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgYWdlbnRJbXBvcnRFcnJvcihhZ2VudFVyaTogc3RyaW5nLCBlcnJvclRleHQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRBbiBlcnJvciBvY2N1cmVkIHdoaWxlIHRyeWluZyB0byBldmFsdWF0ZSB0aGUgYWdlbnQgYXQgXCIke2FnZW50VXJpfVwiLlxuXHRcdFx0XHRUaGUgZXJyb3IgbWVzc2FnZSByZXR1cm5lZCB3YXM6ICR7ZXJyb3JUZXh0fWApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgYWdlbnRJbnZhbGlkKHJhd1VyaTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdFRoZSBjb2RlIGZpbGUgYXQgJHtyYXdVcml9IGRvZXMgbm90IGV4cG9ydCBhIGZ1bmN0aW9uLiBDb25zaWRlciBsb29raW5nXG5cdFx0XHRcdGF0IHRoZSBkb2N1bWVudGlvbiBhbmQgZXhhbXBsZXMgZm9yIHRoZSBwcm9wZXIgd2F5IHRvIHN0dWN0dXJlIGFuXG5cdFx0XHRcdGFnZW50IGNvZGUgZmlsZS5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG5vUmVtb3RlQWdlbnRzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRBZ2VudHMgY2Fubm90IGJlIGxvYWRlZCBmcm9tIHJlbW90ZSBVUklzIGluIHRoaXMgY29udGV4dC5cblx0XHRcdFx0KE1vc3QgbGlrZWx5LCB0aGlzIGNvZGUgaXMgcnVubmluZyBpbiBOb2RlLmpzIHdoZXJlIHRoZSBsb2FkaW5nXG5cdFx0XHRcdG9mIHJlbW90ZSBjb2RlIGlzIGEgc2VjdXJpdHkgcmlzaykuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBjYXVzZVBhcmFtZXRlck5hbWVJblVzZShwYXJhbU5hbWU6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgdXNlIHRoZSBuYW1lIFwiJHtwYXJhbU5hbWV9XCIgYXMgYSBwYXJhbWV0ZXJcblx0XHRcdFx0bmFtZSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBpbiB1c2UuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBkb3VibGVUcmFuc2FjdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiQ2Fubm90IHN0YXJ0IGEgbmV3IHRyYW5zYWN0aW9uIHdoaWxlIGFub3RoZXIgaXMgZXhlY3V0aW5nLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRVcmlSZXRyYWN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJVUkkgY29udGFpbnMgdG9vIGZldyBwYXRoIHNlZ21lbnRzIHRvIHBlcmZvcm0gdGhpcyByZXRyYWN0aW9uLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRVcmkocmF3VXJpPzogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkludmFsaWQgVVJJXCIgKyAodHlwZW9mIHJhd1VyaSA9PT0gXCJzdHJpbmdcIiA/IFwiOiBcIiArIHJhd1VyaSA6IFwiXCIpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHVyaU5vdFN1cHBvcnRlZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiVVJJcyBvZiB0aGlzIHR5cGUgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgY2Fubm90TWFrZUFic29sdXRlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgbWFrZSB0aGlzIFVSSSBhYnNvbHV0ZSBiZWNhdXNlIG5vIFxuXHRcdFx0XHRwcm9jZXNzIG9yIHdpbmRvdyBvYmplY3QgY291bGQgYmUgZm91bmRgKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGFic29sdXRlVXJpRXhwZWN0ZWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgVGhpcyBtZXRob2QgZXhwZWN0cyBhbiBhYnNvbHV0ZSBVUkkgdG8gYmUgc3BlY2lmaWVkLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgbXVzdFNwZWNpZnlWaWEoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdE11c3Qgc3BlY2lmeSB0aGUgXCJ2aWFcIiBhcmd1bWVudCBiZWNhdXNlIHRoZSBwYXJzZWQgVVJJIFxuXHRcdFx0XHR3YXMgZm91bmQgdG8gYmUgcmVsYXRpdmVgKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHZpYUNhbm5vdEJlUmVsYXRpdmUoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgVVJJIGluc3RhbmNlcyBzcGVjaWZpZWQgaW4gdGhlIFwidmlhXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgcmVsYXRpdmVgKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRUeXBlUGF0aCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0T25lIG9yIG1vcmUgb2YgdGhlIHR5cGVzIGluIHRoZSBzcGVjaWZpZWQgdHlwZSBwYXRoIGFyZSBpbnZhbGlkLFxuXHRcdFx0XHRiZWNhdXNlIHRoZXkgY29udGFpbiBlaXRoZXIgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlLCBvclxuXHRcdFx0XHRpcyBhbiBlbXB0eSBzdHJpbmcuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBpbnZhbGlkRXh0ZW5zaW9uKHJlcXVpcmVkRXh0ZW5zaW9uOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0VGhpcyBtZXRob2QgcmVxdWlyZXMgVVJJcyB0aGF0IGhhdmUgdGhlIFxuXHRcdFx0XHRcIi4ke3JlcXVpcmVkRXh0ZW5zaW9ufVwiIGV4dGVuc2lvbi5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWREb2N1bWVudFJlZmVyZW5jZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0VGhpcyBkb2N1bWVudCBjYW5ub3QgYmUgYWRkZWQgYXMgYSBkZXBlbmRlbmN5XG5cdFx0XHRcdG9mIHRoZSB0YXJnZXQgZG9jdW1lbnQgYmVjYXVzZSBpdCdzIHN0b3JhZ2UgbG9jYXRpb25cblx0XHRcdFx0KG1lbW9yeSBvciBkaXNrKSBkaWZmZXJzIGZyb20gdGhlIHRoYXQgb2YgdGhlIHRhcmdldC5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG5vbkVtcHR5RG9jdW1lbnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkNhbm5vdCBjYWxsIHRoaXMgbWV0aG9kIG9uIGEgbm9uLWVtcHR5IGRvY3VtZW50LlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRXaGlsZUluRWRpdFRyYW5zYWN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXG5cdFx0XHRcdGBDYW5ub3QgY2FsbCB0aGlzIG1ldGhvZCwgb3IgcnVuIHRoaXMgaG9vayB3aGlsZSBhbiBlZGl0XG5cdFx0XHRcdHRyYW5zYWN0aW9uIGlzIHVuZGVyd2F5LmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgdW5jYWNoYWJsZURvY3VtZW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgY2FjaGUgdGhpcyBkb2N1bWVudCBiZWNhdXNlIGl0IHdhcyBub3QgbG9hZGVkIGZyb20gYSBmaWxlLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgZG9jdW1lbnRBbHJlYWR5TG9hZGVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRBIGRvY3VtZW50IHdpdGggdGhpcyBVUkkgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkLlxuXHRcdFx0XHRVc2UgRG9jdW1lbnQuZnJvbVVyaSgpIGluc3RlYWQuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBkb2N1bWVudE5vdExvYWRlZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiVGhpcyBkb2N1bWVudCBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gdGhlIGN1cnJlbnQgcHJvZ3JhbS5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBjYW5ub3RSZWZyZXNoKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRUaGlzIHJlc291cmNlIGNhbm5vdCBiZSByZWxvYWRlZCBiZWNhdXNlIGl0IG9ubHkgZXhpc3RzIGluIG1lbW9yeS5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG9mZnNldFJlcXVpcmVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRPZmZzZXQgYXJndW1lbnQgaXMgcmVxdWlyZWQgYmVjYXVzZSB0aGUgYSB3aGl0ZXNwYWNlLW9ubHlcblx0XHRcdFx0c3RhdGVtZW50IHdhcyBwYXNzZWQuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyB1bnN1cHBvcnRlZFBsYXRmb3JtKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJUaGlzIGNvZGUgYXBwZWFycyB0byBiZSBvcGVyYXRpbmcgaW4gYW4gdW5zdXBwb3J0ZWQgcGxhdGZvcm0uXCIpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIHByb3BlciBlcnJvciBvYmplY3QgZnJvbSB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcihtc2c6IHN0cmluZylcblx0e1xuXHRcdHJldHVybiBuZXcgRXJyb3IobXNnLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKSk7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBVbml2ZXJzYWwgY2xhc3MgZm9yIGhhbmRsaW5nIFVSSXMgdGhhdCBleGlzdCB3aXRoaW4gYSBUcnV0aCBkb2N1bWVudC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBVcmlcblx0e1xuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdHMgYSBuZXcgVXJpIGluc3RhbmNlIHRoYXQgcG9pbnRzIHRvIGEgKHBvc3NpYmx5IG5lc3RlZClcblx0XHQgKiB0eXBlIGRlZmluZWQgaW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRzdGF0aWMgZnJvbShkb2N1bWVudDogRG9jdW1lbnQsIC4uLnR5cGVzOiBzdHJpbmdbXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuc291cmNlVXJpLmV4dGVuZFR5cGUodHlwZXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byBwYXJzZSB0aGUgc3BlY2lmaWVkIHN0cmluZyBvciBVcmkgaW50b1xuXHRcdCAqIGFub3RoZXIgVXJpIGluc3RhbmNlLiBJZiB0aGUgcGFyYW1ldGVyIGlzIGFscmVhZHlcblx0XHQgKiBhIFVyaSwgaXQgaXMgcmV0dXJuZWQgd2l0aG91dCBmdXJ0aGVyIHByb2Nlc3NpbmcuXG5cdFx0ICovXG5cdFx0c3RhdGljIG1heWJlUGFyc2UodmFsdWU6IHN0cmluZyB8IFVyaSk6IFVyaSB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBVcmkpXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFxuXHRcdFx0aWYgKCF2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnRyeVBhcnNlKHZhbHVlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gcGFyc2UgdGhlIHNwZWNpZmllZCBzdHJpbmcgaW50byBhIFVyaSBpbnN0YW5jZS5cblx0XHQgKiBSZXR1cm5zIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgVXJpIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG5cdFx0ICovXG5cdFx0c3RhdGljIHRyeVBhcnNlKHVyaTogc3RyaW5nIHwgVXJpLCB2aWE/OiBVcmkgfCBzdHJpbmcpOiBVcmkgfCBudWxsXG5cdFx0e1xuXHRcdFx0aWYgKCF1cmkpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB1cmlMaWtlID0gdHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFVyaVBhcnNlci5wYXJzZSh1cmkpIDpcblx0XHRcdFx0dXJpO1xuXHRcdFx0XG5cdFx0XHRpZiAodXJpTGlrZSA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dFVyaSA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoISh1cmlMaWtlLmlzUmVsYXRpdmUgJiYgdmlhKSlcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVyaSh1cmlMaWtlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHZpYVBhcnNlZCA9IHR5cGVvZiB2aWEgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFVyaVBhcnNlci5wYXJzZSh2aWEpIDpcblx0XHRcdFx0XHR2aWE7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodmlhUGFyc2VkID09PSBudWxsKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkVXJpKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodmlhUGFyc2VkLmlzUmVsYXRpdmUpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnZpYUNhbm5vdEJlUmVsYXRpdmUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHVyaVN0b3JlcyA9IE5vdC51bmRlZmluZWQodXJpTGlrZS5zdG9yZXMpO1xuXHRcdFx0XHRjb25zdCB2aWFTdG9yZXMgPSBOb3QudW5kZWZpbmVkKHZpYVBhcnNlZC5zdG9yZXMpO1xuXHRcdFx0XHRjb25zdCByZXRyYWN0ID0gdXJpTGlrZS5yZXRyYWN0aW9uQ291bnQgfHwgMDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh2aWFTdG9yZXMubGVuZ3RoIDwgcmV0cmFjdClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZFVyaSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBVcmkodXJpTGlrZSwge1xuXHRcdFx0XHRcdHByb3RvY29sOiB2aWFQYXJzZWQucHJvdG9jb2wsXG5cdFx0XHRcdFx0c3RvcmVzOiByZXRyYWN0ID4gMCA/XG5cdFx0XHRcdFx0XHR2aWFTdG9yZXMuc2xpY2UoMCwgLXJldHJhY3QpLmNvbmNhdCh1cmlTdG9yZXMpIDpcblx0XHRcdFx0XHRcdHZpYVN0b3Jlcy5jb25jYXQodXJpU3RvcmVzKSxcblx0XHRcdFx0XHRyZXRyYWN0aW9uQ291bnQ6IC0xLFxuXHRcdFx0XHRcdGlzUmVsYXRpdmU6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmV0dXJuIG51bGwgd2hlbiBhbiBleHRlbnNpb24gd2FzIGZvdW5kIHRoYXQgaXNuJ3Rcblx0XHRcdC8vIHVua25vd24gKGFsc28gd2hlbiBubyBleHRlbnNpb24gd2FzIGZvdW5kKS4gVGhpc1xuXHRcdFx0Ly8gaXMgaW4gb3JkZXIgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgdGVybXMgdGhhdCBoYXZlXG5cdFx0XHQvLyBhIHNwZWNpYWwgbWVhbmluZyBpbiBhIHRydXRoIGRvY3VtZW50LlxuXHRcdFx0aWYgKG91dFVyaS5leHQgPT09IFVyaUV4dGVuc2lvbi51bmtub3duKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gWW91IGNhbid0IGhhdmUgYSB0eXBlIHBhdGggdGhhdCBwb2ludHMgdG8gYSBcblx0XHRcdC8vIG5vbi10cnV0aCBmaWxlLCBzbyBudWxsIGlzIHJldHVybmVkIGluIHRoaXMgY2FzZS5cblx0XHRcdGlmIChvdXRVcmkudHlwZXMubGVuZ3RoID4gMClcblx0XHRcdFx0aWYgKG91dFVyaS5leHQgIT09IFVyaUV4dGVuc2lvbi50cnV0aClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dFVyaTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29waWVzIHRoZSBzcGVjaWZpZWQgVVJJIG9yIFNwaW5lIGludG8gYW5vdGhlciBVUkkgaW5zdGFuY2UuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNsb25lKHZhbHVlOiBTcGluZSB8IFVyaSk6IFVyaVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVyaSlcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzcmNVcmkgPSB2YWx1ZS5kb2N1bWVudC5zb3VyY2VVcmk7XG5cdFx0XHRjb25zdCB0eXBlU2VnbWVudHMgPSB2YWx1ZS52ZXJ0ZWJyYWUubWFwKHZlcnQgPT5cblx0XHRcdFx0bmV3IFVyaUNvbXBvbmVudCh2ZXJ0LnRvU3RyaW5nKHRydWUpKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgVXJpKHNyY1VyaSwgeyB0eXBlczogdHlwZVNlZ21lbnRzIH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBDcmVhdGVzIGFuIGludGVybmFsIFVSSSB1c2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFcblx0XHQgKiBkb2N1bWVudCB0aGF0IGV4aXN0cyBvbmx5IGluIG1lbW9yeS5cblx0XHQgKi9cblx0XHRzdGF0aWMgY3JlYXRlSW50ZXJuYWwoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG1heCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXHRcdFx0Y29uc3QgZXh0ID0gVXJpRXh0ZW5zaW9uLnRydXRoO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFVyaSh7XG5cdFx0XHRcdHByb3RvY29sOiBVcmlQcm90b2NvbC5pbnRlcm5hbCxcblx0XHRcdFx0ZmlsZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KS50b1N0cmluZygzNikgKyBleHQsXG5cdFx0XHRcdGV4dFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgY29uc3RydWN0b3IoLi4udXJpTGlrZTogUGFydGlhbDxVcmk+W10pXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCB1cmlQcm9wcyBvZiB1cmlMaWtlKVxuXHRcdFx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHVyaVByb3BzKTtcblx0XHRcdFxuXHRcdFx0T2JqZWN0LmZyZWV6ZSh0aGlzLnN0b3Jlcyk7XG5cdFx0XHRPYmplY3QuZnJlZXplKHRoaXMudHlwZXMpO1xuXHRcdFx0T2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogRGVidWdnaW5nIHV0aWxpdHkuIERvIG5vdCB1c2UuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLnRvVHlwZVN0cmluZygpOyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgcHJvdG9jb2w6IFVyaVByb3RvY29sID0gVXJpUHJvdG9jb2wuZmlsZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgcmVmZXJlbmNlZCBpbiB0aGUgVVJJLCBpbmNsdWRpbmcgYW55IGV4dGVuc2lvbi5cblx0XHQgKi9cblx0XHRyZWFkb25seSBmaWxlOiBzdHJpbmcgPSBcIlwiO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBmaWxlIHJlZmVyZW5jZWQgaW4gdGhlIFVSSSwgaWYgYW55LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGV4dDogVXJpRXh0ZW5zaW9uID0gVXJpRXh0ZW5zaW9uLnRydXRoO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc3RvcmUtc2lkZSBjb21wb25lbnRzIG9mIHRoaXMgVVJJLlxuXHRcdCAqIEV4Y2x1ZGVzIHRoZSBmaWxlIG5hbWUuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgc3RvcmVzOiByZWFkb25seSBVcmlDb21wb25lbnRbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgdHlwZS1zaWRlIGNvbXBvbmVudHMgb2YgdGhpcyBVUkkuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdHlwZXM6IHJlYWRvbmx5IFVyaUNvbXBvbmVudFtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBudW1iZXIgb2YgcmV0cmFjdGlvbnMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGlzXG5cdFx0ICogVVJJLCBpbiB0aGUgY2FzZSB3aGVuIHRoZSBVUkkgaXMgcmVsYXRpdmUuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgcmV0cmFjdGlvbkNvdW50OiBudW1iZXIgPSAwO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoZSBVUkkgaXMgYSByZWxhdGl2ZSBwYXRoLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlzUmVsYXRpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFVyaSB3aG9zZSBwYXRoIG9mIHR5cGVzIGlzXG5cdFx0ICogcmV0cmFjdGVkIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGxldmVsc1xuXHRcdCAqIG9mIGRlcHRoLlxuXHRcdCAqL1xuXHRcdHJldHJhY3RUeXBlKGZhY3RvcjogbnVtYmVyKTogVXJpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHlwZXMgPSB0aGlzLnR5cGVzLnNsaWNlKDAsIC1mYWN0b3IpO1xuXHRcdFx0cmV0dXJuIG5ldyBVcmkodGhpcywgeyB0eXBlcyB9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIG5ldyBVcmksIHdob3NlIHBhdGggb2YgdHlwZXMgaXNcblx0XHQgKiByZXRyYWN0ZWQgdG8gdGhlIHNwZWNpZmllZCBsZXZlbCBvZiBkZXB0aC5cblx0XHQgKi9cblx0XHRyZXRyYWN0VHlwZVRvKGRlcHRoOiBudW1iZXIpOiBVcmlcblx0XHR7XG5cdFx0XHRyZXR1cm4gZGVwdGggPCB0aGlzLnR5cGVzLmxlbmd0aCA/XG5cdFx0XHRcdHRoaXMucmV0cmFjdFR5cGUodGhpcy50eXBlcy5sZW5ndGggLSBkZXB0aCkgOlxuXHRcdFx0XHR0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFVyaSB3aG9zZSBwYXRoIG9mIHN0b3JlcyBpc1xuXHRcdCAqIHJldHJhY3RlZCBieSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBsZXZlbHNcblx0XHQgKiBvZiBkZXB0aC5cblx0XHQgKi9cblx0XHRyZXRyYWN0U3RvcmUoZmFjdG9yOiBudW1iZXIpOiBVcmlcblx0XHR7XG5cdFx0XHRjb25zdCBmb2xkZXJzID0gdGhpcy5zdG9yZXMuc2xpY2UoMCwgLWZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gbmV3IFVyaSh0aGlzLCB7IHN0b3JlczogZm9sZGVycyB9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIG5ldyBVcmksIHdob3NlIHBhdGggb2YgZm9sZGVycyBpc1xuXHRcdCAqIHJldHJhY3RlZCB0byB0aGUgc3BlY2lmaWVkIGxldmVsIG9mIGRlcHRoLlxuXHRcdCAqL1xuXHRcdHJldHJhY3RTdG9yZVRvKGRlcHRoOiBudW1iZXIpOiBVcmlcblx0XHR7XG5cdFx0XHRyZXR1cm4gZGVwdGggPCB0aGlzLnN0b3Jlcy5sZW5ndGggP1xuXHRcdFx0XHR0aGlzLnJldHJhY3RUeXBlKHRoaXMuc3RvcmVzLmxlbmd0aCAtIGRlcHRoKSA6XG5cdFx0XHRcdHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGV4dGVuZFR5cGUoYWRkaXRpb25hbFR5cGVOYW1lczogc3RyaW5nIHwgcmVhZG9ubHkgc3RyaW5nW10pOiBVcmlcblx0XHR7XG5cdFx0XHRpZiAoIWFkZGl0aW9uYWxUeXBlTmFtZXMpXG5cdFx0XHRcdHJldHVybiBuZXcgVXJpKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb21wb25lbnRzID0gdHlwZW9mIGFkZGl0aW9uYWxUeXBlTmFtZXMgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRbbmV3IFVyaUNvbXBvbmVudChhZGRpdGlvbmFsVHlwZU5hbWVzKV0gOlxuXHRcdFx0XHRhZGRpdGlvbmFsVHlwZU5hbWVzLm1hcCh0ID0+IG5ldyBVcmlDb21wb25lbnQodCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFVyaSh0aGlzLCB7IHR5cGVzOiB0aGlzLnR5cGVzLmNvbmNhdChjb21wb25lbnRzKSB9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0ZXh0ZW5kU3RvcmUoYWRkaXRpb25hbFN0b3Jlczogc3RyaW5nIHwgcmVhZG9ubHkgc3RyaW5nW10pOiBVcmlcblx0XHR7XG5cdFx0XHRpZiAoIWFkZGl0aW9uYWxTdG9yZXMpXG5cdFx0XHRcdHJldHVybiBuZXcgVXJpKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdG9yZXMgPSB0eXBlb2YgYWRkaXRpb25hbFN0b3JlcyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFtuZXcgVXJpQ29tcG9uZW50KGFkZGl0aW9uYWxTdG9yZXMpXSA6XG5cdFx0XHRcdGFkZGl0aW9uYWxTdG9yZXMubWFwKHMgPT4gbmV3IFVyaUNvbXBvbmVudChzKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgVXJpKHRoaXMsIHsgc3RvcmVzIH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzXG5cdFx0ICogVXJpIGlzIHN0cnVjdHVyYWxseSBlcXVpdmFsZW50IHRvIHRoZSBzcGVjaWZpZWQgVXJpLlxuXHRcdCAqL1xuXHRcdGVxdWFscyhvdGhlcjogVXJpLCBjb21wYXJlVHlwZXM/OiBib29sZWFuKTogYm9vbGVhblxuXHRcdHtcblx0XHRcdGlmICh0aGlzID09PSBvdGhlcilcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdGlmIChjb21wYXJlVHlwZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLnR5cGVzLmxlbmd0aCAhPT0gb3RoZXIudHlwZXMubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnR5cGVzLnNvbWUoKHQsIGkpID0+IHQudmFsdWUgIT09IG90aGVyLnR5cGVzW2ldLnZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnByb3RvY29sICE9PSBvdGhlci5wcm90b2NvbClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5zdG9yZXMuc29tZSgocywgaSkgPT4gcy52YWx1ZSAhPT0gb3RoZXIuc3RvcmVzW2ldLnZhbHVlKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0dG9BYnNvbHV0ZSgpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLmlzUmVsYXRpdmUpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB2aWE6IHN0cmluZyB8IG51bGwgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dHJ5XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIpXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHByb2Nlc3MuY3dkID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzLmN3ZCgpIHx8IG51bGw7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdy5sb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cubG9jYXRpb24uaHJlZiA9PT0gXCJzdHJpbmdcIilcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkgeyB9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGlmICh2aWEgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5jYW5ub3RNYWtlQWJzb2x1dGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIFVyaS50cnlQYXJzZSh0aGlzLCB2aWEpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgcGF0aCBvZiB0eXBlcyBjb250YWluZWQgYnkgdGhpcyBVUkksIFxuXHRcdCAqIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIHN0cmluZy5cblx0XHQgKi9cblx0XHR0b1R5cGVTdHJpbmcoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnR5cGVzLm1hcCh0ID0+IHQudG9TdHJpbmdFbmNvZGVkKCkpXG5cdFx0XHRcdC5qb2luKFVyaVN5bnRheC5jb21wb25lbnRTZXBhcmF0b3IpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgcGF0aCBvZiBzdG9yZXMgY29udGFpbmVkIGJ5IHRoaXMgVVJJLCBcblx0XHQgKiBjb25jYXRlbmF0ZWQgaW50byBhIHNpbmdsZSBzdHJpbmcuXG5cdFx0ICovXG5cdFx0dG9TdG9yZVN0cmluZyhvbWl0RmlsZSA9IGZhbHNlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRoaXNBYnNvbHV0ZSA9IE5vdC5udWxsKHRoaXMuaXNSZWxhdGl2ZSA/IHRoaXMudG9BYnNvbHV0ZSgpIDogdGhpcyk7XG5cdFx0XHRcblx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZW4gdGhlIHNwZWNpZmllZCBwcm90b2NvbCBpcyBcImZpbGVcIixcblx0XHRcdC8vIHRoZSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggYSAvIHNvIHRoYXQgd2UgZ2V0XG5cdFx0XHQvLyBhbmQgb3V0cHV0IHRoYXQgbG9va3MgbGlrZSAvVXNlcnMvcGVyc29uLy4uLi5cblx0XHRcdGNvbnN0IHByb3RvID0gdGhpc0Fic29sdXRlLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5maWxlID9cblx0XHRcdFx0XCIvXCIgOlxuXHRcdFx0XHR0aGlzQWJzb2x1dGUucHJvdG9jb2wgKyBcIi8vXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGlzV2ViID0gXG5cdFx0XHRcdHRoaXNBYnNvbHV0ZS5wcm90b2NvbCA9PT0gVXJpUHJvdG9jb2wuaHR0cCB8fCBcblx0XHRcdFx0dGhpc0Fic29sdXRlLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5odHRwcztcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IHRoaXNBYnNvbHV0ZS5zdG9yZXNcblx0XHRcdFx0LmNvbmNhdChvbWl0RmlsZSA/IFtdIDogW25ldyBVcmlDb21wb25lbnQodGhpcy5maWxlKV0pXG5cdFx0XHRcdC5tYXAoKHQsIGkpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gaSA9PT0gMCAmJiBpc1dlYiA/XG5cdFx0XHRcdFx0XHR0LnRvU3RyaW5nSG9zdCgpIDpcblx0XHRcdFx0XHRcdHQudG9TdHJpbmdFbmNvZGVkKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5qb2luKFVyaVN5bnRheC5jb21wb25lbnRTZXBhcmF0b3IpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcHJvdG8gKyBjb21wb25lbnRzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0bGV0IG91dCA9IHRoaXMudG9TdG9yZVN0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy50eXBlcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRvdXQgKz0gVXJpU3ludGF4LnR5cGVTZXBhcmF0b3IgKyB0aGlzLnRvVHlwZVN0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH1cblx0fVxuXG5cdGRlY2xhcmUgY29uc3Qgd2luZG93OiBhbnk7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBsaXN0cyBhbGwgYXZhaWxibGUgcHJvdG9jb2xzXG5cdCAqIHN1cHBvcnRlZCBieSB0aGUgc3lzdGVtLiBUaGUgbGlzdCBjYW4gYmUgZW51bWVyYXRlZFxuXHQgKiB2aWEgVXJpLmVhY2hQcm90b2NvbCgpXG5cdCAqL1xuXHRleHBvcnQgZW51bSBVcmlQcm90b2NvbFxuXHR7XG5cdFx0bm9uZSA9IFwiXCIsXG5cdFx0dW5rbm93biA9IFwiP1wiLFxuXHRcdGZpbGUgPSBcImZpbGU6XCIsXG5cdFx0aHR0cHMgPSBcImh0dHBzOlwiLFxuXHRcdGh0dHAgPSBcImh0dHA6XCIsXG5cdFx0aW50ZXJuYWwgPSBcImludGVybmFsOlwiXG5cdH1cblxuXHRleHBvcnQgbmFtZXNwYWNlIFVyaVByb3RvY29sXG5cdHtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIFVyaVByb3RvY29sIG1lbWJlciBmcm9tIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdGV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKHZhbHVlOiBzdHJpbmcpOiBVcmlQcm90b2NvbCB8IG51bGxcblx0XHR7XG5cdFx0XHRjb25zdCB2YWxzID0gPHN0cmluZ1tdPk9iamVjdC52YWx1ZXMoVXJpUHJvdG9jb2wpO1xuXHRcdFx0Y29uc3QgaWR4ID0gdmFscy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdHJldHVybiBpZHggPCAwID8gbnVsbCA6IDxVcmlQcm90b2NvbD52YWxzW2lkeF07XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVXJpUGFyc2VyXG5cdHtcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRzdGF0aWMgcGFyc2UocmF3OiBzdHJpbmcpOiBQYXJ0aWFsPFVyaT4gfCBudWxsXG5cdFx0e1xuXHRcdFx0bGV0IGlzUmVsYXRpdmUgPSBmYWxzZTtcblx0XHRcdGxldCByZXRyYWN0aW9uQ291bnQgPSAwO1xuXHRcdFx0bGV0IHByb3RvY29sID0gXCJcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihyYXcpO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWRzIC4vXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZEN1cnJlbnQoKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFVyaVN5bnRheC5jdXJyZW50KSlcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoVXJpU3ludGF4LmNvbXBvbmVudFNlcGFyYXRvcikpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHBhcnNlci5wb3NpdGlvbiA9IG1hcms7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWFkcyAuLi8uLi8uLi9cblx0XHRcdCAqIEByZXR1cm5zIFRydWUgaWYgYXQgbGVhc3Qgb25lIHJldHJhY3Rpb24gd2FzIHJlYWQsIG90aGVyd2lzZSBmYWxzZS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcmVhZFJldHJhY3Rpb25zKClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdG9rZW4gPSBVcmlTeW50YXgucmV0cmFjdCArIFVyaVN5bnRheC5jb21wb25lbnRTZXBhcmF0b3I7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghcGFyc2VyLnJlYWQodG9rZW4pKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0cmFjdGlvbkNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZXRyYWN0aW9uQ291bnQgPiAwO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWRzIHByb3RvOlxuXHRcdFx0ICogQXNzaWducyB0aGUgbG9jYWwgcHJvdG9jb2wgdmFyaWFibGUgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0ICogQHJldHVybnMgVHJ1cyBpZiBhIHByb3RvY29sIHdhcyBmb3VuZCwgb3RoZXJ3aXNlIGZhbHNlLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRQcm90b2NvbCgpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGxldCByYXdQcm90byA9IFwiXCI7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoVXJpU3ludGF4LnByb3RvY29sUmVsYXRpdmUpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cHJvdG9jb2wgPSBVcmlQcm90b2NvbC51bmtub3duO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjYW5jZWwgPSAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGNoYXIgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGlzVXBwZXJBc2NpaShjaGFyKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyYXdQcm90byArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIuY2hhckNvZGVBdCgwKSArIDMyKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaXNMb3dlckFzY2lpKGNoYXIpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJhd1Byb3RvICs9IGNoYXI7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY2hhciA9PT0gXCI6XCIpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmF3UHJvdG8gKz0gXCI6XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGNhbmNlbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBQcm90b2NvbHMgbmVlZCB0byBoYXZlIHRoZSAvLyBzdWZmaXggYWZ0ZXIgdGhlbSAuLi4gZm9yIG5vdy5cblx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChcIi8vXCIpKVxuXHRcdFx0XHRcdHJldHVybiBjYW5jZWwoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiAocHJvdG9jb2wgPSByYXdQcm90bykgIT09IFwiXCI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZHMgdGhlIHN0b3JlIHNpZGUgb3IgdGhlIHR5cGUgc2lkZSBvZiBhIFVSSS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcmVhZENvbXBvbmVudHMoc2lkZTogXCJzdG9yZVwiIHwgXCJ0eXBlXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IG91dDogVXJpQ29tcG9uZW50W10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNhbmNlbCA9ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBjb21wID0gcmVhZENvbXBvbmVudCgpO1xuXHRcdFx0XHRcdGlmIChjb21wID09PSBudWxsKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gVVJJcyBjYW5ub3QgaGF2ZSB0eXBlLXNpZGUtb25seSBjb21wb25lbnRzIG9uIHRoZWlyIHN0b3JlIHNpZGVcblx0XHRcdFx0XHRpZiAoc2lkZSA9PT0gXCJzdG9yZVwiKVxuXHRcdFx0XHRcdFx0aWYgKGNvbXAuaW5kZXggPj0gMCB8fCBjb21wLmlzUGF0dGVybilcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhbmNlbCgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG91dC5wdXNoKGNvbXApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzaWRlID09PSBcInN0b3JlXCIgJiYgcGFyc2VyLnJlYWQoVXJpU3ludGF4LnR5cGVTZXBhcmF0b3IpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFVyaVN5bnRheC5jb21wb25lbnRTZXBhcmF0b3IpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBvdXQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZHMgYSBzaW5nbGUgVVJJIGNvbXBvbmVudC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcmVhZENvbXBvbmVudCgpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IGVuY0NoYXJzID0gXCIuXy1+JVwiLnNwbGl0KFwiXCIpO1xuXHRcdFx0XHRjb25zdCBwb3J0Q2hhciA9IFwiOlwiO1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBcIlwiO1xuXHRcdFx0XHRsZXQgcG9ydCA9IFwiXCI7XG5cdFx0XHRcdGxldCBpc1BhcnNpbmdQb3J0ID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhbm9uQ29tcCA9IG1heWJlUmVhZEFub255bW91c0NvbXBvbmVudCgpO1xuXHRcdFx0XHRpZiAoYW5vbkNvbXApXG5cdFx0XHRcdFx0cmV0dXJuIGFub25Db21wO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcXVpdCA9ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocGFyc2VyLnBlZWsoVXJpU3ludGF4LmNvbXBvbmVudFNlcGFyYXRvcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBnID0gcGFyc2VyLnJlYWRHcmFwaGVtZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChnID09PSBwb3J0Q2hhcilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoIWlzVmFsaWRIb3N0TmFtZSh2YWx1ZSkgfHwgIWlzVmFsaWRJUHY0QWRkcmVzcyh2YWx1ZSkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBxdWl0KCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlzUGFyc2luZ1BvcnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpc1BhcnNpbmdQb3J0KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmICghaXNEaWdpdChnKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHF1aXQoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cG9ydCArPSBnO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAocG9ydC5sZW5ndGggPiA1KVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcXVpdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICghZW5jQ2hhcnMuaW5jbHVkZXMoZykgJiYgIWlzVXBwZXJBc2NpaShnKSAmJiAhaXNMb3dlckFzY2lpKGcpICYmICFpc0RpZ2l0KGcpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBxdWl0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgdmFsdWUgKz0gZztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZhbHVlID09PSBcIlwiKVxuXHRcdFx0XHRcdHJldHVybiBxdWl0KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IFVyaUNvbXBvbmVudChwb3J0ID8gdmFsdWUgKyBwb3J0Q2hhciArIHBvcnQgOiB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZEFub255bW91c0NvbXBvbmVudCgpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjYW5jZWwgPSAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBhbm9uID0gcGFyc2VyLnJlYWQoVXJpU3ludGF4LmluZGV4ZXJTdGFydCk7XG5cdFx0XHRcdGlmICghYW5vbilcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoVXJpU3ludGF4LmluZGV4ZXJFbmQpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGFub24ubGVuZ3RoID4gMCA/XG5cdFx0XHRcdFx0XHRcdG5ldyBVcmlDb21wb25lbnQoYW5vbiArIFVyaVN5bnRheC5pbmRleGVyRW5kKSA6XG5cdFx0XHRcdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGcgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0aWYgKCFpc0RpZ2l0KGcpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRhbm9uICs9IGc7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBjYW5jZWwoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG1heWJlUmVhZEN1cnJlbnQoKSB8fCByZWFkUmV0cmFjdGlvbnMoKSlcblx0XHRcdHtcblx0XHRcdFx0aXNSZWxhdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChtYXliZVJlYWRQcm90b2NvbCgpKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBEbyBub3RoaW5nXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChwYXJzZXIucmVhZChVcmlTeW50YXguY29tcG9uZW50U2VwYXJhdG9yKSlcblx0XHRcdHtcblx0XHRcdFx0cHJvdG9jb2wgPSBVcmlQcm90b2NvbC5maWxlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3RvcmVzID0gcmVhZENvbXBvbmVudHMoXCJzdG9yZVwiKTtcblx0XHRcdFxuXHRcdFx0aWYgKHN0b3JlcyA9PT0gbnVsbCB8fCBzdG9yZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gVVJJIGVuZHMgd2l0aCBhIC8sIHRoaXMgaXNuJ3QgYSB2YWxpZCBVUklcblx0XHRcdGlmIChwYXJzZXIucmVhZFRoZW5UZXJtaW5hbChVcmlTeW50YXguY29tcG9uZW50U2VwYXJhdG9yKSlcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIFVSSSBlbmRzIHdpdGggYSAvLywgdGhpcyBpc24ndCBhIHZhbGlkIFVSSVxuXHRcdFx0aWYgKHBhcnNlci5yZWFkVGhlblRlcm1pbmFsKFVyaVN5bnRheC50eXBlU2VwYXJhdG9yKSlcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHR5cGVzID0gcmVhZENvbXBvbmVudHMoXCJ0eXBlXCIpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZXMgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZXMubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGJlIGRvbmUgYnkgbm93LiBcblx0XHRcdFx0Ly8gSWYgd2UncmUgbm90LCB0aGVyZSdzIHNvbWUgZ2FyYmFnZSBhdCB0aGUgXG5cdFx0XHRcdC8vIGVuZCBvZiB0aGUgVVJJLCBzdWNoIGFzIGEgZm9yd2FyZCBzbGFzaC5cblx0XHRcdFx0aWYgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZpbGUgPSBzdG9yZXNbc3RvcmVzLmxlbmd0aCAtIDFdLnZhbHVlO1xuXHRcdFx0Y29uc3QgZXh0ID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChmaWxlLmVuZHNXaXRoKFVyaUV4dGVuc2lvbi50cnV0aCkpXG5cdFx0XHRcdFx0cmV0dXJuIFVyaUV4dGVuc2lvbi50cnV0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChmaWxlLmVuZHNXaXRoKFVyaUV4dGVuc2lvbi5qcykpXG5cdFx0XHRcdFx0cmV0dXJuIFVyaUV4dGVuc2lvbi5qcztcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChmaWxlLmVuZHNXaXRoKFVyaUV4dGVuc2lvbi53YXNtKSlcblx0XHRcdFx0XHRyZXR1cm4gVXJpRXh0ZW5zaW9uLndhc207XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gVXJpRXh0ZW5zaW9uLnVua25vd247XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBJZiBhbiBleHRlbnNpb24gd2FzIGRldGVjdGVkLCB0aGUgbGFzdCBjb21wb25lbnRcblx0XHRcdC8vIGZyb20gdGhlIGVuZCBvZiB0aGUgVVJJIHNob3VsZCBiZSByZW1vdmVkLCBiZWNhdXNlXG5cdFx0XHQvLyBcInN0b3Jlc1wiIGRvZXMgbm90IGluY2x1ZGUgZmlsZSBuYW1lcy5cblx0XHRcdGlmIChleHQgIT09IFVyaUV4dGVuc2lvbi51bmtub3duKVxuXHRcdFx0XHRzdG9yZXMucG9wKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHByb3RvY29sOiBVcmlQcm90b2NvbC5yZXNvbHZlKHByb3RvY29sKSB8fCBVcmlQcm90b2NvbC51bmtub3duLFxuXHRcdFx0XHRmaWxlOiBleHQgPyBmaWxlIDogXCJcIixcblx0XHRcdFx0ZXh0LFxuXHRcdFx0XHRyZXRyYWN0aW9uQ291bnQsXG5cdFx0XHRcdGlzUmVsYXRpdmUsXG5cdFx0XHRcdHN0b3JlczogT2JqZWN0LmZyZWV6ZShzdG9yZXMpLFxuXHRcdFx0XHR0eXBlczogT2JqZWN0LmZyZWV6ZSh0eXBlcylcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIGlzVXBwZXJBc2NpaShjaGFyOiBzdHJpbmcpXG5cdHtcblx0XHRjb25zdCBwb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCkgfHwgMDtcblx0XHRyZXR1cm4gcG9pbnQgPj0gNjUgJiYgcG9pbnQgPD0gOTA7XG5cdH1cblxuXG5cdC8qKiAqL1xuXHRmdW5jdGlvbiBpc0xvd2VyQXNjaWkoY2hhcjogc3RyaW5nKVxuXHR7XG5cdFx0Y29uc3QgcG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApIHx8IDA7XG5cdFx0cmV0dXJuIHBvaW50ID49IDk3ICYmIHBvaW50IDw9IDEyMjtcblx0fVxuXG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIGlzRGlnaXQoY2hhcjogc3RyaW5nKVxuXHR7XG5cdFx0Y29uc3QgcG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApIHx8IDA7XG5cdFx0cmV0dXJuIHBvaW50ID49IDQ4ICYmIHBvaW50IDw9IDU3O1xuXHR9XG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIGlzVmFsaWRJUHY0QWRkcmVzcyhtYXliZUlQOiBzdHJpbmcpXG5cdHtcblx0XHRpZiAoIW1heWJlSVApXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XG5cdFx0Y29uc3QgaXBQYXJ0cyA9IG1heWJlSVAuc3BsaXQoXCIuXCIpLmZpbHRlcihzID0+IHMpO1xuXHRcdFxuXHRcdGlmIChpcFBhcnRzLmxlbmd0aCAhPT0gNClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRpZiAoaXBQYXJ0cy5zb21lKHMgPT4gIS9eXFxkezEsM30kLy50ZXN0KHMpKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRpZiAoaXBQYXJ0cy5zb21lKHMgPT4gcGFyc2VJbnQocywgMTApID4gMjU1KSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKiAqL1xuXHRmdW5jdGlvbiBpc1ZhbGlkSG9zdE5hbWUobWF5YmVIb3N0TmFtZTogc3RyaW5nKVxuXHR7XG5cdFx0aWYgKCFtYXliZUhvc3ROYW1lKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdGNvbnN0IGhvc3RQYXJ0cyA9IG1heWJlSG9zdE5hbWUuc3BsaXQoXCIuXCIpO1xuXHRcdGlmIChob3N0UGFydHMuc29tZShzID0+IHMubGVuZ3RoID09PSAwKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IGhvc3RQYXJ0IG9mIGhvc3RQYXJ0cylcblx0XHR7XG5cdFx0XHQvLyBOT1RFOiBUaGlzIGlzIGEgbWFrZS1zaGlmdCBob3N0IG5hbWUgdmFsaWRhdGlvblxuXHRcdFx0Ly8gbWV0aG9kLiBJdCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmdcblx0XHRcdC8vIHRoYXQgY29uZm9ybXMgdG8gdGhlIHJlbGV2YW50IFJGQyBzcGVjaWZpY2F0aW9ucy5cblx0XHRcdGNvbnN0IGhvc3RTZWdtZW50UGFydHMgPSBob3N0UGFydC5zcGxpdCgvLXwtLS8pO1xuXHRcdFx0Zm9yIChjb25zdCBob3N0U2VnbWVudFBhcnQgb2YgaG9zdFNlZ21lbnRQYXJ0cylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGhvc3RTZWdtZW50UGFydC5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBjcCBvZiBbLi4uaG9zdFNlZ21lbnRQYXJ0XS5tYXAocyA9PiBzLmNvZGVQb2ludEF0KDApKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghY3AgfHwgIShcblx0XHRcdFx0XHRcdGNwID49IDQ4ICYmIGNwIDw9IDU3IHx8XG5cdFx0XHRcdFx0XHRjcCA+PSA2NSAmJiBjcCA8PSA5MCB8fFxuXHRcdFx0XHRcdFx0Y3AgPj0gOTcgJiYgY3AgPD0gMTIyIHx8XG5cdFx0XHRcdFx0XHRjcCA+PSAxMjggJiYgY3AgPD0gMTY1IHx8XG5cdFx0XHRcdFx0XHRjcCA+PSAyNTUpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHRjb25zdCBoYXNoUmVnZXggPSBuZXcgUmVnRXhwKFwiW2EtZjAtOV17XCIgKyBIYXNoLmxlbmd0aCArIFwifVwiLCBcImlcIik7XG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2luZ2xlIGNvbXBvbmVudCBvZiBhIFVyaS5cblx0ICogSGFuZGxlZCBlbmNvZGluZyBhbmQgZGVjb2Rpbmcgb2YgdGhlIHVuZGVybHlpbmcgdmFsdWUuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVXJpQ29tcG9uZW50XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3RvcihyYXc6IHN0cmluZylcblx0XHR7XG5cdFx0XHR0aGlzLmlzUmV0cmFjdCA9IHJhdyA9PT0gXCIuLlwiO1xuXHRcdFx0dGhpcy5pc0N1cnJlbnQgPSByYXcgPT09IFwiLlwiO1xuXHRcdFx0dGhpcy5oYXNoID0gdGhpcy50cnlFeHRyYWN0SGFzaChyYXcpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmF3Lmxlbmd0aCA+IDIpXG5cdFx0XHRcdGlmIChyYXdbMF0gPT09IFVyaVN5bnRheC5pbmRleGVyU3RhcnQpXG5cdFx0XHRcdFx0aWYgKHJhd1tyYXcubGVuZ3RoIC0gMV0gPT09IFVyaVN5bnRheC5pbmRleGVyRW5kKVxuXHRcdFx0XHRcdFx0aWYgKC9cXGQrLy50ZXN0KHJhdy5zbGljZSgxLCAtMSkpKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmluZGV4ID0gK3Jhdy5zbGljZSgxLCAtMSk7XG5cdFx0XHRcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmluZGV4ID49IDAgP1xuXHRcdFx0XHR0aGlzLmluZGV4LnRvU3RyaW5nKCkgOlxuXHRcdFx0XHR1bmVzY2FwZShyYXcpO1xuXHRcdFx0XG5cdFx0XHRPYmplY3QuZnJlZXplKHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHRyeUV4dHJhY3RIYXNoKHRleHQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCBkZWxpbSA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW47XG5cdFx0XHRjb25zdCBkZWxpbUVzYyA9IGVzY2FwZShkZWxpbSk7XG5cdFx0XHRjb25zdCBkZWxpbUxlbiA9XG5cdFx0XHRcdHRleHQuc3RhcnRzV2l0aChkZWxpbSkgPyBkZWxpbS5sZW5ndGggOlxuXHRcdFx0XHR0ZXh0LnN0YXJ0c1dpdGgoZGVsaW1Fc2MpID8gZGVsaW1Fc2MubGVuZ3RoIDpcblx0XHRcdFx0LTE7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGhhc2hMZW4gPSBIYXNoLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0aWYgKGRlbGltTGVuIDwgMCB8fCB0ZXh0Lmxlbmd0aCA8IGRlbGltTGVuICsgaGFzaExlbiArIDEpXG5cdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBoYXNoID0gdGV4dC5zdWJzdHIoZGVsaW1MZW4sIGhhc2hMZW4pO1xuXHRcdFx0aWYgKGhhc2gubGVuZ3RoICE9PSBoYXNoTGVuIHx8ICFoYXNoUmVnZXgudGVzdChoYXNoKSlcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH1cblx0XHRcblx0XHQvKiogU3RvcmVzIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgcmVwcmVzZW50cyBhIHBhdHRlcm4uICovXG5cdFx0Z2V0IGlzUGF0dGVybigpIHsgcmV0dXJuIHRoaXMuaGFzaCAhPT0gXCJcIjsgfVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgd2hldGhlciB0aGlzIGNvbXBvbmVudCBpcyB0aGUgcmV0cmFjdGlvbiBpbmRpY2F0b3IgKC4uKSAqL1xuXHRcdHJlYWRvbmx5IGlzUmV0cmFjdDogYm9vbGVhbjtcblx0XHRcblx0XHQvKiogU3RvcmVzIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgaXMgdGhlIGN1cnJlbnQgaW5kaWNhdG9yICguKSAqL1xuXHRcdHJlYWRvbmx5IGlzQ3VycmVudDogYm9vbGVhbjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBudW1iZXIgdGhhdCBpbmRpY2F0ZXMgYSB0eXBlIGluZGV4IHRoYXQgdGhpcyBVcmlDb21wb25lbnQsIFxuXHRcdCAqIHJlZmVycyB0bywgdXNlZCBpbiB0aGUgY2FzZSB3aGVuIHRoaXMgVXJpQ29tcG9uZW50IGlzIHJlZmVycmluZyB0b1xuXHRcdCAqIGFuIGFub255bW91cyB0eXBlLlxuXHRcdCAqIFxuXHRcdCAqIFN0b3JlcyAtMSBpbiB0aGUgY2FzZSB3aGVuIGFuIGluZGV4IHZhbHVlIGlzIG5vdCByZWxldmFudCB0byB0aGlzXG5cdFx0ICogVXJpQ29tcG9uZW50IGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGluZGV4OiBudW1iZXIgPSAtMTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGRlY29kZWQgdGV4dCB2YWx1ZSBvZiB0aGlzIFVyaUNvbXBvbmVudC5cblx0XHQgKiBTdG9yZXMgYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgLmluZGV4IHByb3BlcnR5IGluIHRoZSBjYXNlIHdoZW5cblx0XHQgKiBpdCBpcyBncmVhdGVyIHRoYW4gLTEuXG5cdFx0ICogVGhpcyBoYXMgdGhlIHNhbWUgdmFsdWUgYXMgdGhlIHJlc3VsdCBvZiB0aGUgLnRvU3RyaW5nKCkgbWV0aG9kLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHZhbHVlOiBzdHJpbmcgPSBcIlwiO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHBhdHRlcm4gaGFzaCwgaW4gdGhlIGNhc2Ugd2hlbiB0aGlzIFVyaUNvbXBvbmVudFxuXHRcdCAqIHJlbGF0ZXMgdG8gYSBwYXR0ZXJuLiBTdG9yZXMgYW4gZW1wdHkgc3RyaW5nIGluIG90aGVyIGNhc2VzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgaGFzaDogc3RyaW5nID0gXCJcIjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgcmF3IGRlY29kZWQgdGV4dCB2YWx1ZSBvZiB0aGlzIFVyaUNvbXBvbmVudC5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBVUkwgZW5jb2RlZCB0ZXh0IHZhbHVlIG9mIHRoaXMgVXJpQ29tcG9uZW50LlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nRW5jb2RlZCgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaXNQYXR0ZXJuKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBkZSA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW47XG5cdFx0XHRcdHJldHVybiBkZSArIGVzY2FwZSh0aGlzLnZhbHVlLnNsaWNlKGRlLmxlbmd0aCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pbmRleCA+PSAwKVxuXHRcdFx0XHRyZXR1cm4gVXJpU3ludGF4LmluZGV4ZXJTdGFydCArIHRoaXMuaW5kZXggKyBVcmlTeW50YXguaW5kZXhlckVuZDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGVzY2FwZSh0aGlzLnZhbHVlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIHRleHQgdmFsdWUgb2YgdGhpcyBVcmlDb21wb25lbnQsIHVzaW5nIGFuXG5cdFx0ICogZW5jb2RpbmcgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUkZDIDM5ODYgaG9zdCBuYW1lLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nSG9zdCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBVUkwoXCJodHRwOi8vXCIgKyB0aGlzLnZhbHVlKS5ob3N0O1xuXHRcdH1cblx0fVxuXG5cdGRlY2xhcmUgY29uc3QgVVJMOiB0eXBlb2YgaW1wb3J0KFwidXJsXCIpLlVSTDtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKiAqL1xuXHRleHBvcnQgY29uc3QgVXJpUmVhZGVyID0gbmV3IGNsYXNzIFVyaVJlYWRlclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCB0aGUgY29udGVudHMgb2YgdGhlIGdpdmVuIFVSSS5cblx0XHQgKiBJZiBhbiBlcnJvciBpcyBnZW5lcmF0ZWQgd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYSBmaWxlIFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24sIHRoZSBlcnJvcnMgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0YXN5bmMgdHJ5UmVhZCh1cmk6IFVyaSlcblx0XHR7XG5cdFx0XHRpZiAodXJpLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5maWxlKVxuXHRcdFx0XHRyZXR1cm4gYXdhaXQgcmVhZEZpbGUodXJpLnRvU3RvcmVTdHJpbmcoKSk7XG5cdFx0XHRcblx0XHRcdGVsc2UgaWYgKHVyaS5wcm90b2NvbCA9PT0gVXJpUHJvdG9jb2wuaHR0cCB8fFxuXHRcdFx0XHR1cmkucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmh0dHBzKVxuXHRcdFx0XHRyZXR1cm4gYXdhaXQgRmV0Y2guZXhlYyh1cmkudG9TdG9yZVN0cmluZygpKTtcblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0fVxuXHR9KCk7XG5cblxuXHQvKiogKi9cblx0Y29uc3QgZmlsZUV4aXN0cyA9IChwYXRoOiBzdHJpbmcpID0+XG5cdFx0bmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUsIHJlamVjdCkgPT5cblx0XHR7XG5cdFx0XHRGcy5tb2R1bGUuZXhpc3RzKHBhdGgsIHJlc29sdmUpO1xuXHRcdH0pO1xuXG5cblx0LyoqICovXG5cdGNvbnN0IHJlYWRGaWxlID0gKHBhdGg6IHN0cmluZywgb3B0cyA9IFwidXRmOFwiKSA9PlxuXHRcdG5ldyBQcm9taXNlPHN0cmluZyB8IEVycm9yPihyZXNvbHZlID0+XG5cdFx0e1xuXHRcdFx0RnMubW9kdWxlLnJlYWRGaWxlKHBhdGgsIG9wdHMsIChlcnJvciwgZGF0YSkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmVzb2x2ZShlcnJvciAmJiBlcnJvci5lcnJubyA/XG5cdFx0XHRcdFx0ZXJyb3IgOlxuXHRcdFx0XHRcdGRhdGEgfHwgXCJcIik7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXG5cdC8qKiAqL1xuXHRjb25zdCB3cml0ZUZpbGUgPSAocGF0aDogc3RyaW5nLCBkYXRhOiBzdHJpbmcsIG9wdHMgPSBcInV0ZjhcIikgPT5cblx0XHRuZXcgUHJvbWlzZTxudWxsIHwgRXJyb3I+KHJlc29sdmUgPT5cblx0XHR7XG5cdFx0XHRGcy5tb2R1bGUud3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdHMsIGVycm9yID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJlc29sdmUoZXJyb3IgfHwgbnVsbCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IHN0b3JlcyBsYW5ndWFnZSBzeW50YXggdG9rZW5zLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gU3ludGF4XG5cdHtcblx0XHR0YWIgPSBcIlxcdFwiLFxuXHRcdHNwYWNlID0gXCIgXCIsXG5cdFx0dGVybWluYWwgPSBcIlxcblwiLFxuXHRcdGNvbWJpbmF0b3IgPSBcIixcIixcblx0XHRqb2ludCA9IFwiOlwiLFxuXHRcdGxpc3QgPSBcIi4uLlwiLFxuXHRcdGVzY2FwZUNoYXIgPSBcIlxcXFxcIixcblx0XHRjb21tZW50ID0gXCIvL1wiXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFVyaVN5bnRheFxuXHR7XG5cdFx0cmV0cmFjdCA9IFwiLi5cIixcblx0XHRjdXJyZW50ID0gXCIuXCIsXG5cdFx0Y29tcG9uZW50U2VwYXJhdG9yID0gXCIvXCIsXG5cdFx0dHlwZVNlcGFyYXRvciA9IFwiLy9cIixcblx0XHRwcm90b2NvbFJlbGF0aXZlID0gXCIvL1wiLFxuXHRcdGluZGV4ZXJTdGFydCA9IFwiW1wiLFxuXHRcdGluZGV4ZXJFbmQgPSBcIl1cIixcblx0fVxuXG5cblx0LyoqXG5cdCAqIEEgY29uc3RhbnQgZW51bWVyYXRpb25zIHRoYXQgc3RvcmVzIHRoZSB2YWxpZCBleHRlbnNpb25zXG5cdCAqIHRoYXQgbXVzdCBiZSBwcmVzZW50IGluIGEgcGFyc2FibGUgVVJJLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gVXJpRXh0ZW5zaW9uXG5cdHtcblx0XHR1bmtub3duID0gXCJcIixcblx0XHR0cnV0aCA9IFwiLnRydXRoXCIsXG5cdFx0anMgPSBcIi50cnV0aC5qc1wiLFxuXHRcdHdhc20gPSBcIi50cnV0aC53YXNtXCJcblx0fVxuXG5cblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIHRoZSBlc2NhcGUgc2VxdWVuY2VzXG5cdCAqIHRoYXQgb25seSBtYXRjaCBhIHNpbmdsZSBraW5kIG9mIGNoYXJhY3Rlci4gXCJTaWduXCIgaW5cblx0ICogdGhpcyBjYXNlIHJlZmVycyB0byB0aGUgZmFjdCB0aGF0IHRoZXNlIGFyZSBlc2NhcGVcblx0ICogc2VxdWVuY2VzIHRoYXQgcmVmZXIgdG8gYW5vdGhlciBjaGFyYWN0ZXIuXG5cdCAqL1xuXHRleHBvcnQgZW51bSBSZWdleFN5bnRheFNpZ25cblx0e1xuXHRcdHRhYiA9IFwiXFxcXHRcIixcblx0XHRsaW5lRmVlZCA9IFwiXFxcXG5cIixcblx0XHRjYXJyaWFnZVJldHVybiA9IFwiXFxcXHJcIixcblx0XHRlc2NhcGVkRmluYWxpemVyID0gXCJcXFxcL1wiLFxuXHRcdGJhY2tzbGFzaCA9IFwiXFxcXFxcXFxcIlxuXHR9XG5cblx0ZXhwb3J0IG5hbWVzcGFjZSBSZWdleFN5bnRheFNpZ25cblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgUmVnZXhTeW50YXhTaWduIG1lbWJlciBmcm9tIHRoZVxuXHRcdCAqIHNwZWNpZmllZCBzaWduIGxpdGVyYWwgKGV4OiBcIlxcdFwiKSBvciByYXcgc2lnbmFibGVcblx0XHQgKiBjaGFyYWN0ZXIgKGV4OiBcIlx0XCIpLlxuXHRcdCAqL1xuXHRcdGV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKHZhbHVlOiBzdHJpbmcpOiBSZWdleFN5bnRheFNpZ24gfCBudWxsXG5cdFx0e1xuXHRcdFx0aWYgKHZhbHVlLmxlbmd0aCA8IDEgfHwgdmFsdWUubGVuZ3RoID4gMilcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHZhbHMgPSA8c3RyaW5nW10+T2JqZWN0LnZhbHVlcyhSZWdleFN5bnRheFNpZ24pO1xuXHRcdFx0Y29uc3QgaWR4ID0gdmFscy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdHJldHVybiBpZHggPCAwID8gbnVsbCA6IDxSZWdleFN5bnRheFNpZ24+dmFsc1tpZHhdO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRleHBvcnQgZnVuY3Rpb24gdW5lc2NhcGUodmFsdWU6IHN0cmluZylcblx0XHR7XG5cdFx0XHRzd2l0Y2ggKHZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4U2lnbi50YWI6IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCg5KTtcblx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheFNpZ24ubGluZUZlZWQ6IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCgxMCk7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLmNhcnJpYWdlUmV0dXJuOiByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoMTMpO1xuXHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4U2lnbi5lc2NhcGVkRmluYWxpemVyOiByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoNDcpO1xuXHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4U2lnbi5iYWNrc2xhc2g6IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCg5Mik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIHRoZSBlc2NhcGUgc2VxdWVuY2VzXG5cdCAqIHRoYXQgY2FuIG1hdGNoIG1vcmUgdGhhbiBvbmUga2luZCBvZiBjaGFyYWN0ZXIuXG5cdCAqL1xuXHRleHBvcnQgZW51bSBSZWdleFN5bnRheEtub3duU2V0XG5cdHtcblx0XHRkaWdpdCA9IFwiXFxcXGRcIixcblx0XHRkaWdpdE5vbiA9IFwiXFxcXERcIixcblx0XHRhbHBoYW51bWVyaWMgPSBcIlxcXFx3XCIsXG5cdFx0YWxwaGFudW1lcmljTm9uID0gXCJcXFxcV1wiLFxuXHRcdHdoaXRlc3BhY2UgPSBcIlxcXFxzXCIsXG5cdFx0d2hpdGVzcGFjZU5vbiA9IFwiXFxcXFNcIixcblx0XHR3aWxkID0gXCIuXCIsXG5cdH1cblxuXHRleHBvcnQgbmFtZXNwYWNlIFJlZ2V4U3ludGF4S25vd25TZXRcblx0e1xuXHRcdGNvbnN0IHZhbHMgPSA8c3RyaW5nW10+T2JqZWN0LnZhbHVlcyhSZWdleFN5bnRheEtub3duU2V0KTtcblx0XHRcblx0XHRleHBvcnQgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZTogc3RyaW5nKTogUmVnZXhTeW50YXhLbm93blNldCB8IG51bGxcblx0XHR7XG5cdFx0XHRjb25zdCBpZHggPSB2YWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0cmV0dXJuIGlkeCA8IDAgPyBudWxsIDogPFJlZ2V4U3ludGF4S25vd25TZXQ+dmFsc1tpZHhdO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIHRoZSBkZWxpbWl0ZXJzIGF2YWlsYWJsZVxuXHQgKiBpbiB0aGUgc3lzdGVtJ3MgcmVndWxhciBleHByZXNzaW9uIGZsYXZvci5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFJlZ2V4U3ludGF4RGVsaW1pdGVyXG5cdHtcblx0XHRtYWluID0gXCIvXCIsXG5cdFx0dXRmMTZHcm91cFN0YXJ0ID0gXCJcXFxcdXtcIixcblx0XHR1dGYxNkdyb3VwRW5kID0gXCJ9XCIsXG5cdFx0Z3JvdXBTdGFydCA9IFwiKFwiLFxuXHRcdGdyb3VwRW5kID0gXCIpXCIsXG5cdFx0YWx0ZXJuYXRvciA9IFwifFwiLFxuXHRcdHNldFN0YXJ0ID0gXCJbXCIsXG5cdFx0c2V0RW5kID0gXCJdXCIsXG5cdFx0cXVhbnRpZmllclN0YXJ0ID0gXCJ7XCIsXG5cdFx0cXVhbnRpZmllckVuZCA9IFwifVwiLFxuXHRcdHF1YW50aWZpZXJTZXBhcmF0b3IgPSBcIixcIixcblx0XHRyYW5nZSA9IFwiLVwiLFxuXHR9XG5cblxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBzdG9yZXMgbWlzY2VsbGFuZW91cyByZWd1bGFyXG5cdCAqIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgZG9uJ3QgZml0IGludG9cblx0ICogdGhlIG90aGVyIGVudW1lcmF0aW9ucy5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIFJlZ2V4U3ludGF4TWlzY1xuXHR7XG5cdFx0c3RhciA9IFwiKlwiLFxuXHRcdHBsdXMgPSBcIitcIixcblx0XHRuZWdhdGUgPSBcIl5cIixcblx0XHRyZXN0cmFpbmVkID0gXCI/XCIsXG5cdFx0Ym91bmRhcnkgPSBcIlxcXFxiXCIsXG5cdFx0Ym91bmRhcnlOb24gPSBcIlxcXFxCXCIsXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IHN0b3JlcyB0aGUgZGVsaW1pdGVycyBhdmFpbGFibGVcblx0ICogaW4gdGhlIGluZml4IHN5bnRheC5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIEluZml4U3ludGF4XG5cdHtcblx0XHRzdGFydCA9IFwiPFwiLFxuXHRcdGVuZCA9IFwiPlwiLFxuXHRcdG5vbWluYWxTdGFydCA9IFwiPDxcIixcblx0XHRub21pbmFsRW5kID0gXCI+PlwiLFxuXHRcdHBhdHRlcm5TdGFydCA9IFwiPC9cIixcblx0XHRwYXR0ZXJuRW5kID0gXCIvPlwiXG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgbWFuYWdlcyB0aGUgZGlhZ25vc3RpY3MgdGhhdCBoYXZlIGJlZW4gXG5cdCAqIHJlcG9ydGVkIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcHJvZ3JhbS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGYXVsdFNlcnZpY2Vcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHQvLyBMaXN0ZW4gZm9yIGludmFsaWRhdGlvbnMgYW5kIGNsZWFyIG91dCBhbnkgZmF1bHRzXG5cdFx0XHQvLyB0aGF0IGNvcnJlc3BvbmQgdG8gb2JqZWN0cyB0aGF0IGRvbid0IGV4aXN0IGluIHRoZVxuXHRcdFx0Ly8gZG9jdW1lbnQgYW55bW9yZS4gXG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VJbnZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnBhcmVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBzbXQuZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQoc210LCB0cnVlKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVTdGF0ZW1lbnRGYXVsdHMoc3RhdGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBkYXRhLmRvY3VtZW50LmVhY2hEZXNjZW5kYW50KCkpXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVTdGF0ZW1lbnRGYXVsdHMoc3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuaW5FZGl0VHJhbnNhY3Rpb24gPSB0cnVlO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VFZGl0Q29tcGxldGUsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuaW5FZGl0VHJhbnNhY3Rpb24gPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBpbkVkaXRUcmFuc2FjdGlvbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYWxsIGZhdWx0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZW1vdmVTdGF0ZW1lbnRGYXVsdHMoc3RhdGVtZW50OiBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0dGhpcy5idWZmZXJGcmFtZS5yZW1vdmVTb3VyY2Uoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHN0YXRlbWVudC5hbGxTcGFucylcblx0XHRcdFx0dGhpcy5idWZmZXJGcmFtZS5yZW1vdmVTb3VyY2Uoc3Bhbik7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIHN0YXRlbWVudC5pbmZpeFNwYW5zKVxuXHRcdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLnJlbW92ZVNvdXJjZShpbmZpeFNwYW4pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBFbnVtZXJhdGVzIHRocm91Z2ggdGhlIHVucmVjdGlmaWVkIGZhdWx0cyByZXRhaW5lZFxuXHRcdCAqIGJ5IHRoaXMgRmF1bHRTZXJ2aWNlLlxuXHRcdCAqL1xuXHRcdCplYWNoKClcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNTb3J0ZWQgPSBcblx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLmFzeW5jRnJhbWUuZmF1bHRzLnZhbHVlcygpKVxuXHRcdFx0XHRcdC5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLnZpc2libGVGcmFtZS5mYXVsdHMudmFsdWVzKCkpKVxuXHRcdFx0XHRcdC5tYXAoZmF1bHRNYXAgPT4gQXJyYXkuZnJvbShmYXVsdE1hcC52YWx1ZXMoKSkpXG5cdFx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuXHRcdFx0XHRcdC5zb3J0KChhLCBiKSA9PiBhLmxpbmUgLSBiLmxpbmUpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0IG9mIGZhdWx0c1NvcnRlZClcblx0XHRcdFx0eWllbGQgZmF1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2Zcblx0XHQgKiB1bnJlY3RpZmllZCBmYXVsdHMgcmV0YWluZWQgYnkgdGhpcyBGYXVsdFNlcnZpY2UuXG5cdFx0ICovXG5cdFx0Z2V0IGNvdW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy52aXNpYmxlRnJhbWUuZmF1bHRzLnNpemU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlcG9ydHMgYSBmYXVsdC4gSWYgYSBzaW1pbGFyIEZhdWx0IG9uIHRoZSBzYW1lIGFyZWFcblx0XHQgKiBvZiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gcmVwb3J0ZWQsIHRoZSBtZXRob2Rcblx0XHQgKiBydW5zIHRoZSBGYXVsdFJlcG9ydGVkIGhvb2suXG5cdFx0ICovXG5cdFx0cmVwb3J0KGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLmFkZEZhdWx0KGZhdWx0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwb3J0cyBhIGZhdWx0IG91dHNpZGUgdGhlIGNvbnRleHQgb2YgYW4gZWRpdCB0cmFuc2FjdGlvbi5cblx0XHQgKiBUaGlzIG1ldGhvZCBpcyB0byBiZSB1c2VkIGZvciBmYXVsdHMgdGhhdCBhcmUgcmVwb3J0ZWQgaW5cblx0XHQgKiBhc3luY2hyb25vdXMgY2FsbGJhY2tzLCBzdWNoIGFzIG5ldHdvcmsgZXJyb3JzLlxuXHRcdCAqL1xuXHRcdHJlcG9ydEFzeW5jKGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLmFkZEZhdWx0KGZhdWx0KTtcblx0XHRcdFxuXHRcdFx0aWYgKCF0aGlzLmluRWRpdFRyYW5zYWN0aW9uKVxuXHRcdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzXG5cdFx0ICogRmF1bHRTZXJ2aWNlIHJldGFpbnMgYSBmYXVsdCB0aGF0IGlzIHNpbWlsYXIgdG8gdGhlIHNwZWNpZmllZFxuXHRcdCAqIGZhdWx0IChtZWFuaW5nIHRoYXQgaXQgaGFzIHRoZSBzYW1lIGNvZGUgYW5kIHNvdXJjZSkuXG5cdFx0ICovXG5cdFx0aGFzKHNpbWlsYXJGYXVsdDogRmF1bHQpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCByZXRhaW5lZEZhdWx0IG9mIHRoaXMuZWFjaCgpKVxuXHRcdFx0XHRpZiAocmV0YWluZWRGYXVsdC50eXBlLmNvZGUgPT09IHNpbWlsYXJGYXVsdC50eXBlLmNvZGUpXG5cdFx0XHRcdFx0aWYgKHJldGFpbmVkRmF1bHQuc291cmNlID09PSBzaW1pbGFyRmF1bHQuc291cmNlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgRmF1bHQgb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiByZXBvcnRlZFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgc291cmNlLiBJZiB0aGUgc291cmNlIGhhcyBubyBmYXVsdHMsIGFuIGVtcHR5XG5cdFx0ICogYXJyYXkgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0Y2hlY2s8VFNvdXJjZSBleHRlbmRzIG9iamVjdD4oc291cmNlOiBUU291cmNlKTogRmF1bHQ8VFNvdXJjZT5bXVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dDogRmF1bHQ8VFNvdXJjZT5bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJldGFpbmVkRmF1bHQgb2YgdGhpcy5lYWNoKCkpXG5cdFx0XHRcdGlmIChyZXRhaW5lZEZhdWx0LnNvdXJjZSA9PT0gc291cmNlKVxuXHRcdFx0XHRcdG91dC5wdXNoKDxGYXVsdDxUU291cmNlPj5yZXRhaW5lZEZhdWx0KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogVXNlZCBpbnRlcm5hbGx5IHRvIGluZm9ybSB0aGUgRmF1bHRTZXJ2aWNlIHRoYXQgdHlwZS1sZXZlbCBmYXVsdFxuXHRcdCAqIGFuYWx5c2lzIGlzIGJlaW5nIGRvbmUgb24gdGhlIHByb3ZpZGVkIE5vZGUuIFRoaXMgaXMgbmVjZXNzYXJ5XG5cdFx0ICogYmVjYXVzZSB0eXBlLWxldmVsIGZhdWx0cyBkbyBub3QgbGl2ZSBiZXlvbmQgYSBzaW5nbGUgZWRpdCBmcmFtZSxcblx0XHQgKiBzbyB0aGUgRmF1bHRTZXJ2aWNlIG5lZWRzIHRvIGtub3cgd2hpY2ggTm9kZXMgd2VyZSBhbmFseXplZFxuXHRcdCAqIHNvIHRoYXQgbmV3bHkgcmVjdGlmaWVkIGZhdWx0cyBjYW4gYmUgY2xlYXJlZCBvdXQuXG5cdFx0ICogXG5cdFx0ICogV2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGFueSB0aGUgZmF1bHRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG5cdFx0ICogc3BlY2lmaWVkIE5vZGUgYXJlIGNsZWFyZWQgb3V0LCBhbmQgYXJlIG9ubHkgYWRkZWQgYmFjayBpbiBpZlxuXHRcdCAqIHRoZXkgd2VyZSByZS1kZXRlY3RlZCBkdXJpbmcgdGhpcyBlZGl0IHRyYW5zYWN0aW9uLlxuXHRcdCAqL1xuXHRcdGluZm9ybShub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNtdHMgPSBub2RlLnN0YXRlbWVudHMuZmlsdGVyKHNtdCA9PiAhc210LmlzRGlzcG9zZWQpO1xuXHRcdFx0XG5cdFx0XHQvLyBDbGVhciBvdXQgYW55IHN0YXRlbWVudC1sZXZlbCBmYXVsdHMgdGhhdCB0b3VjaCB0aGUgbm9kZVxuXHRcdFx0Zm9yIChjb25zdCBzbXQgb2Ygc210cylcblx0XHRcdFx0dGhpcy5idWZmZXJGcmFtZS5yZW1vdmVTb3VyY2Uoc210KTtcblx0XHRcdFx0XG5cdFx0XHQvLyBDbGVhciBvdXQgYW55IHNwYW4tbGV2ZWwgZmF1bHRzIHRoYXQgdG91Y2ggdGhlIG5vZGVcblx0XHRcdGNvbnN0IHNwYW5zID0gc210c1xuXHRcdFx0XHQubWFwKHNtdCA9PiBzbXQuc3BhbnMpXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucylcblx0XHRcdFx0dGhpcy5idWZmZXJGcmFtZS5yZW1vdmVTb3VyY2Uoc3Bhbik7XG5cdFx0XHRcblx0XHRcdC8vIENsZWFyIG91dCBhbnkgaW5maXgtbGV2ZWwgZmF1bHRzIHRoYXQgdG91Y2ggdGhlIG5vZGVcblx0XHRcdGNvbnN0IGluZml4ZXMgPSBzbXRzXG5cdFx0XHRcdC5tYXAoc210ID0+IHNtdC5pbmZpeFNwYW5zIHx8IFtdKVxuXHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4IG9mIGluZml4ZXMpXG5cdFx0XHRcdHRoaXMuYnVmZmVyRnJhbWUucmVtb3ZlU291cmNlKGluZml4KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICovXG5cdFx0cmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZmF1bHRzQWRkZWQ6IEZhdWx0W10gPSBbXTtcblx0XHRcdGNvbnN0IGZhdWx0c1JlbW92ZWQ6IEZhdWx0W10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBtYXAgb2YgdGhpcy5idWZmZXJGcmFtZS5mYXVsdHMudmFsdWVzKCkpXG5cdFx0XHRcdGZvciAoY29uc3QgZmF1bHQgb2YgbWFwLnZhbHVlcygpKVxuXHRcdFx0XHRcdGlmICghdGhpcy52aXNpYmxlRnJhbWUuaGFzRmF1bHQoZmF1bHQpKVxuXHRcdFx0XHRcdFx0ZmF1bHRzQWRkZWQucHVzaChmYXVsdCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgbWFwIG9mIHRoaXMudmlzaWJsZUZyYW1lLmZhdWx0cy52YWx1ZXMoKSlcblx0XHRcdFx0Zm9yIChjb25zdCBmYXVsdCBvZiBtYXAudmFsdWVzKCkpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmJ1ZmZlckZyYW1lLmhhc0ZhdWx0KGZhdWx0KSlcblx0XHRcdFx0XHRcdGZhdWx0c1JlbW92ZWQucHVzaChmYXVsdCk7XG5cdFx0XHRcblx0XHRcdHRoaXMudmlzaWJsZUZyYW1lID0gdGhpcy5idWZmZXJGcmFtZTtcblx0XHRcdHRoaXMuYnVmZmVyRnJhbWUgPSB0aGlzLmJ1ZmZlckZyYW1lLmNsb25lKCk7XG5cdFx0XHRcblx0XHRcdGlmIChmYXVsdHNBZGRlZC5sZW5ndGggKyBmYXVsdHNSZW1vdmVkLmxlbmd0aCA+IDApXG5cdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VGYXVsdENoYW5nZShcblx0XHRcdFx0XHRmYXVsdHNBZGRlZCxcblx0XHRcdFx0XHRmYXVsdHNSZW1vdmVkKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgZmF1bHRzIHRoYXQgYXJlIHByZXNlbnRlZCB0byBleHRlcm5hbCBjb25zdW1lclxuXHRcdCAqIG9mIHRoZSBmYXVsdCBzZXJ2aWNlIHdoZW4gdGhleSB1c2UgdGhlIGFjY2Vzc29yIG1ldGhvZHMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB2aXNpYmxlRnJhbWUgPSBuZXcgRmF1bHRGcmFtZSgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgZmF1bHRzIHRoYXQgaGF2ZSBiZWVuIGJ1aWx0IHVwIGR1cmluZyBhbiBlZGl0IHRyYW5zYWN0aW9uLlxuXHRcdCAqIFRoZXNlIGZhdWx0cyBhcmUgY29waWVkIHRvIHRoZSBgdmlzaWJsZUZyYW1lYCB3aGVuIHRoZSBlZGl0XG5cdFx0ICogdHJhbnNhY3Rpb24gY29tcGxldGVzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYnVmZmVyRnJhbWUgPSBuZXcgRmF1bHRGcmFtZSgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgZmF1bHRzIHRoYXQgd2VyZSByZXBvcnRlZCBhc3luY2hyb25vdXNseSwgYW5kIHRoZXJlZm9yZVxuXHRcdCAqIGFyZSBub3QgYm91bmQgdG8gYW55IGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBhc3luY0ZyYW1lID0gbmV3IEZhdWx0RnJhbWUoKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0Y2xhc3MgRmF1bHRGcmFtZVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y2xvbmUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG5ld0ZyYW1lID0gbmV3IEZhdWx0RnJhbWUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbZmF1bHRTb3VyY2UsIGV4aXN0aW5nTWFwXSBvZiB0aGlzLmZhdWx0cylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV3TWFwOiBURmF1bHRNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IFtjb2RlLCBmYXVsdF0gb2YgZXhpc3RpbmdNYXApXG5cdFx0XHRcdFx0bmV3TWFwLnNldChjb2RlLCBmYXVsdCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRuZXdGcmFtZS5mYXVsdHMuc2V0KGZhdWx0U291cmNlLCBuZXdNYXApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3RnJhbWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFkZEZhdWx0KGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNGb3JTb3VyY2UgPSB0aGlzLmZhdWx0cy5nZXQoZmF1bHQuc291cmNlKTtcblx0XHRcdGlmIChmYXVsdHNGb3JTb3VyY2UpXG5cdFx0XHR7XG5cdFx0XHRcdGZhdWx0c0ZvclNvdXJjZS5zZXQoZmF1bHQudHlwZS5jb2RlLCBmYXVsdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcDogVEZhdWx0TWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRtYXAuc2V0KGZhdWx0LnR5cGUuY29kZSwgZmF1bHQpO1xuXHRcdFx0XHR0aGlzLmZhdWx0cy5zZXQoZmF1bHQuc291cmNlLCBtYXApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZW1vdmVTb3VyY2Uoc291cmNlOiBURmF1bHRTb3VyY2UpXG5cdFx0e1xuXHRcdFx0dGhpcy5mYXVsdHMuZGVsZXRlKHNvdXJjZSk7XG5cdFx0XHRcblx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpXG5cdFx0XHRcdGZvciAoY29uc3QgY3J1ZnRPYmplY3Qgb2Ygc291cmNlLmNydWZ0T2JqZWN0cylcblx0XHRcdFx0XHR0aGlzLmZhdWx0cy5kZWxldGUoY3J1ZnRPYmplY3QpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZW1vdmVGYXVsdChmYXVsdDogRmF1bHQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZmF1bHRzRm9yU291cmNlID0gdGhpcy5mYXVsdHMuZ2V0KGZhdWx0LnNvdXJjZSk7XG5cdFx0XHRpZiAoZmF1bHRzRm9yU291cmNlKVxuXHRcdFx0XHRmYXVsdHNGb3JTb3VyY2UuZGVsZXRlKGZhdWx0LnR5cGUuY29kZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGhhc0ZhdWx0KGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNGb3JTb3VyY2UgPSB0aGlzLmZhdWx0cy5nZXQoZmF1bHQuc291cmNlKTtcblx0XHRcdHJldHVybiBmYXVsdHNGb3JTb3VyY2UgP1xuXHRcdFx0XHRmYXVsdHNGb3JTb3VyY2UuaGFzKGZhdWx0LnR5cGUuY29kZSkgOlxuXHRcdFx0XHRmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBkb3VibHktbmVzdGVkIG1hcCBvZiBmYXVsdCBzb3VyY2VzLCBmYXVsdCBjb2RlcywgYW5kIHRoZSBhY3R1YWwgZmF1bHQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZmF1bHRzID0gbmV3IE1hcDxURmF1bHRTb3VyY2UsIFRGYXVsdE1hcD4oKTtcblx0fVxuXG5cdHR5cGUgVEZhdWx0TWFwID0gTWFwPG51bWJlciwgRmF1bHQ+O1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgdHlwZSB0aGF0IGRlc2NyaWJlcyB0aGUgcG9zc2libGUgb2JqZWN0cyB3aXRoaW4gYSBkb2N1bWVudFxuXHQgKiB0aGF0IG1heSBiZSByZXNwb25zaWJsZSBmb3IgdGhlIGdlbmVyYXRpb24gb2YgYSBmYXVsdC5cblx0ICovXG5cdGV4cG9ydCB0eXBlIFRGYXVsdFNvdXJjZSA9IFN0YXRlbWVudCB8IFNwYW4gfCBJbmZpeFNwYW47XG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEZhdWx0PFRTb3VyY2UgPSBURmF1bHRTb3VyY2U+XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKiAqL1xuXHRcdFx0cmVhZG9ubHkgdHlwZTogRmF1bHRUeXBlPFRTb3VyY2U+LFxuXHRcdFx0XG5cdFx0XHQvKiogVGhlIGRvY3VtZW50IG9iamVjdCB0aGF0IGNhdXNlZCB0aGUgZmF1bHQgdG8gYmUgcmVwb3J0ZWQuICovXG5cdFx0XHRyZWFkb25seSBzb3VyY2U6IFRTb3VyY2UsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIHRoYXQgY29udGFpbnMgbW9yZSBpbi1kZXB0aCBkZXRhaWxcblx0XHRcdCAqIG9mIHRoZSBmYXVsdCB0aGF0IG9jY3VyZWQsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBtZXNzYWdlLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBhZGRpdGlvbmFsRGV0YWlsOiBzdHJpbmcgPSBcIlwiKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMuc291cmNlO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgKzEncyBhcmUgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIGRlYWwgd2l0aCB0aGUgZmFjdCB0aGF0XG5cdFx0XHQvLyBtb3N0IGVkaXRvcnMgYXJlIDEtYmFzZWQgd2hlcmVhcyB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cblx0XHRcdC8vIG9mIHN0YXRlbWVudCBzdHJpbmdzIGFyZSAwLWJhc2VkLlxuXHRcdFx0XG5cdFx0XHRpZiAoc3JjIGluc3RhbmNlb2YgU3RhdGVtZW50KVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBUaGUgVGFic0FuZFNwYWNlcyBmYXVsdCBpcyB0aGUgb25seSBmYXVsdCB0aGF0IG5lZWRzIGFcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIHdoZXJlIGl0IGhhcyBhIGRpZmZlcmVudCByZXBvcnRpbmcgbG9jYXRpb24uXG5cdFx0XHRcdHRoaXMucmFuZ2UgPSB0eXBlLmNvZGUgPT09IEZhdWx0cy5UYWJzQW5kU3BhY2VzLmNvZGUgP1xuXHRcdFx0XHRcdFsxLCBzcmMuaW5kZW50ICsgMV0gOlxuXHRcdFx0XHRcdFtzcmMuaW5kZW50ICsgMSwgc3JjLnNvdXJjZVRleHQubGVuZ3RoICsgMV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBTcGFuIHx8IHNyYyBpbnN0YW5jZW9mIEluZml4U3Bhbilcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5yYW5nZSA9IFtcblx0XHRcdFx0XHRzcmMuYm91bmRhcnkub2Zmc2V0U3RhcnQgKyAxLFxuXHRcdFx0XHRcdHNyYy5ib3VuZGFyeS5vZmZzZXRFbmQgKyAxXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydHMgdGhpcyBmYXVsdCBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLFxuXHRcdCAqIHN1aXRhYmxlIGZvciBvdXRwdXQgYXMgYW4gZXJyb3IgbWVzc2FnZS5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZG9jID0gdGhpcy5kb2N1bWVudDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYXZvaWRQcm90b2NvbHMgPSBbXG5cdFx0XHRcdFVyaVByb3RvY29sLmludGVybmFsLFxuXHRcdFx0XHRVcmlQcm90b2NvbC5ub25lLFxuXHRcdFx0XHRVcmlQcm90b2NvbC51bmtub3duXG5cdFx0XHRdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gYXZvaWRQcm90b2NvbHMuaW5jbHVkZXMoZG9jLnNvdXJjZVVyaS5wcm90b2NvbCkgP1xuXHRcdFx0XHRcIlwiIDogZG9jLnNvdXJjZVVyaS50b1N0b3JlU3RyaW5nKCkgKyBcIiBcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29sTnVtcyA9IHRoaXMucmFuZ2Uuam9pbihcIi1cIik7XG5cdFx0XHRjb25zdCBjb2xUZXh0ID0gY29sTnVtcyA/IFwiLCBDb2wgXCIgKyBjb2xOdW1zIDogXCJcIjtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGAke3RoaXMudHlwZS5tZXNzYWdlfSAoJHt1cmlUZXh0fUxpbmUgJHt0aGlzLmxpbmV9JHtjb2xUZXh0fSlgO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBEb2N1bWVudCBpbiB3aGljaCB0aGlzIEZhdWx0IHdhcyBkZXRlY3RlZC5cblx0XHQgKi9cblx0XHRnZXQgZG9jdW1lbnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXRlbWVudC5kb2N1bWVudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgU3RhdGVtZW50IGluIHdoaWNoIHRoaXMgRmF1bHQgd2FzIGRldGVjdGVkLlxuXHRcdCAqL1xuXHRcdGdldCBzdGF0ZW1lbnQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMuc291cmNlO1xuXHRcdFx0cmV0dXJuIE5vdC5udWxsKFxuXHRcdFx0XHRzcmMgaW5zdGFuY2VvZiBTdGF0ZW1lbnQgPyBzcmMgOlxuXHRcdFx0XHRzcmMgaW5zdGFuY2VvZiBTcGFuID8gc3JjLnN0YXRlbWVudCA6XG5cdFx0XHRcdHNyYyBpbnN0YW5jZW9mIEluZml4U3BhbiA/IHNyYy5zdGF0ZW1lbnQgOlxuXHRcdFx0XHRudWxsKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgbGluZSBudW1iZXIgb2YgdGhlIFN0YXRlbWVudCBpbiB3aGljaCB0aGlzIEZhdWx0IHdhcyBkZXRlY3RlZC5cblx0XHQgKi9cblx0XHRnZXQgbGluZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210ID0gdGhpcy5zdGF0ZW1lbnQ7XG5cdFx0XHRyZXR1cm4gc210LmRvY3VtZW50LmdldExpbmVOdW1iZXIoc210KSArIDE7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIGNoYXJhY3RlciBvZmZzZXRzXG5cdFx0ICogd2l0aGluIHRoZSBTdGF0ZW1lbnQgaW4gd2hpY2ggdGhpcyBGYXVsdCB3YXMgZGV0ZWN0ZWQuIFRoZSBjaGFyYWN0ZXJcblx0XHQgKiBvZmZzZXRzIGFyZSAxLWJhc2VkIChub3QgMC1iYXNlZCkgdG8gY29tcGx5IHdpdGggdGhlIGJlaGF2aW91ciBvZiBcblx0XHQgKiBtb3N0IHRleHQgZWRpdG9ycy5cblx0XHQgKi9cblx0XHRyZWFkb25seSByYW5nZTogbnVtYmVyW107XG5cdH1cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRmF1bHRUeXBlPFRTb3VyY2UgPSBURmF1bHRTb3VyY2U+XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogQW4gZXJyb3IgY29kZSwgdXNlZnVsIGZvciByZWZlcmVuY2UgcHVycG9zZXMsIG9yIGRpc3BsYXkgaW4gYSB1c2VyIGludGVyZmFjZS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgY29kZTogbnVtYmVyLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBmYXVsdC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgbWVzc2FnZTogc3RyaW5nLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgc2V2ZXJpdHk6IEZhdWx0U2V2ZXJpdHkpXG5cdFx0e1xuXHRcdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZS50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBmYXVsdCBvZiB0aGlzIHR5cGUuXG5cdFx0ICovXG5cdFx0Y3JlYXRlKHNvdXJjZTogVFNvdXJjZSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IEZhdWx0PFRTb3VyY2U+KHRoaXMsIHNvdXJjZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBmb2xsb3dpbmcgZGVmaW5pdGlvbnMgYXJlIGludGVudGlvbmFsbHkgZXF1aXZhbGVudFxuXHQgKiB0byB0aGUgc2V2ZXJpdHkgY29kZXMgZnJvbSB0aGUgbW9uYWNvIGVkaXRvci5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBlbnVtIEZhdWx0U2V2ZXJpdHlcblx0e1xuXHRcdC8qKiBVbnVzZWQuICovXG5cdFx0aGludCA9IDEsXG5cdFx0XG5cdFx0LyoqIFVudXNlZC4gKi9cblx0XHRpbmZvID0gMixcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIHNldmVyaXR5IG9mIGEgZmF1bHQgaXMgXCJ3YXJuaW5nXCIsIHdoaWNoIG1lYW5zIHRoYXRcblx0XHQgKiB0aGUgYXNzb2NpYXRlZCBvYmplY3Qgd2lsbCBzdGlsbCBiZSBwcm9jZXNzZWQgZHVyaW5nIHR5cGUgYW5hbHlzaXMuXG5cdFx0ICovXG5cdFx0d2FybmluZyA9IDQsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBzZXZlcml0eSBvZiBhIGZhdWx0IGlzIFwiZXJyb3JcIiwgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdCAqIHRoZSBhc3NvY2lhdGVkIG9iamVjdCB3aWxsIGJlIGlnbm9yZWQgZHVyaW5nIHR5cGUgYW5hbHlzaXMuXG5cdFx0ICovXG5cdFx0ZXJyb3IgPSA4XG5cdH1cblxuXHQvKipcblx0ICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgZnJvemVuIGZhdWx0IGluc3RhbmNlcy5cblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUZhdWx0PFQ+KFxuXHRcdGNvZGU6IG51bWJlcixcblx0XHRtZXNzYWdlOiBzdHJpbmcsXG5cdFx0c2V2ZXJpdHkgPSBGYXVsdFNldmVyaXR5LmVycm9yKVxuXHR7XG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUobmV3IEZhdWx0VHlwZTxUPihjb2RlLCBtZXNzYWdlLCBzZXZlcml0eSkpO1xuXHR9XG5cblx0Y29uc3QgcXVhbnRpZmllcnMgPSBcblx0XHRgKCR7UmVnZXhTeW50YXhNaXNjLnN0YXJ9LCBcblx0XHQke1JlZ2V4U3ludGF4TWlzYy5wbHVzfSxcblx0XHQke1JlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJTdGFydH0uLiR7UmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllckVuZH0pYDtcblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgRmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVhY2goKVxuXHRcdHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IDxGYXVsdFR5cGU8b2JqZWN0PltdPk9iamVjdC52YWx1ZXMoRmF1bHRzKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBmYXVsdFR5cGUgb2YgdmFsdWVzKVxuXHRcdFx0XHRpZiAoZmF1bHRUeXBlIGluc3RhbmNlb2YgRmF1bHRUeXBlKVxuXHRcdFx0XHRcdHlpZWxkIGZhdWx0VHlwZTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBGYXVsdFR5cGUgaW5zdGFuY2Vcblx0XHQgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGZhdWx0IHdpdGggdGhlIHNwZWNpZmllZCBjb2RlLCBhc1xuXHRcdCAqIHdlbGwgYXMgdGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLiBJbiB0aGUgY2FzZSB3aGVuIHRoZVxuXHRcdCAqIGZhdWx0Q29kZSB3YXMgbm90IGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdG5hbWVPZihmYXVsdENvZGU6IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBlbnRyaWVzID0gPFtzdHJpbmcsIEZhdWx0VHlwZTxvYmplY3Q+XVtdPk9iamVjdC5lbnRyaWVzKEZhdWx0cyk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW25hbWUsIHR5cGVdIG9mIGVudHJpZXMpXG5cdFx0XHRcdGlmICh0eXBlIGluc3RhbmNlb2YgRmF1bHRUeXBlKVxuXHRcdFx0XHRcdGlmICh0eXBlLmNvZGUgPT09IGZhdWx0Q29kZSlcblx0XHRcdFx0XHRcdHJldHVybiBuYW1lO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9LFxuXHRcdFxuXHRcdC8vIyBSZXNvdXJjZS1yZWxhdGVkIGZhdWx0c1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFVucmVzb2x2ZWRSZXNvdXJjZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMCxcblx0XHRcdFwiVVJJIHBvaW50cyB0byBhIHJlc291cmNlIHRoYXQgY291bGQgbm90IGJlIHJlc29sdmVkLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRDaXJjdWxhclJlc291cmNlUmVmZXJlbmNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAyLFxuXHRcdFx0XCJVUkkgcG9pbnRzIHRvIGEgcmVzb3VyY2UgdGhhdCB3b3VsZCBjYXVzZSBhIGNpcmN1bGFyIHJlZmVyZW5jZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5zZWN1cmVSZXNvdXJjZVJlZmVyZW5jZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwNCxcblx0XHRcdGBEb2N1bWVudHMgbG9hZGVkIGZyb20gcmVtb3RlIGxvY2F0aW9uc1xuXHRcdFx0Y2Fubm90IHJlZmVyZW5jZSBkb2N1bWVudHMgc3RvcmVkIGxvY2FsbHkuYCksXG5cdFx0XG5cdFx0Ly8jIFR5cGUgdmVyaWZpY2F0aW9uIGZhdWx0c1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFVucmVzb2x2ZWRBbm5vdGF0aW9uOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDIwMSxcblx0XHRcdFwiVW5yZXNvbHZlZCBhbm5vdGF0aW9uLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRDaXJjdWxhclR5cGVSZWZlcmVuY2U6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MjAzLFxuXHRcdFx0XCJDaXJjdWxhciB0eXBlIHJlZmVyZW5jZSBkZXRlY3RlZC5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Q29udHJhY3RWaW9sYXRpb246IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQvLyEgQ0hBTkdFIFRISVMgVE8gMjA0XG5cdFx0XHQyMDUsXG5cdFx0XHRcIk92ZXJyaWRkZW4gdHlwZXMgbXVzdCBleHBsaWNpdGx5IGV4cGFuZCB0aGUgdHlwZSBhcyBkZWZpbmVkIGluIHRoZSBiYXNlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRUeXBlQ2Fubm90QmVSZWZyZXNoZWQ6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQyMDYsXG5cdFx0XHRgVGhpcyB0eXBlIGNhbm5vdCBiZSByZWZyZXNoZWQsIGJlY2F1c2Ugb25lIG9yIG1vcmUgYmFzZVxuXHRcdFx0dHlwZXMgYXJlIGltcG9zaW5nIGEgc3BlY2lmaWMgdHlwZSBjb250cmFjdCBvbiBpdC4gQ29uc2lkZXJcblx0XHRcdG9taXR0aW5nIHRoZSAke1N5bnRheC5qb2ludH0gb3BlcmF0b3IgaGVyZS5gLFxuXHRcdFx0RmF1bHRTZXZlcml0eS53YXJuaW5nKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJZ25vcmVkQW5ub3RhdGlvbjogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQyMDcsXG5cdFx0XHRgVGhpcyBhbm5vdGF0aW9uIGlzIGlnbm9yZWQgYmVjYXVzZSBhbm90aGVyIGFubm90YXRpb25cblx0XHRcdGluIHRoaXMgc3RhdGVtZW50IHJlc29sdmVzIHRvIHRoZSBzYW1lIHR5cGUuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SWdub3JlZEFsaWFzOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDIwOSxcblx0XHRcdGBBbGlhc2VzIChtZWFuaW5nIGFubm90YXRpb25zIHRoYXQgYXJlIG1hdGNoZWQgYnkgcGF0dGVybnMpXG5cdFx0XHRjYW4ndCBiZSBhZGRlZCBvbnRvIHR5cGVzIHRoYXQgaGF2ZSBhIGNvbnRyYWN0IHB1dCBpbiBwbGFjZVxuXHRcdFx0YnkgYSBiYXNlIHR5cGUuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VHlwZVNlbGZSZWZlcmVudGlhbDogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQyMTEsXG5cdFx0XHRcIlR5cGVzIGNhbm5vdCBiZSBzZWxmLXJlZmVyZW50aWFsXCIpLFxuXHRcdFxuXHRcdC8vIyBMaXN0LXJlbGF0ZWQgZmF1bHRzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0QW5vbnltb3VzSW5MaXN0SW50cmluc2ljOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MzAwLFxuXHRcdFx0XCJUeXBlcyBjb250YWluZWQgZGlyZWN0bHkgYnkgTGlzdC1pbnRyaW5zaWMgdHlwZXMgY2Fubm90IGJlIGFub255bW91cy5cIixcblx0XHRcdEZhdWx0U2V2ZXJpdHkud2FybmluZyksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0TGlzdENvbnRyYWN0VmlvbGF0aW9uOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDMwMSxcblx0XHRcdFwiVGhlIGNvbnRhaW5pbmcgbGlzdCBjYW5ub3QgY29udGFpbiBjaGlsZHJlbiBvZiB0aGlzIHR5cGUuXCIsXG5cdFx0XHRGYXVsdFNldmVyaXR5Lndhcm5pbmcpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdExpc3RJbnRyaW5zaWNFeHRlbmRpbmdMaXN0OiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDMwMyxcblx0XHRcdFwiTGlzdCBpbnRyaW5zaWMgdHlwZXMgY2Fubm90IGV4dGVuZCBmcm9tIG90aGVyIGxpc3RzLlwiKSxcblx0XHRcblx0XHQvKiogKFRoaXMgaXMgdGhlIHNhbWUgdGhpbmcgYXMgYSBsaXN0IGRpbWVuc2lvbmFsaXR5IGNvbmZsaWN0KSAqL1xuXHRcdExpc3RFeHRyaW5zaWNFeHRlbmRpbmdOb25MaXN0OiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDMwNSxcblx0XHRcdFwiTGlzdHMgY2Fubm90IGV4dGVuZCBmcm9tIG5vbi1saXN0cy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0TGlzdERpbWVuc2lvbmFsRGlzY3JlcGFuY3lGYXVsdDogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQzMDcsXG5cdFx0XHRgQSB1bmlvbiBjYW5ub3QgYmUgY3JlYXRlZCBiZXR3ZWVuIHRoZXNlIHR3byB0eXBlc1xuXHRcdFx0YmVjYXVzZSB0aGV5IGFyZSBsaXN0cyBvZiBkaWZmZXJlbnQgZGltZW5zaW9ucy5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRMaXN0QW5ub3RhdGlvbkNvbmZsaWN0OiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDMwOSxcblx0XHRcdGBBbGwgZnJhZ21lbnRzIG9mIHRoaXMgYW5ub3RhdGlvbiBuZWVkIHRvIGhhdmVcblx0XHRcdGEgbGlzdCBvcGVyYXRvciAoJHtTeW50YXgubGlzdH0pYCksXG5cdFx0XG5cdFx0Ly8jIFBhdHRlcm4tcmVsYXRlZCBmYXVsdHNcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuSW52YWxpZDogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQwMCxcblx0XHRcdFwiSW52YWxpZCBwYXR0ZXJuLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuV2l0aG91dEFubm90YXRpb246IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MDIsXG5cdFx0XHRcIlBhdHRlcm4gaGFzIG5vIGFubm90YXRpb25zLlwiLFxuXHRcdFx0RmF1bHRTZXZlcml0eS53YXJuaW5nKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuQ2FuTWF0Y2hFbXB0eTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQwNCxcblx0XHRcdFwiUGF0dGVybnMgbXVzdCBub3QgYmUgYWJsZSB0byBtYXRjaCBhbiBlbXB0eSBpbnB1dC5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybk1hdGNoaW5nVHlwZXNBbHJlYWR5RXhpc3RzOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDA2LFxuXHRcdFx0YEEgcGF0dGVybiBtYXRjaGluZyB0aGVzZSB0eXBlcyBoYXMgXG5cdFx0XHRhbHJlYWR5IGJlZW4gZGVmaW5lZCBpbiB0aGlzIHNjb3BlLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5NYXRjaGluZ0xpc3Q6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0NDA3LFxuXHRcdFx0XCJBIHBhdHRlcm4gY2Fubm90IG1hdGNoIGEgbGlzdCB0eXBlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuQ2FuTWF0Y2hXaGl0ZXNwYWNlT25seTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQyMCxcblx0XHRcdFwiUGF0dGVybnMgbXVzdCBub3QgYmUgYWJsZSB0byBtYXRjaCBhbiBpbnB1dCBcIiArXG5cdFx0XHRcImNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5BY2NlcHRzTGVhZGluZ1doaXRlc3BhY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MjIsXG5cdFx0XHRcIlBhdHRlcm5zIG11c3Qgbm90IGJlIGFibGUgdG8gbWF0Y2ggYW4gaW5wdXQgXCIgK1xuXHRcdFx0XCJjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuUmVxdWlyZXNMZWFkaW5nV2hpdGVzcGFjZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQyNCxcblx0XHRcdFwiUGF0dGVybnMgbXVzdCBub3QgYmUgYWJsZSB0byBtYXRjaCBhbiBpbnB1dCBcIiArXG5cdFx0XHRcImNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5BY2NlcHRzVHJhaWxpbmdXaGl0ZXNwYWNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDI2LFxuXHRcdFx0XCJQYXR0ZXJucyBtdXN0IG5vdCBiZSBhYmxlIHRvIG1hdGNoIGFuIGlucHV0IFwiICtcblx0XHRcdFwiY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVyblJlcXVpcmVzVHJhaWxpbmdXaGl0ZXNwYWNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDI4LFxuXHRcdFx0XCJQYXR0ZXJucyBtdXN0IG5vdCBiZSBhYmxlIHRvIG1hdGNoIGFuIGlucHV0IFwiICtcblx0XHRcdFwiY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybk5vbkNvdmFyaWFudDogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQ0MCxcblx0XHRcdFwiUGF0dGVybiBkb2VzIG5vdCBtYXRjaCBpdCdzIGJhc2UgdHlwZXMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5QYXJ0aWFsV2l0aENvbWJpbmF0b3I6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0NDIsXG5cdFx0XHRcIlBhcnRpYWwgcGF0dGVybnMgY2Fubm90IGV4cGxpY2l0bHkgbWF0Y2ggdGhlIGNvbW1hIGNoYXJhY3Rlci5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybnNGb3JtRGlzY3JlcGFudFVuaW9uOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDQ5OSxcblx0XHRcdFwiQSB1bmlvbiBjYW5ub3QgYmUgY3JlYXRlZCBiZXR3ZWVuIHRoZXNlIHR5cGVzIGJlY2F1c2UgdGhlaXIgXCIgKyBcblx0XHRcdFwiYXNzb2NpYXRlZCBwYXR0ZXJucyBjb25mbGljdCB3aXRoIGVhY2ggb3RoZXIuXCIpLFxuXHRcdFxuXHRcdC8vIyBJbmZpeCByZWxhdGVkXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhIYXNRdWFudGlmaWVyOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0Ly8vMCxcblx0XHRcdDUwMCxcblx0XHRcdGBJbmZpeGVzIGNhbm5vdCBoYXZlIHF1YW50aWZpZXJzICR7cXVhbnRpZmllcnN9IGFwcGxpZWQgdG8gdGhlbWApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4SGFzRHVwbGljYXRlSWRlbnRpZmllcjogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzAsXG5cdFx0XHQ1MDEsXG5cdFx0XHRcIkluZml4ZXMgY2Fubm90IGhhdmUgZHVwbGljYXRlIGlkZW50aWZpZXJzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeEhhc1NlbGZSZWZlcmVudGlhbFR5cGU6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MTAsXG5cdFx0XHQ1MDMsXG5cdFx0XHRcIkluZml4ZXMgY2Fubm90IGJlIHNlbGYtcmVmZXJlbnRpYWwuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4Tm9uQ29udmFyaWFudDogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQxMixcblx0XHRcdDUwNSxcblx0XHRcdFwiSW5maXhlcyBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB0aGVpciBiYXNlcy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhDYW5ub3REZWZpbmVOZXdUeXBlczogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQyMixcblx0XHRcdDUwNyxcblx0XHRcdGBBIHR5cGUgcmVmZXJlbmNlZCBpbiBhbiBpbmZpeCBtdXN0IGJlIGNvbnRhaW5lZFxuXHRcdFx0YnkgdGhlIHBhdHRlcm4gc3RhdGVtZW50IGRpcmVjdGx5LCBvciBiZSBjb250YWluZWRcblx0XHRcdGJ5IG9uZSBvZiBpdCdzIG1hdGNoZWQgYmFzZXMuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhSZWZlcmVuY2VkVHlwZU11c3RIYXZlUGF0dGVybjogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQxNCxcblx0XHRcdDUwOSxcblx0XHRcdFwiVHlwZXMgYXBwbGllZCB0byBhbiBpbmZpeCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWQgcGF0dGVybi5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhSZWZlcmVuY2VkVHlwZUNhbm5vdEJlUmVjdXJzaXZlOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDE2LFxuXHRcdFx0NTExLFxuXHRcdFx0XCJUeXBlcyBhcHBsaWVkIHRvIGFuIGluZml4IG11c3Qgbm90IGNyZWF0ZSBhIHJlY3Vyc2l2ZSBzdHJ1Y3R1cmUuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4Q29udHJhY3RWaW9sYXRpb246IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MjQsXG5cdFx0XHQ1MTMsXG5cdFx0XHRcIkluZml4IHR5cGUgYW5ub3RhdGlvbnMgbXVzdCBleHBsaWNpdGx5IGV4cGFuZCB0aGUgdHlwZSBhcyBkZWZpbmVkIGJ5IHRoZSBiYXNlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeFBvcHVsYXRpb25DaGFpbmluZzogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQyNixcblx0XHRcdDUxNSxcblx0XHRcdFwiUG9wdWxhdGlvbiBpbmZpeGVzIGNhbm5vdCBoYXZlIG11bHRpcGxlIGRlY2xhcmF0aW9ucy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhVc2luZ0xpc3RPcGVyYXRvcjogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzAsXG5cdFx0XHQ1MTcsXG5cdFx0XHRgSW5maXggaWRlbnRpZmllcnMgY2Fubm90IGVuZCB3aXRoIHRoZSBsaXN0IG9wZXJhdG9yICgke1N5bnRheC5saXN0fSkuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhSZWZlcmVuY2luZ0xpc3Q6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MjgsXG5cdFx0XHQ1MTksXG5cdFx0XHRcIkluZml4ZXMgY2Fubm90IHJlZmVyZW5jZSBsaXN0IHR5cGVzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQb3J0YWJpbGl0eUluZml4SGFzTXVsdGlwbGVEZWZpbml0aW9uczogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQxOCxcblx0XHRcdDUyMSxcblx0XHRcdGBQb3J0YWJpbGl0eSBpbmZpeGVzIHdpdGggY29tcGF0aWJsZSB0eXBlcyBjYW5ub3Rcblx0XHRcdGJlIHNwZWNpZmllZCBtb3JlIHRoYW4gb25jZS5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQb3J0YWJpbGl0eUluZml4SGFzVW5pb246IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MTgsXG5cdFx0XHQ1MjMsXG5cdFx0XHRcIlBvcnRhYmlsaXR5IGluZml4ZXMgd2l0aCB1bmlvbmVkIHR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkIGF0IHRoaXMgdGltZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UG9wdWxhdGlvbkluZml4SGFzTXVsdGlwbGVEZWZpbml0aW9uczogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzAsXG5cdFx0XHQ1MjUsXG5cdFx0XHRgRGVjbGFyYXRpb25zIGluIGEgcG9wdWxhdGlvbiBpbmZpeCBjYW5ub3QgYmUgXG5cdFx0XHRkZWZpbmVkIHR3aWNlIGluIHRoZSBzYW1lIHBhdHRlcm5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHROb21pbmFsSW5maXhNdXN0U3VidHlwZTogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQvLy80MzAsXG5cdFx0XHQ1MjcsXG5cdFx0XHRcIlBhdHRlcm5zIHdpdGggbm9taW5hbCBpbmZpeGVzIHJlcXVpcmUgYW4gaW5wdXQgdGhhdCBpcyBcIiArXG5cdFx0XHRcImEgc3VidHlwZSBvZiB0aGUgdHlwZSBzcGVjaWZpZWQsIG5vdCB0aGUgdHlwZSBpdHNlbGYuXCIpLFxuXHRcdFxuXHRcdC8vIyBQYXJzZSBlcnJvcnNcblx0XHRcblx0XHQvKiogKi9cblx0XHRTdGF0ZW1lbnRCZWdpbnNXaXRoQ29tbWE6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ2MDAsXG5cdFx0XHRcIlN0YXRlbWVudHMgY2Fubm90IGJlZ2luIHdpdGggYSBjb21tYS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0U3RhdGVtZW50QmVnaW5zV2l0aEVsbGlwc2lzOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NjAyLFxuXHRcdFx0XCJTdGF0ZW1lbnRzIGNhbm5vdCBiZWdpbiB3aXRoIGFuIGVsbGlwc2lzICguLi4pLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRTdGF0ZW1lbnRCZWdpbnNXaXRoRXNjYXBlZFNwYWNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NjA0LFxuXHRcdFx0XCJTdGF0ZW1lbnRzIGNhbm5vdCBiZWdpbiB3aXRoIGFuIGVzY2FwZSBjaGFyYWN0ZXIgKFxcXFwpIFwiICsgXG5cdFx0XHRcInRoYXQgaXMgZm9sbG93ZWQgYnkgYSB0YWIgb3Igc3BhY2UuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFN0YXRlbWVudENvbnRhaW5zT25seUVzY2FwZUNoYXJhY3RlcjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDYwNixcblx0XHRcdFwiQSBzdGF0ZW1lbnQgY2Fubm90IGNvbnNpc3Qgb2YgYSBzaW5nbGUgZXNjYXBlIGNoYXJhY3RlciAoXFxcXClcIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0U3RhdGVtZW50QmVnaW5zV2l0aEludmFsaWRTZXF1ZW5jZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDYwOCxcblx0XHRcdFwiQSBzdGF0ZW1lbnQgY2Fubm90IGJlZ2luIHdpdGggdGhlIHNlcXVlbmNlczogLyosIC8rLCBvciAvP1wiKSxcblx0XHRcblx0XHQvLyMgUGFyc2luZyBGYXVsdHNcblx0XHRcblx0XHQvKiogKi9cblx0XHRUYWJzQW5kU3BhY2VzOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwMCxcblx0XHRcdFwiU3RhdGVtZW50IGluZGVudCBjb250YWlucyBhIG1peHR1cmUgb2YgdGFicyBhbmQgc3BhY2VzLlwiLFxuXHRcdFx0RmF1bHRTZXZlcml0eS53YXJuaW5nKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHREdXBsaWNhdGVEZWNsYXJhdGlvbjogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQxMDAxLFxuXHRcdFx0XCJEdXBsaWNhdGVkIGRlY2xhcmF0aW9uLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRVbnRlcm1pbmF0ZWRDaGFyYWN0ZXJTZXQ6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDAyLFxuXHRcdFx0YFVudGVybWluYXRlZCBjaGFyYWN0ZXIgc2V0LiBQYXR0ZXJuIGhhcyBhbiBvcGVuaW5nXG5cdFx0XHRcIiR7UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0U3RhcnR9XCIgY2hhcmFjdGVyIHdpdGhvdXQgYSBtYXRjaGluZ1xuXHRcdFx0XCIke1JlZ2V4U3ludGF4RGVsaW1pdGVyLnNldEVuZH1cIiBjaGFyYWN0ZXIuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VW50ZXJtaW5hdGVkR3JvdXA6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDA0LFxuXHRcdFx0YFVudGVybWluYXRlZCBncm91cC4gUGF0dGVybiBoYXMgYW4gb3BlbmluZ1xuXHRcdFx0XCIke1JlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwU3RhcnR9XCIgY2hhcmFjdGVyIHdpdGhvdXQgYSBtYXRjaGluZ1xuXHRcdFx0XCIke1JlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kfVwiIGNoYXJhY3Rlci5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHREdXBsaWNhdGVRdWFudGlmaWVyOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwNixcblx0XHRcdGBNdWx0aXBsZSBjb25zZWN1dGl2ZSBxdWFudGlmaWVycyAke3F1YW50aWZpZXJzfSBhcmUgbm90IGFsbG93ZWQuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VW50ZXJtaW5hdGVkSW5maXg6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDA4LFxuXHRcdFx0YFVudGVybWluYXRlZCBpbmZpeC4gUGF0dGVybiBoYXMgYW4gb3BlbmluZyAke0luZml4U3ludGF4LnN0YXJ0fSxcblx0XHRcdCR7SW5maXhTeW50YXgubm9taW5hbFN0YXJ0fSwgJHtJbmZpeFN5bnRheC5wYXR0ZXJuU3RhcnR9IGRlbGltaXRlciB3aXRob3V0XG5cdFx0XHRhIG1hdGNoaW5nIGNsb3NpbmcgZGVsaW1pdGVyLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEVtcHR5UGF0dGVybjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMTAsXG5cdFx0XHRcIlBhdHRlcm4gaGFzIG5vIG1hdGNoYWJsZSBjb250ZW50LlwiKVxuXHR9KTtcblxuXG5cdC8vIEFkZGl0aW9uYWwgc2FmZXR5XG5cdEFycmF5LmZyb20oRmF1bHRzLmVhY2goKSkuZXZlcnkoT2JqZWN0LmZyZWV6ZSk7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogSW5maW5pdGUgaW5jcmVtZW50YWwgY291bnRlci5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBWZXJzaW9uU3RhbXBcblx0e1xuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBuZXh0KClcblx0XHR7XG5cdFx0XHRjb25zdCBjcmVhdGVTdGFtcCA9IChzdGFtcDogVFN0YW1wTnVtYmVyKSA9PlxuXHRcdFx0XHRuZXcgVmVyc2lvblN0YW1wKE9iamVjdC5mcmVlemUoc3RhbXApKTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLm5leHRTdGFtcCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVTdGFtcCh0aGlzLm5leHRTdGFtcCA9IEJpZ0ludCgxKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8xMDU3NFxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5uZXh0U3RhbXAgPT09IFwiYmlnaW50XCIpXG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW1wKCsrdGhpcy5uZXh0U3RhbXApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5uZXh0U3RhbXAgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMubmV4dFN0YW1wID0gWzFdO1xuXHRcdFx0XHRcdHJldHVybiBjcmVhdGVTdGFtcCh0aGlzLm5leHRTdGFtcC5zbGljZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbnMgPSB0aGlzLm5leHRTdGFtcDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5zKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIFBvbHlmaWxsIGluZmluaXRlIG51bWJlciBjb3VudGVyIGZvciB1c2UgaW4gdGhlIFxuXHRcdFx0XHRcdC8vIGFic2VuY2Ugb2YgYSBuYXRpdmUgQmlnSW50IGltcGxlbWVudGF0aW9uLlxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBucy5sZW5ndGg7IGktLSA+IDA7KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChuc1tpXSA9PT0gOTk5Xzk5OV85OTlfOTk5KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRuc1tpXSA9IDA7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMClcblx0XHRcdFx0XHRcdFx0XHRucy51bnNoaWZ0KDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRuc1tpXSsrO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW1wKG5zLnNsaWNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgbmV4dFN0YW1wOiBUU3RhbXBOdW1iZXI7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RhbXA6IFRTdGFtcE51bWJlcikgeyB9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0bmV3ZXJUaGFuKG90aGVyU3RhbXA6IFZlcnNpb25TdGFtcClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFtcCA+IG90aGVyU3RhbXAuc3RhbXA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnN0YW1wKSA/XG5cdFx0XHRcdHRoaXMuc3RhbXAuam9pbihcIlwiKSA6XG5cdFx0XHRcdHRoaXMuc3RhbXAudG9TdHJpbmcoKTtcblx0XHR9XG5cdH1cblxuXHR0eXBlIFRTdGFtcE51bWJlciA9IGJpZ2ludCB8IHJlYWRvbmx5IGJpZ2ludFtdIHwgbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW107XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQWxwaGFiZXRSYW5nZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBmcm9tOiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSB0bzogbnVtYmVyKVxuXHRcdHsgfVxuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQWxwaGFiZXRcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKC4uLnJhbmdlczogQWxwaGFiZXRSYW5nZVtdKVxuXHRcdHtcblx0XHRcdHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIGRlZmluZWQgaW4gdGhlIGFscGhhYmV0LlxuXHRcdCAqL1xuXHRcdCpbU3ltYm9sLml0ZXJhdG9yXSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCByYW5nZSBvZiB0aGlzLnJhbmdlcylcblx0XHRcdFx0Zm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPD0gcmFuZ2UudG87IGkrKylcblx0XHRcdFx0XHR5aWVsZCBTdHJpbmcuZnJvbUNvZGVQb2ludChpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSXRlcmF0ZXMgdGhyb3VnaCBhbGwgZGVmaW5lZCByYW5nZXMgaW4gdGhlIGFscGhhYmV0LFxuXHRcdCAqIGV4Y2x1ZGluZyB0aGUgd2lsZGNhcmQgcmFuZ2UuXG5cdFx0ICovXG5cdFx0KmVhY2hSYW5nZSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaGFzV2lsZGNhcmQoKSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgcmFuZ2VJZHggPSAwOyByYW5nZUlkeCA8IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDE7KVxuXHRcdFx0XHRcdHlpZWxkIHRoaXMucmFuZ2VzW3JhbmdlSWR4KytdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHR5aWVsZCByYW5nZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzKHN5bWJvbDogc3RyaW5nIHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGlmIChzeW1ib2wgPT09IEFscGhhYmV0LndpbGRjYXJkKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYXNXaWxkY2FyZCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb2RlID0gdG9DaGFyQ29kZShzeW1ib2wpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHRpZiAocmFuZ2UuZnJvbSA+PSBjb2RlICYmIHJhbmdlLnRvIDw9IGNvZGUpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzV2lsZGNhcmQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJuZyA9IHRoaXMucmFuZ2VzO1xuXHRcdFx0cmV0dXJuIHJuZy5sZW5ndGggPiAwICYmIHJuZ1tybmcubGVuZ3RoIC0gMV0gPT09IEFscGhhYmV0LndpbGRjYXJkUmFuZ2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCBcblx0XHQgKiBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBzeW1ib2xzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHRzeW1ib2xzLnB1c2gocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8gP1xuXHRcdFx0XHRcdFN0cmluZy5mcm9tQ29kZVBvaW50KHJhbmdlLmZyb20pIDpcblx0XHRcdFx0XHRTdHJpbmcuZnJvbUNvZGVQb2ludChyYW5nZS5mcm9tKSArIFwiIC0gXCIgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChyYW5nZS50bykpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNXaWxkY2FyZCgpKVxuXHRcdFx0XHRzeW1ib2xzLnB1c2goQWxwaGFiZXQud2lsZGNhcmQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXCJbXCIgKyBzeW1ib2xzLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHJhbmdlczogcmVhZG9ubHkgQWxwaGFiZXRSYW5nZVtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgc3BlY2lhbCB0b2tlbiB0aGF0IHRoZSBzeXN0ZW0gdW5kZXJzdGFuZHMgdG8gYmUgdGhlXG5cdFx0ICogd2lsZGNhcmQgY2hhcmFjdGVyLiBUaGUgbGVuZ3RoIG9mIHRoZSB0b2tlbiBpcyBsb25nZXIgdGhhbiBhbnlcblx0XHQgKiBvdGhlciB0b2tlbiB0aGF0IGNvdWxkIG90aGVyd2lzZSBiZSBmb3VuZCBpbiB0aGUgYWxwaGFiZXQuXG5cdFx0ICovXG5cdFx0c3RhdGljIHJlYWRvbmx5IHdpbGRjYXJkID0gXCIoKHdpbGQpKVwiO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHJhbmdlIHRoYXQgcmVwcmVzZW50cyB0aGUgd2lsZGNhcmQgY2hhcmFjdGVyLlxuXHRcdCAqIFRoZSByYW5nZSBvZiB0aGUgd2lsZGNhcmQgaXMgcG9zaXRpdmUgaW5maW5pdHkgaW4gYm90aCBkaXJlY3Rpb25zLFxuXHRcdCAqIHRvIGVuc3VyZSB0aGF0IGl0J3MgYWx3YXlzIHNvcnRlZCBsYXN0IGluIHRoZSByYW5nZXMgYXJyYXkuXG5cdFx0ICovXG5cdFx0c3RhdGljIHJlYWRvbmx5IHdpbGRjYXJkUmFuZ2UgPSBPYmplY3QuZnJlZXplKG5ldyBBbHBoYWJldFJhbmdlKEluZmluaXR5LCBJbmZpbml0eSkpO1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgZGlzcG9zYWJsZSBjbGFzcyBmb3IgZWFzaWx5IGNyZWF0aW5nIEFscGhhYmV0IGluc3RhbmNlc1xuXHQgKiAoVGhpcyBkZXNpZ24gYXZvaWRzIGludHJvZHVjaW5nIG11dGFiaWxpdHkgaW50byB0aGUgQWxwaGFiZXQgY2xhc3MpLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEFscGhhYmV0QnVpbGRlclxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoLi4ub3RoZXJzOiAoQWxwaGFiZXQgfCBBbHBoYWJldFJhbmdlIHwgc3RyaW5nIHwgbnVtYmVyKVtdKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBvdGhlcnMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgQWxwaGFiZXQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB0aGVSYW5nZXMgPSBBcnJheS5mcm9tKGl0ZW0uZWFjaFJhbmdlKCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhlUmFuZ2VzKVxuXHRcdFx0XHRcdFx0dGhpcy5yYW5nZXMucHVzaChyYW5nZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEFscGhhYmV0UmFuZ2UpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnJhbmdlcy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGNvZGUgPSB0b0NoYXJDb2RlKGl0ZW0pO1xuXHRcdFx0XHRcdHRoaXMucmFuZ2VzLnB1c2gobmV3IEFscGhhYmV0UmFuZ2UoY29kZSwgY29kZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYW4gZW50cnkgdG8gdGhlIGFscGhhYmV0LlxuXHRcdCAqIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIHRoZSBlbnRyeSByZWZlcnMgdG8gYVxuXHRcdCAqIHNpbmdsZSBjaGFyYWN0ZXIsIHJhdGhlciB0aGFuIGEgcmFuZ2Ugb2YgY2hhcmFjdGVycy5cblx0XHQgKi9cblx0XHRhZGQoZnJvbTogc3RyaW5nIHwgbnVtYmVyLCB0bz86IHN0cmluZyB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCB0b0FzTnVtID0gdG8gPT09IHVuZGVmaW5lZCA/IGZyb20gOiB0bztcblx0XHRcdFxuXHRcdFx0dGhpcy5yYW5nZXMucHVzaChuZXcgQWxwaGFiZXRSYW5nZShcblx0XHRcdFx0dG9DaGFyQ29kZShmcm9tKSxcblx0XHRcdFx0dG9DaGFyQ29kZSh0b0FzTnVtKSkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkV2lsZCgpXG5cdFx0e1xuXHRcdFx0dGhpcy5yYW5nZXMucHVzaChBbHBoYWJldC53aWxkY2FyZFJhbmdlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBvcHRpbWl6ZWQgQWxwaGFiZXQgaW5zdGFuY2VzIGNvbXBvc2VkIFxuXHRcdCAqIGZyb20gdGhlIGNoYXJhY3RlcnMgYW5kIHJhbmdlcyBhcHBsaWVkIHRvIHRoaXMgQWxwaGFiZXRCdWlsZGVyLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBpbnZlcnQgSW4gdHJ1ZSwgY2F1c2VzIHRoZSBlbnRyaWVzIGluIHRoZSBnZW5lcmF0ZWRcblx0XHQgKiBBbHBoYWJldCB0byBiZSByZXZlcnNlZCwgc3VjaCB0aGF0IGV2ZXJ5IGNoYXJhY3RlciBtYXJrZWRcblx0XHQgKiBhcyBpbmNsdWRlZCBpcyBleGNsdWRlZCwgYW5kIHZpY2UgdmVyc2EuXG5cdFx0ICovXG5cdFx0dG9BbHBoYWJldChpbnZlcnQ/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnJhbmdlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBuZXcgQWxwaGFiZXQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmFuZ2VzID0gdGhpcy5yYW5nZXNcblx0XHRcdFx0LnNsaWNlKClcblx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG5cdFx0XHRcblx0XHRcdC8vIFF1aWNrIG9wdGltaXphdGlvbiBvZiByYW5nZXNcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aCAtIDE7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdGhpc1JhbmdlID0gcmFuZ2VzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKGkgPCByYW5nZXMubGVuZ3RoIC0gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IG5leHRSYW5nZSA9IHJhbmdlc1tpICsgMV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gT21pdFxuXHRcdFx0XHRcdGlmICh0aGlzUmFuZ2UudG8gPj0gbmV4dFJhbmdlLnRvKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJhbmdlcy5zcGxpY2UoaSArIDEsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDb25jYXRcblx0XHRcdFx0XHRlbHNlIGlmICh0aGlzUmFuZ2UudG8gKyAxID49IG5leHRSYW5nZS5mcm9tKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJhbmdlcy5zcGxpY2UoaSArIDEsIDEpO1xuXHRcdFx0XHRcdFx0cmFuZ2VzW2ldID0gbmV3IEFscGhhYmV0UmFuZ2UodGhpc1JhbmdlLmZyb20sIG5leHRSYW5nZS50byk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIE5leHRcblx0XHRcdFx0XHRlbHNlIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChpbnZlcnQpXG5cdFx0XHR7XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFRoaXMgYWxwaGFiZXQgaW52ZXJzaW9uIGFsZ29yaXRobSBoYXMgdG8gZGVhbCB3aXRoIDQgY2FzZXMsXG5cdFx0XHRcdC8vIGRlcGVuZGluZyBvbiB0aGUgcGF0dGVybiBvZiB0aGUgcmFuZ2VzIGFuZCB0aGUgc3BhY2VzLlxuXHRcdFx0XHQvLyBBZnRlciB0aGUgcmFuZ2VzIGFyZSBzb3J0ZWQgYW5kIG9wdGltaXplZCwgdGhlIHJhbmdlc1xuXHRcdFx0XHQvLyBhcnJheSByZXByZXNlbnRzIGEgbGF5b3V0IHRoYXQgYWx0ZXJuYXRlcyBiZXR3ZWVuIHJhbmdlc1xuXHRcdFx0XHQvLyBhbmQgc3BhY2VzLiBUaGVyZSBhcmUgNCBiYXNpYyBsYXlvdXRzIChSID0gUmFuZ2UsIFMgPSBTcGFjZSk6XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFJTUlMgLSBTdGFydHMgd2l0aCBhIHJhbmdlLCBlbmRzIHdpdGggYSBzcGFjZVxuXHRcdFx0XHQvLyBTUlNSIC0gU3RhcnRzIHdpdGggYSBzcGFjZSwgZW5kcyB3aXRoIGEgcmFuZ2Vcblx0XHRcdFx0Ly8gUlNSU1IgLSBTdGFydHMgd2l0aCBhIHJhbmdlLCBlbmRzIHdpdGggYSByYW5nZVxuXHRcdFx0XHQvLyBTUlNSUyAtIFN0YXJ0cyB3aXRoIGEgc3BhY2UsIGVuZHMgd2l0aCBhIHNwYWNlXG5cdFx0XHRcdC8vIFxuXHRcdFx0XHQvLyBUaGUgYWxnb3JpdGhtIGRlYWwgd2l0aCBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZVxuXHRcdFx0XHQvLyBzZXBhcmF0ZWx5LCB0byBtYWtlIHRoZSBsb29waW5nIGxlc3MgY29tcGxpY2F0ZWQuIFxuXHRcdFx0XHQvLyBcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHJhbmdlc0ludjogQWxwaGFiZXRSYW5nZVtdID0gW107XG5cdFx0XHRcdGNvbnN0IGxhc3RSYW5nZSA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXNaZXJvID0gcmFuZ2VzWzBdLmZyb20gPT09IDA7XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXNNYXggPSBsYXN0UmFuZ2UudG8gPT09IFVuaWNvZGVNYXg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobWF0Y2hlc1plcm8gJiYgbWF0Y2hlc01heCAmJiByYW5nZXMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgQWxwaGFiZXQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghbWF0Y2hlc1plcm8pXG5cdFx0XHRcdFx0cmFuZ2VzSW52LnB1c2gobmV3IEFscGhhYmV0UmFuZ2UoMCwgcmFuZ2VzWzBdLmZyb20pKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGVuZEF0ID0gbWF0Y2hlc01heCA/XG5cdFx0XHRcdFx0bGFzdFJhbmdlLmZyb20gOlxuXHRcdFx0XHRcdFVuaWNvZGVNYXg7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHByZXZSYW5nZUVuZCA9IHJhbmdlc1tpXS50bztcblx0XHRcdFx0XHRjb25zdCBuZXh0UmFuZ2VTdGFydCA9IGkgPCByYW5nZXMubGVuZ3RoIC0gMSA/IFxuXHRcdFx0XHRcdFx0cmFuZ2VzW2kgKyAxXS5mcm9tIDpcblx0XHRcdFx0XHRcdFVuaWNvZGVNYXggKyAxO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJhbmdlc0ludi5wdXNoKG5ldyBBbHBoYWJldFJhbmdlKFxuXHRcdFx0XHRcdFx0cHJldlJhbmdlRW5kICsgMSxcblx0XHRcdFx0XHRcdG5leHRSYW5nZVN0YXJ0IC0gMSkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChuZXh0UmFuZ2VTdGFydCA+PSBlbmRBdClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIW1hdGNoZXNNYXgpXG5cdFx0XHRcdFx0cmFuZ2VzSW52LnB1c2gobmV3IEFscGhhYmV0UmFuZ2UobGFzdFJhbmdlLmZyb20sIFVuaWNvZGVNYXgpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBBbHBoYWJldCguLi5yYW5nZXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHJhbmdlczogQWxwaGFiZXRSYW5nZVtdID0gW107XG5cdH1cblxuXG5cdC8qKiAqL1xuXHRmdW5jdGlvbiB0b0NoYXJDb2RlKHN5bWJvbDogc3RyaW5nIHwgbnVtYmVyKVxuXHR7XG5cdFx0cmV0dXJuIHR5cGVvZiBzeW1ib2wgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0c3ltYm9sLmNoYXJDb2RlQXQoMCkgOlxuXHRcdFx0c3ltYm9sO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVHJhbnNpdGlvbk1hcFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IodHJhbnNpdGlvbkxpdGVyYWw/OiBJVHJhbnNpdGlvbkxpdGVyYWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSBuZXcgTWFwPG51bWJlciwgVHJhbnNpdGlvblN0YXRlPigpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHJhbnNpdGlvbkxpdGVyYWwpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3N0YXRlSWRUZXh0LCB0c2xPYmplY3RdIG9mIE9iamVjdC5lbnRyaWVzKHRyYW5zaXRpb25MaXRlcmFsKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlSWQgPSBwYXJzZUludChzdGF0ZUlkVGV4dCwgMTApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzdGF0ZUlkICE9PSBzdGF0ZUlkKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghdHNsT2JqZWN0IHx8IHR5cGVvZiB0c2xPYmplY3QgIT09IFwib2JqZWN0XCIpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgdHNsOiBJVHJhbnNpdGlvblN0YXRlTGl0ZXJhbCA9IHRzbE9iamVjdDtcblx0XHRcdFx0XHR0cmFuc2l0aW9ucy5zZXQoc3RhdGVJZCwgbmV3IFRyYW5zaXRpb25TdGF0ZSh0c2wpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCpbU3ltYm9sLml0ZXJhdG9yXSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZCwgdHJhbnNpdGlvblN0YXRlXSBvZiB0aGlzLnRyYW5zaXRpb25zLmVudHJpZXMoKSlcblx0XHRcdFx0eWllbGQgPFtudW1iZXIsIFRyYW5zaXRpb25TdGF0ZV0+W3N0YXRlSWQsIHRyYW5zaXRpb25TdGF0ZV07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGNsb25lKClcblx0XHR7XG5cdFx0XHRjb25zdCBvdXQgPSBuZXcgVHJhbnNpdGlvbk1hcCh7fSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudHJhbnNpdGlvbnMpXG5cdFx0XHRcdG91dC50cmFuc2l0aW9ucy5zZXQoa2V5LCB2YWx1ZS5jbG9uZSgpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzKHN0YXRlSWQ6IG51bWJlciwgc3ltYm9sPzogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRyYW5zaXRpb25TdGF0ZSA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KHN0YXRlSWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRyYW5zaXRpb25TdGF0ZSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3ltYm9sID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiAhIXRyYW5zaXRpb25TdGF0ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRyYW5zaXRpb25TdGF0ZS5oYXMoc3ltYm9sKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0KHN0YXRlSWQ6IG51bWJlcik6IFRyYW5zaXRpb25TdGF0ZSB8IHVuZGVmaW5lZDtcblx0XHRnZXQoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZDtcblx0XHRnZXQoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHJhbnNpdGlvblN0YXRlID0gdGhpcy50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdGlmICghdHJhbnNpdGlvblN0YXRlKVxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3ltYm9sID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiB0cmFuc2l0aW9uU3RhdGU7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cmFuc2l0aW9uU3RhdGUuZ2V0KHN5bWJvbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFjcXVpcmUoc3RhdGVJZDogbnVtYmVyKTogVHJhbnNpdGlvblN0YXRlO1xuXHRcdGFjcXVpcmUoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w6IHN0cmluZyk6IG51bWJlcjtcblx0XHRhY3F1aXJlKHN0YXRlSWQ6IG51bWJlciwgc3ltYm9sPzogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRyYW5zaXRpb25TdGF0ZSA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KHN0YXRlSWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRyYW5zaXRpb25TdGF0ZSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cdFx0XHRcblx0XHRcdGlmIChzeW1ib2wgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb25TdGF0ZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3ViU3RhdGVJZCA9IHRyYW5zaXRpb25TdGF0ZS5nZXQoc3ltYm9sKTtcblx0XHRcdGlmIChzdWJTdGF0ZUlkID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc3ViU3RhdGVJZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVhY2hTdGF0ZUlkKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHN0YXRlSWQgb2YgdGhpcy50cmFuc2l0aW9ucy5rZXlzKCkpXG5cdFx0XHRcdHlpZWxkIHN0YXRlSWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCBcblx0XHQgKiBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBvdXQgPSBbXCJ7XCJdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkLCB0U3RhdGVdIG9mIHRoaXMudHJhbnNpdGlvbnMpXG5cdFx0XHRcdG91dC5wdXNoKFwiXFx0XCIgKyBzdGF0ZUlkICsgXCI6IFwiICsgdFN0YXRlLnRvU3RyaW5nKCkpO1xuXHRcdFx0XG5cdFx0XHRvdXQucHVzaChcIn1cIik7XG5cdFx0XHRyZXR1cm4gb3V0LmpvaW4oXCJcXG5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByb3RlY3RlZCByZWFkb25seSB0cmFuc2l0aW9uczogTWFwPG51bWJlciwgVHJhbnNpdGlvblN0YXRlPjtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIE11dGFibGVUcmFuc2l0aW9uTWFwIGV4dGVuZHMgVHJhbnNpdGlvbk1hcFxuXHR7XG5cdFx0LyoqICovXG5cdFx0aW5pdGlhbGl6ZShzcmNTdGF0ZUlkOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0dGhpcy50cmFuc2l0aW9ucy5zZXQoc3JjU3RhdGVJZCwgbmV3IFRyYW5zaXRpb25TdGF0ZSgpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c2V0KHNyY1N0YXRlSWQ6IG51bWJlciwgc3ltYm9sOiBzdHJpbmcsIGRzdFN0YXRlSWQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCB0U3RhdGUgPSB0aGlzLnRyYW5zaXRpb25zLmdldChzcmNTdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0aWYgKCF0U3RhdGUpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHRTdGF0ZSA9IG5ldyBUcmFuc2l0aW9uU3RhdGUoKTtcblx0XHRcdFx0dFN0YXRlLnNldChzeW1ib2wsIGRzdFN0YXRlSWQpO1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb25zLnNldChzcmNTdGF0ZUlkLCB0U3RhdGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0U3RhdGUuc2V0KHN5bWJvbCwgZHN0U3RhdGVJZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgaW50ZXJmYWNlIElUcmFuc2l0aW9uTGl0ZXJhbFxuXHR7XG5cdFx0W3N0YXRlSWQ6IG51bWJlcl06IElUcmFuc2l0aW9uU3RhdGVMaXRlcmFsO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVHJhbnNpdGlvblN0YXRlXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihzb3VyY2U/OiBJVHJhbnNpdGlvblN0YXRlTGl0ZXJhbClcblx0XHR7XG5cdFx0XHR0aGlzLnN0YXRlTWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc291cmNlKVxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzeW1ib2wsIHN0YXRlSWRdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZU1hcC5zZXQoc3ltYm9sLCBzdGF0ZUlkKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y2xvbmUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNsb25lZCA9IG5ldyBUcmFuc2l0aW9uU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3ltYm9sLCBzdGF0ZUlkXSBvZiB0aGlzLnN0YXRlTWFwKVxuXHRcdFx0XHRjbG9uZWQuc3RhdGVNYXAuc2V0KHN5bWJvbCwgc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjbG9uZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGhhcyhzeW1ib2w6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZU1hcC5oYXMoc3ltYm9sKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0KHN5bWJvbDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXRlTWFwLmdldChzeW1ib2wpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzZXQoc3ltYm9sOiBzdHJpbmcsIHN0YXRlSWQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHR0aGlzLnN0YXRlTWFwLnNldChzeW1ib2wsIHN0YXRlSWQpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqZWFjaFN5bWJvbCgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzeW1ib2wgb2YgdGhpcy5zdGF0ZU1hcC5rZXlzKCkpXG5cdFx0XHRcdHlpZWxkIHN5bWJvbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QsIFxuXHRcdCAqIGZvciB0ZXN0aW5nIGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dDogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3ltYm9sLCBzdGF0ZUlkXSBvZiB0aGlzLnN0YXRlTWFwKVxuXHRcdFx0XHRvdXQucHVzaChcInsgXCIgKyBzeW1ib2wgKyBcIjogXCIgKyBzdGF0ZUlkICsgXCIgfVwiKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dC5sZW5ndGggPyBvdXQuam9pbihcIiwgXCIpIDogXCJ7fVwiO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcm90ZWN0ZWQgcmVhZG9ubHkgc3RhdGVNYXA6IE1hcDxzdHJpbmcsIG51bWJlcj47XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBpbnRlcmZhY2UgSVRyYW5zaXRpb25TdGF0ZUxpdGVyYWxcblx0e1xuXHRcdFtzeW1ib2w6IHN0cmluZ106IG51bWJlcjtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEd1aWRlXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihmcm9tPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyXVtdIHwgR3VpZGUpXG5cdFx0e1xuXHRcdFx0aWYgKGZyb20gaW5zdGFuY2VvZiBHdWlkZSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5oYXNEc3QgPSBmcm9tLmhhc0RzdDtcblx0XHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFNyYywgc3RhdGVJZERzdF0gb2YgZnJvbS5hcnJvd3MpXG5cdFx0XHRcdFx0dGhpcy5hcnJvd3Muc2V0KHN0YXRlSWRTcmMsIHN0YXRlSWREc3QpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGZyb20gPT09IFwibnVtYmVyXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYWRkKGZyb20pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZnJvbSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFNyYywgc3RhdGVJZERzdF0gb2YgZnJvbSlcblx0XHRcdFx0XHR0aGlzLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGNsb25lKClcblx0XHR7XG5cdFx0XHRjb25zdCBjbG9uZWQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFNyYywgc3RhdGVJZERzdF0gb2YgdGhpcy5hcnJvd3MpXG5cdFx0XHRcdGNsb25lZC5hcnJvd3Muc2V0KHN0YXRlSWRTcmMsIHN0YXRlSWREc3QpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY2xvbmVkO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoc3RhdGVJZFNyYzogbnVtYmVyKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFycm93cy5oYXMoc3RhdGVJZFNyYyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldChzdGF0ZUlkU3JjOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyb3dzLmdldChzdGF0ZUlkU3JjKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkKHN0YXRlSWRTcmM6IG51bWJlciwgc3RhdGVJZERzdDogbnVtYmVyIHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaXNGcm96ZW4pXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFzRHN0ID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChzdGF0ZUlkRHN0ICE9PSBzdGF0ZUlkRHN0KVxuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLmhhc0RzdCA9PT0gdHJ1ZSAmJiB0eXBlb2Ygc3RhdGVJZERzdCAhPT0gXCJudW1iZXJcIiB8fFxuXHRcdFx0XHRcdHRoaXMuaGFzRHN0ID09PSBmYWxzZSAmJiB0eXBlb2Ygc3RhdGVJZERzdCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIG5lZWQgdG8gYmUga2VwdCBjb25zaXN0ZW50IGFjcm9zcyB0aGUgaW5zdGFuY2UuXCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5hcnJvd3Muc2V0KHN0YXRlSWRTcmMsIHN0YXRlSWREc3QpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLmhhc0RzdCA9IHN0YXRlSWREc3QgIT09IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFwcGVuZChvdGhlcjogR3VpZGUpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaXNGcm96ZW4pXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFzRHN0ID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzcmMsIGRzdF0gb2Ygb3RoZXIuYXJyb3dzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5oYXNEc3QgPSB0eXBlb2YgZHN0ID09PSBcIm51bWJlclwiO1xuXHRcdFx0XHRcdHRoaXMuYXJyb3dzLnNldChzcmMsIGRzdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG90aGVyLmhhc0RzdCA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0aWYgKG90aGVyLnNpemUgIT09IDApXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzcmMsIGRzdF0gb2Ygb3RoZXIuYXJyb3dzKVxuXHRcdFx0XHRcdHRoaXMuYXJyb3dzLnNldChzcmMsIGRzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGZpcnN0KClcblx0XHR7XG5cdFx0XHRjb25zdCBvdXQgPSB0aGlzLmFycm93cy5nZXQoMCk7XG5cdFx0XHRpZiAob3V0ID09PSBudWxsIHx8IG91dCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmtleXMoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgc3JjIG9mIHRoaXMuYXJyb3dzLmtleXMoKSlcblx0XHRcdFx0eWllbGQgc3JjO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqdmFsdWVzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QgPT09IHRydWUpXG5cdFx0XHRcdGZvciAoY29uc3QgZHN0IG9mIHRoaXMuYXJyb3dzLnZhbHVlcygpKVxuXHRcdFx0XHRcdHlpZWxkIE5vdC5udWxsKGRzdCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplbnRyaWVzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QgPT09IGZhbHNlKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZW51bWVyYXRlIHRoZSBmdWxsIGVudHJpZXMgb2YgdGhpcyBpbnN0YW5jZS5cIik7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3N0YXRlSWRTcmMsIHN0YXRlSWREc3RdIG9mIHRoaXMuYXJyb3dzKVxuXHRcdFx0XHR5aWVsZCA8W251bWJlciwgbnVtYmVyXT5bc3RhdGVJZFNyYywgTm90Lm51bGwoc3RhdGVJZERzdCldO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYXJyb3dzLnNpemU7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgY29udGVudHNcblx0XHQgKiBvZiB0aGlzIGd1aWRlIG1hdGNoIHRoZSBjb250ZW50cyBvZiB0aGUgZ3VpZGUgc3BlY2lmaWVkIGluIHRoZVxuXHRcdCAqIHBhcmFtZXRlci5cblx0XHQgKi9cblx0XHRlcXVhbHMob3RoZXI6IEd1aWRlKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3JjLCBkc3RdIG9mIHRoaXMuYXJyb3dzKVxuXHRcdFx0XHRpZiAob3RoZXIuYXJyb3dzLmdldChzcmMpICE9PSBkc3QpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZnJlZXplKClcblx0XHR7XG5cdFx0XHR0aGlzLmlzRnJvemVuID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdCwgXG5cdFx0ICogZm9yIHRlc3RpbmcgYW5kIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaGFzRHN0KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBsaXRlcmFsOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFNyYywgc3RhdGVJZERzdF0gb2YgdGhpcy5hcnJvd3MpXG5cdFx0XHRcdFx0bGl0ZXJhbC5wdXNoKHN0YXRlSWRTcmMgKyBcIjogXCIgKyBzdGF0ZUlkRHN0KTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBcInsgXCIgKyBsaXRlcmFsLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFwiW1wiICsgQXJyYXkuZnJvbSh0aGlzLmFycm93cy5rZXlzKCkpLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGhhc0RzdDogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgaXNGcm96ZW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGFycm93cyA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXIgfCBudWxsPigpO1xuXHR9XG59XG4iLCJcbi8qKlxuICogVGhpcyBjb2RlIGlzIGEgVHlwZVNjcmlwdCBjb252ZXJzaW9uIG9mIGEgcG9ydGlvbiBvZiB0aGUgdGhlIFB5dGhvblxuICogcHJvamVjdCBcImdyZWVuZXJ5XCIsIGZyb20gR2l0SHViIHVzZXIgXCJxbnRtXCIuIFxuICogXG4gKiBUaGUgZ3JlZW5lcnkgcHJvamVjdCBjYW4gYmUgZm91bmQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9xbnRtL2dyZWVuZXJ5XG4gKiBcbiAqIFNwZWNpZmljYWxseSwgdGhlIGNvZGUgZnJvbSB3aGVyZSB0aGlzIGNvZGUgZHJldyBpbnNwaXJhdGlvbiBpczpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9xbnRtL2dyZWVuZXJ5L2Jsb2IvbWFzdGVyL2dyZWVuZXJ5L2ZzbS5weVxuICogXG4gKiBQb3NzaWJseSByZWxldmFudCBibG9nIHBvc3Q6XG4gKiBodHRwczovL3FudG0ub3JnL2FsZ29cbiAqIFxuICogVGhlIG9yaWdpbmFsIE1JVCBsaWNlbnNlIGZyb20gZ3JlZW5lcnkgaXMgYXMgZm9sbG93czpcbiAqIFxuICogQ29weXJpZ2h0IChDKSAyMDEyIHRvIDIwMTcgYnkgcW50bVxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0VcbiAqIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIE9ibGl2aW9uIGlzIGEgU3ltYm9sIG9iamVjdCB0aGF0IGlzIHJldHVybmVkIHdoaWxlIGNhbGxpbmcgY3Jhd2woKSBpZiB0aGUgRnNtXG5cdCAqIGlzIHRyYW5zaXRpb25lZCB0byB0aGUgb2JsaXZpb24gc3RhdGUuIEZvciBleGFtcGxlIHdoaWxlIGNyYXdsaW5nIHR3byBGc21zXG5cdCAqIGluIHBhcmFsbGVsIHdlIG1heSB0cmFuc2l0aW9uIHRvIHRoZSBvYmxpdmlvbiBzdGF0ZSBvZiBib3RoIEZzbXMgYXQgb25jZS5cblx0ICogVGhpcyB3YXJyYW50cyBhbiBvdXQtb2YtYm91bmQgc2lnbmFsIHdoaWNoIHdpbGwgcmVkdWNlIHRoZSBjb21wbGV4aXR5IG9mXG5cdCAqIHRoZSBuZXcgRnNtJ3MgbWFwLlxuXHQgKi9cblx0Y29uc3QgT2JsaXZpb24gPSBTeW1ib2woKTtcblxuXG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBGaW5pdGUgU3RhdGUgTWFjaGluZSBvciBGc20gaGFzIGFuIGFscGhhYmV0IGFuZCBhIHNldCBvZiBzdGF0ZXMuIEF0IGFueVxuXHQgKiBnaXZlbiBtb21lbnQsIHRoZSBGc20gaXMgaW4gb25lIHN0YXRlLiBXaGVuIHBhc3NlZCBhIHN5bWJvbCBmcm9tIHRoZVxuXHQgKiBhbHBoYWJldCwgdGhlIEZzbSBqdW1wcyB0byBhbm90aGVyIHN0YXRlIChvciBwb3NzaWJseSB0aGUgc2FtZSBzdGF0ZSkuXG5cdCAqIEEgVHJhbnNpdGlvbk1hcCBpbmRpY2F0ZXMgd2hlcmUgdG8ganVtcC4gT25lIHN0YXRlIGlzIG5vbWluYXRlZCBhcyB0aGVcblx0ICogaW5pdGlhbCBzdGF0ZS4gWmVybyBvciBtb3JlIHN0YXRlcyBhcmUgbm9taW5hdGVkIGFzIGZpbmFsIHN0YXRlcy4gSWYsIGFmdGVyXG5cdCAqIGNvbnN1bWluZyBhIHN0cmluZyBvZiBzeW1ib2xzLCB0aGUgRnNtIGlzIGluIGEgZmluYWwgc3RhdGUsIHRoZW4gaXQgaXMgc2FpZFxuXHQgKiB0byBcImFjY2VwdFwiIHRoZSBzdHJpbmcuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRnNtXG5cdHtcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gaW5zdGFuY2UgdGhhdCBhY2NlcHRcblx0XHQgKiBubyBpbnB1dHMsIG5vdCBldmVuIGFuIGVtcHR5IHN0cmluZy5cblx0XHQgKi9cblx0XHRzdGF0aWMgZW1wdHkoYWxwaGFiZXQ6IEFscGhhYmV0KVxuXHRcdHtcblx0XHRcdGNvbnN0IHRzbDogSVRyYW5zaXRpb25TdGF0ZUxpdGVyYWwgPSB7fTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzeW1ib2wgb2YgYWxwaGFiZXQpXG5cdFx0XHRcdHRzbFtzeW1ib2xdID0gMDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBGc20oXG5cdFx0XHRcdGFscGhhYmV0LFxuXHRcdFx0XHRuZXcgU2V0KFswXSksXG5cdFx0XHRcdDAsXG5cdFx0XHRcdG5ldyBTZXQoKSxcblx0XHRcdFx0bmV3IFRyYW5zaXRpb25NYXAoeyAwOiB0c2wgfSkpO1xuXHRcdH1cblxuXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gRnNtIHRoYXQgbWF0Y2hlcyBvbmx5IGFuIGVtcHR5IHN0cmluZy5cblx0XHQgKi9cblx0XHRzdGF0aWMgZXBzaWxvbihhbHBoYWJldDogQWxwaGFiZXQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBGc20oXG5cdFx0XHRcdGFscGhhYmV0LFxuXHRcdFx0XHRuZXcgU2V0KFswXSksXG5cdFx0XHRcdDAsXG5cdFx0XHRcdG5ldyBTZXQoWzBdKSxcblx0XHRcdFx0bmV3IFRyYW5zaXRpb25NYXAoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBpdGVyYWJsZSBvZiBzeW1ib2xzIHRoZSBGc20gY2FuIGJlIGZlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgYWxwaGFiZXQ6IEFscGhhYmV0LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBzZXQgb2YgcG9zc2libGUgc3RhdGVzIGZvciB0aGUgRnNtLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzdGF0ZXM6IFJlYWRvbmx5U2V0PG51bWJlcj4sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIEZzbS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgaW5pdGlhbDogbnVtYmVyLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBzZXQgb2Ygc3RhdGVzIHRoYXQgdGhlIEZzbSBhY2NlcHRzLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBmaW5hbHM6IFJlYWRvbmx5U2V0PG51bWJlcj4sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogTWF5IGJlIHNwYXJzZSAoaS5lLiBpdCBtYXkgb21pdCB0cmFuc2l0aW9ucykuIFxuXHRcdFx0ICogSW4gdGhlIGNhc2Ugb2Ygb21pdHRlZCB0cmFuc2l0aW9ucywgYSBub24tZmluYWxcblx0XHRcdCAqIFwib2JsaXZpb25cIiBzdGF0ZSBpcyBzaW11bGF0ZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHRyYW5zaXRpb25zOiBUcmFuc2l0aW9uTWFwKVxuXHRcdHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBwcmVzZW50IEZzbVxuXHRcdCAqIGFjY2VwdHMgdGhlIHN1cHBsaWVkIGFycmF5IG9mIHN5bWJvbHMuIEVxdWl2YWxlbnRseSwgY29uc2lkZXIgdGhpc1xuXHRcdCAqIEZzbSBpbnN0YW5jZSBhcyBhIHBvc3NpYmx5LWluZmluaXRlIHNldCBvZiBzdHJpbmdzIGFuZCB0ZXN0IHdoZXRoZXJcblx0XHQgKiB0aGUgaW5wdXQgaXMgYSBtZW1iZXIgb2YgaXQuXG5cdFx0ICogXG5cdFx0ICogSWYgdGhlIHdpbGRjYXJkIGNoYXJhY3RlciBpcyBwcmVzZW50IGluIHRoZSBzcGVjaWZpZWQgYWxwaGFiZXQsIHRoZW5cblx0XHQgKiBhbnkgc3ltYm9sIG5vdCBpbiB0aGUgc3BlY2lmaWVkIGFscGhhYmV0IHdpbGwgYmUgYXNzdW1lZCB0byBiZSBcblx0XHQgKiB3aWxkY2FyZC5cblx0XHQgKi9cblx0XHRhY2NlcHRzKGlucHV0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdGhpc0hhc1dpbGQgPSB0aGlzLmFscGhhYmV0Lmhhc1dpbGRjYXJkKCk7XG5cdFx0XHRsZXQgc3RhdGVJZCA9IHRoaXMuaW5pdGlhbDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjaGFyIG9mIGlucHV0KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzeW1ib2wgPSB0aGlzSGFzV2lsZCAmJiAhdGhpcy5hbHBoYWJldC5oYXMoY2hhcikgP1xuXHRcdFx0XHRcdEFscGhhYmV0LndpbGRjYXJkIDpcblx0XHRcdFx0XHRjaGFyO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTWlzc2luZyB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB0byBkZWFkIHN0YXRlXG5cdFx0XHRcdGlmICghdGhpcy50cmFuc2l0aW9ucy5oYXMoc3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBuZXdTdGF0ZUlkID0gdGhpcy50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0aWYgKG5ld1N0YXRlSWQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHR0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHN0YXRlSWQgPSBuZXdTdGF0ZUlkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5hbHMuaGFzKHN0YXRlSWQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHJlZHVjZWQgdmVyc2lvbiBvZiB0aGUgRnNtLCBkb3duIHRvIGEgbWluaW1hbCBmaW5pdGVcblx0XHQgKiBzdGF0ZSBtYWNoaW5lIGVxdWl2YWxlbnQuXG5cdFx0ICogXG5cdFx0ICogKEEgcmVzdWx0IGJ5IEJyem96b3dza2kgKDE5NjMpIHNob3dzIHRoYXQgYSBtaW5pbWFsIGZpbml0ZSBzdGF0ZVxuXHRcdCAqIG1hY2hpbmUgZXF1aXZhbGVudCB0byB0aGUgb3JpZ2luYWwgY2FuIGJlIG9idGFpbmVkIGJ5IHJldmVyc2luZ1xuXHRcdCAqIHRoZSBvcmlnaW5hbCB0d2ljZS4pXG5cdFx0ICovXG5cdFx0cmVkdWNlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlKCkucmV2ZXJzZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gaW5zdGFuY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb25jYXRlbmF0aW9uXG5cdFx0ICogb2YgdGhlIHNwZWNpZmllZCBzZXJpZXMgb2YgZmluaXRlIHN0YXRlIG1hY2hpbmVzLlxuXHRcdCAqL1xuXHRcdGNvbmNhdGVuYXRlKC4uLmZzbXM6IEZzbVtdKVxuXHRcdHtcblx0XHRcdGlmIChmc21zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZzbXMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRyZXR1cm4gZnNtc1swXTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWtlIGEgc3RhdGUgaW4gdGhlIG51bWJlcmVkIEZzbSBhbmQgcmV0dXJuIGEgc2V0IGNvbnRhaW5pbmcgaXQsXG5cdFx0XHQgKiBwbHVzIChpZiBpdCdzIGZpbmFsKSB0aGUgZmlyc3Qgc3RhdGUgZnJvbSB0aGUgbmV4dCBGc20sIFxuXHRcdFx0ICogcGx1cyAoaWYgdGhhdCdzIGZpbmFsKSB0aGUgZmlyc3Qgc3RhdGUgZnJvbSB0aGUgbmV4dCBidXQgb25lIEZzbSwgXG5cdFx0XHQgKiBwbHVzLi4uXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGNvbm5lY3RBbGwgPSAoaWR4OiBudW1iZXIsIHN1YnN0YXRlSWQ6IG51bWJlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdHJlc3VsdC5hZGQoaWR4LCBzdWJzdGF0ZUlkKTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBpID0gaWR4O1xuXHRcdFx0XHRsZXQgaWQgPSBzdWJzdGF0ZUlkO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKGkgPCBmc21zLmxlbmd0aCAtIDEgJiYgZnNtc1tpXS5maW5hbHMuaGFzKGlkKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRpZCA9IGZzbXNbaV0uaW5pdGlhbDtcblx0XHRcdFx0XHRyZXN1bHQuYWRkKGksIGlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVXNlIGEgc3VwZXJzZXQgY29udGFpbmluZyBzdGF0ZXMgZnJvbSBhbGwgRnNtcyBhdCBvbmNlLlxuXHRcdFx0ICogV2Ugc3RhcnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBGc20uIElmIHRoaXMgc3RhdGUgaXMgZmluYWwgaW4gdGhlXG5cdFx0XHQgKiBmaXJzdCBGc20sIHRoZW4gd2UgYXJlIGFsc28gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgRnNtLiBBbmQgc28gb24uXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZzbXMubGVuZ3RoID4gMClcblx0XHRcdFx0aW5pdGlhbC5hcHBlbmQoY29ubmVjdEFsbCgwLCBmc21zWzBdLmluaXRpYWwpKTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJZiB5b3UncmUgaW4gYSBmaW5hbCBzdGF0ZSBvZiB0aGUgZmluYWwgRnNtLCBpdCdzIGZpbmFsLlxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCBmaW5hbEZuID0gKGd1aWRlOiBHdWlkZSkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbaSwgc3Vic3RhdGVJZF0gb2YgZ3VpZGUuZW50cmllcygpKVxuXHRcdFx0XHRcdGlmIChpID09PSBmc21zLmxlbmd0aCAtIDEgJiYgZnNtc1tpXS5maW5hbHMuaGFzKHN1YnN0YXRlSWQpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdGNvbnN0IGZvbGxvd0ZuID0gKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgW2ksIHN1YnN0YXRlSWRdIG9mIGd1aWRlLmVudHJpZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGZzbSA9IGZzbXNbaV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGZzbS50cmFuc2l0aW9ucy5oYXMoc3Vic3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBzdG9yZWRWYWx1ZSA9IGZzbS50cmFuc2l0aW9ucy5hY3F1aXJlKHN1YnN0YXRlSWQsIHN5bWJvbCk7XG5cdFx0XHRcdFx0XHRuZXh0LmFwcGVuZChjb25uZWN0QWxsKGksIHN0b3JlZFZhbHVlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dC5zaXplID09PSAwID9cblx0XHRcdFx0XHRPYmxpdmlvbiA6XG5cdFx0XHRcdFx0bmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFscGhhYmV0cyA9IGZzbXMubWFwKGZzbSA9PiBmc20uYWxwaGFiZXQpO1xuXHRcdFx0Y29uc3QgYWxwaGFiZXQgPSBuZXcgQWxwaGFiZXRCdWlsZGVyKC4uLmFscGhhYmV0cykudG9BbHBoYWJldCgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY3Jhd2woYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKTtcblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29uY2F0ZW5hdGUgdHdvIGZpbml0ZSBzdGF0ZSBtYWNoaW5lcyB0b2dldGhlci5cblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgdGhpcyBhY2NlcHRzIFwiMCpcIiBhbmQgb3RoZXIgYWNjZXB0cyBcIjErKDB8MSlcIixcblx0XHQgKiB3aWxsIHJldHVybiBhIGZpbml0ZSBzdGF0ZSBtYWNoaW5lIGFjY2VwdGluZyBcIjAqMSsoMHwxKVwiLlxuXHRcdCAqIEFjY29tcGxpc2hlZCBieSBlZmZlY3RpdmVseSBmb2xsb3dpbmcgbm9uLWRldGVybWluaXN0aWNhbGx5LlxuXHRcdCAqL1xuXHRcdGFkZChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNvbmNhdGVuYXRlKHRoaXMsIG90aGVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdGhlIHByZXNlbnQgRnNtIGFjY2VwdHMgWCwgcmV0dXJucyBhbiBGc20gYWNjZXB0aW5nIFgqXG5cdFx0ICogKGkuZS4gMCBvciBtb3JlIGluc3RhbmNlcyBvZiBYKS4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IGFzIHNpbXBsZVxuXHRcdCAqIGFzIG5haXZlbHkgY29ubmVjdGluZyB0aGUgZmluYWwgc3RhdGVzIGJhY2sgdG8gdGhlIGluaXRpYWwgc3RhdGU6IFxuXHRcdCAqIHNlZSAoYiphYikqIGZvciBleGFtcGxlLlxuXHRcdCAqL1xuXHRcdHN0YXIoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUodGhpcy5pbml0aWFsKTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmb2xsb3dGbiA9IChndWlkZTogR3VpZGUsIHN5bWJvbDogc3RyaW5nKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnN0YXRlSWQgb2YgZ3VpZGUua2V5cygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHRoaXMudHJhbnNpdGlvbnMuaGFzKHN1YnN0YXRlSWQsIHN5bWJvbCkpXG5cdFx0XHRcdFx0XHRuZXh0LmFkZCh0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUoc3Vic3RhdGVJZCwgc3ltYm9sKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgb25lIG9mIG91ciBzdWJzdGF0ZXMgaXMgZmluYWwsIHRoZW4gd2UgY2FuIGFsc28gY29uc2lkZXJcblx0XHRcdFx0XHQvLyB0cmFuc2l0aW9ucyBmcm9tIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBvcmlnaW5hbCBGc20uXG5cdFx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyhzdWJzdGF0ZUlkKSAmJiB0aGlzLnRyYW5zaXRpb25zLmhhcyh0aGlzLmluaXRpYWwsIHN5bWJvbCkpXG5cdFx0XHRcdFx0XHRuZXh0LmFkZCh0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUodGhpcy5pbml0aWFsLCBzeW1ib2wpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5leHQuc2l6ZSA9PT0gMCA/XG5cdFx0XHRcdFx0T2JsaXZpb24gOlxuXHRcdFx0XHRcdG5leHQ7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdGNvbnN0IGZpbmFsRm4gPSAoZ3VpZGU6IEd1aWRlKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnN0YXRlSWQgb2YgZ3VpZGUua2V5cygpKVxuXHRcdFx0XHRcdGlmICh0aGlzLmZpbmFscy5oYXMoc3Vic3RhdGVJZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBjcmF3bCh0aGlzLmFscGhhYmV0LCBpbml0aWFsLCBmaW5hbEZuLCBmb2xsb3dGbikub3IoRnNtLmVwc2lsb24odGhpcy5hbHBoYWJldCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHaXZlbiBhbiBGc20gYW5kIGEgbXVsdGlwbGljYXRpb24gZmFjdG9yLCByZXR1cm4gdGhlIG11bHRpcGxpZWQgRnNtLlxuXHRcdCAqL1xuXHRcdG11bHRpcGx5KGZhY3RvcjogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGlmIChmYWN0b3IgPCAwKVxuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpbml0aWFsID0gbmV3IEd1aWRlKFtbdGhpcy5pbml0aWFsLCAwXV0pO1xuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdGNvbnN0IGZpbmFsRm4gPSAoZ3VpZGU6IEd1aWRlKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdWJzdGF0ZUlkLCBpdGVyYXRpb25dIG9mIGd1aWRlLmVudHJpZXMoKSlcblx0XHRcdFx0XHRpZiAodGhpcy5pbml0aWFsID09PSBzdWJzdGF0ZUlkKVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyh0aGlzLmluaXRpYWwpIHx8IGl0ZXJhdGlvbiA9PT0gZmFjdG9yKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZm9sbG93Rm4gPSAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBbc3Vic3RhdGVJZCwgaXRlcmF0aW9uXSBvZiBndWlkZS5lbnRyaWVzKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaXRlcmF0aW9uIDwgZmFjdG9yICYmIHRoaXMudHJhbnNpdGlvbnMuaGFzKHN1YnN0YXRlSWQsIHN5bWJvbCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgbnVtID0gdGhpcy50cmFuc2l0aW9ucy5hY3F1aXJlKHN1YnN0YXRlSWQsIHN5bWJvbCk7XG5cdFx0XHRcdFx0XHRuZXh0LmFkZChudW0sIGl0ZXJhdGlvbik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICh0aGlzLmZpbmFscy5oYXMobnVtKSlcblx0XHRcdFx0XHRcdFx0bmV4dC5hZGQodGhpcy5pbml0aWFsLCBpdGVyYXRpb24gKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuZXh0LnNpemUgPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIE9ibGl2aW9uO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5leHQ7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY3Jhd2wodGhpcy5hbHBoYWJldCwgaW5pdGlhbCwgZmluYWxGbiwgZm9sbG93Rm4pLnJlZHVjZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gb2JqZWN0IHRoYXQgcHJlc2VudHMgdGhlIHVuaW9uIG9mXG5cdFx0ICogYWxsIHN1cHBsaWVkIEZzbSBpbnN0YW5jZXMuXG5cdFx0ICovXG5cdFx0dW5pb24oLi4uZnNtczogRnNtW10pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGNyYXdsUGFyYWxsZWwoXG5cdFx0XHRcdHByZXBlbmRGc20odGhpcywgZnNtcyksIFxuXHRcdFx0XHRhY2NlcHRzID0+IGFjY2VwdHMuc29tZSh2YWwgPT4gdmFsKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGxvZ2ljYWwgYWx0ZXJuYXRpb24gYmV0d2VlbiB0aGlzIEZzbSwgYW5kIHRoZSBGc21cblx0XHQgKiBpbnN0YW5jZSBzdXBwbGllZCBpbiB0aGUgYXJndW1lbnQuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBmaW5pdGUgc3RhdGUgbWFjaGluZSB3aGljaCBhY2NlcHRzIGFueSBzZXF1ZW5jZSBvZlxuXHRcdCAqIHN5bWJvbHMgdGhhdCBpcyBhY2NlcHRlZCBieSBlaXRoZXIgc2VsZiBvciBvdGhlci4gTm90ZSB0aGF0IHRoZSBzZXRcblx0XHQgKiBvZiBzdHJpbmdzIHJlY29nbmlzZWQgYnkgdGhlIHR3byBGc21zIHVuZGVyZ29lcyBhIHNldCB1bmlvbi5cblx0XHQgKi9cblx0XHRvcihvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnVuaW9uKG90aGVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBuZXcgRnNtIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlXG5cdFx0ICogaW50ZXJzZWN0aW9uIG9mIGFsbCBzdXBwbGllZCBGc20gaW5zdGFuY2VzLlxuXHRcdCAqL1xuXHRcdGludGVyc2VjdGlvbiguLi5mc21zOiBGc21bXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gY3Jhd2xQYXJhbGxlbChcblx0XHRcdFx0cHJlcGVuZEZzbSh0aGlzLCBmc21zKSwgXG5cdFx0XHRcdGFjY2VwdHMgPT4gYWNjZXB0cy5ldmVyeSh2YWwgPT4gdmFsKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRyZWF0IHRoZSBGc21zIGFzIHNldHMgb2Ygc3RyaW5ncyBhbmQgcmV0dXJuIHRoZVxuXHRcdCAqIGludGVyc2VjdGlvbiBvZiB0aG9zZSBzZXRzIGluIHRoZSBmb3JtIG9mIGEgbmV3IEZzbS5cblx0XHQgKi9cblx0XHRhbmQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb24ob3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY29tcHV0ZWRcblx0XHQgKiBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiBhbGwgc3VwcGxlZCBGc20gaW5zdGFuY2VzLlxuXHRcdCAqL1xuXHRcdHN5bW1ldHJpY0RpZmZlcmVuY2UoLi4uZnNtczogRnNtW10pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGNyYXdsUGFyYWxsZWwoXG5cdFx0XHRcdHByZXBlbmRGc20odGhpcywgZnNtcyksIFxuXHRcdFx0XHRhY2NlcHRzID0+IGFjY2VwdHMuZmlsdGVyKHZhbCA9PiB2YWwpLmxlbmd0aCAlIDIgPT09IDEpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gaW5zdGFuY2VzIHRoYXQgcmVjb2duaXNlcyBvbmx5IHRoZSBzdHJpbmdzXG5cdFx0ICogcmVjb2duaXNlZCBieSB0aGlzIEZzbSwgb3IgdGhlIEZzbSBpbnN0YW5jZSBzdXBwbGllZCBpbiB0aGUgXG5cdFx0ICogb3RoZXIgYXJndW1lbnQsIGJ1dCBub3QgYm90aC5cblx0XHQgKi9cblx0XHR4b3Iob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zeW1tZXRyaWNEaWZmZXJlbmNlKG90aGVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBuZXcgRnNtIGluc3RhbmNlIHRoYXQgcmVjb2dpemVzIGFsbCBpbnB1dHMgdGhhdFxuXHRcdCAqIHdvdWxkIG5vdCBiZSBhY2NlcHRlZCBieSB0aGlzIEZzbS5cblx0XHQgKi9cblx0XHRub3QoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUoW1swLCB0aGlzLmluaXRpYWxdXSk7XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZm9sbG93Rm4gPSAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XHRjb25zdCBmaXJzdCA9IGd1aWRlLmZpcnN0KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZmlyc3QgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5oYXMoZmlyc3QsIHN5bWJvbCkpXG5cdFx0XHRcdFx0XHRuZXh0LmFkZCgwLCB0aGlzLnRyYW5zaXRpb25zLmdldChmaXJzdCwgc3ltYm9sKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGZpcnN0ID0gZ3VpZGUuZmlyc3QoKTtcblx0XHRcdFx0cmV0dXJuICEoZmlyc3QgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbmFscy5oYXMoZmlyc3QpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBjcmF3bCh0aGlzLmFscGhhYmV0LCBpbml0aWFsLCBmaW5hbEZuLCBmb2xsb3dGbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBzdWNoIHRoYXQgZm9yIGV2ZXJ5IGlucHV0IHRoYXQgdGhlIHN1cHBsaWVkXG5cdFx0ICogRnNtIGFjY2VwdHMsIHRoZSBuZXcgRnNtIGFjY2VwdHMgdGhlIHNhbWUgaW5wdXQsIGJ1dCByZXZlcnNlZC5cblx0XHQgKi9cblx0XHRyZXZlcnNlKClcblx0XHR7XG5cdFx0XHQvLyBTdGFydCBmcm9tIGEgY29tcG9zaXRlIFwic3RhdGUtc2V0XCIgY29uc2lzdGluZyBvZiBhbGwgZmluYWwgc3RhdGVzLlxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGZpbmFsIHN0YXRlcywgdGhpcyBzZXQgaXMgZW1wdHkgYW5kIHdlJ2xsIGZpbmQgdGhhdFxuXHRcdFx0Ly8gbm8gb3RoZXIgc3RhdGVzIGdldCBnZW5lcmF0ZWQuXG5cdFx0XHRjb25zdCBpbml0aWFsID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVJZCBvZiB0aGlzLmZpbmFscylcblx0XHRcdFx0aW5pdGlhbC5hZGQoc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdC8vIEZpbmQgZXZlcnkgcG9zc2libGUgd2F5IHRvIHJlYWNoIHRoZSBjdXJyZW50IHN0YXRlLXNldFxuXHRcdFx0Ly8gdXNpbmcgdGhpcyBzeW1ib2wuXG5cdFx0XHRjb25zdCBmb2xsb3dGbiA9IChndWlkZTogR3VpZGUsIHN5bWJvbDogc3RyaW5nKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHByZXZTdGF0ZUlkIG9mIHRoaXMudHJhbnNpdGlvbnMuZWFjaFN0YXRlSWQoKSlcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHN0YXRlSWQgb2YgZ3VpZGUua2V5cygpKVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudHJhbnNpdGlvbnMuaGFzKHByZXZTdGF0ZUlkLCBzeW1ib2wpKVxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5nZXQocHJldlN0YXRlSWQsIHN5bWJvbCkgPT09IHN0YXRlSWQpXG5cdFx0XHRcdFx0XHRcdFx0bmV4dC5hZGQocHJldlN0YXRlSWQpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5leHQuc2l6ZSA9PT0gMCA/XG5cdFx0XHRcdFx0T2JsaXZpb24gOlxuXHRcdFx0XHRcdG5leHQ7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdGNvbnN0IGZpbmFsRm4gPSAoZ3VpZGU6IEd1aWRlKSA9PiBndWlkZS5oYXModGhpcy5pbml0aWFsKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNyYXdsKHRoaXMuYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIEZzbSBpbnN0YW5jZVxuXHRcdCAqIGFjY2VwdHMgdGhlIHNhbWUgc2V0IG9mIGlucHV0cyBhcyB0aGUgRnNtIGluc3RhbmNlIHNwZWNpZmllZFxuXHRcdCAqIGluIHRoZSBhcmd1bWVudC5cblx0XHQgKi9cblx0XHRlcXVpdmFsZW50KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMueG9yKG90aGVyKS5pc0VtcHR5KCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBGc20gaW5zdGFuY2Vcblx0XHQgKiBkb2VzIG5vdCBhY2NlcHQgdGhlIHNhbWUgc2V0IG9mIGlucHV0cyBhcyB0aGUgRnNtIGluc3RhbmNlXG5cdFx0ICogc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudC5cblx0XHQgKi9cblx0XHR1bmVxdWl2YWxlbnQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gIXRoaXMueG9yKG90aGVyKS5pc0VtcHR5KCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIEZzbSBpbnN0YW5jZSB3aGljaCByZWNvZ25pc2VzIG9ubHkgdGhlIGlucHV0c1xuXHRcdCAqIHJlY29nbmlzZWQgYnkgdGhlIGZpcnN0IEZzbSBpbnN0YW5jZSBpbiB0aGUgbGlzdCwgYnV0IG5vbmUgb2YgXG5cdFx0ICogdGhlIG90aGVycy5cblx0XHQgKi9cblx0XHRkaWZmZXJlbmNlKC4uLmZzbXM6IEZzbVtdKVxuXHRcdHtcblx0XHRcdHJldHVybiBjcmF3bFBhcmFsbGVsKFxuXHRcdFx0XHRwcmVwZW5kRnNtKHRoaXMsIGZzbXMpLCBcblx0XHRcdFx0YWNjZXB0cyA9PiBhY2NlcHRzWzBdICYmIGFjY2VwdHMuc2xpY2UoMSkuZXZlcnkoYWNjZXB0cyA9PiAhYWNjZXB0cykpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGZpbmFsIHN0YXRlXG5cdFx0ICogY2FuIGJlIHJlYWNoZWQgZnJvbSB0aGUgc3BlY2lmaWVkIHN0YXRlLlxuXHRcdCAqL1xuXHRcdGlzU3RhdGVMaXZlKHN0YXRlSWQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCByZWFjaGFibGUgPSBbc3RhdGVJZF07XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcmVhY2hhYmxlLmxlbmd0aDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZUlkID0gcmVhY2hhYmxlW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyhjdXJyZW50U3RhdGVJZCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5oYXMoY3VycmVudFN0YXRlSWQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvblN0YXRlID0gdGhpcy50cmFuc2l0aW9ucy5hY3F1aXJlKGN1cnJlbnRTdGF0ZUlkKTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiB0cmFuc2l0aW9uU3RhdGUuZWFjaFN5bWJvbCgpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IG5leHQgPSB0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUoY3VycmVudFN0YXRlSWQsIHN5bWJvbCk7XG5cdFx0XHRcdFx0XHRpZiAoIXJlYWNoYWJsZS5pbmNsdWRlcyhuZXh0KSlcblx0XHRcdFx0XHRcdFx0cmVhY2hhYmxlLnB1c2gobmV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQW4gRnNtIGlzIGVtcHR5IGlmIGl0IHJlY29nbmlzZXMgbm8gc3RyaW5ncy4gQW4gRnNtIG1heSBiZSBhcmJpdHJhcmlseVxuXHRcdCAqIGNvbXBsaWNhdGVkIGFuZCBoYXZlIGFyYml0cmFyaWx5IG1hbnkgZmluYWwgc3RhdGVzIHdoaWxlIHN0aWxsIHJlY29nbmlzaW5nXG5cdFx0ICogbm8gc3RyaW5ncyBiZWNhdXNlIHRob3NlIGZpbmFsIHN0YXRlcyBtYXkgYWxsIGJlIGluYWNjZXNzaWJsZSBmcm9tIHRoZVxuXHRcdCAqIGluaXRpYWwgc3RhdGUuIEVxdWFsbHksIGFuIEZzbSBtYXkgYmUgbm9uLWVtcHR5IGRlc3BpdGUgaGF2aW5nIGFuIGVtcHR5XG5cdFx0ICogYWxwaGFiZXQgaWYgdGhlIGluaXRpYWwgc3RhdGUgaXMgZmluYWwuXG5cdFx0ICovXG5cdFx0aXNFbXB0eSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICF0aGlzLmlzU3RhdGVMaXZlKHRoaXMuaW5pdGlhbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlIHN0cmluZ3MgKGxpc3RzIG9mIHN5bWJvbHMpIHRoYXQgdGhpcyBGc20gYWNjZXB0cy4gU2luY2UgdGhlcmUgbWF5XG5cdFx0ICogYmUgaW5maW5pdGVseSBtYW55IG9mIHRoZXNlIHdlIHVzZSBhIGdlbmVyYXRvciBpbnN0ZWFkIG9mIGNvbnN0cnVjdGluZyBhXG5cdFx0ICogc3RhdGljIGxpc3QuIFN0cmluZ3Mgd2lsbCBiZSBzb3J0ZWQgaW4gb3JkZXIgb2YgbGVuZ3RoIGFuZCB0aGVuIGxleGljYWxseS5cblx0XHQgKiBUaGlzIHByb2NlZHVyZSB1c2VzIGFyYml0cmFyeSBhbW91bnRzIG9mIG1lbW9yeSBidXQgaXMgdmVyeSBmYXN0LiBUaGVyZVxuXHRcdCAqIG1heSBiZSBtb3JlIGVmZmljaWVudCB3YXlzIHRvIGRvIHRoaXMsIHRoYXQgSSBoYXZlbid0IGludmVzdGlnYXRlZCB5ZXQuXG5cdFx0ICogWW91IGNhbiB1c2UgdGhpcyBpbiBsaXN0IGNvbXByZWhlbnNpb25zLlxuXHRcdCAqL1xuXHRcdCplYWNoU3RyaW5nKClcblx0XHR7XG5cdFx0XHRcIk5vdCBpbXBsZW1lbnRlZFwiO1xuXHRcdFx0ZGVidWdnZXI7XG5cdFx0XHR5aWVsZCBcIlwiO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgYWN0IG9mIG1lcmdpbmdcblx0XHQgKiB0aGlzIEZzbSBpbnN0YW5jZSB3aXRoIHRoZSBGc20gaW5zdGFuY2Ugc3VwcGxpZWQgaW4gdGhlIGFyZ3VtZW50XG5cdFx0ICogd291bGQgcmVzdWx0IGluIGFuIEZzbSBpbnN0YW5jZSB0aGF0IGFjY2VwdHMgbm8gaW5wdXRzLlxuXHRcdCAqL1xuXHRcdGlzRGlzY3JlcGFudChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFuZChvdGhlcikuaXNFbXB0eSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IG9mIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IHRoaXMgRnNtIGluc3RhbmNlIGlzIGEgc3Vic2V0IG9mIHRoZSBpbnB1dHMgYWNjZXB0ZWQgYnkgXG5cdFx0ICogb3RoZXIgRnNtIGluc3RhbmNlIHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRpc1N1YnNldChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmRpZmZlcmVuY2Uob3RoZXIpLmlzRW1wdHkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNldCBvZiBpbnB1dHNcblx0XHQgKiBhY2NlcHRlZCBieSB0aGlzIEZzbSBpbnN0YW5jZSBpcyBhIHByb3BlciBzdWJzZXQgb2YgdGhlIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IG90aGVyIEZzbSBpbnN0YW5jZSBzcGVjaWZpZWQuXG5cdFx0ICovXG5cdFx0aXNQcm9wZXJTdWJzZXQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaWZmZXJlbmNlKG90aGVyKS5pc0VtcHR5KCkgJiYgdGhpcy51bmVxdWl2YWxlbnQob3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IG9mIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IHRoaXMgRnNtIGluc3RhbmNlIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGlucHV0cyBhY2NlcHRlZFxuXHRcdCAqIGJ5IG90aGVyIEZzbSBpbnN0YW5jZSBzcGVjaWZpZWQuXG5cdFx0ICovXG5cdFx0aXNTdXBlcnNldChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiBvdGhlci5kaWZmZXJlbmNlKHRoaXMpLmlzRW1wdHkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNldCBvZiBpbnB1dHNcblx0XHQgKiBhY2NlcHRlZCBieSB0aGlzIEZzbSBpbnN0YW5jZSBpcyBhIHByb3BlciBzdXBlcnNldCBvZiB0aGUgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgb3RoZXIgRnNtIGluc3RhbmNlIHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRpc1Byb3BlclN1cGVyc2V0KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG90aGVyLmRpZmZlcmVuY2UodGhpcykuaXNFbXB0eSgpICYmIG90aGVyLnVuZXF1aXZhbGVudCh0aGlzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29tcHV0ZSB0aGUgQnJ6b3pvd3NraSBkZXJpdmF0aXZlIG9mIHRoaXMgRnNtIHdpdGggcmVzcGVjdCB0byB0aGUgaW5wdXRcblx0XHQgKiBzdHJpbmcgb2Ygc3ltYm9scy4gPGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jyem96b3dza2lfZGVyaXZhdGl2ZT5cblx0XHQgKiBJZiBhbnkgb2YgdGhlIHN5bWJvbHMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBhbHBoYWJldCwgdGhhdCdzIGEgS2V5RXJyb3IuXG5cdFx0ICogSWYgeW91IGZhbGwgaW50byBvYmxpdmlvbiwgdGhlbiB0aGUgZGVyaXZhdGl2ZSBpcyBhbiBGc20gYWNjZXB0aW5nIG5vXG5cdFx0ICogc3RyaW5ncy5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gaW5zdGFuY2Ugd2l0aCB0aGUgY29tcHV0ZWQgY2hhcmFjdGVyaXN0aWNzLlxuXHRcdCAqL1xuXHRcdGRlcml2ZShpbnB1dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGxldCBzdGF0ZUlkOiBudW1iZXIgPSB0aGlzLmluaXRpYWw7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgY2hhciBvZiBpbnB1dClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3ltYm9sID0gKCgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy5hbHBoYWJldC5oYXMoY2hhcikpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmFscGhhYmV0Lmhhc1dpbGRjYXJkKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoY2hhcik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiBBbHBoYWJldC53aWxkY2FyZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGNoYXI7XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXRoaXMudHJhbnNpdGlvbnMuaGFzKHN0YXRlSWQsIHN5bWJvbCkpXG5cdFx0XHRcdFx0cmV0dXJuIE9ibGl2aW9uO1xuXHRcdFx0XHRcblx0XHRcdFx0c3RhdGVJZCA9IHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZShzdGF0ZUlkLCBzeW1ib2wpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IEZzbShcblx0XHRcdFx0dGhpcy5hbHBoYWJldCxcblx0XHRcdFx0dGhpcy5zdGF0ZXMsXG5cdFx0XHRcdHN0YXRlSWQsXG5cdFx0XHRcdHRoaXMuZmluYWxzLFxuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb25zLmNsb25lKCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdCwgXG5cdFx0ICogZm9yIHRlc3RpbmcgYW5kIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XCJhbHBoYWJldCA9IFwiICsgdGhpcy5hbHBoYWJldC50b1N0cmluZygpLFxuXHRcdFx0XHRcInN0YXRlcyA9IFwiICsgQXJyYXkuZnJvbSh0aGlzLnN0YXRlcykuam9pbigpLFxuXHRcdFx0XHRcImluaXRhbCA9IFwiICsgdGhpcy5pbml0aWFsLFxuXHRcdFx0XHRcImZpbmFscyA9IFwiICsgQXJyYXkuZnJvbSh0aGlzLmZpbmFscykuam9pbigpLFxuXHRcdFx0XHRcInRyYW5zaXRpb25zID0gXCIgKyB0aGlzLnRyYW5zaXRpb25zLnRvU3RyaW5nKClcblx0XHRcdF0uam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHByZXBlbmQgYW4gRnNtIGluc3RhbmNlIHRvIGFuIEZzbSBhcnJheS5cblx0ICovXG5cdGZ1bmN0aW9uIHByZXBlbmRGc20oZnNtOiBGc20sIGZzbXM6IEZzbVtdKVxuXHR7XG5cdFx0cmV0dXJuIFtmc21dLmNvbmNhdCguLi5mc21zKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIENyYXdsIHNldmVyYWwgRnNtcyBpbiBwYXJhbGxlbCwgbWFwcGluZyB0aGUgc3RhdGVzIG9mIGEgbGFyZ2VyIG1ldGEtRnNtLlxuXHQgKiBUbyBkZXRlcm1pbmUgd2hldGhlciBhIHN0YXRlIGluIHRoZSBsYXJnZXIgRnNtIGlzIGZpbmFsLCBwYXNzIGFsbCBvZiB0aGVcblx0ICogZmluYWxpdHkgc3RhdHVzZXMgKGUuZy4gW3RydWUsIGZhbHNlLCBmYWxzZV0gdG8gdGVzdEZuLlxuXHQgKi9cblx0ZnVuY3Rpb24gY3Jhd2xQYXJhbGxlbChmc21zOiBGc21bXSwgdGVzdEZuOiAoYWNjZXB0czogYm9vbGVhbltdKSA9PiBib29sZWFuKVxuXHR7XG5cdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZSgpO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgW2luZGV4LCBmc21dIG9mIGZzbXMuZW50cmllcygpKVxuXHRcdFx0aW5pdGlhbC5hZGQoaW5kZXgsIGZzbS5pbml0aWFsKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBEZWRpY2F0ZWQgZnVuY3Rpb24gYWNjZXB0cyBhIFwic3VwZXJzZXRcIiBhbmQgcmV0dXJucyB0aGUgbmV4dCBcInN1cGVyc2V0XCJcblx0XHQgKiBvYnRhaW5lZCBieSBmb2xsb3dpbmcgdGhpcyB0cmFuc2l0aW9uIGluIHRoZSBuZXcgRnNtLlxuXHRcdCAqL1xuXHRcdGNvbnN0IGZvbGxvd0ZuID0gKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgbmV4dCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtpbmRleCwgZnNtXSBvZiBmc21zLmVudHJpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3RhdGVJZCA9IGd1aWRlLmdldChpbmRleCk7XG5cdFx0XHRcdGlmIChzdGF0ZUlkID09PSBudWxsIHx8IHN0YXRlSWQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHN1YnN0YXRlSWQgPSBmc20udHJhbnNpdGlvbnMuZ2V0KHN0YXRlSWQpO1xuXHRcdFx0XHRpZiAoc3Vic3RhdGVJZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYWxwaGEgPSBmc20uYWxwaGFiZXQ7XG5cdFx0XHRcdGNvbnN0IGFjdHVhbFN5bWJvbCA9IGFscGhhLmhhcyhzeW1ib2wpICYmIGFscGhhLmhhc1dpbGRjYXJkKCkgP1xuXHRcdFx0XHRcdEFscGhhYmV0LndpbGRjYXJkIDpcblx0XHRcdFx0XHRzeW1ib2w7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3Vic3RhdGVJZC5oYXMoYWN0dWFsU3ltYm9sKSlcblx0XHRcdFx0XHRuZXh0LmFkZChpbmRleCwgZnNtLnRyYW5zaXRpb25zLmdldChzdGF0ZUlkLCBhY3R1YWxTeW1ib2wpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG5leHQuc2l6ZSA9PT0gMClcblx0XHRcdFx0cmV0dXJuIE9ibGl2aW9uO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV4dDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZSB0aGUgXCJpcyBmaW5hbD9cIiBjb25kaXRpb24gb2YgZWFjaCBzdWJzdGF0ZUlkLCB0aGVuIHBhc3MgaXQgdG8gdGhlXG5cdFx0ICogdGVzdCB0byBkZXRlcm1pbmUgZmluYWxpdHkgb2YgdGhlIG92ZXJhbGwgRnNtLlxuXHRcdCAqL1xuXHRcdGNvbnN0IGZpbmFsRm4gPSAoZ3VpZGU6IEd1aWRlKSA9PlxuXHRcdHtcblx0XHRcdGNvbnN0IGFjY2VwdHM6IGJvb2xlYW5bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtpZHgsIGZzbV0gb2YgZnNtcy5lbnRyaWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN1YnN0YXRlSWQgPSBndWlkZS5nZXQoaWR4KTtcblx0XHRcdFx0aWYgKHN1YnN0YXRlSWQgIT09IG51bGwgJiYgc3Vic3RhdGVJZCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGFjY2VwdHMucHVzaChndWlkZS5oYXMoaWR4KSAmJiBmc20uZmluYWxzLmhhcyhzdWJzdGF0ZUlkKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0ZXN0Rm4oYWNjZXB0cyk7XG5cdFx0fTtcblx0XHRcblx0XHRjb25zdCBhbHBoYWJldHMgPSBmc21zLm1hcChmc20gPT4gZnNtLmFscGhhYmV0KTtcblx0XHRjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldEJ1aWxkZXIoLi4uYWxwaGFiZXRzKS50b0FscGhhYmV0KCk7XG5cdFx0cmV0dXJuIGNyYXdsKGFscGhhYmV0LCBpbml0aWFsLCBmaW5hbEZuLCBmb2xsb3dGbikucmVkdWNlKCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBHaXZlbiB0aGUgYWJvdmUgY29uZGl0aW9ucyBhbmQgaW5zdHJ1Y3Rpb25zLCBjcmF3bCBhIG5ldyB1bmtub3duIEZzbSxcblx0ICogbWFwcGluZyBpdHMgc3RhdGVzLCBmaW5hbCBzdGF0ZXMgYW5kIHRyYW5zaXRpb25zLiBSZXR1cm4gdGhlIG5ldyBGc20uXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmF3bChcblx0XHRhbHBoYWJldDogQWxwaGFiZXQsXG5cdFx0aW5pdGlhbDogR3VpZGUsXG5cdFx0ZmluYWxGbjogKGd1aWRlOiBHdWlkZSkgPT4gYm9vbGVhbixcblx0XHRmb2xsb3dGbjogKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+IEd1aWRlIHwgdHlwZW9mIE9ibGl2aW9uKVxuXHR7XG5cdFx0Y29uc3QgZGVidWdMaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHRjb25zdCBndWlkZXMgPSBbaW5pdGlhbF07XG5cdFx0Y29uc3QgZmluYWxzID0gbmV3IFNldDxudW1iZXI+KCk7XG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSBuZXcgTXV0YWJsZVRyYW5zaXRpb25NYXAoKTtcblx0XHRcblx0XHQvLyBJdGVyYXRlIG92ZXIgYSBncm93aW5nIGxpc3Rcblx0XHRmb3IgKGNvbnN0IFtpLCBndWlkZV0gb2YgZ3VpZGVzLmVudHJpZXMoKSlcblx0XHR7XG5cdFx0XHQvLyBBZGQgdG8gZmluYWxzXG5cdFx0XHRpZiAoZmluYWxGbihndWlkZSkpXG5cdFx0XHRcdGZpbmFscy5hZGQoaSk7XG5cdFx0XHRcblx0XHRcdC8vIENvbXB1dGUgdHJhbnNpdGlvbnMgZm9yIHRoaXMgc3RhdGVcblx0XHRcdHRyYW5zaXRpb25zLmluaXRpYWxpemUoaSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3ltYm9sIG9mIGFscGhhYmV0KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gZm9sbG93Rm4oZ3VpZGUsIHN5bWJvbCk7XG5cdFx0XHRcdGlmIChuZXh0ICE9PSBPYmxpdmlvbilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBuZXh0SWR4ID0gZ3VpZGVzLmZpbmRJbmRleChndWlkZSA9PiBndWlkZS5lcXVhbHMobmV4dCkpO1xuXHRcdFx0XHRcdGlmIChuZXh0SWR4IDwgMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRuZXh0SWR4ID0gZ3VpZGVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdGd1aWRlcy5wdXNoKG5leHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0cmFuc2l0aW9ucy5zZXQoaSwgc3ltYm9sLCBuZXh0SWR4KTtcblx0XHRcdFx0XHRkZWJ1Z0xpbmVzLnB1c2gobmV4dC50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbmV3IEZzbShcblx0XHRcdGFscGhhYmV0LFxuXHRcdFx0bmV3IFNldChBcnJheShndWlkZXMubGVuZ3RoKS5rZXlzKCkpLFxuXHRcdFx0MCxcblx0XHRcdGZpbmFscyxcblx0XHRcdHRyYW5zaXRpb25zKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBUcmFuc2xhdGVzIFBhdHRlcm4gaW5zdGFuY2VzIGludG8gYSBjb3JyZXNwb25kaW5nIEZzbS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGc21UcmFuc2xhdG9yXG5cdHtcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgZXhlYyh1bml0czogSXRlcmFibGU8UmVnZXhVbml0Pilcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHVuaXQgb2YgdW5pdHMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhTZXQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcm91cClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4U2lnbilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gPEZzbT5udWxsITtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgdHJhbnNsYXRlU2V0KFxuXHRcdFx0c2V0OiBSZWdleFNldCxcblx0XHRcdGFscGhhOiBBbHBoYWJldEJ1aWxkZXIgfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgdHJhbnNsYXRlR3JvdXAoXG5cdFx0XHRncm91cDogUmVnZXhHcm91cCxcblx0XHRcdGFscGhhOiBBbHBoYWJldEJ1aWxkZXIgfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRjb25zdCBidWlsZGVyID0gYWxwaGEgfHwgbmV3IEFscGhhYmV0QnVpbGRlcigpLmFkZFdpbGQoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgY3JlYXRlR3JvdXBBbHBoYWJldChncm91cDogUmVnZXhHcm91cClcblx0XHR7XG5cdFx0XHRjb25zdCBidWlsZGVyID0gbmV3IEFscGhhYmV0QnVpbGRlcigpO1xuXHRcdFx0YnVpbGRlci5hZGRXaWxkKCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZWxlbWVudCBvZiBncm91cC5jYXNlcylcblx0XHRcdHtcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHRyYW5zbGF0ZUdyYXBoZW1lKFxuXHRcdFx0Z3JhcGhlbWU6IFJlZ2V4R3JhcGhlbWUsXG5cdFx0XHRhbHBoYTogQWxwaGFiZXRCdWlsZGVyIHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHRyYW5zbGF0ZVNpZ24oXG5cdFx0XHRzaWduOiBSZWdleFNpZ24sXG5cdFx0XHRhbHBoYTogQWxwaGFiZXRCdWlsZGVyIHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRG9jdW1lbnRcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEludGVybmFsIGNvbnN0cnVjdG9yIGZvciBEb2N1bWVudCBvYmplY3RzLlxuXHRcdCAqIERvY3VtZW50IG9iamVjdHMgYXJlIGNyZWF0ZWQgdmlhIGEgUHJvZ3JhbVxuXHRcdCAqIG9iamVjdC5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihwcm9ncmFtOiBQcm9ncmFtLCBzb3VyY2VVcmk6IFVyaSwgc291cmNlVGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGlmIChzb3VyY2VVcmkudHlwZXMubGVuZ3RoKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZEFyZ3VtZW50KCk7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHR0aGlzLl9zb3VyY2VVcmkgPSBzb3VyY2VVcmk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmluRWRpdClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmRvdWJsZVRyYW5zYWN0aW9uKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuc3RhdGVtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHN0YXRlbWVudFRleHQgb2YgcmVhZExpbmVzKHNvdXJjZVRleHQpKVxuXHRcdFx0XHR0aGlzLnN0YXRlbWVudHMucHVzaChuZXcgU3RhdGVtZW50KHRoaXMsIHN0YXRlbWVudFRleHQpKTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZURvY3VtZW50VXJpQ2hhbmdlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLmRvY3VtZW50ID09PSB0aGlzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaW5FZGl0KVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRXaGlsZUluRWRpdFRyYW5zYWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLl9zb3VyY2VVcmkgPSBkYXRhLm5ld1VyaTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhpcyBkb2N1bWVudCBmb3IgdGhlIHJvb3QtbGV2ZWwgdHlwZXMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHVyaSBUaGUgVVJJIG9mIHRoZSBkb2N1bWVudCB0byBxdWVyeS4gSWYgdGhlIFVSSSBjb250YWluc1xuXHRcdCAqIGEgdHlwZSBwYXRoLCBpdCBpcyBmYWN0b3JlZCBpbnRvIHRoZSBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHR5cGVQYXRoIFRoZSB0eXBlIHBhdGggd2l0aGluIHRoZSBkb2N1bWVudCB0byBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBmdWxseSBjb25zdHJ1Y3RlZCBUeXBlIGluc3RhbmNlIHRoYXQgY29ycmVzcG9uZHMgdG9cblx0XHQgKiB0aGUgdHlwZSBhdCB0aGUgVVJJIHNwZWNpZmllZCwgb3IgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIG5vIHR5cGVcblx0XHQgKiBjb3VsZCBiZSBmb3VuZC5cblx0XHQgKi9cblx0XHRxdWVyeSguLi50eXBlUGF0aDogc3RyaW5nW10pOiBUeXBlIHwgbnVsbFxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnByb2dyYW0ucXVlcnkodGhpcywgLi4udHlwZVBhdGgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSByb290LWxldmVsIHR5cGVzIHRoYXQgYXJlIGRlZmluZWQgd2l0aGluIHRoaXMgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0IHR5cGVzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fdHlwZXMpXG5cdFx0XHRcdHJldHVybiB0aGlzLl90eXBlcztcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGVzID0gT2JqZWN0LmZyZWV6ZSh0aGlzLnByb2dyYW0ucXVlcnkodGhpcykpO1xuXHRcdH1cblx0XHRwcml2YXRlIF90eXBlczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgU3RhdGVtZW50IG9iamVjdHMgdGhhdCByZXByZXNlbnRcblx0XHQgKiBhbmNlc3RyeSBvZiB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudC4gSWYgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0YXRlbWVudCBpcyBub3QgaW4gdGhpcyBkb2N1bWVudCwgdGhlIHJldHVybmVkIHZhbHVlXG5cdFx0ICogaXMgbnVsbC5cblx0XHQgKi9cblx0XHRnZXRBbmNlc3RyeShzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnRvU3RhdGVtZW50KHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBzdGF0ZW1lbnQgaXMgcm9vdC1sZXZlbCwgaXQgY2FuJ3QgaGF2ZSBhbiBhbmNlc3RyeS5cblx0XHRcdGlmIChzbXQuaW5kZW50ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0YXJ0aW5nSW5kZXggPSB0aGlzLnRvTGluZU51bWJlcihzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3RhcnRpbmdJbmRleCA8IDApXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3RhcnRpbmdJbmRleCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBhbmNlc3RyeSA9IFtzbXRdO1xuXHRcdFx0bGV0IGluZGVudFRvQmVhdCA9IHNtdC5pbmRlbnQ7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGlkeCA9IHN0YXJ0aW5nSW5kZXg7IC0taWR4ID4gLTE7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjdXJyZW50U3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzW2lkeF07XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCA8IGluZGVudFRvQmVhdClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFuY2VzdHJ5LnVuc2hpZnQoY3VycmVudFN0YXRlbWVudCk7XG5cdFx0XHRcdFx0aW5kZW50VG9CZWF0ID0gY3VycmVudFN0YXRlbWVudC5pbmRlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCA9PT0gMClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGFuY2VzdHJ5LnNsaWNlKDAsIC0xKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIHBhcmVudCBTdGF0ZW1lbnQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBTdGF0ZW1lbnQuIElmIHRoZSBzdGF0ZW1lbnQgaXMgdG9wIGxldmVsLCBhIHJlZmVyZW5jZSB0b1xuXHRcdCAqIHRoaXMgZG9jdW1lbnQgb2JqZWN0IGlzIHJldHVybmVkLiBJZiB0aGUgc3RhdGVtZW50IGlzXG5cdFx0ICogbm90IGZvdW5kIGluIHRoZSBkb2N1bWVudCwgb3IgdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnRcblx0XHQgKiBpcyBhIG5vLW9wLCB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbnVsbC5cblx0XHQgKi9cblx0XHRnZXRQYXJlbnQoc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210ID0gdGhpcy50b1N0YXRlbWVudChzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBzdGF0ZW1lbnQgaXMgcm9vdC1sZXZlbCwgaXQgY2FuJ3QgaGF2ZSBhIHBhcmVudC5cblx0XHRcdGlmIChzbXQuaW5kZW50ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3RhcnRpbmdJbmRleCA9IHRoaXMudG9MaW5lTnVtYmVyKHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGlmIChzdGFydGluZ0luZGV4IDwgMClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChzdGFydGluZ0luZGV4ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Y29uc3QgY3VycmVudEluZGVudCA9IHNtdC5pbmRlbnQ7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGlkeCA9IHN0YXJ0aW5nSW5kZXg7IC0taWR4ID4gLTE7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjdXJyZW50U3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzW2lkeF07XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCA8IGN1cnJlbnRJbmRlbnQpXG5cdFx0XHRcdFx0cmV0dXJuIGN1cnJlbnRTdGF0ZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIElmIGEgcGFyZW50IHN0YXRlbWVudCB3YXNuJ3QgZm91bmQsIHRoZW4gdGhlXG5cdFx0XHQvLyBpbnB1dCBzdGF0ZW1lbnQgaXMgdG9wLWxldmVsLCBhbmQgYSByZWZlcmVuY2Vcblx0XHRcdC8vIHRvIHRoaXMgRG9jdW1lbnQgb2JqZWN0IGlzIHJldHVybmVkLlxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBTdGF0ZW1lbnQgdGhhdCB3b3VsZCBhY3QgYXMgdGhlIHBhcmVudCBcblx0XHQgKiBpZiBhIHN0YXRlbWVudCB3aGVyZSB0byBiZSBpbnNlcnRlZCBhdCB0aGUgc3BlY2lmaWVkXG5cdFx0ICogdmlydHVhbCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuIElmIGFuIGluc2VydGVkXG5cdFx0ICogc3RhdGVtZW50IHdvdWxkIGJlIHRvcC1sZXZlbCwgYSByZWZlcmVuY2UgdG8gdGhpcyBcblx0XHQgKiBkb2N1bWVudCBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0Z2V0UGFyZW50RnJvbVBvc2l0aW9uKHZpcnR1YWxMaW5lOiBudW1iZXIsIHZpcnR1YWxPZmZzZXQ6IG51bWJlcik6IFN0YXRlbWVudCB8IHRoaXNcblx0XHR7XG5cdFx0XHRpZiAodmlydHVhbExpbmUgPT09IDAgfHwgdmlydHVhbE9mZnNldCA8IDEgfHwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGxpbmUgPSBhcHBseUJvdW5kcyh2aXJ0dWFsTGluZSwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGlkeCA9IGxpbmU7IGlkeC0tOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlbWVudCA9IHRoaXMuc3RhdGVtZW50c1tpZHhdO1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRTdGF0ZW1lbnQuaXNOb29wICYmIGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50IDwgdmlydHVhbE9mZnNldClcblx0XHRcdFx0XHRyZXR1cm4gY3VycmVudFN0YXRlbWVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBzaWJsaW5nIFN0YXRlbWVudCBvYmplY3RzIG9mIHRoZSBcblx0XHQgKiBzcGVjaWZpZWQgU3RhdGVtZW50LiBJZiB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudFxuXHRcdCAqIGlzIG5vdCBmb3VuZCBpbiB0aGUgZG9jdW1lbnQsIG9yIGlzIGEgbm8tb3AsIHRoZVxuXHRcdCAqIHJldHVybmVkIHZhbHVlIGlzIG51bGwuXG5cdFx0ICovXG5cdFx0Z2V0U2libGluZ3Moc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210ID0gdGhpcy50b1N0YXRlbWVudChzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChzbXQuaW5kZW50ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbihudWxsKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoc210KTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhcmVudCA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJlbnQgPT09IHRoaXMpXG5cdFx0XHRcdHJldHVybiBwYXJlbnQuZ2V0Q2hpbGRyZW4obnVsbCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKDxTdGF0ZW1lbnQ+cGFyZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGNoaWxkIFN0YXRlbWVudCBvYmplY3RzIG9mIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBTdGF0ZW1lbnQuIElmIHRoZSBhcmd1bWVudCBpcyBudWxsIG9yIG9taXR0ZWQsIHRoZSBkb2N1bWVudCdzXG5cdFx0ICogdG9wLWxldmVsIHN0YXRlbWVudHMgYXJlIHJldHVybmVkLiBJZiB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudCBcblx0XHQgKiBpcyBub3QgZm91bmQgaW4gdGhlIGRvY3VtZW50LCB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbnVsbC5cblx0XHQgKi9cblx0XHRnZXRDaGlsZHJlbihzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bGwgPSBudWxsKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNoaWxkcmVuOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBTdG9yZXMgdGhlIGluZGVudCB2YWx1ZSB0aGF0IGNhdXNlcyB0aGUgbG9vcFxuXHRcdFx0Ly8gdG8gdGVybWluYXRlIHdoZW4gcmVhY2hlZC5cblx0XHRcdGNvbnN0IGJyZWFrSW5kZW50ID0gc3RhdGVtZW50ID8gc3RhdGVtZW50LmluZGVudCA6IC0xO1xuXHRcdFx0bGV0IGNoaWxkSW5kZW50ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0YXJ0SWR4ID0gc3RhdGVtZW50ID8gXG5cdFx0XHRcdHRoaXMuZ2V0TGluZU51bWJlcihzdGF0ZW1lbnQpIDpcblx0XHRcdFx0LTE7XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0SWR4ID49IHRoaXMuc3RhdGVtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaWR4ID0gc3RhcnRJZHg7ICsraWR4IDwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZW1lbnQgPSB0aGlzLnN0YXRlbWVudHNbaWR4XTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYmFjayB1cCB0aGUgaW5kZW50YXRpb25cblx0XHRcdFx0Ly8gb2YgY2hpbGQgc3RhdGVtZW50cywgaW4gb3JkZXIgdG8gZGVhbCB3aXRoIGJpemFycmVcblx0XHRcdFx0Ly8gKGJ1dCB1bmZvcnR1bmF0ZWx5LCB2YWxpZCkgaW5kZW50YXRpb24uXG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCA8IGNoaWxkSW5kZW50KVxuXHRcdFx0XHRcdGNoaWxkSW5kZW50ID0gY3VycmVudFN0YXRlbWVudC5pbmRlbnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgYSBzZXJpZXMgb2YgYVxuXHRcdFx0XHQvLyBzdGF0ZW1lbnQgbG9jYWxpdHkuXG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCA8PSBicmVha0luZGVudClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCA8PSBjaGlsZEluZGVudClcblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGN1cnJlbnRTdGF0ZW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY2hpbGRyZW47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBzdGF0ZW1lbnQsIG9yIHRoZSBzdGF0ZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBoYXMgYW55XG5cdFx0ICogZGVzY2VuZGFudHMuIElmIHRoZSBhcmd1bWVudCBpcyBudWxsLCB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYVxuXHRcdCAqIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgZG9jdW1lbnQgaGFzIGFueSBub24tbm9vcFxuXHRcdCAqIHN0YXRlbWVudHMuXG5cdFx0ICovXG5cdFx0aGFzRGVzY2VuZGFudHMoc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudW1iZXIgfCBudWxsKVxuXHRcdHtcblx0XHRcdGlmIChzdGF0ZW1lbnQgPT09IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IGlkeCA9IC0xOyArK2lkeCA8IHRoaXMuc3RhdGVtZW50cy5sZW5ndGg7KVxuXHRcdFx0XHRcdGlmICghdGhpcy5zdGF0ZW1lbnRzW2lkeF0uaXNOb29wKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHNtdCA9IHN0YXRlbWVudCBpbnN0YW5jZW9mIFN0YXRlbWVudCA/XG5cdFx0XHRcdFx0c3RhdGVtZW50IDogXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZW1lbnRzW3N0YXRlbWVudF07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc210LmlzTm9vcClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgaWR4ID0gc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50ID9cblx0XHRcdFx0XHR0aGlzLmdldExpbmVOdW1iZXIoc3RhdGVtZW50KSA6XG5cdFx0XHRcdFx0c3RhdGVtZW50O1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKCsraWR4IDwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZW1lbnQgPSB0aGlzLnN0YXRlbWVudHNbaWR4XTtcblx0XHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pc05vb3ApXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gY3VycmVudFN0YXRlbWVudC5pbmRlbnQgPiBzbXQuaW5kZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50IGluXG5cdFx0ICogdGhlIGRvY3VtZW50LCByZWx5aW5nIG9uIGNhY2hpbmcgd2hlbiBhdmFpbGFibGUuXG5cdFx0ICogSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZG9jdW1lbnQsXG5cdFx0ICogdGhlIHJldHVybmVkIHZhbHVlIGlzIC0xLlxuXHRcdCAqL1xuXHRcdGdldExpbmVOdW1iZXIoc3RhdGVtZW50OiBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50cy5pbmRleE9mKHN0YXRlbWVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRcblx0XHQgKiB3cml0dGVuIGluIHRoZSBjb21tZW50cyBkaXJlY3RseSBhYm92ZSB0aGUgc3BlY2lmaWVkXG5cdFx0ICogc3RhdGVtZW50LiBXaGl0ZXNwYWNlIGxpbmVzIGFyZSBpZ25vcmVkLiBJZiB0aGUgc3BlY2lmaWVkXG5cdFx0ICogc3RhdGVtZW50IGlzIGEgbm8tb3AsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdGdldE5vdGVzKHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNtdCA9IHRoaXMudG9TdGF0ZW1lbnQoc3RhdGVtZW50KTtcblx0XHRcdGlmIChzbXQuaXNOb29wKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IGxpbmVOdW0gPSB0aGlzLmdldExpbmVOdW1iZXIoc210KTtcblx0XHRcdGlmIChsaW5lTnVtIDwgMSlcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb21tZW50TGluZXM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRjb25zdCByZXF1aXJlZEluZGVudCA9IHNtdC5pbmRlbnQ7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IG51bSA9IGxpbmVOdW07IG51bS0tOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlbWVudCA9IHRoaXMuc3RhdGVtZW50c1tudW1dO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaXNXaGl0ZXNwYWNlKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY29tbWVudFRleHQgPSBjdXJyZW50U3RhdGVtZW50LmdldENvbW1lbnRUZXh0KCk7XG5cdFx0XHRcdGlmIChjb21tZW50VGV4dCA9PT0gbnVsbClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmluZGVudCAhPT0gcmVxdWlyZWRJbmRlbnQpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb21tZW50TGluZXMucHVzaChjb21tZW50VGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIGNvbW1lbnRMaW5lcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRW51bWVyYXRlcyB0aHJvdWdoIGVhY2ggc3RhdGVtZW50IHRoYXQgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBcblx0XHQgKiBzcGVjaWZpZWQgc3RhdGVtZW50LiBJZiB0aGUgcGFyYW1ldGVycyBhcmUgbnVsbCBvciBvbWl0dGVkLCBhbGwgXG5cdFx0ICogc3RhdGVtZW50cyBpbiB0aGlzIERvY3VtZW50IGFyZSB5aWVsZGVkLlxuXHRcdCAqIFxuXHRcdCAqIFRoZSBtZXRob2QgeWllbGRzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB5aWVsZGVkIHN0YXRlbWVudCxcblx0XHQgKiBhcyB3ZWxsIGFzIGEgbnVtZXJpYyBsZXZlbCB2YWx1ZSB0aGF0IHNwZWNpZmllcyB0aGUgZGlmZmVyZW5jZSBpbiBcblx0XHQgKiB0aGUgbnVtYmVyIG9mIG5lc3RpbmcgbGV2ZWxzIGJldHdlZW4gdGhlIHNwZWNpZmllZCBpbml0aWFsU3RhdGVtZW50XG5cdFx0ICogYW5kIHRoZSB5aWVsZGVkIHN0YXRlbWVudC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5pdGlhbFN0YXRlbWVudCBBIHJlZmVyZW5jZSB0byB0aGUgc3RhdGVtZW50IG9iamVjdFxuXHRcdCAqIGZyb20gd2hlcmUgdGhlIGVudW1lcmF0aW9uIHNob3VsZCBiZWdpbi5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5jbHVkZUluaXRpYWwgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvclxuXHRcdCAqIG5vdCB0aGUgc3BlY2lmaWVkIGluaXRpYWxTdGF0ZW1lbnQgc2hvdWxkIGFsc28gYmUgcmV0dXJuZWRcblx0XHQgKiBhcyBhbiBlbGVtZW50IGluIHRoZSBlbnVtZXJhdGlvbi4gSWYgdHJ1ZSwgaW5pdGlhbFN0YXRlbWVudFxuXHRcdCAqIG11c3QgYmUgbm9uLW51bGwuXG5cdFx0ICovXG5cdFx0KmVhY2hEZXNjZW5kYW50KFxuXHRcdFx0aW5pdGlhbFN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVsbCA9IG51bGwsIFxuXHRcdFx0aW5jbHVkZUluaXRpYWw/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGlmIChpbmNsdWRlSW5pdGlhbClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFpbml0aWFsU3RhdGVtZW50KVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHlpZWxkIHsgc3RhdGVtZW50OiBpbml0aWFsU3RhdGVtZW50LCBsZXZlbDogMCB9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBpbml0aWFsQ2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKGluaXRpYWxTdGF0ZW1lbnQpO1xuXHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBpbml0aWFsIGxldmVsIGlzIDAgaWYgdGhlIHNwZWNpZmllZCBpbml0aWFsU3RhdGVtZW50IGlzXG5cdFx0XHQvLyBudWxsLCBiZWNhdXNlIGl0IGluZGljYXRlcyB0aGF0IHRoZSBlbnVtZXJhdGlvbiBzdGFydHNcblx0XHRcdC8vIGF0IHRoZSByb290IG9mIHRoZSBkb2N1bWVudC5cblx0XHRcdGxldCBsZXZlbCA9IGluaXRpYWxTdGF0ZW1lbnQgPyAxIDogMDtcblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2Uoc3RhdGVtZW50OiBTdGF0ZW1lbnQpOiBJdGVyYWJsZUl0ZXJhdG9yPHtcblx0XHRcdFx0c3RhdGVtZW50OiBTdGF0ZW1lbnQ7XG5cdFx0XHRcdGxldmVsOiBudW1iZXI7XG5cdFx0XHR9PlxuXHRcdFx0e1xuXHRcdFx0XHR5aWVsZCB7IHN0YXRlbWVudCwgbGV2ZWwgfTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldmVsKys7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGNoaWxkU3RhdGVtZW50IG9mIHNlbGYuZ2V0Q2hpbGRyZW4oc3RhdGVtZW50KSlcblx0XHRcdFx0XHR5aWVsZCAqcmVjdXJzZShjaGlsZFN0YXRlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXZlbC0tO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHN0YXRlbWVudCBvZiBpbml0aWFsQ2hpbGRyZW4pXG5cdFx0XHRcdHlpZWxkICpyZWN1cnNlKHN0YXRlbWVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICogRW51bWVyYXRlcyB0aHJvdWdoIGVhY2ggdW5pcXVlIFVSSSBkZWZpbmVkIGluIHRoaXMgZG9jdW1lbnQsXG5cdFx0ICogdGhhdCBhcmUgcmVmZXJlbmNlZCB3aXRoaW4gdGhlIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBzdGF0ZW1lbnQuIElmIHRoZSBwYXJhbWV0ZXJzIGFyZSBudWxsIG9yIG9taXR0ZWQsIGFsbCB1bmlxdWVcblx0XHQgKiBVUklzIHJlZmVyZW5jZWQgaW4gdGhpcyBkb2N1bWVudCBhcmUgeWllbGRlZC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5pdGlhbFN0YXRlbWVudCBBIHJlZmVyZW5jZSB0byB0aGUgc3RhdGVtZW50IG9iamVjdFxuXHRcdCAqIGZyb20gd2hlcmUgdGhlIGVudW1lcmF0aW9uIHNob3VsZCBiZWdpbi5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5jbHVkZUluaXRpYWwgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvclxuXHRcdCAqIG5vdCB0aGUgc3BlY2lmaWVkIGluaXRpYWxTdGF0ZW1lbnQgc2hvdWxkIGFsc28gYmUgcmV0dXJuZWRcblx0XHQgKiBhcyBhbiBlbGVtZW50IGluIHRoZSBlbnVtZXJhdGlvbi4gSWYgdHJ1ZSwgaW5pdGlhbFN0YXRlbWVudFxuXHRcdCAqIG11c3QgYmUgbm9uLW51bGwuXG5cdFx0ICovXG5cdFx0KmVhY2hVcmkoXG5cdFx0XHRpbml0aWFsU3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudWxsID0gbnVsbCxcblx0XHRcdGluY2x1ZGVJbml0aWFsPzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gTk9URTogQWx0aG91Z2ggdGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCwgaWYgaXQgd2VyZVxuXHRcdFx0Ly8gdG8gYmUgcmV2aXZlZCwgaXQgd291bGQgbmVlZCB0byBzdXBwb3J0IFwiY3J1ZnRcIi5cblx0XHRcdC8vXG5cdFx0XHRcblx0XHRcdGNvbnN0IHlpZWxkZWRVcmlzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0XHRjb25zdCBpdGVyID0gdGhpcy5lYWNoRGVzY2VuZGFudChpbml0aWFsU3RhdGVtZW50LCBpbmNsdWRlSW5pdGlhbCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZGVzY2VuZGFudCBvZiBpdGVyKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgZGVzY2VuZGFudC5zdGF0ZW1lbnQuZGVjbGFyYXRpb25zKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzcGluZSBvZiBzcGFuLmZhY3RvcigpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHVyaSA9IFVyaS5jbG9uZShzcGluZSk7XG5cdFx0XHRcdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICgheWllbGRlZFVyaXMuaGFzKHVyaVRleHQpKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR5aWVsZGVkVXJpcy5hZGQodXJpVGV4dCk7XG5cdFx0XHRcdFx0XHRcdHlpZWxkIHsgdXJpLCB1cmlUZXh0IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVudW1lcmF0ZXMgdGhyb3VnaCBlYWNoIHN0YXRlbWVudCBpbiB0aGUgZG9jdW1lbnQsXG5cdFx0ICogaW5jbHVkaW5nIGNvbW1lbnRzIGFuZCB3aGl0ZXNwYWNlLW9ubHkgbGluZXMsIHN0YXJ0aW5nXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQgb3IgbnVtZXJpYyBwb3NpdGlvbi5cblx0XHQgKiBcblx0XHQgKiBAeWllbGRzIFRoZSBzdGF0ZW1lbnRzIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXBwZWFyXG5cdFx0ICogaW4gdGhlIGRvY3VtZW50LCBleGNsdWRpbmcgd2hpdGVzcGFjZS1vbmx5IHN0YXRlbWVudHMuXG5cdFx0ICovXG5cdFx0KmVhY2hTdGF0ZW1lbnQoc3RhdGVtZW50PzogU3RhdGVtZW50IHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN0YXJ0TnVtID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghc3RhdGVtZW50KVxuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHN0YXRlbWVudCBpbnN0YW5jZW9mIFN0YXRlbWVudClcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRMaW5lTnVtYmVyKHN0YXRlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gc3RhdGVtZW50O1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0TnVtIC0gMTsgKytpIDwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aDspXG5cdFx0XHRcdHlpZWxkIHRoaXMuc3RhdGVtZW50c1tpXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgdGhlIFN0YXRlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5cdFx0ICogTmVnYXRpdmUgbnVtYmVycyByZWFkIFN0YXRlbWVudCBzdGFydGluZyBmcm9tIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHJlYWQobGluZU51bWJlcjogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IGxpbmVCb3VuZGVkID0gYXBwbHlCb3VuZHMobGluZU51bWJlciwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZW1lbnRzW2xpbmVCb3VuZGVkXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY29udmVydHMgYSBzdGF0ZW1lbnQgb3IgaXQncyBpbmRleFxuXHRcdCAqIHdpdGhpbiB0aGlzIGRvY3VtZW50IHRvIGEgc3RhdGVtZW50IG9iamVjdC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHRvU3RhdGVtZW50KHN0YXRlbWVudE9ySW5kZXg6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRyZXR1cm4gc3RhdGVtZW50T3JJbmRleCBpbnN0YW5jZW9mIFN0YXRlbWVudCA/IFxuXHRcdFx0XHRzdGF0ZW1lbnRPckluZGV4IDpcblx0XHRcdFx0dGhpcy5yZWFkKHN0YXRlbWVudE9ySW5kZXgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcXVpY2tseSB0dXJuIGEgdmFsdWUgdGhhdCBtYXkgYmVcblx0XHQgKiBhIHN0YXRlbWVudCBvciBhIHN0YXRlbWVudCBpbmRleCwgaW50byBhIGJvdW5kZWQgc3RhdGVtZW50IFxuXHRcdCAqIGluZGV4LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgdG9MaW5lTnVtYmVyKHN0YXRlbWVudE9ySW5kZXg6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRyZXR1cm4gc3RhdGVtZW50T3JJbmRleCBpbnN0YW5jZW9mIFN0YXRlbWVudCA/XG5cdFx0XHRcdHRoaXMuZ2V0TGluZU51bWJlcihzdGF0ZW1lbnRPckluZGV4KSA6XG5cdFx0XHRcdGFwcGx5Qm91bmRzKHN0YXRlbWVudE9ySW5kZXgsIHRoaXMuc3RhdGVtZW50cy5sZW5ndGgpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogXG5cdFx0ICogU3RhcnRzIGFuIGVkaXQgdHJhbnNhY3Rpb24gaW4gdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbi5cblx0XHQgKiBFZGl0IHRyYW5zYWN0aW9ucyBhcmUgdXNlZCB0byBzeW5jaHJvbml6ZSBjaGFuZ2VzIG1hZGUgaW5cblx0XHQgKiBhbiB1bmRlcmx5aW5nIGZpbGUsIHR5cGljYWxseSBkb25lIGJ5IGEgdXNlciBpbiBhIHRleHQgZWRpdGluZ1xuXHRcdCAqIGVudmlyb25tZW50LiBTeXN0ZW0taW5pdGlhdGVkIGNoYW5nZXMgc3VjaCBhcyBhdXRvbWF0ZWRcblx0XHQgKiBmaXhlcywgcmVmYWN0b3JzLCBvciByZW5hbWVzIGRvIG5vdCBnbyB0aHJvdWdoIHRoaXMgcGF0aHdheS5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gZWRpdEZuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpbiB3aGljaCB0byBwZXJmb3JtXG5cdFx0ICogZG9jdW1lbnQgbXV0YXRpb24gb3BlcmF0aW9ucy5cblx0XHQgKi9cblx0XHRlZGl0KGVkaXRGbjogKG11dGF0b3I6IElEb2N1bWVudE11dGF0b3IpID0+IHZvaWQpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaW5FZGl0KVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uZG91YmxlVHJhbnNhY3Rpb24oKTtcblx0XHRcdFxuXHRcdFx0Y2xhc3MgSW5zZXJ0Q2FsbCB7IGNvbnN0cnVjdG9yKHJlYWRvbmx5IHNtdDogU3RhdGVtZW50LCByZWFkb25seSBhdDogbnVtYmVyKSB7IH0gfVxuXHRcdFx0Y2xhc3MgVXBkYXRlQ2FsbCB7IGNvbnN0cnVjdG9yKHJlYWRvbmx5IHNtdDogU3RhdGVtZW50LCByZWFkb25seSBhdDogbnVtYmVyKSB7IH0gfVxuXHRcdFx0Y2xhc3MgRGVsZXRlQ2FsbCB7IGNvbnN0cnVjdG9yKHJlYWRvbmx5IGF0OiBudW1iZXIsIHJlYWRvbmx5IGNvdW50OiBudW1iZXIpIHsgfSB9XG5cdFx0XHR0eXBlIFRDYWxsVHlwZSA9IEluc2VydENhbGwgfCBVcGRhdGVDYWxsIHwgRGVsZXRlQ2FsbDtcblx0XHRcdGNvbnN0IGNhbGxzOiBUQ2FsbFR5cGVbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRsZXQgaGFzRGVsZXRlID0gZmFsc2U7XG5cdFx0XHRsZXQgaGFzSW5zZXJ0ID0gZmFsc2U7XG5cdFx0XHRsZXQgaGFzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHRoaXMuaW5FZGl0ID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0ZWRpdEZuKHtcblx0XHRcdFx0ZGVsZXRlOiAoYXQgPSAtMSwgY291bnQgPSAxKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjYWxscy5wdXNoKG5ldyBEZWxldGVDYWxsKGF0LCBjb3VudCkpO1xuXHRcdFx0XHRcdFx0aGFzRGVsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydDogKHRleHQ6IHN0cmluZywgYXQgPSAtMSkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhbGxzLnB1c2gobmV3IEluc2VydENhbGwobmV3IFN0YXRlbWVudCh0aGlzLCB0ZXh0KSwgYXQpKTtcblx0XHRcdFx0XHRoYXNJbnNlcnQgPSB0cnVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cGRhdGU6ICh0ZXh0OiBzdHJpbmcsIGF0ID0gLTEpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBib3VuZEF0ID0gYXBwbHlCb3VuZHMoYXQsIHRoaXMuc3RhdGVtZW50cy5sZW5ndGgpO1xuXHRcdFx0XHRcdGlmICh0aGlzLnJlYWQoYm91bmRBdCkuc291cmNlVGV4dCAhPT0gdGV4dClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjYWxscy5wdXNoKG5ldyBVcGRhdGVDYWxsKG5ldyBTdGF0ZW1lbnQodGhpcywgdGV4dCksIGF0KSk7XG5cdFx0XHRcdFx0XHRoYXNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGlmIChjYWxscy5sZW5ndGggPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuaW5FZGl0ID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQmVnaW4gdGhlIGFsZ29yaXRobSB0aGF0IGRldGVybWluZXMgdGhlIGNoYW5nZXNldCxcblx0XHRcdC8vIGFuZCBydW5zIHRoZSBhcHByb3ByaWF0ZSBpbnZhbGlkYXRpb24gYW5kIHJldmFsaWRhdGlvblxuXHRcdFx0Ly8gaG9va3MuIFRoaXMgaXMgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2Ugd2UgbmVlZCB0b1xuXHRcdFx0Ly8gcGVyZm9ybSBmaW5hbGl6YXRpb24gYXQgdGhlIGJvdHRvbSAoYW5kIHRoZXJlIGFyZSBlYXJseVxuXHRcdFx0Ly8gcmV0dXJuIHBvaW50cyB0aHJvdWdob3V0IHRoZSBhbGdvcml0aG0uXG5cdFx0XHQoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaGFzTWl4ZWQgPVxuXHRcdFx0XHRcdGhhc0luc2VydCAmJiBoYXNVcGRhdGUgfHxcblx0XHRcdFx0XHRoYXNJbnNlcnQgJiYgaGFzRGVsZXRlIHx8XG5cdFx0XHRcdFx0aGFzVXBkYXRlICYmIGhhc0RlbGV0ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJvdW5kQXQgPSAoY2FsbDogVENhbGxUeXBlKSA9PlxuXHRcdFx0XHRcdGFwcGx5Qm91bmRzKGNhbGwuYXQsIHRoaXMuc3RhdGVtZW50cy5sZW5ndGgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZG9EZWxldGUgPSAoY2FsbDogRGVsZXRlQ2FsbCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGF0ID0gYm91bmRBdChjYWxsKTtcblx0XHRcdFx0XHRjb25zdCBzbXRzID0gdGhpcy5zdGF0ZW1lbnRzLnNwbGljZShhdCwgY2FsbC5jb3VudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzbXQgb2Ygc210cylcblx0XHRcdFx0XHRcdHNtdC5kaXNwb3NlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIHNtdHM7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkb0luc2VydCA9IChjYWxsOiBJbnNlcnRDYWxsKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNhbGwuYXQgPj0gdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHMucHVzaChjYWxsLnNtdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBhdCA9IGJvdW5kQXQoY2FsbCk7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHMuc3BsaWNlKGF0LCAwLCBjYWxsLnNtdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZG9VcGRhdGUgPSAoY2FsbDogVXBkYXRlQ2FsbCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGF0ID0gYm91bmRBdChjYWxsKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHNbYXRdLmRpc3Bvc2UoKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHNbYXRdID0gY2FsbC5zbXQ7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWhhc01peGVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gVGhpcyBoYW5kbGVzIHRoZSBmaXJzdCBvcHRpbWl6YXRpb24sIHdoaWNoIGlzIHRoZSBjYXNlIHdoZXJlXG5cdFx0XHRcdFx0Ly8gdGhlIG9ubHkga2luZHMgb2YgbXV0YXRpb25zIHdoZXJlIHVwZGF0ZXMsIGFuZCBubyBzdHJ1Y3R1cmFsXG5cdFx0XHRcdFx0Ly8gY2hhbmdlcyBvY2N1cmVkLiBUaGlzIGhhbmRsZXMgdHlwaWNhbCBcInVzZXIgaXMgdHlwaW5nXCIgY2FzZXMuXG5cdFx0XHRcdFx0Ly8gTW9zdCBlZGl0cyB3aWxsIGJlIGNhdWdodCBoZXJlLlxuXHRcdFx0XHRcdGlmIChoYXNVcGRhdGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gU29ydCB0aGUgdXBkYXRlIGNhbGxzIGJ5IHRoZWlyIGluZGV4LCBhbmQgcHJ1bmUgdXBkYXRlc1xuXHRcdFx0XHRcdFx0Ly8gdGhhdCB3b3VsZCBiZSBvdmVycmlkZGVuIGluIGEgZm9sbG93aW5nIGNhbGwuXG5cdFx0XHRcdFx0XHQvLyEgUmVtb3ZlIHRoaXMgdW5uZWNlc3NhcnkgdmFyaWFibGUgb25jZSB3ZSBjYW4gZG8gdGhhdFxuXHRcdFx0XHRcdFx0Ly8hIHdpdGhvdXQgRVNMaW50IGNvbXBsYWluaW5nICh1bm5lY2Vzc2FyeSBicmFja2V0cykuXG5cdFx0XHRcdFx0XHRjb25zdCB1cGRhdGVDYWxsc1R5cGVkID0gY2FsbHMgYXMgVXBkYXRlQ2FsbFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgdXBkYXRlQ2FsbHMgPSB1cGRhdGVDYWxsc1R5cGVkXG5cdFx0XHRcdFx0XHRcdC5zb3J0KChhLCBiKSA9PiBhLmF0IC0gYi5hdClcblx0XHRcdFx0XHRcdFx0LmZpbHRlcigoY2FsbCwgaSkgPT4gaSA+PSBjYWxscy5sZW5ndGggLSAxIHx8IGNhbGwuYXQgIT09IGNhbGxzW2kgKyAxXS5hdCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IG9sZFN0YXRlbWVudHMgPSB1cGRhdGVDYWxscy5tYXAoYyA9PiB0aGlzLnN0YXRlbWVudHNbYy5hdF0pO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3U3RhdGVtZW50cyA9IHVwZGF0ZUNhbGxzLm1hcChjID0+IGMuc210KTtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ZXMgPSBPYmplY3QuZnJlZXplKHVwZGF0ZUNhbGxzLm1hcChjID0+IGMuYXQpKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3Qgbm9TdHJ1Y3R1cmFsQ2hhbmdlcyA9IG9sZFN0YXRlbWVudHMuZXZlcnkoKG9sZFNtdCwgaWR4KSA9PlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuZXdTbXQgPSBuZXdTdGF0ZW1lbnRzW2lkeF07XG5cdFx0XHRcdFx0XHRcdHJldHVybiBvbGRTbXQuaW5kZW50ID09PSBuZXdTbXQuaW5kZW50IHx8XG5cdFx0XHRcdFx0XHRcdFx0b2xkU210LmlzTm9vcCAmJiBuZXdTbXQuaXNOb29wO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChub1N0cnVjdHVyYWxDaGFuZ2VzKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjb25zdCBoYXNPcFN0YXRlbWVudHMgPVxuXHRcdFx0XHRcdFx0XHRcdG9sZFN0YXRlbWVudHMuc29tZShzbXQgPT4gIXNtdC5pc05vb3ApIHx8XG5cdFx0XHRcdFx0XHRcdFx0bmV3U3RhdGVtZW50cy5zb21lKHNtdCA9PiAhc210LmlzTm9vcCk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzT3BTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGVsbCBzdWJzY3JpYmVycyB0byBibG93IGF3YXkgYWxsIHRoZSBvbGQgc3RhdGVtZW50cy5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlSW52YWxpZGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRvbGRTdGF0ZW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW5kZXhlcykpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBSdW4gdGhlIGFjdHVhbCBtdXRhdGlvbnNcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCB1cGRhdGVDYWxsIG9mIHVwZGF0ZUNhbGxzKVxuXHRcdFx0XHRcdFx0XHRcdGRvVXBkYXRlKHVwZGF0ZUNhbGwpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGhhc09wU3RhdGVtZW50cylcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdC8vIFRlbGwgc3Vic2NyaWJlcnMgd2hhdCBjaGFuZ2VkXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZVJldmFsaWRhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLCBcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1N0YXRlbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleGVzKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRoaXMgaGFuZGxlcyB0aGUgc2Vjb25kIG9wdGltaXphdGlvbiwgd2hpY2ggaXMgdGhlIGNhc2Ugd2hlcmVcblx0XHRcdFx0XHQvLyBvbmx5IGRlbGV0ZXMgb2NjdXJlZCwgYW5kIG5vbmUgb2YgdGhlIGRlbGV0ZWQgc3RhdGVtZW50cyBoYXZlIGFueVxuXHRcdFx0XHRcdC8vIGRlc2NlbmRhbnRzLiBUaGlzIHdpbGwgaGFuZGxlIHRoZSBtYWpvcml0eSBvZiBcImRlbGV0ZSBhIGxpbmVcIiBjYXNlcy5cblx0XHRcdFx0XHRpZiAoaGFzRGVsZXRlKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlbGV0ZUNhbGxzID0gPERlbGV0ZUNhbGxbXT5jYWxscztcblx0XHRcdFx0XHRcdGNvbnN0IGRlYWRTdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVhZEluZGV4ZXM6IG51bWJlcltdID0gW107XG5cdFx0XHRcdFx0XHRsZXQgaGFzT3BTdGF0ZW1lbnRzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvckNhbGxzOlxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBkZWxldGVDYWxsIG9mIGRlbGV0ZUNhbGxzKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IGRlbGV0ZUNhbGwuY291bnQ7KVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGVhZFNtdCA9IHRoaXMuc3RhdGVtZW50c1tkZWxldGVDYWxsLmF0ICsgaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuaGFzRGVzY2VuZGFudHMoZGVhZFNtdCkpXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVhZFN0YXRlbWVudHMubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrIGZvckNhbGxzO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRkZWFkU3RhdGVtZW50cy5wdXNoKGRlYWRTbXQpO1xuXHRcdFx0XHRcdFx0XHRcdGRlYWRJbmRleGVzLnB1c2goaSk7XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFkZWFkU210LmlzTm9vcClcblx0XHRcdFx0XHRcdFx0XHRcdGhhc09wU3RhdGVtZW50cyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGRlYWRTdGF0ZW1lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIFRlbGwgc3Vic2NyaWJlcnMgdG8gYmxvdyBhd2F5IGFsbCB0aGUgb2xkIHN0YXRlbWVudHMuXG5cdFx0XHRcdFx0XHRcdC8vIEFuIGVkaXQgdHJhbnNhY3Rpb24gY2FuIGJlIGF2b2lkZWQgY29tcGxldGVseSBpbiB0aGUgY2FzZVxuXHRcdFx0XHRcdFx0XHQvLyB3aGVuIHRoZSBvbmx5IHN0YXRlbWVudHMgdGhhdCB3ZXJlIGRlbGV0ZWQgd2VyZSBub29wcy5cblx0XHRcdFx0XHRcdFx0aWYgKGhhc09wU3RhdGVtZW50cylcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlSW52YWxpZGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWFkU3RhdGVtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRcdGRlYWRJbmRleGVzKSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBSdW4gdGhlIGFjdHVhbCBtdXRhdGlvbnNcblx0XHRcdFx0XHRcdFx0ZGVsZXRlQ2FsbHMuZm9yRWFjaChkb0RlbGV0ZSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBSdW4gYW4gZW1wdHkgcmV2YWxpZGF0aW9uIGhvb2ssIHRvIGNvbXBseSB3aXRoIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBydWxlIHRoYXQgZm9yIGV2ZXJ5IGludmFsaWRhdGlvbiBob29rLCB0aGVyZSBpcyBhbHdheXMgYVxuXHRcdFx0XHRcdFx0XHQvLyBjb3JyZXNwb25kaW5nIHJldmFsaWRhdGlvbiBob29rLlxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzT3BTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VSZXZhbGlkYXRlKHRoaXMsIFtdLCBbXSkpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGlzIGhhbmRsZXMgdGhlIHRoaXJkIG9wdGltaXphdGlvbiwgd2hpY2ggaXMgdGhlIGNhc2Vcblx0XHRcdFx0XHQvLyB3aGVyZSB0aGVyZSBhcmUgb25seSBub29wIHN0YXRlbWVudHMgYmVpbmcgaW5zZXJ0ZWRcblx0XHRcdFx0XHQvLyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdFx0XHRpZiAoaGFzSW5zZXJ0KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGluc2VydENhbGxzID0gPEluc2VydENhbGxbXT5jYWxscztcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRDYWxscy5ldmVyeShjYWxsID0+IGNhbGwuc210LmlzTm9vcCkpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGluc2VydENhbGxzLmZvckVhY2goZG9JbnNlcnQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBdCB0aGlzIHBvaW50LCB0aGUgY2hlY2tzIHRvIHNlZSBpZiB3ZSBjYW4gZ2V0IGF3YXkgd2l0aFxuXHRcdFx0XHQvLyBwZXJmb3JtaW5nIHNpbXBsaXN0aWMgdXBkYXRlcyBoYXZlIGZhaWxlZC4gU28gd2UgbmVlZFxuXHRcdFx0XHQvLyB0byByZXNvcnQgdG8gaW52YWxpZGF0aW5nIGFuZCByZXZhbGlkYXRpbmcgbGFyZ2VyIHN3YXRocyBcblx0XHRcdFx0Ly8gb2Ygc3RhdGVtZW50cy5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFN0b3JlcyBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHdob3NlIGRlc2NlbmRhbnQgc3RhdGVtZW50c1xuXHRcdFx0XHQvLyBzaG91bGQgYmUgaW52YWxpZGF0ZWQuIFxuXHRcdFx0XHQvL2NvbnN0IGludmFsaWRhdGVkUGFyZW50czogeyBhdDogbnVtYmVyOyBwYXJlbnQ6IFN0YXRlbWVudDsgfVtdID0gW107XG5cdFx0XHRcdGNvbnN0IGludmFsaWRhdGVkUGFyZW50cyA9IG5ldyBNYXA8bnVtYmVyLCBTdGF0ZW1lbnQ+KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTdG9yZXMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVudGlyZSBkb2N1bWVudFxuXHRcdFx0XHQvLyBuZWVkcyB0byBiZSBpbnZhbGlkYXRlZC5cblx0XHRcdFx0bGV0IG11c3RJbnZhbGlkYXRlRG9jID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgZmlyc3Qgc3RlcCBpcyB0byBnbyB0aHJvdWdoIGFsbCB0aGUgc3RhdGVtZW50cywgYW5kIGNvbXB1dGUgdGhlIFxuXHRcdFx0XHQvLyBzZXQgb2YgcGFyZW50IHN0YXRlbWVudHMgZnJvbSB3aGVyZSBpbnZhbGlkYXRpb24gc2hvdWxkIG9yaWdpbmF0ZS5cblx0XHRcdFx0Ly8gSW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzLCB0aGlzIHdpbGwgb25seSBiZSBvbmUgc2luZ2xlIHN0YXRlbWVudCBvYmplY3QuXG5cdFx0XHRcdGZvciAoY29uc3QgY2FsbCBvZiBjYWxscylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGF0Qm91bmRlZCA9IGFwcGx5Qm91bmRzKGNhbGwuYXQsIHRoaXMuc3RhdGVtZW50cy5sZW5ndGgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjYWxsIGluc3RhbmNlb2YgRGVsZXRlQ2FsbClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWxldGVkU3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzW2F0Qm91bmRlZF07XG5cdFx0XHRcdFx0XHRpZiAoZGVsZXRlZFN0YXRlbWVudC5pc05vb3ApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudChhdEJvdW5kZWQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgU3RhdGVtZW50KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpbnZhbGlkYXRlZFBhcmVudHMuc2V0KGNhbGwuYXQsIHBhcmVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bXVzdEludmFsaWRhdGVEb2MgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgdGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGNhbGwgaW5zdGFuY2VvZiBJbnNlcnRDYWxsKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoY2FsbC5zbXQuaXNOb29wKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoY2FsbCBpbnN0YW5jZW9mIFVwZGF0ZUNhbGwpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9sZFN0YXRlbWVudCA9IHRoaXMuc3RhdGVtZW50c1thdEJvdW5kZWRdO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKG9sZFN0YXRlbWVudC5pc05vb3AgJiYgY2FsbC5zbXQuaXNOb29wKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudEZyb21Qb3NpdGlvbihcblx0XHRcdFx0XHRcdFx0Y2FsbC5hdCxcblx0XHRcdFx0XHRcdFx0Y2FsbC5zbXQuaW5kZW50KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIFN0YXRlbWVudClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aW52YWxpZGF0ZWRQYXJlbnRzLnNldChjYWxsLmF0LCBwYXJlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocGFyZW50ID09PSB0aGlzKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRtdXN0SW52YWxpZGF0ZURvYyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQWx0aG91Z2ggdW5jbGVhciBob3cgdGhpcyBjb3VsZCBoYXBwZW4sIGlmIHRoZXJlXG5cdFx0XHRcdC8vIGFyZSBubyBpbnZhbGlkYXRlZCBwYXJlbnRzLCB3ZSBjYW4gc2FmZWx5IHJldHVybi5cblx0XHRcdFx0aWYgKCFtdXN0SW52YWxpZGF0ZURvYyAmJiBpbnZhbGlkYXRlZFBhcmVudHMuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBQcnVuZSBhbnkgcmVkdW5kYW50IHBhcmVudHMuIEEgcGFyZW50IGlzIHJlZHVuZGFudFxuXHRcdFx0XHQvLyB3aGVuIGl0J3MgYSBkZXNjZW5kYW50IG9mIGFub3RoZXIgcGFyZW50IGluIHRoZSBcblx0XHRcdFx0Ly8gaW52YWxpZGF0aW9uIGFycmF5LiBUaGUgYWxnb3JpdGhtIGJlbG93IGNvbXBhcmVzIHRoZVxuXHRcdFx0XHQvLyBzdGF0ZW1lbnQgYW5jZXN0cmllcyBvZiBlYWNoIHBvc3NpYmxlIHBhaXJzIG9mIGludmFsaWRhdGVkXG5cdFx0XHRcdC8vIHBhcmVudHMsIGFuZCBzcGxpY2VzIGludmFsaWRhdGVkIHBhcmVudHMgb3V0IG9mIHRoZSBcblx0XHRcdFx0Ly8gYXJyYXkgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgcGFyZW50IGlzIHBhcmVudGVkIGJ5IHNvbWVcblx0XHRcdFx0Ly8gb3RoZXIgaW52YWxpZGF0ZWQgcGFyZW50IGluIHRoZSBpbnZhbGlkYXRlZFBhcmVudHMgYXJyYXkuXG5cdFx0XHRcdGNvbnN0IGludmFsaWRhdGVkQW5jZXN0cmllczogU3RhdGVtZW50W11bXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBhdCBvZiBpbnZhbGlkYXRlZFBhcmVudHMua2V5cygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnkgPSB0aGlzLmdldEFuY2VzdHJ5KGF0KTtcblx0XHRcdFx0XHRpZiAoYW5jZXN0cnkpXG5cdFx0XHRcdFx0XHRpbnZhbGlkYXRlZEFuY2VzdHJpZXMucHVzaChhbmNlc3RyeSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpbnZhbGlkYXRlZEFuY2VzdHJpZXMubGVuZ3RoID4gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBpbnZhbGlkYXRlZEFuY2VzdHJpZXMubGVuZ3RoOyBpLS07KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGFuY2VzdHJ5QSA9IGludmFsaWRhdGVkQW5jZXN0cmllc1tpXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgbiA9IGk7IG4tLTspXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGFuY2VzdHJ5QiA9IGludmFsaWRhdGVkQW5jZXN0cmllc1tuXTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChhbmNlc3RyeUEubGVuZ3RoID09PSBhbmNlc3RyeUIubGVuZ3RoKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29uc3QgYUxlc3NCID0gYW5jZXN0cnlBLmxlbmd0aCA8IGFuY2VzdHJ5Qi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGFuY2VzdHJ5U2hvcnQgPSBhTGVzc0IgPyBhbmNlc3RyeUEgOiBhbmNlc3RyeUI7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGFuY2VzdHJ5TG9uZyA9IGFMZXNzQiA/IGFuY2VzdHJ5QiA6IGFuY2VzdHJ5QTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChhbmNlc3RyeVNob3J0LmV2ZXJ5KChzbXQsIGlkeCkgPT4gc210ID09PSBhbmNlc3RyeUxvbmdbaWR4XSkpXG5cdFx0XHRcdFx0XHRcdFx0aW52YWxpZGF0ZWRBbmNlc3RyaWVzLnNwbGljZShhTGVzc0IgPyBuIDogaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBwYXJlbnRzID0gbXVzdEludmFsaWRhdGVEb2MgPyBbXSA6IEFycmF5LmZyb20oaW52YWxpZGF0ZWRQYXJlbnRzLnZhbHVlcygpKTtcblx0XHRcdFx0Y29uc3QgaW5kZXhlcyA9IG11c3RJbnZhbGlkYXRlRG9jID8gW10gOiBBcnJheS5mcm9tKGludmFsaWRhdGVkUGFyZW50cy5rZXlzKCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTm90aWZ5IG9ic2VydmVycyBvZiB0aGUgSW52YWxpZGF0ZSBob29rIHRvIGludmFsaWRhdGUgdGhlXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgc2V0IG9mIHBhcmVudCBzdGF0ZW1lbnRzLlxuXHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlSW52YWxpZGF0ZSh0aGlzLCBwYXJlbnRzLCBpbmRleGVzKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkZWxldGVkU3RhdGVtZW50czogU3RhdGVtZW50W10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFBlcmZvcm0gdGhlIGRvY3VtZW50IG11dGF0aW9ucy5cblx0XHRcdFx0Zm9yIChjb25zdCBjYWxsIG9mIGNhbGxzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNhbGwgaW5zdGFuY2VvZiBEZWxldGVDYWxsKVxuXHRcdFx0XHRcdFx0ZGVsZXRlZFN0YXRlbWVudHMucHVzaCguLi5kb0RlbGV0ZShjYWxsKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZWxzZSBpZiAoY2FsbCBpbnN0YW5jZW9mIEluc2VydENhbGwpXG5cdFx0XHRcdFx0XHRkb0luc2VydChjYWxsKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbHNlIGlmIChjYWxsIGluc3RhbmNlb2YgVXBkYXRlQ2FsbClcblx0XHRcdFx0XHRcdGRvVXBkYXRlKGNhbGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IGRlbGV0ZWQgc3RhdGVtZW50cyBmcm9tIHRoZSBpbnZhbGlkYXRlZFBhcmVudHMgbWFwXG5cdFx0XHRcdGZvciAoY29uc3QgZGVsZXRlZFN0YXRlbWVudCBvZiBkZWxldGVkU3RhdGVtZW50cylcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFthdCwgcGFyZW50U3RhdGVtZW50XSBvZiBpbnZhbGlkYXRlZFBhcmVudHMpXG5cdFx0XHRcdFx0XHRpZiAoZGVsZXRlZFN0YXRlbWVudCA9PT0gcGFyZW50U3RhdGVtZW50KVxuXHRcdFx0XHRcdFx0XHRpbnZhbGlkYXRlZFBhcmVudHMuZGVsZXRlKGF0KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE5vdGlmeSBvYnNlcnZlcnMgb2YgdGhlIFJldmFsaWRhdGUgaG9vayB0byB1cGRhdGUgdGhlXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgc2V0IG9mIHBhcmVudCBzdGF0ZW1lbnRzLlxuXHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlUmV2YWxpZGF0ZShcblx0XHRcdFx0XHR0aGlzLCBcblx0XHRcdFx0XHRBcnJheS5mcm9tKGludmFsaWRhdGVkUGFyZW50cy52YWx1ZXMoKSksXG5cdFx0XHRcdFx0QXJyYXkuZnJvbShpbnZhbGlkYXRlZFBhcmVudHMua2V5cygpKVxuXHRcdFx0XHQpKTtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdC8vIFBlcmZvcm0gYSBkZWJ1Zy10aW1lIGNoZWNrIHRvIGJlIHN1cmUgdGhhdCB0aGVyZSBhcmVcblx0XHRcdC8vIG5vIGRpc3Bvc2VkIHN0YXRlbWVudHMgbGVmdCBoYW5naW5nIGFyb3VuZCBpbiB0aGUgZG9jdW1lbnRcblx0XHRcdC8vIGFmdGVyIHRoZSBlZGl0IHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG5cdFx0XHRpZiAoXCJERUJVR1wiKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiB0aGlzLnN0YXRlbWVudHMpXG5cdFx0XHRcdFx0aWYgKHNtdC5pc0Rpc3Bvc2VkKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBDbGVhbiBvdXQgYW55IHR5cGUgY2FjaGVcblx0XHRcdHRoaXMuX3R5cGVzID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gVGVsbCBzdWJzY3JpYmVycyB0aGF0IHRoZSBlZGl0IHRyYW5zYWN0aW9uIGNvbXBsZXRlZC5cblx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VFZGl0Q29tcGxldGUodGhpcykpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcdHRoaXMuaW5FZGl0ID0gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIGEgY29tcGxldGUgZWRpdCB0cmFuc2FjdGlvbiwgYXBwbHlpbmcgdGhlIHNlcmllc1xuXHRcdCAqIG9mIGVkaXRzIHNwZWNpZmllZCBpbiB0aGUgYGVkaXRzYCBwYXJhbWV0ZXIuIFxuXHRcdCAqL1xuXHRcdGVkaXRBdG9taWMoZWRpdHM6IElEb2N1bWVudEVkaXRbXSlcblx0XHR7XG5cdFx0XHR0aGlzLmVkaXQoc3RhdGVtZW50cyA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVkaXRJbmZvIG9mIGVkaXRzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCFlZGl0SW5mby5yYW5nZSlcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyByYW5nZSBpbmNsdWRlZC5cIik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRMaW5lID0gZWRpdEluZm8ucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTtcblx0XHRcdFx0XHRjb25zdCBlbmRMaW5lID0gZWRpdEluZm8ucmFuZ2UuZW5kTGluZU51bWJlciAtIDE7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRDaGFyID0gZWRpdEluZm8ucmFuZ2Uuc3RhcnRDb2x1bW4gLSAxO1xuXHRcdFx0XHRcdGNvbnN0IGVuZENoYXIgPSBlZGl0SW5mby5yYW5nZS5lbmRDb2x1bW4gLSAxO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0TGluZVRleHQgPSB0aGlzLnJlYWQoc3RhcnRMaW5lKS5zb3VyY2VUZXh0O1xuXHRcdFx0XHRcdGNvbnN0IGVuZExpbmVUZXh0ID0gdGhpcy5yZWFkKGVuZExpbmUpLnNvdXJjZVRleHQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgcHJlZml4U2VnbWVudCA9IHN0YXJ0TGluZVRleHQuc2xpY2UoMCwgc3RhcnRDaGFyKTtcblx0XHRcdFx0XHRjb25zdCBzdWZmaXhTZWdtZW50ID0gZW5kTGluZVRleHQuc2xpY2UoZW5kQ2hhcik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudHMgPSBlZGl0SW5mby50ZXh0LnNwbGl0KFwiXFxuXCIpO1xuXHRcdFx0XHRcdGNvbnN0IHBhc3RDb3VudCA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuXHRcdFx0XHRcdGNvbnN0IHByZXNlbnRDb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBkZWx0YUNvdW50ID0gcHJlc2VudENvdW50IC0gcGFzdENvdW50O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIERldGVjdCB0aGUgcHVyZSB1cGRhdGUgY2FzZXNcblx0XHRcdFx0XHRpZiAoZGVsdGFDb3VudCA9PT0gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAocGFzdENvdW50ID09PSAxKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLnVwZGF0ZShcblx0XHRcdFx0XHRcdFx0XHRwcmVmaXhTZWdtZW50ICsgZWRpdEluZm8udGV4dCArIHN1ZmZpeFNlZ21lbnQsIFxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0TGluZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLnVwZGF0ZShwcmVmaXhTZWdtZW50ICsgc2VnbWVudHNbMF0sIHN0YXJ0TGluZSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKylcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMudXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4U2VnbWVudCArIHNlZ21lbnRzW2ldICsgc3VmZml4U2VnbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0TGluZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMudXBkYXRlKHNlZ21lbnRzLnNsaWNlKC0xKVswXSArIHN1ZmZpeFNlZ21lbnQsIGVuZExpbmUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gRGV0ZWN0IHRoZSBwdXJlIGRlbGV0ZSBjYXNlc1xuXHRcdFx0XHRcdGlmIChkZWx0YUNvdW50IDwgMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBkZWxldGVDb3VudCA9IGRlbHRhQ291bnQgKiAtMTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBEZXRlY3QgYSBkZWxldGUgcmFuZ2luZyBmcm9tIHRoZSBlbmQgb2YgXG5cdFx0XHRcdFx0XHQvLyBvbmUgbGluZSwgdG8gdGhlIGVuZCBvZiBhIHN1Y2Nlc3NpdmUgbGluZVxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0Q2hhciA9PT0gc3RhcnRMaW5lVGV4dC5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdGlmIChlbmRDaGFyID09PSBlbmRMaW5lVGV4dC5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLmRlbGV0ZShzdGFydExpbmUgKyAxLCBkZWxldGVDb3VudCk7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gRGV0ZWN0IGEgZGVsZXRlIHJhbmdpbmcgZnJvbSB0aGUgc3RhcnQgb2Zcblx0XHRcdFx0XHRcdC8vIG9uZSBsaW5lIHRvIHRoZSBzdGFydCBvZiBhIHN1Y2Nlc3NpdmUgbGluZVxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0Q2hhciArIGVuZENoYXIgPT09IDApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMuZGVsZXRlKHN0YXJ0TGluZSwgZGVsZXRlQ291bnQpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gRGV0ZWN0IHRoZSBwdXJlIGluc2VydCBjYXNlc1xuXHRcdFx0XHRcdGlmIChkZWx0YUNvdW50ID4gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBDdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSwgYW5kIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBcblx0XHRcdFx0XHRcdC8vIGluc2VydGVkIGNvbnRlbnQgaXMgZW1wdHkgKG1vc3QgbGlrZWx5LCBlbnRlciB3YXMgcHJlc3NlZClcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChzdGFydENoYXIgPT09IHN0YXJ0TGluZVRleHQubGVuZ3RoICYmIHNlZ21lbnRzWzBdID09PSBcIlwiKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgKytpIDwgc2VnbWVudHMubGVuZ3RoOylcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZW1lbnRzLmluc2VydChzZWdtZW50c1tpXSwgc3RhcnRMaW5lICsgaSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gQ3Vyc29yIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUsIGFuZCB0aGVcblx0XHRcdFx0XHRcdC8vIGxhc3QgbGluZSBvZiB0aGUgaW5zZXJ0ZWQgY29udGVudCBpcyBlbXB0eS5cblx0XHRcdFx0XHRcdGlmIChzdGFydENoYXIgPT09IDAgJiYgc2VnbWVudHMuc2xpY2UoLTEpWzBdID09PSBcIlwiKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHNlZ21lbnRzLmxlbmd0aCAtIDE7KVxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMuaW5zZXJ0KHNlZ21lbnRzW2ldLCBzdGFydExpbmUgKyBpKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBcImZhbGxiYWNrXCIgYmVoYXZpb3IgLS0gc2ltcGx5IGRlbGV0ZSBldmVyeXRoaW5nXG5cdFx0XHRcdFx0Ly8gdGhhdCBpcyBvbGQsIGFuZCBpbnNlcnQgZXZlcnl0aGluZyB0aGF0IGlzIG5ldy5cblx0XHRcdFx0XHRjb25zdCBkZWxldGVDb3VudCA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuXHRcdFx0XHRcdHN0YXRlbWVudHMuZGVsZXRlKHN0YXJ0TGluZSwgZGVsZXRlQ291bnQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGluc2VydExpbmVzID0gc2VnbWVudHMuc2xpY2UoKTtcblx0XHRcdFx0XHRpbnNlcnRMaW5lc1swXSA9IHByZWZpeFNlZ21lbnQgKyBpbnNlcnRMaW5lc1swXTtcblx0XHRcdFx0XHRpbnNlcnRMaW5lc1tpbnNlcnRMaW5lcy5sZW5ndGggLSAxXSArPSBzdWZmaXhTZWdtZW50O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgaW5zZXJ0TGluZXMubGVuZ3RoOylcblx0XHRcdFx0XHRcdHN0YXRlbWVudHMuaW5zZXJ0KGluc2VydExpbmVzW2ldLCBzdGFydExpbmUgKyBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgdGhlIFVSSSBmcm9tIHdoZXJlIHRoaXMgZG9jdW1lbnQgd2FzIGxvYWRlZC4gKi9cblx0XHRnZXQgc291cmNlVXJpKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc291cmNlVXJpO1xuXHRcdH1cblx0XHRwcml2YXRlIF9zb3VyY2VVcmk6IFVyaTtcblx0XHRcblx0XHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSBDb21waWxlciB0aGF0IG93bnMgdGhpcyBEb2N1bWVudC4gKi9cblx0XHRyZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgY29tcGxldGUgbGlzdCBvZiB0aGUgRG9jdW1lbnQncyBzdGF0ZW1lbnRzLFxuXHRcdCAqIHNvcnRlZCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFwcGVhciBpbiB0aGUgZmlsZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHN0YXRlbWVudHM6IFN0YXRlbWVudFtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBzdGF0ZSB2YXJpYWJsZSB0aGF0IHN0b3JlcyB3aGV0aGVyIGFuXG5cdFx0ICogZWRpdCB0cmFuc2FjdGlvbiBpcyBjdXJyZW50bHkgdW5kZXJ3YXkuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBpbkVkaXQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBBIHJvbGxpbmcgdmVyc2lvbiBzdGFtcCB0aGF0IGluY3JlbWVudHMgYWZ0ZXIgZWFjaCBlZGl0IHRyYW5zYWN0aW9uLlxuXHRcdCAqL1xuXHRcdGdldCB2ZXJzaW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmVyc2lvbjtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfdmVyc2lvbiA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBEb2N1bWVudC5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhrZWVwT3JpZ2luYWxGb3JtYXR0aW5nPzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0aWYgKGtlZXBPcmlnaW5hbEZvcm1hdHRpbmcpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHRoaXMuc3RhdGVtZW50cylcblx0XHRcdFx0XHRsaW5lcy5wdXNoKHN0YXRlbWVudC5zb3VyY2VUZXh0KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgZm9yIChjb25zdCB7IHN0YXRlbWVudCwgbGV2ZWwgfSBvZiB0aGlzLmVhY2hEZXNjZW5kYW50KCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGluZGVudCA9IFN5bnRheC50YWIucmVwZWF0KGxldmVsKTtcblx0XHRcdFx0bGluZXMucHVzaChpbmRlbnQgKyBzdGF0ZW1lbnQudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYW4gaW50ZXJmYWNlIGZvciBjcmVhdGluZyBhXG5cdCAqIGJhdGNoIG9mIGRvY3VtZW50IG11dGF0aW9uIG9wZXJhdGlvbnMuXG5cdCAqL1xuXHRpbnRlcmZhY2UgSURvY3VtZW50TXV0YXRvclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0cyBhIGZhY3QgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgcmV0dXJucyB0aGUgaW5zZXJ0ZWQgRmFjdC4gXG5cdFx0ICogTmVnYXRpdmUgbnVtYmVycyBpbnNlcnQgZmFjdHMgc3RhcnRpbmcgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKiBUaGUgZmFjdFRleHQgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgb25lIHNpbmdsZSBjb21wbGV0ZSBsaW5lIG9mIHRleHQuXG5cdFx0ICovXG5cdFx0aW5zZXJ0KHRleHQ6IHN0cmluZywgYXQ6IG51bWJlcik6IHZvaWQ7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZXMgYSBmYWN0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIHJldHVybnMgdGhlIHJlcGxhY2VkIEZhY3QuIFxuXHRcdCAqIE5lZ2F0aXZlIG51bWJlcnMgaW5zZXJ0IGZhY3RzIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0ICogVGhlIGZhY3RUZXh0IGFyZ3VtZW50IGlzIGV4cGVjdGVkIHRvIGJlIG9uZSBzaW5nbGUgY29tcGxldGUgbGluZSBvZiB0ZXh0LlxuXHRcdCAqL1xuXHRcdHVwZGF0ZShmYWN0VGV4dDogc3RyaW5nLCBhdDogbnVtYmVyKTogdm9pZDtcblx0XHRcblx0XHQvKiogXG5cdFx0ICogRGVsZXRlcyBhIGZhY3QgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgcmV0dXJucyB0aGUgZGVsZXRlZCBGYWN0LiBcblx0XHQgKiBOZWdhdGl2ZSBudW1iZXJzIGRlbGV0ZSBmYWN0cyBzdGFydGluZyBmcm9tIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGRlbGV0ZShhdDogbnVtYmVyLCBjb3VudD86IG51bWJlcik6IHZvaWQ7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGludGVyZmFjZSBJRG9jdW1lbnRFZGl0XG5cdHtcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSByYW5nZSBpbiB0aGUgZG9jdW1lbnQgdGhhdCByZXByZXNlbnRzIHRoZVxuXHRcdCAqIGNvbnRlbnQgdGhhdCBzaG91bGQgYmUgcmVwbGFjZWQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgcmFuZ2U6IElEb2N1bWVudEVkaXRSYW5nZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIG5ldyB0ZXh0IHRvIGJlIGluc2VydGVkIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHRleHQ6IHN0cmluZztcblx0fVxuXG5cblx0LyoqXG5cdCAqIEFuIGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgYSB0ZXh0IHJhbmdlIHdpdGhpbiB0aGUgbG9hZGVkIGRvY3VtZW50LlxuXHQgKiBUaGlzIGludGVyZmFjZSBpcyBleHBsaWNpdGx5IGRlc2lnbmVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgTW9uYWNvXG5cdCAqIHRleHQgZWRpdG9yIEFQSSAoYW5kIG1heWJlIG90aGVycykgdG8gc2ltcGxpZnkgaW50ZWdyYXRpb25zLlxuXHQgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJRG9jdW1lbnRFZGl0UmFuZ2Vcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbGluZSBudW1iZXIgb24gd2hpY2ggdGhlIHJhbmdlIHN0YXJ0cyAoc3RhcnRzIGF0IDApLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHN0YXJ0TGluZU51bWJlcjogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgY29sdW1uIG9uIHdoaWNoIHRoZSByYW5nZSBzdGFydHMgaW4gbGluZVxuXHRcdCAqIGBzdGFydExpbmVOdW1iZXJgIChzdGFydHMgYXQgMCkuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgc3RhcnRDb2x1bW46IG51bWJlcjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGxpbmUgbnVtYmVyIG9uIHdoaWNoIHRoZSByYW5nZSBlbmRzLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGVuZExpbmVOdW1iZXI6IG51bWJlcjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIENvbHVtbiBvbiB3aGljaCB0aGUgcmFuZ2UgZW5kcyBpbiBsaW5lXG5cdFx0ICogYGVuZExpbmVOdW1iZXJgLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGVuZENvbHVtbjogbnVtYmVyO1xuXHR9XG5cblxuXHQvKipcblx0ICogR2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgeWllbGRzIGFsbCBzdGF0ZW1lbnRzICh1bnBhcnNlZCBsaW5lcylcblx0ICogb2YgdGhlIGdpdmVuIHNvdXJjZSB0ZXh0LiBcblx0ICovXG5cdGZ1bmN0aW9uICpyZWFkTGluZXMoc291cmNlOiBzdHJpbmcpXG5cdHtcblx0XHRsZXQgY3Vyc29yID0gLTE7XG5cdFx0bGV0IHN0YXRlbWVudFN0YXJ0ID0gMDtcblx0XHRjb25zdCBjaGFyID0gKCkgPT4gc291cmNlW2N1cnNvcl07XG5cdFx0XG5cdFx0Zm9yICg7Oylcblx0XHR7XG5cdFx0XHRpZiAoY3Vyc29yID49IHNvdXJjZS5sZW5ndGggLSAxKVxuXHRcdFx0XHRyZXR1cm4geWllbGQgc291cmNlLnNsaWNlKHN0YXRlbWVudFN0YXJ0KTtcblx0XHRcdFxuXHRcdFx0Y3Vyc29yKys7XG5cdFx0XHRcblx0XHRcdGlmIChjaGFyKCkgPT09IFN5bnRheC50ZXJtaW5hbClcblx0XHRcdHtcblx0XHRcdFx0eWllbGQgc291cmNlLnNsaWNlKHN0YXRlbWVudFN0YXJ0LCBjdXJzb3IpO1xuXHRcdFx0XHRzdGF0ZW1lbnRTdGFydCA9IGN1cnNvciArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogUGVyZm9ybXMgdGhlIGludGVnZXIgYm91bmRpbmcgYW5kIHdyYXBwaW5nIGZvcm11bGEgdGhhdCBpc1xuXHQgKiBjb21tb24gb24gYWxsIHBvc2l0aW9uYWwgYXJndW1lbnRzIGZvdW5kIGluIEphdmFTY3JpcHQgYXJyYXlcblx0ICogYW5kIHN0cmluZyBtZXRob2RzIChzdWNoIGFzIEFycmF5LnNsaWNlKS5cblx0ICovXG5cdGZ1bmN0aW9uIGFwcGx5Qm91bmRzKGluZGV4OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKVxuXHR7XG5cdFx0aWYgKGluZGV4ID09PSAwIHx8IGxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAwO1xuXHRcdFxuXHRcdGlmIChpbmRleCA+IDApXG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuXHRcdFxuXHRcdGlmIChpbmRleCA8IDApXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuXHRcdFxuXHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCBzdG9yZXMgYWxsIHRoZSBkb2N1bWVudHMgbG9hZGVkIGludG8gYVxuXHQgKiBwcm9ncmFtLCBhbmQgdGhlIGludGVyLWRlcGVuZGVuY2llcyBiZXR3ZWVuIHRoZW0uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRG9jdW1lbnRHcmFwaFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlRG9jdW1lbnRVcmlDaGFuZ2UsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbb2xkVXJpVGV4dCwgZG9jRW50cnldIG9mIHRoaXMuZG9jdW1lbnRzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGRvY0VudHJ5LmRvY3VtZW50ICE9PSBkYXRhLmRvY3VtZW50KVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbmV3VXJpVGV4dCA9IGRhdGEubmV3VXJpLnRvU3RvcmVTdHJpbmcoKTtcblx0XHRcdFx0XHRjb25zdCBlbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldChvbGRVcmlUZXh0KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZW50cnkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudHMuZGVsZXRlKG9sZFVyaVRleHQpO1xuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudHMuc2V0KG5ld1VyaVRleHQsIGVudHJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVJldmFsaWRhdGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZG9jVXJpID0gZGF0YS5kb2N1bWVudC5zb3VyY2VVcmkudG9TdHJpbmcoKTtcblx0XHRcdFx0Y29uc3QgZW50cnkgPSB0aGlzLmRvY3VtZW50cy5nZXQoZG9jVXJpKTtcblx0XHRcdFx0Y29uc3QgaGVhZGVyID0gZW50cnkgPyBlbnRyeS5oZWFkZXIgOiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhlIGhlYWRlciBpcyBiZWluZyByZS1jb21wdXRlZCBvbiBldmVyeSBkb2N1bWVudFxuXHRcdFx0XHQvLyBtb2RpZmljYXRpb24uIFRoZXJlIG1heSBiZSBzb21lIG9wdGltaXphdGlvbnMgaGVyZVxuXHRcdFx0XHQvLyB0byBlbGltaW5hdGUgcmVjb21wdXRlIGluIGNvbW1vbiBjYXNlcywgYnV0IGl0IHdvdWxkXG5cdFx0XHRcdC8vIGJlIGEgbWljcm8tb3B0aW1pemF0aW9uIGF0IHRoZSB0aW1lIG9mIHRoaXMgd3JpdGluZy5cblx0XHRcdFx0aWYgKGhlYWRlcilcblx0XHRcdFx0XHRoZWFkZXIucmVjb21wdXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVVyaVJlZmVyZW5jZUFkZCwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZGF0YS51cmkuZXh0ICE9PSBVcmlFeHRlbnNpb24udHJ1dGgpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc210ID0gZGF0YS5zdGF0ZW1lbnQ7XG5cdFx0XHRcdGlmIChzbXQpXG5cdFx0XHRcdFx0dGhpcy50cnlMaW5rKHNtdC5kb2N1bWVudCwgc210LCBkYXRhLnVyaSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVVyaVJlZmVyZW5jZVJlbW92ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZGF0YS51cmkuZXh0ICE9PSBVcmlFeHRlbnNpb24udHJ1dGgpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZW50cnkgPSB0aGlzLmRvY3VtZW50cy5nZXQoZGF0YS51cmkudG9TdG9yZVN0cmluZygpKTtcblx0XHRcdFx0aWYgKCFlbnRyeSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBzbXQgPSBkYXRhLnN0YXRlbWVudDtcblx0XHRcdFx0aWYgKHNtdClcblx0XHRcdFx0XHR0aGlzLnVubGluayhzbXQuZG9jdW1lbnQsIGVudHJ5LmRvY3VtZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWFkcyBhIERvY3VtZW50IGZyb20gdGhlIHNwZWNpZmllZCBVUkkuXG5cdFx0ICogVGhlIGRvY3VtZW50IGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLCBhc3luY2hyb25vdXNseS5cblx0XHQgKi9cblx0XHRhc3luYyByZWFkKHVyaTogc3RyaW5nIHwgVXJpKVxuXHRcdHtcblx0XHRcdGNvbnN0IHVyaVBhcnNlZCA9IFVyaS50cnlQYXJzZSh1cmkpO1xuXHRcdFx0aWYgKCF1cmlQYXJzZWQpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkVXJpKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHVyaUFic29sdXRlID0gdXJpUGFyc2VkLnRvQWJzb2x1dGUoKTtcblx0XHRcdGlmICghdXJpQWJzb2x1dGUpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVhZFJlc3VsdCA9IGF3YWl0IFVyaVJlYWRlci50cnlSZWFkKHVyaUFic29sdXRlKTtcblx0XHRcdGlmIChyZWFkUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpXG5cdFx0XHRcdHJldHVybiByZWFkUmVzdWx0O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGUodXJpQWJzb2x1dGUsIHJlYWRSZXN1bHQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRvY3VtZW50IHRoYXQgd2lsbCBleGlzdCBvbmx5IGluIG1lbW9yeS5cblx0XHQgKiBUaGUgZG9jdW1lbnQgbWF5IG5vdCBiZSBsaW5rZWQgdG8gb3RoZXIgZG9jdW1lbnRzIGluIHRoZVxuXHRcdCAqIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGNyZWF0ZSgpOiBEb2N1bWVudDtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRvY3VtZW50IHRoYXQgd2lsbCBleGlzdCBvbmx5IGluIG1lbW9yeSxcblx0XHQgKiB3aGljaCBpcyBpbml0aWFsaXplZCB3aXRoIHRoZSBzcGVjaWZpZWQgc291cmNlIHRleHQuIFRoZSBkb2N1bWVudFxuXHRcdCAqIG1heSBub3QgYmUgbGlua2VkIHRvIG90aGVyIGRvY3VtZW50cyBpbiB0aGUgZ3JhcGguXG5cdFx0ICovXG5cdFx0Y3JlYXRlKHNvdXJjZVRleHQ6IHN0cmluZyk6IERvY3VtZW50O1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGZyb20gdGhlIHNwZWNpZmllZCBVUkksIFxuXHRcdCAqIHdpdGggdGhlIHNwZWNpZmllZCBzb3VyY2VUZXh0LiBJZiB0aGUgY29udGVudCBzdGlsbCBuZWVkcyB0byBiZSBcblx0XHQgKiByZWFkIGZyb20gYSBVUkksIHVzZSB0aGUgLnJlYWQoKSBtZXRob2QuXG5cdFx0ICovXG5cdFx0Y3JlYXRlKHVyaTogVXJpIHwgc3RyaW5nLCBzb3VyY2VUZXh0OiBzdHJpbmcpOiBEb2N1bWVudDtcblx0XHRjcmVhdGUocGFyYW0xPzogVXJpIHwgc3RyaW5nLCBwYXJhbTI/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgemVyb0FyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwO1xuXHRcdFx0Y29uc3Qgb25lQXJnID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdXJpID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh6ZXJvQXJncyB8fCBvbmVBcmcpXG5cdFx0XHRcdFx0cmV0dXJuIFVyaS5jcmVhdGVJbnRlcm5hbCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFwYXJhbTEpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyYW0xIGluc3RhbmNlb2YgVXJpKVxuXHRcdFx0XHRcdHJldHVybiBwYXJhbTE7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gVXJpLnRyeVBhcnNlKHBhcmFtMSk7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXVyaSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRVcmkoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlVGV4dCA9IFxuXHRcdFx0XHR6ZXJvQXJncyA/IFwiXCIgOlxuXHRcdFx0XHRvbmVBcmcgPyAocGFyYW0xIHx8IFwiXCIpLnRvU3RyaW5nKCkgOlxuXHRcdFx0XHRwYXJhbTIgfHwgXCJcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZG9jdW1lbnQgPSBuZXcgRG9jdW1lbnQodGhpcy5wcm9ncmFtLCB1cmksIHNvdXJjZVRleHQpO1xuXHRcdFx0Y29uc3QgaGVhZGVyID0gbmV3IERvY3VtZW50SGVhZGVyKGRvY3VtZW50KTtcblx0XHRcdGNvbnN0IGVudHJ5OiBJRG9jdW1lbnRFbnRyeSA9IHsgZG9jdW1lbnQsIGhlYWRlciB9O1xuXHRcdFx0dGhpcy5kb2N1bWVudHMuc2V0KHVyaS50b1N0b3JlU3RyaW5nKCksIGVudHJ5KTtcblx0XHRcdGhlYWRlci5yZWNvbXB1dGUoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZURvY3VtZW50Q3JlYXRlKGRvY3VtZW50KSk7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEJsb2NrcyBleGVjdXRpb24gdW50aWwgYWxsIHF1ZXVlZCBJTyBvcGVyYXRpb25zIGhhdmUgY29tcGxldGVkLlxuXHRcdCAqL1xuXHRcdGF3YWl0KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5hc3luY0NvdW50ID09PSAwKVxuXHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRoaXMud2FpdEZucy5wdXNoKHJlc29sdmUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBkb2N1bWVudCBsb2FkZWQgaW50byB0aGlzIGdyYXBoXG5cdFx0ICogd2l0aCB0aGUgc3BlY2lmaWVkIFVSSS5cblx0XHQgKi9cblx0XHRnZXQodXJpOiBzdHJpbmcgfCBVcmkpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIgPyB1cmkgOiB1cmkudG9TdG9yZVN0cmluZygpO1xuXHRcdFx0Y29uc3QgZW50cnkgPSB0aGlzLmRvY3VtZW50cy5nZXQodXJpVGV4dCk7XG5cdFx0XHRyZXR1cm4gZW50cnkgPyBlbnRyeS5kb2N1bWVudCA6IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyXG5cdFx0ICogdGhlIHNwZWNpZmllZCBEb2N1bWVudCBoYXMgYmVlbiBsb2FkZWQgaW50b1xuXHRcdCAqIHRoaXMgRG9jdW1lbnRHcmFwaC5cblx0XHQgKi9cblx0XHRoYXMocGFyYW06IFVyaSB8IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdGlmIChwYXJhbSBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZG9jdW1lbnRzLnZhbHVlcygpKVxuXHRcdFx0XHRcdGlmIChlbnRyeS5kb2N1bWVudCA9PT0gcGFyYW0pXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuICEhdGhpcy5nZXQocGFyYW0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBkb2N1bWVudHMgbG9hZGVkIGludG8gdGhpc1xuXHRcdCAqIERvY3VtZW50R3JhcGguIFRoZSBhcnJheSByZXR1cm5lZCBpcyBzb3J0ZWQgdG9wb2xvZ2ljYWxseSBcblx0XHQgKiBmcm9tIGxlZnQgdG8gcmlnaHQsIHNvIHRoYXQgZm9yd2FyZCB0cmF2ZXJzYWxzIGFyZSBndWFyYW50ZWVkIFxuXHRcdCAqIHRvIG5vdCBjYXVzZSBkZXBlbmRlbmN5IGNvbmZsaWN0cy5cblx0XHQgKi9cblx0XHRlYWNoKClcblx0XHR7XG5cdFx0XHQvLyBUaGUgdG9wb2xvZ2ljYWwgc29ydGluZyBtZWNoYW5pc20gdXNlcyBhIHZhcmlhbnQgb2YgZGVwdGgtZmlyc3Qgc2VhcmNoLlxuXHRcdFx0Ly8gQWxnb3JpdGhtIGlzIGRlc2NyaWJlZCBoZXJlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nXG5cdFx0XHRcblx0XHRcdGNvbnN0IHNvcnRlZFJlc3VsdDogRG9jdW1lbnRbXSA9IFtdO1xuXHRcdFx0Y29uc3QgZG9jc0ZpbmFsaXplZCA9IG5ldyBTZXQ8RG9jdW1lbnQ+KCk7XG5cdFx0XHRjb25zdCBkb2NzSW5TdGFjayA9IG5ldyBTZXQ8RG9jdW1lbnQ+KCk7XG5cdFx0XHRjb25zdCBhbGxEb2NzID0gQXJyYXkuZnJvbSh0aGlzLmRvY3VtZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0Lm1hcChlbnRyeSA9PiBlbnRyeS5kb2N1bWVudCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlY3Vyc2UgPSAoY3VycmVudERvYzogRG9jdW1lbnQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkb2NzRmluYWxpemVkLmhhcyhjdXJyZW50RG9jKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBDeWNsZSBkZXRlY3RlZC4gVGhpcyBjb25kaXRpb24gc2hvdWxkIG5ldmVyIHBhc3MgYmVjYXVzZVxuXHRcdFx0XHQvLyBEb2N1bWVudEdyYXBoIGlzIHN1cHBvc2VkIHRvIHByZXZlbnQgY3ljbGVzLlxuXHRcdFx0XHRpZiAoZG9jc0luU3RhY2suaGFzKGN1cnJlbnREb2MpKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGRvY3NJblN0YWNrLmFkZChjdXJyZW50RG9jKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRlcHMgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQoY3VycmVudERvYyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZGVwcylcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKVxuXHRcdFx0XHRcdFx0cmVjdXJzZShkZXAudGFyZ2V0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGRvY3NGaW5hbGl6ZWQuYWRkKGN1cnJlbnREb2MpO1xuXHRcdFx0XHRzb3J0ZWRSZXN1bHQudW5zaGlmdChjdXJyZW50RG9jKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHdoaWxlIChkb2NzRmluYWxpemVkLnNpemUgPCBhbGxEb2NzLmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dFVudmlzaXRlZCA9IGFsbERvY3MuZmluZChkID0+ICFkb2NzRmluYWxpemVkLmhhcyhkKSk7XG5cdFx0XHRcdGlmICghbmV4dFVudmlzaXRlZClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZWN1cnNlKG5leHRVbnZpc2l0ZWQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc29ydGVkUmVzdWx0O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBEZWxldGVzIGEgZG9jdW1lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBsb2FkZWQgaW50byB0aGUgY29tcGlsZXIuXG5cdFx0ICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIGJ5IHRoZSBob3N0IGVudmlyb25tZW50IHdoZW4gYSBmaWxlIGNoYW5nZXMuXG5cdFx0ICovXG5cdFx0ZGVsZXRlKHRhcmdldDogRG9jdW1lbnQgfCBVcmkpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZG9jID0gdGFyZ2V0IGluc3RhbmNlb2YgRG9jdW1lbnQgPyB0YXJnZXQgOiAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZW50cnkgPSB0aGlzLmRvY3VtZW50cy5nZXQodGFyZ2V0LnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRyZXR1cm4gZW50cnkgPyBlbnRyeS5kb2N1bWVudCA6IG51bGw7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWRvYylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlRG9jdW1lbnRDcmVhdGUoZG9jKSk7XG5cdFx0XHRcblx0XHRcdC8vIEdvIHRocm91Z2ggdGhlIGVudGlyZSBtYXAgb2YgZGVwZW5kZW50IGRvY3VtZW50cywgXG5cdFx0XHQvLyBhbmQgZmluZCBkb2N1bWVudHMgdGhhdCBoYXZlIHRoZSBkZWxldGVkIGRvY3VtZW50IFxuXHRcdFx0Ly8gbGlzdGVkIGFzIG9uZSBvZiBpdCdzIGRlcGVuZGVudHMuIFRoZXNlIGRvY3VtZW50cyBhcmVcblx0XHRcdC8vIHRoZW4gcmVtb3ZlZCBmcm9tIHRoZSBhcnJheSBvZiBkZXBlbmRlbnRzLlxuXHRcdFx0Zm9yIChjb25zdCBbcmVmRG9jLCBkZXBlbmRlbnRzXSBvZiB0aGlzLmRlcGVuZGVudHMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGRvY0lkeCA9IGRlcGVuZGVudHMuaW5kZXhPZihkb2MpO1xuXHRcdFx0XHRpZiAoZG9jSWR4ID4gLTEpXG5cdFx0XHRcdFx0ZGVwZW5kZW50cy5zcGxpY2UoZG9jSWR4LCAxKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChkZXBlbmRlbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHR0aGlzLmRlcGVuZGVudHMuZGVsZXRlKHJlZkRvYyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIERlbGV0ZSB0aGUgZGVwZW5kZW5jaWVzIG9mIHRoZSBkb2N1bWVudFxuXHRcdFx0Ly8gYWZ0ZXIgd2UncmUgZG9uZSBjbGVhcmluZyBvdXQgdGhlIGRlcGVuZGVudHMuXG5cdFx0XHR0aGlzLmRlcGVuZGVuY2llcy5kZWxldGUoZG9jKTtcblx0XHRcdFxuXHRcdFx0Ly8gRGVsZXRlIHRoZSBkZWxldGVkIGRvY3VtZW50IGxhc3Rcblx0XHRcdHRoaXMuZG9jdW1lbnRzLmRlbGV0ZShkb2Muc291cmNlVXJpLnRvU3RyaW5nKCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIGFsbCBkb2N1bWVudHMgZnJvbSB0aGlzIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGNsZWFyKClcblx0XHR7XG5cdFx0XHR0aGlzLmRvY3VtZW50cy5jbGVhcigpO1xuXHRcdFx0dGhpcy5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcblx0XHRcdHRoaXMuZGVwZW5kZW50cy5jbGVhcigpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBkZXBlbmRlbmNpZXNcblx0XHQgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBkb2N1bWVudC4gVGhlIHJldHVybmVkXG5cdFx0ICogYXJyYXkgaXMgc29ydGVkIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgZGVwZW5kZW5jaWVzXG5cdFx0ICogYXJlIGRlZmluZWQgaW4gdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGdldERlcGVuZGVuY2llcyhkb2M6IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMuZGVwZW5kZW5jaWVzLmdldChkb2MpO1xuXHRcdFx0aWYgKCFkZXBlbmRlbmNpZXMpXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdXJpc1NvcnRlZDogc3RyaW5nW10gPSBbXTtcblx0XHRcdGNvbnN0IGRvY0RlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcy5tYXAoZCA9PiBkLnRhcmdldCk7XG5cdFx0XHRjb25zdCBlbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldChkb2Muc291cmNlVXJpLnRvU3RyaW5nKCkpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZW50cnkgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHN0YXRlbWVudCBvZiBkb2MuZWFjaFN0YXRlbWVudCgpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoc3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIGEgbm9uLW5vb3Agc3RhdGVtZW50IGlzIHJlYWNoZWQgdGhhdCBpc24ndCBhIHBhcnRcblx0XHRcdFx0Ly8gb2YgdGhlIGhlYWRlciwgdGhlIGVuZCBvZiB0aGUgaGVhZGVyIGhhcyBiZWVuIHJlYWNoZWQuXG5cdFx0XHRcdGNvbnN0IHJlZlVyaSA9IGVudHJ5LmhlYWRlci5nZXRIZWFkZXJVcmkoc3RhdGVtZW50KTtcblx0XHRcdFx0aWYgKCFyZWZVcmkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHR1cmlzU29ydGVkLnB1c2gocmVmVXJpLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBkZXBzU29ydGVkID0gdXJpc1NvcnRlZC5tYXAodXJpVGV4dCA9PiBcblx0XHRcdFx0Tm90LnVuZGVmaW5lZChkb2NEZXBlbmRlbmNpZXMuZmluZChkb2NEZXAgPT4gXG5cdFx0XHRcdFx0ZG9jRGVwLnNvdXJjZVVyaS50b1N0cmluZygpID09PSB1cmlUZXh0KSkpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGVwc1NvcnRlZC5zb21lKGQgPT4gZCA9PT0gdW5kZWZpbmVkKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZGVwc1NvcnRlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZGVwZW5kZW50c1xuXHRcdCAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGdldERlcGVuZGVudHMoZG9jOiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCBkZXBlbmRlbnRzID0gdGhpcy5kZXBlbmRlbnRzLmdldChkb2MpO1xuXHRcdFx0cmV0dXJuIGRlcGVuZGVudHMgP1xuXHRcdFx0XHRkZXBlbmRlbnRzLnNsaWNlKCkgOlxuXHRcdFx0XHRbXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gYWRkIGEgbGluayBmcm9tIG9uZSBkb2N1bWVudCB0byBhbm90aGVyLFxuXHRcdCAqIHZpYSB0aGUgc3BlY2lmaWVkIFVSSS4gSWYgdGhlcmUgaXMgc29tZSByZWFzb24gd2h5IHRoZVxuXHRcdCAqIGxpbmsgY2Fubm90IGJlIGVzdGFibGlzaGVkLCAoY2lyY3VsYXIgcmVmZXJlbmNlcywgYmFkXG5cdFx0ICogVVJJcyksIG5vIGxpbmsgaXMgYWRkZWQsIGFuZCBhIGZhdWx0IGlzIHJlcG9ydGVkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgdHJ5TGluayhcblx0XHRcdGNvbnRhaW5pbmdEb2N1bWVudDogRG9jdW1lbnQsIFxuXHRcdFx0Y29udGFpbmluZ1N0YXRlbWVudDogU3RhdGVtZW50LCBcblx0XHRcdHVyaTogVXJpKVxuXHRcdHtcblx0XHRcdHRoaXMuYXN5bmNDb3VudCsrO1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHVyaS50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IChhc3luYyAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZWZEb2N1bWVudCA9IGF3YWl0IChhc3luYyAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gSXMgdGhlIGRvY3VtZW50IGFscmVhZHkgbG9hZGVkIGludG8gdGhlIGdyYXBoP1xuXHRcdFx0XHRcdGNvbnN0IGV4aXN0aW5nRW50cnkgPSB0aGlzLmRvY3VtZW50cy5nZXQodXJpVGV4dCk7XG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nRW50cnkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdFbnRyeS5kb2N1bWVudDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBSZWFkIHRoZSBkb2N1bWVudCBpZiBpdCB3YXNuJ3QgbG9hZGVkXG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkKHVyaSk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGZhdWx0ID0gRmF1bHRzLlVucmVzb2x2ZWRSZXNvdXJjZS5jcmVhdGUoY29udGFpbmluZ1N0YXRlbWVudCk7XG5cdFx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydEFzeW5jKGZhdWx0KTtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBuZXdFbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldCh1cmlUZXh0KTtcblx0XHRcdFx0XHRpZiAoIW5ld0VudHJ5KVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBuZXdFbnRyeS5kb2N1bWVudDtcblx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghcmVmRG9jdW1lbnQpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQmFpbCBpZiBhIGRvY3VtZW50IGxvYWRlZCBmcm9tIEhUVFAgaXMgdHJ5aW5nIHRvIHJlZmVyZW5jZVxuXHRcdFx0XHQvLyBhIGRvY3VtZW50IGxvY2F0ZWQgb24gdGhlIGZpbGUgc3lzdGVtLlxuXHRcdFx0XHRjb25zdCBzcmNQcm90byA9IGNvbnRhaW5pbmdEb2N1bWVudC5zb3VyY2VVcmkucHJvdG9jb2w7XG5cdFx0XHRcdGNvbnN0IGRzdFByb3RvID0gcmVmRG9jdW1lbnQuc291cmNlVXJpLnByb3RvY29sO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKChzcmNQcm90byA9PT0gVXJpUHJvdG9jb2wuaHR0cCB8fCBzcmNQcm90byA9PT0gVXJpUHJvdG9jb2wuaHR0cHMpICYmIFxuXHRcdFx0XHRcdGRzdFByb3RvID09PSBVcmlQcm90b2NvbC5maWxlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcGFyYW0gPSBGYXVsdHMuSW5zZWN1cmVSZXNvdXJjZVJlZmVyZW5jZS5jcmVhdGUoY29udGFpbmluZ1N0YXRlbWVudCk7XG5cdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmZhdWx0cy5yZXBvcnRBc3luYyhwYXJhbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIEJhaWwgaWYgdGhlIGFkZGl0aW9uIG9mIHRoZSByZWZlcmVuY2UgaXMgZ29pbmcgdG8gcmVzdWx0IGluIGEgY2lyY3VsYXIgcmVmZXJlbmNlLlxuXHRcdFx0XHRpZiAodGhpcy53b3VsZENyZWF0ZUN5Y2xlcyhjb250YWluaW5nRG9jdW1lbnQsIHJlZkRvY3VtZW50KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHBhcmFtID0gRmF1bHRzLkNpcmN1bGFyUmVzb3VyY2VSZWZlcmVuY2UuY3JlYXRlKGNvbnRhaW5pbmdTdGF0ZW1lbnQpO1xuXHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5mYXVsdHMucmVwb3J0QXN5bmMocGFyYW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMubGluayhjb250YWluaW5nRG9jdW1lbnQsIHJlZkRvY3VtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5hc3luY0NvdW50LS07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5hc3luY0NvdW50IDwgMClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5hc3luY0NvdW50ID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgd2FpdEZucyA9IHRoaXMud2FpdEZucy5zbGljZSgpO1xuXHRcdFx0XHRcdHRoaXMud2FpdEZucy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdHdhaXRGbnMuZm9yRWFjaChmbiA9PiBmbigpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkoKSxcblx0XHRcdDApO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgd2hlblxuXHRcdCAqIGFsbCBvdXRzdGFuZGluZyBhc3luYyBvcGVyYXRpb25zIGhhdmUgY29tcGxldGVkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgd2FpdEZuczogKCgpID0+IHZvaWQpW10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb3VudHMgdGhlIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGluIHByb2dyZXNzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYXN5bmNDb3VudCA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgYWRkaXRpb24gb2YgYSByZWZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvXG5cdFx0ICogc3BlY2lmaWVkIGRvY3VtZW50cyB3b3VsZCByZXN1bHQgaW4gYSBkb2N1bWVudCBncmFwaCB3aXRoXG5cdFx0ICogY2lyY3VsYXIgcmVsYXRpb25zaGlwcy5cblx0XHQgKiBcblx0XHQgKiBUaGUgYWxnb3JpdGhtIHVzZWQgcGVyZm9ybXMgYSBkZXB0aC1maXJzdCBkZXBlbmRlbmN5IHNlYXJjaCxcblx0XHQgKiBzdGFydGluZyBhdCB0aGUgY2FuZGlkYXRlVG8uIElmIHRoZSB0cmF2ZXJzYWwgcGF0dGVybiBpcyBhYmxlIHRvXG5cdFx0ICogbWFrZSBpdHMgd2F5IHRvIGNhbmRpZGF0ZUZyb20sIGl0IGNhbiBiZSBjb25jbHVkZWQgdGhhdCB0aGVcblx0XHQgKiBhZGRpdGlvbiBvZiB0aGUgcHJvcG9zZWQgcmVmZXJlbmNlIHdvdWxkIHJlc3VsdCBpbiBhIGN5Y2xpY2FsXG5cdFx0ICogcmVsYXRpb25zaGlwLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgd291bGRDcmVhdGVDeWNsZXMocHJvcG9zZWRGcm9tOiBEb2N1bWVudCwgcHJvcG9zZWRUbzogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2hlY2tGb3JDeWNsZXNSZWN1cnNpdmUgPSAoY3VycmVudDogRG9jdW1lbnQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjdXJyZW50ID09PSBwcm9wb3NlZEZyb20pXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkZXBlbmRlbmNpZXMgPSAodGhpcy5kZXBlbmRlbmNpZXMuZ2V0KGN1cnJlbnQpIHx8IFtdKS5tYXAoZCA9PiBkLnRhcmdldCk7XG5cdFx0XHRcdGlmIChkZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjdXJyZW50ID09PSBwcm9wb3NlZEZyb20pXG5cdFx0XHRcdFx0ZGVwZW5kZW5jaWVzLnVuc2hpZnQocHJvcG9zZWRUbyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZGVwZW5kZW5jaWVzLnNvbWUoZCA9PiBjaGVja0ZvckN5Y2xlc1JlY3Vyc2l2ZShkKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY2hlY2tGb3JDeWNsZXNSZWN1cnNpdmUocHJvcG9zZWRUbyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYSBkZXBlbmRlbmN5IGJldHdlZW4gdHdvIGRvY3VtZW50cyBpbiB0aGUgZ3JhcGguXG5cdFx0ICogSWYgYSBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIHR3byBkb2N1bWVudHMgYWxyZWFkeSBleGlzdHMsXG5cdFx0ICogdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGUgZGVwZW5kZW5jeSBpcyBpbmNyZW1lbnRlZC5cblx0XHQgKiBUaGlzIG1ldGhvZCBpcyBleGVjdXRlZCBvbmx5IGFmdGVyIG90aGVyIG1ldGhvZHMgaGF2ZVxuXHRcdCAqIGluZGljYXRlZCB0aGF0IHRoZSBhZGRpdGlvbiBvZiB0aGUgbGluayB3aWxsIG5vdCBjYXVzZSBjb25mbGljdC5cblx0XHQgKi9cblx0XHRwcml2YXRlIGxpbmsoZnJvbTogRG9jdW1lbnQsIHRvOiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCBkZXBlbmRlbmN5QXJyYXkgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQoZnJvbSk7XG5cdFx0XHRpZiAoZGVwZW5kZW5jeUFycmF5KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeUFycmF5LmZpbmQoZCA9PiBkLnRhcmdldCA9PT0gdG8pO1xuXHRcdFx0XHRpZiAoZGVwZW5kZW5jeSlcblx0XHRcdFx0XHRkZXBlbmRlbmN5LnJlZmVyZW5jZUNvdW50Kys7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRkZXBlbmRlbmN5QXJyYXkucHVzaChuZXcgRGVwZW5kZW5jeSh0bykpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmRlcGVuZGVuY2llcy5zZXQoZnJvbSwgW25ldyBEZXBlbmRlbmN5KHRvKV0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBkZXBlbmRlbnRBcnJheSA9IHRoaXMuZGVwZW5kZW50cy5nZXQodG8pO1xuXHRcdFx0aWYgKGRlcGVuZGVudEFycmF5KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIWRlcGVuZGVudEFycmF5LmluY2x1ZGVzKGZyb20pKVxuXHRcdFx0XHRcdGRlcGVuZGVudEFycmF5LnB1c2goZnJvbSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZGVwZW5kZW50cy5zZXQodG8sIFtmcm9tXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBkZXBlbmRlbmN5IGJldHdlZW4gdHdvIGRvY3VtZW50cyBpbiB0aGUgZ3JhcGguXG5cdFx0ICogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGUgZGVwZW5kZW5jeSBpcyBncmVhdGVyIHRoYW4gMSwgdGhlXG5cdFx0ICogdGhlIHJlZmVyZW5jZSBjb3VudCBpcyBkZWNyZW1lbnRlZCBpbnN0ZWFkIG9mIHRoZSBkZXBlbmRlbmN5XG5cdFx0ICogYmVpbmcgcmVtb3ZlZCBjb21wbGV0ZWx5LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgdW5saW5rKGZyb206IERvY3VtZW50LCB0bzogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZGVwZW5kZW5jeUFycmF5ID0gdGhpcy5kZXBlbmRlbmNpZXMuZ2V0KGZyb20pO1xuXHRcdFx0aWYgKCFkZXBlbmRlbmN5QXJyYXkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVwZW5kZW5jeUlkeCA9IGRlcGVuZGVuY3lBcnJheS5maW5kSW5kZXgoZCA9PiBkLnRhcmdldCA9PT0gdG8pO1xuXHRcdFx0aWYgKGRlcGVuZGVuY3lJZHggPCAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5QXJyYXlbZGVwZW5kZW5jeUlkeF07XG5cdFx0XHRcblx0XHRcdGlmIChkZXBlbmRlbmN5LnJlZmVyZW5jZUNvdW50ID4gMSlcblx0XHRcdHtcblx0XHRcdFx0ZGVwZW5kZW5jeS5yZWZlcmVuY2VDb3VudC0tO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRkZXBlbmRlbmN5QXJyYXkuc3BsaWNlKGRlcGVuZGVuY3lJZHgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gR2V0IHJpZCBvZiB0aGUgZW50cnkgaW4gdGhlIGRlcGVuZGVuY2llcyBtYXBcblx0XHRcdFx0Ly8gY29tcGxldGVseSBpZiB0aGUgZGVwZW5kZW5jeSBhcnJheSBpcyBub3cgZW1wdHkuXG5cdFx0XHRcdGlmIChkZXBlbmRlbmN5QXJyYXkubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHRoaXMuZGVwZW5kZW5jaWVzLmRlbGV0ZShmcm9tKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVwZW5kZW50QXJyYXkgPSB0aGlzLmRlcGVuZGVudHMuZ2V0KHRvKTtcblx0XHRcdGlmIChkZXBlbmRlbnRBcnJheSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZGVwSWR4ID0gZGVwZW5kZW50QXJyYXkuaW5kZXhPZihmcm9tKTtcblx0XHRcdFx0aWYgKGRlcElkeCA+IC0xKVxuXHRcdFx0XHRcdGRlcGVuZGVudEFycmF5LnNwbGljZShkZXBJZHgsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogXG5cdFx0ICogQSBtYXAgb2YgZG9jdW1lbnRzIGxvYWRlZCBpbnRvIHRoZSBncmFwaCxcblx0XHQgKiBpbmRleGVkIGJ5IHRoZWlyIFVSSXMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBkb2N1bWVudHMgPSBuZXcgTWFwPHN0cmluZywgSURvY3VtZW50RW50cnk+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBtYXAgb2YgZWFjaCBkb2N1bWVudCdzIGRlcGVuZGVuY2llcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGRlcGVuZGVuY2llcyA9IG5ldyBNYXA8RG9jdW1lbnQsIERlcGVuZGVuY3lbXT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIG1hcCBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgZGVwZW5kIG9uIGVhY2ggZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBkZXBlbmRlbnRzID0gbmV3IE1hcDxEb2N1bWVudCwgRG9jdW1lbnRbXT4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydHMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgRG9jdW1lbnRHcmFwaCB0byBhIFxuXHRcdCAqIHN0cmluZyByZXByZXNlbnRhdGlvbiwgdXNlZnVsIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbdXJpVGV4dCwgZW50cnldIG9mIHRoaXMuZG9jdW1lbnRzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1cmkgPSBVcmkudHJ5UGFyc2UodXJpVGV4dCk7XG5cdFx0XHRcdGNvbnN0IGRvYyA9IGVudHJ5LmRvY3VtZW50O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCF1cmkpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0bGluZXMucHVzaCh1cmkudG9TdHJpbmcoKSk7XG5cdFx0XHRcdGxpbmVzLnB1c2goXCJcXHREZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkb2NEZXBlbmRlbmNpZXMgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQoZG9jKTtcblx0XHRcdFx0aWYgKGRvY0RlcGVuZGVuY2llcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChkb2NEZXBlbmRlbmNpZXMubGVuZ3RoKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBkb2NEZXBlbmRlbmNpZXMpXG5cdFx0XHRcdFx0XHRcdGxpbmVzLnB1c2goXCJcXHRcXHRcIiArIGRlcGVuZGVuY3kudGFyZ2V0LnNvdXJjZVVyaS50b1N0cmluZygpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBsaW5lcy5wdXNoKFwiXFx0XFx0KG5vbmUpXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgbGluZXMucHVzaChcIlxcdFxcdCh1bmRlZmluZWQpXCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0bGluZXMucHVzaChcIlxcdERlcGVuZGVudHNcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkb2NEZXBlbmRlbnRzID0gdGhpcy5kZXBlbmRlbnRzLmdldChkb2MpO1xuXHRcdFx0XHRpZiAoZG9jRGVwZW5kZW50cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChkb2NEZXBlbmRlbnRzLmxlbmd0aClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGRvY0RlcGVuZGVudCBvZiBkb2NEZXBlbmRlbnRzKVxuXHRcdFx0XHRcdFx0XHRsaW5lcy5wdXNoKFwiXFx0XFx0XCIgKyBkb2NEZXBlbmRlbnQuc291cmNlVXJpLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGxpbmVzLnB1c2goXCJcXHRcXHQobm9uZSlcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBsaW5lcy5wdXNoKFwiXFx0XFx0KHVuZGVmaW5lZClcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRsaW5lcy5wdXNoKFwiXCIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGluZXMuc2xpY2UoMCwgLTEpLmpvaW4oXCJcXG5cIik7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRpbnRlcmZhY2UgSURvY3VtZW50RW50cnlcblx0e1xuXHRcdGhlYWRlcjogRG9jdW1lbnRIZWFkZXI7XG5cdFx0ZG9jdW1lbnQ6IERvY3VtZW50O1xuXHR9XG5cblxuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIGRlcGVuZGVuY3kgXG5cdCAqIGJldHdlZW4gZG9jdW1lbnRzLlxuXHQgKi9cblx0Y2xhc3MgRGVwZW5kZW5jeVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgdGFyZ2V0OiBEb2N1bWVudCkgeyB9XG5cdFx0XG5cdFx0cmVmZXJlbmNlQ291bnQgPSAwO1xuXHR9XG59XG4iLCJcblxuXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBkb2N1bWVudCdzIGhlYWRlci5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBEb2N1bWVudEhlYWRlclxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoZG9jdW1lbnQ6IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRm9yY2VzIHRoZSBoZWFkZXIgdG8gYmUgcmVjb21wdXRlZCwgYnkgc2Nhbm5pbmdcblx0XHQgKiB0aGUgc3RhdGVtZW50cyBpbiB0aGUgdW5kZXJseWluZyBkb2N1bWVudC5cblx0XHQgKiBcblx0XHQgKiBJZiB0aGUgaGVhZGVyIGhhcyBjaGFuZ2VkLCB0aGUgbWV0aG9kIHJ1bnMgdGhlXG5cdFx0ICogbmVjZXNzYXJ5IGhvb2tzIHRvIG5vdGlmeSBzdWJzY3JpYmVycyBvZiBob29rcyBcblx0XHQgKiBhbnkgYWRkZWQgb3IgcmVtb3ZlZC5cblx0XHQgKi9cblx0XHRyZWNvbXB1dGUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG9sZFVyaU1hcCA9IHRoaXMudXJpTWFwO1xuXHRcdFx0Y29uc3QgbmV3VXJpTWFwID0gbmV3IE1hcDxTdGF0ZW1lbnQsIFVyaT4oKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB7IHN0YXRlbWVudCB9IG9mIHRoaXMuZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQoKSlcblx0XHRcdHtcblx0XHRcdFx0Ly8gQ3VycmVudGx5LCBhbnkgc3RhdGVtZW50IHdpdGggYW4gYW5ub3RhdGlvbiBpc1xuXHRcdFx0XHQvLyBjb25zaWRlcmVkIHRvIGJlIGEgbm9uLWhlYWRlciBzdGF0ZW1lbnQuIFRoaXNcblx0XHRcdFx0Ly8gd2lsbCBjaGFuZ2UgaWYgc2NvcGVkIHJlZmVyZW5jZXMgYmVjb21lIHN1cHBvcnRlZC5cblx0XHRcdFx0Ly8gQWxzbywgb25seSBvbmUgVVJJIHJlZmVyZW5jZSBzdGF0ZW1lbnQgcGVyIGxpbmUgaXNcblx0XHRcdFx0Ly8gYWNjZXB0ZWQuIFZhY2N1b3VzIHN0YXRlbWVudHMgYnJlYWsgdGhlIGhlYWRlci5cblx0XHRcdFx0aWYgKHN0YXRlbWVudC5hbGxBbm5vdGF0aW9ucy5sZW5ndGggPiAwIHx8IHN0YXRlbWVudC5hbGxEZWNsYXJhdGlvbnMubGVuZ3RoICE9PSAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZGVjbCA9IHN0YXRlbWVudC5hbGxEZWNsYXJhdGlvbnNbMF07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodHlwZW9mIGRlY2wuYm91bmRhcnkuc3ViamVjdCA9PT0gXCJzdHJpbmdcIilcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIShkZWNsLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBVcmkpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmVmVXJpID0gZGVjbC5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0XHRjb25zdCBkb2NVcmkgPSB0aGlzLmRvY3VtZW50LnNvdXJjZVVyaTtcblx0XHRcdFx0Y29uc3QgdXJpQWJzb2x1dGUgPSBOb3QubnVsbChVcmkudHJ5UGFyc2UocmVmVXJpLCBkb2NVcmkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdG5ld1VyaU1hcC5zZXQoc3RhdGVtZW50LCB1cmlBYnNvbHV0ZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChvbGRVcmlNYXAuc2l6ZSArIG5ld1VyaU1hcC5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlbW92ZWRVcmlNYXAgPSBuZXcgTWFwPFVyaSwgU3RhdGVtZW50PigpO1xuXHRcdFx0Y29uc3QgYWRkZWRVcmlNYXAgPSBuZXcgTWFwPFVyaSwgU3RhdGVtZW50PigpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZW1lbnQsIG9sZFVyaV0gb2Ygb2xkVXJpTWFwKVxuXHRcdFx0XHRpZiAoIW5ld1VyaU1hcC5oYXMoc3RhdGVtZW50KSlcblx0XHRcdFx0XHRyZW1vdmVkVXJpTWFwLnNldChvbGRVcmksIHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3N0YXRlbWVudCwgbmV3VXJpXSBvZiBuZXdVcmlNYXApXG5cdFx0XHRcdGlmICghb2xkVXJpTWFwLmhhcyhzdGF0ZW1lbnQpKVxuXHRcdFx0XHRcdGFkZGVkVXJpTWFwLnNldChuZXdVcmksIHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLmRvY3VtZW50LnByb2dyYW07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3VyaSwgc3RhdGVtZW50XSBvZiByZW1vdmVkVXJpTWFwKVxuXHRcdFx0XHRwcm9ncmFtLmNhdXNlKG5ldyBDYXVzZVVyaVJlZmVyZW5jZVJlbW92ZShzdGF0ZW1lbnQsIHVyaSkpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFt1cmksIHN0YXRlbWVudF0gb2YgYWRkZWRVcmlNYXApXG5cdFx0XHRcdHByb2dyYW0uY2F1c2UobmV3IENhdXNlVXJpUmVmZXJlbmNlQWRkKHN0YXRlbWVudCwgdXJpKSk7XG5cdFx0XHRcblx0XHRcdHRoaXMudXJpTWFwLmNsZWFyKCk7XG5cdFx0XHRuZXdVcmlNYXAuZm9yRWFjaCgodXJpLCBzdGF0ZW1lbnQpID0+IHRoaXMudXJpTWFwLnNldChzdGF0ZW1lbnQsIHVyaSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgZG9jdW1lbnQgcmVmZXJlbmNlIFVSSSB0aGF0IGNvcnJlc3BvbmRzIFxuXHRcdCAqIHRvIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50LiBSZXR1cm5zIG51bGwgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdCAqIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50IGlzIG5vdCBhIHBhcnQgb2YgdGhlIGhlYWRlci5cblx0XHQgKi9cblx0XHRnZXRIZWFkZXJVcmkoc3RhdGVtZW50OiBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudXJpTWFwLmdldChzdGF0ZW1lbnQpIHx8IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCBvZiB0aGUgVVJJcyByZWZlcmVuY2VkIGluIHRoZSBoZWFkZXIgb2YgdGhpcyBcblx0XHQgKiBkb2N1bWVudCwgd2hpY2ggYXJlIGluZGV4ZWQgYnkgdGhlIHN0YXRlbWVudCBpbiB3aGljaFxuXHRcdCAqIHRoZSBVUkkgaXMgZm91bmQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1cmlNYXAgPSBuZXcgTWFwPFN0YXRlbWVudCwgVXJpPigpO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50O1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogTG9jYWwgbWFya2VyIHZhbHVlcyB1c2VkIGFzIHJldHVybiB2YWx1ZXMgdG9cblx0ICogaW5kaWNhdGUgdGhhdCBhIHBhdHRlcm4gZmFpbGVkIHRvIHBhcnNlLlxuXHQgKi9cblx0dHlwZSBUUGFyc2VGYXVsdCA9IFJlYWRvbmx5PEZhdWx0VHlwZTxTdGF0ZW1lbnQ+PjtcblxuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIG9wdGlvbnMgZm9yIHRoZSBsaW5lIHBhcnNlci5cblx0ICovXG5cdGV4cG9ydCBpbnRlcmZhY2UgSUxpbmVQYXJzZXJPcHRpb25zXG5cdHtcblx0XHRyZWFkb25seSByZWFkUGF0dGVybnM/OiBib29sZWFuO1xuXHRcdHJlYWRvbmx5IHJlYWRVcmlzPzogYm9vbGVhbjtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFBhcnNlcyBhIHNpbmdsZSBsaW5lIG9mIFRydXRoIGNvZGUsIGFuZCByZXR1cm5zXG5cdCAqIGEgTGluZSBvYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dFxuXHQgKiB3aGF0IHdhcyByZWFkLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIExpbmVQYXJzZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IHlpZWxkcyBhbGwgc3RhdGVtZW50c1xuXHRcdCAqICh1bnBhcnNlZCBsaW5lcykgb2YgdGhlIGdpdmVuIHNvdXJjZSB0ZXh0LiBcblx0XHQgKi9cblx0XHRzdGF0aWMgKnJlYWQoZnVsbFNvdXJjZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGlmIChmdWxsU291cmNlLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRsZXQgY3Vyc29yID0gMDtcblx0XHRcdGxldCBzdGF0ZW1lbnRTdGFydCA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAoOyBjdXJzb3IgPCBmdWxsU291cmNlLmxlbmd0aDsgY3Vyc29yKyspXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChmdWxsU291cmNlW2N1cnNvcl0gPT09IFN5bnRheC50ZXJtaW5hbClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpZWxkIGZ1bGxTb3VyY2Uuc2xpY2Uoc3RhdGVtZW50U3RhcnQsIGN1cnNvcik7XG5cdFx0XHRcdFx0c3RhdGVtZW50U3RhcnQgPSBjdXJzb3IgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzdGF0ZW1lbnRTdGFydCA8IGN1cnNvcilcblx0XHRcdFx0eWllbGQgZnVsbFNvdXJjZS5zbGljZShzdGF0ZW1lbnRTdGFydCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHBhcnNpbmcgYSBzaW5nbGUgbGluZSBhbmQgcHJvZHVjaW5nIGFcblx0XHQgKiBSYXdTdGF0ZW1lbnQgb2JqZWN0LlxuXHRcdCAqIFxuXHRcdCAqIFRoZSBwYXJzaW5nIGFsZ29yaXRobSBpcyBzb21lIGtpbmQgb2YgcXVhc2ktcmVjdXNpdmUgZGVzY2VudCB3aXRoXG5cdFx0ICogbG9va2hlYWRzIGFuZCBiYWNrdHJhY2tpbmcgaW4gc29tZSBwbGFjZXMgdG8gbWFrZSB0aGUgbG9naWMgZWFzaWVyXG5cdFx0ICogdG8gZm9sbG93LiBUZWNobmljYWxseSwgaXQncyBwcm9iYWJseSBzb21lIG1hc2gtdXAgb2YgTEwoaykgJiBMQUxSLlxuXHRcdCAqIE1heWJlIGlmIEkgYmxldyA0IHllYXJzIG9mIG15IGxpZmUgaW4gc29tZSBzaWxseSBDb21wIFNjaSBwcm9ncmFtXG5cdFx0ICogaW5zdGVhZCBvZiBkcm9wcGluZyBvdXQgb2YgaGlnaCBzY2hvb2wgSSBjb3VsZCBzYXkgZm9yIHN1cmUuXG5cdFx0ICovXG5cdFx0c3RhdGljIHBhcnNlKGxpbmVUZXh0OiBzdHJpbmcsIG9wdGlvbnM/OiBJTGluZVBhcnNlck9wdGlvbnMpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcGFyc2VyT3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuXHRcdFx0XHRyZWFkUGF0dGVybnM6IHRydWUsXG5cdFx0XHRcdHJlYWRVcmlzOiB0cnVlXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxpbmVUZXh0KTtcblx0XHRcdGNvbnN0IHNvdXJjZVRleHQgPSBsaW5lVGV4dDtcblx0XHRcdGNvbnN0IGluZGVudCA9IHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0Y29uc3QgZGVjbGFyYXRpb25FbnRyaWVzOiBCb3VuZGFyeTxEZWNsYXJhdGlvblN1YmplY3Q+W10gPSBbXTtcblx0XHRcdGNvbnN0IGFubm90YXRpb25FbnRyaWVzOiBCb3VuZGFyeTxBbm5vdGF0aW9uU3ViamVjdD5bXSA9IFtdO1xuXHRcdFx0Y29uc3QgZXNjID0gU3ludGF4LmVzY2FwZUNoYXI7XG5cdFx0XHRsZXQgZmxhZ3MgPSBMaW5lRmxhZ3Mubm9uZTtcblx0XHRcdGxldCBqb2ludFBvc2l0aW9uID0gLTE7XG5cdFx0XHRsZXQgc3VtID0gXCJcIjtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBVbml2ZXJzYWwgZnVuY3Rpb24gZm9yIHF1aWNrbHkgcHJvZHVjaW5nIGEgUmF3U3RhdGVtZW50XG5cdFx0XHQgKiBpbnN0YW5jZSB1c2luZyB0aGUgdmFsdWVzIG9mIHRoZSBjb25zdHJ1Y3RlZCBsb2NhbCB2YXJpYWJsZXMuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IHJldCA9IChmYXVsdDogVFBhcnNlRmF1bHQgfCBudWxsID0gbnVsbCkgPT4gbmV3IExpbmUoXG5cdFx0XHRcdHNvdXJjZVRleHQsXG5cdFx0XHRcdGluZGVudCxcblx0XHRcdFx0bmV3IEJvdW5kYXJ5R3JvdXAoZGVjbGFyYXRpb25FbnRyaWVzKSxcblx0XHRcdFx0bmV3IEJvdW5kYXJ5R3JvdXAoYW5ub3RhdGlvbkVudHJpZXMpLFxuXHRcdFx0XHRzdW0sXG5cdFx0XHRcdGpvaW50UG9zaXRpb24sXG5cdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHRmYXVsdCk7XG5cdFx0XHRcblx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZW4gdGhlIGxpbmUgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsXG5cdFx0XHQvLyB0aGlzIGNvbmRpdGlvbiB3aWxsIHBhc3MsIGJ5cGFzc2luZyB0aGUgZW50aXJlIHBhcnNpbmcgcHJvY2Vzc1xuXHRcdFx0Ly8gYW5kIHJldHVybmluZyBhbiAoYmFzaWNhbGx5KSBmcmVzaCBSYXdTdGF0ZW1lbnQgb2JqZWN0LlxuXHRcdFx0aWYgKCFwYXJzZXIubW9yZSgpKVxuXHRcdFx0e1xuXHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNXaGl0ZXNwYWNlO1xuXHRcdFx0XHRyZXR1cm4gcmV0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChTeW50YXguY29tbWVudCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIXBhcnNlci5tb3JlKCkgfHwgcGFyc2VyLnJlYWQoU3ludGF4LnNwYWNlKSB8fCBwYXJzZXIucmVhZChTeW50YXgudGFiKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNDb21tZW50O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdW5wYXJzYWJsZUZhdWx0VHlwZSA9ICgoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5jb21iaW5hdG9yKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50QmVnaW5zV2l0aENvbW1hO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChTeW50YXgubGlzdCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlN0YXRlbWVudEJlZ2luc1dpdGhFbGxpcHNpcztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoZXNjICsgU3ludGF4LnNwYWNlKSB8fCBwYXJzZXIucmVhZChlc2MgKyBTeW50YXgudGFiKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50QmVnaW5zV2l0aEVzY2FwZWRTcGFjZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWRUaGVuVGVybWluYWwoZXNjKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50Q29udGFpbnNPbmx5RXNjYXBlQ2hhcmFjdGVyO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHVucGFyc2FibGVGYXVsdFR5cGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNDcnVmdDtcblx0XHRcdFx0XHRyZXR1cm4gcmV0KHVucGFyc2FibGVGYXVsdFR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFya0JlZm9yZVVyaSA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgdXJpID0gbWF5YmVSZWFkVXJpKCk7XG5cdFx0XHRcdGlmICh1cmkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaGFzVXJpO1xuXHRcdFx0XHRcdGRlY2xhcmF0aW9uRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdG1hcmtCZWZvcmVVcmksXG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHR1cmkpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdGhlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBtYXJrQmVmb3JlUGF0dGVybiA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgcGF0dGVybiA9IG1heWJlUmVhZFBhdHRlcm4oKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpc1BhcnNlRmF1bHQocGF0dGVybikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNDcnVmdDtcblx0XHRcdFx0XHRyZXR1cm4gcmV0KHBhdHRlcm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGF0dGVybilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5oYXNQYXR0ZXJuO1xuXHRcdFx0XHRcdGZsYWdzIHw9IHBhdHRlcm4uaXNUb3RhbCA/XG5cdFx0XHRcdFx0XHRMaW5lRmxhZ3MuaGFzVG90YWxQYXR0ZXJuIDpcblx0XHRcdFx0XHRcdExpbmVGbGFncy5oYXNQYXJ0aWFsUGF0dGVybjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRkZWNsYXJhdGlvbkVudHJpZXMucHVzaChuZXcgQm91bmRhcnkoXG5cdFx0XHRcdFx0XHRtYXJrQmVmb3JlUGF0dGVybixcblx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdHBhdHRlcm4pKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdGhlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGJvdW5kc0VudHJ5IG9mIHJlYWREZWNsYXJhdGlvbnMoW10pKVxuXHRcdFx0XHRcdGRlY2xhcmF0aW9uRW50cmllcy5wdXNoKGJvdW5kc0VudHJ5KTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB0aGVuKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIHRoZW4oKVxuXHRcdFx0e1xuXHRcdFx0XHRqb2ludFBvc2l0aW9uID0gbWF5YmVSZWFkSm9pbnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHJlYWRSZXN1bHQgPSByZWFkQW5ub3RhdGlvbnMoW10pO1xuXHRcdFx0XHRzdW0gPSByZWFkUmVzdWx0LnJhdy50cmltKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGJvdW5kc0VudHJ5IG9mIHJlYWRSZXN1bHQuYW5ub3RhdGlvbnMpXG5cdFx0XHRcdFx0YW5ub3RhdGlvbkVudHJpZXMucHVzaChib3VuZHNFbnRyeSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoam9pbnRQb3NpdGlvbiA+IC0xKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZExlbiA9IGRlY2xhcmF0aW9uRW50cmllcy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29uc3QgYUxlbiA9IHJlYWRSZXN1bHQuYW5ub3RhdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChkTGVuID09PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRlY2xhcmF0aW9uRW50cmllcy51bnNoaWZ0KG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0am9pbnRQb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0am9pbnRQb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0bmV3IEFub24oKSkpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoYUxlbiA9PT0gMClcblx0XHRcdFx0XHRcdFx0ZmxhZ3MgfD0gTGluZUZsYWdzLmlzVmFjdW91cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoYUxlbiA9PT0gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNSZWZyZXNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJldCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWRzIHRoZSBmb2xsb3dpbmcgc2VyaWVzIG9mIGRlY2xhcmF0aW9ucywgd2hpY2ggbWF5IGJlXG5cdFx0XHQgKiBlaXRoZXIgZGlyZWN0bHkgY29udGFpbmVkIGJ5IGEgc3RhdGVtZW50LCBvciBpbnNpZGUgYW4gaW5maXguXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHJlYWREZWNsYXJhdGlvbnMocXVpdFRva2Vuczogc3RyaW5nW10pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGVudHJpZXM6IEJvdW5kYXJ5PElkZW50aWZpZXI+W10gPSBbXTtcblx0XHRcdFx0Y29uc3QgdW50aWwgPSBxdWl0VG9rZW5zLmNvbmNhdChTeW50YXguam9pbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCByZWFkUmVzdWx0ID0gbWF5YmVSZWFkSWRlbnRpZmllcih1bnRpbCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHJlYWRSZXN1bHQgIT09IG51bGwpXG5cdFx0XHRcdFx0XHRlbnRyaWVzLnB1c2gobmV3IEJvdW5kYXJ5PElkZW50aWZpZXI+KFxuXHRcdFx0XHRcdFx0XHRyZWFkUmVzdWx0LmF0LCBcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0XHRyZWFkUmVzdWx0LmlkZW50aWZpZXIpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGUgZm9sbG93aW5nIGNvbWJpbmF0b3IgbXVzdCBiZSBlYXRlbiBiZWZvcmVcblx0XHRcdFx0XHQvLyBtb3Zpbmcgb24gdG8gYW5vdGhlciBkZWNsYXJhdGlvbi4gSWYgdGhpcyBmYWlscyxcblx0XHRcdFx0XHQvLyBpdCdzIGJlY2F1c2UgdGhlIHBhcnNlIHN0cmVhbSBoYXMgZW5kZWQuXG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChTeW50YXguY29tYmluYXRvcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGVla0pvaW50KCkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGVudHJpZXM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCB0aGUgam9pbnQgdG9rZW4gZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdFx0ICogQ29uc3VtZXMgYWxsIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UuXG5cdFx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBqb2ludFxuXHRcdFx0ICogdG9rZW4gd2FzIHJlYWQuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZEpvaW50KClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFya0JlZm9yZVdzID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0Y29uc3QgbWFya0FmdGVyV3MgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGxldCBmb3VuZEpvaW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChTeW50YXguam9pbnQgKyBTeW50YXguc3BhY2UpIHx8XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWQoU3ludGF4LmpvaW50ICsgU3ludGF4LnRhYikgfHxcblx0XHRcdFx0XHRwYXJzZXIucmVhZFRoZW5UZXJtaW5hbChTeW50YXguam9pbnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm91bmRKb2ludFBvc2l0aW9uID0gbWFya0FmdGVyV3M7XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFya0JlZm9yZVdzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZm91bmRKb2ludFBvc2l0aW9uO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBqb2ludFxuXHRcdFx0ICogaXMgdGhlIG5leHQgbG9naWNhbCB0b2tlbiB0byBiZSBjb25zdW1lZC4gVHJ1ZSBpcyByZXR1cm5lZFxuXHRcdFx0ICogaW4gdGhlIGNhc2Ugd2hlbiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgc2l0IGJldHdlZW4gdGhlXG5cdFx0XHQgKiBjdXJzb3IgYW5kIHRoZSBqb2ludCBvcGVyYXRvci5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcGVla0pvaW50KClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaW5uZXJQZWVrSm9pbnQgPSAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlci5wZWVrKFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSkgfHxcblx0XHRcdFx0XHRcdHBhcnNlci5wZWVrKFN5bnRheC5qb2ludCArIFN5bnRheC50YWIpIHx8XG5cdFx0XHRcdFx0XHRwYXJzZXIucGVla1RoZW5UZXJtaW5hbChTeW50YXguam9pbnQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGlubmVyUGVla0pvaW50KCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXBhcnNlci5wZWVrKFN5bnRheC5zcGFjZSkgJiYgIXBhcnNlci5wZWVrKFN5bnRheC50YWIpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRjb25zdCBhdEpvaW50ID0gaW5uZXJQZWVrSm9pbnQoKTtcblx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBhdEpvaW50O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZWFkQW5ub3RhdGlvbnMocXVpdFRva2Vuczogc3RyaW5nW10pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGFubm90YXRpb25zOiBCb3VuZGFyeTxBbm5vdGF0aW9uU3ViamVjdD5bXSA9IFtdO1xuXHRcdFx0XHRsZXQgcmF3ID0gXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcmVhZFJlc3VsdCA9IG1heWJlUmVhZElkZW50aWZpZXIocXVpdFRva2Vucyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHJlYWRSZXN1bHQgIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YW5ub3RhdGlvbnMucHVzaChuZXcgQm91bmRhcnkoXG5cdFx0XHRcdFx0XHRcdHJlYWRSZXN1bHQuYXQsIFxuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdHJlYWRSZXN1bHQuaWRlbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyYXcgKz0gcmVhZFJlc3VsdC5yYXc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBuZXh0IHRva2VuIGlzIG5vdCBhIGNvbWJpbmF0b3IsIFxuXHRcdFx0XHRcdC8vIHRoZSBwYXJzZSBzdHJlYW0gaGFzIGVuZGVkLlxuXHRcdFx0XHRcdGlmICghcGFyc2VyLnJlYWQoU3ludGF4LmNvbWJpbmF0b3IpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0YW5ub3RhdGlvbnMsXG5cdFx0XHRcdFx0cmF3XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBhIHJhdyBhbm5vdGF0aW9uIGZyb20gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqIElmIGZvdW5kLCB0aGUgcmF3IHN0cmluZyBmb3VuZCBpcyByZXR1cm5lZC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkSWRlbnRpZmllcihxdWl0VG9rZW5zOiBzdHJpbmdbXSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdW50aWwgPSBxdWl0VG9rZW5zXG5cdFx0XHRcdFx0LmNvbmNhdChTeW50YXguY29tYmluYXRvcilcblx0XHRcdFx0XHQuZmlsdGVyKHRvayA9PiB0b2sgIT09IFN5bnRheC5qb2ludCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBzaG91bGRRdWl0T25Kb2ludCA9IHF1aXRUb2tlbnMuaW5jbHVkZXMoU3ludGF4LmpvaW50KTtcblx0XHRcdFx0Y29uc3QgYXQgPSBwYXJzZXIucG9zaXRpb24gKyBwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0bGV0IHRva2VuID0gXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHVudGlsLnNvbWUodG9rID0+IHBhcnNlci5wZWVrKHRvaykpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNob3VsZFF1aXRPbkpvaW50ICYmIHBlZWtKb2ludCgpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZzEgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gVGhlIG9ubHkgb3BlcmF0b3JzIHRoYXQgY2FuIGJlIG1lYW5pbmdmdWxseSBlc2NhcGVkIGF0XG5cdFx0XHRcdFx0XHQvLyB0aGUgaWRlbnRpZmllciBsZXZlbCBhcmUgdGhlIGpvaW50LCB0aGUgY29tYmluYXRvciwgYW5kIHRoZVxuXHRcdFx0XHRcdFx0Ly8gcGF0dGVybiBkZWxpbWl0ZXIuIE90aGVyIG9jY3VyZW5jZXMgb2YgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHRcdC8vIGFwcGVuZCB0aGlzIGNoYXJhY3RlciB0byB0aGUgaWRlbnRpZmllci5cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGcxID09PSBlc2MpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGcyID0gcGFyc2VyLnJlYWRHcmFwaGVtZSgpO1xuXHRcdFx0XHRcdFx0XHR0b2tlbiArPSBnMjtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRva2VuICs9IGcxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCB0b2tlblRyaW1tZWQgPSB0b2tlbi50cmltKCk7XG5cdFx0XHRcdGlmICghdG9rZW5UcmltbWVkLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0YXQsXG5cdFx0XHRcdFx0aWRlbnRpZmllcjogbmV3IElkZW50aWZpZXIodG9rZW5UcmltbWVkKSxcblx0XHRcdFx0XHRyYXc6IHRva2VuXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBhIFVSSSBzdGFydGluZyBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuXHRcdFx0ICogb2YgdGhlIGN1cnNvci4gVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaXMgbm90IGNoYW5nZWRcblx0XHRcdCAqIGluIHRoZSBjYXNlIHdoZW4gYSB2YWxpZCBVUkkgd2FzIG5vdCByZWFkLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRVcmkoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXBhcnNlck9wdGlvbnMucmVhZFVyaXMpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCB1cmkgPSBVcmkudHJ5UGFyc2UocGFyc2VyLnJlYWRVbnRpbCgpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh1cmkgPT09IG51bGwpXG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB1cmk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBhIHBhdHRlcm4gZnJvbSB0aGUgc3RlYW0uXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFBhdHRlcm4obmVzdGVkID0gZmFsc2UpOiBQYXR0ZXJuIHwgVFBhcnNlRmF1bHQgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghbmVzdGVkICYmICFwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci5tYWluKSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghcGFyc2VyT3B0aW9ucy5yZWFkUGF0dGVybnMpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgc3RhcnRpbmcgc2VxdWVuY2VzLiBUaGV5J3JlIGludmFsaWRcblx0XHRcdFx0Ly8gcmVnZXggc3ludGF4LCBhbmQgd2UgbWF5IHVzZSB0aGVtIGluIHRoZSBmdXR1cmUgdG8gcGFja1xuXHRcdFx0XHQvLyBpbiBvdGhlciBsYW5ndWFnZSBmZWF0dXJlcy5cblx0XHRcdFx0aWYgKHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4TWlzYy5wbHVzKSB8fFxuXHRcdFx0XHRcdHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4TWlzYy5zdGFyKSB8fFxuXHRcdFx0XHRcdHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkKSlcblx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlN0YXRlbWVudEJlZ2luc1dpdGhJbnZhbGlkU2VxdWVuY2U7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUeXBlU2NyaXB0IGlzbid0IHBlcmZlY3QuXG5cdFx0XHRcdGNvbnN0IHVuaXRzID0gbmVzdGVkID9cblx0XHRcdFx0XHRyZWFkUmVnZXhVbml0cyh0cnVlKSA6XG5cdFx0XHRcdFx0cmVhZFJlZ2V4VW5pdHMoZmFsc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdCh1bml0cykpXG5cdFx0XHRcdFx0cmV0dXJuIHVuaXRzO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gUmlnaHQtdHJpbSBhbnkgdHJhaWxpbmcgd2hpdGVzcGFjZVxuXHRcdFx0XHR3aGlsZSAodW5pdHMubGVuZ3RoKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbGFzdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghKGxhc3QgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lKSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChsYXN0LmdyYXBoZW1lICE9PSBTeW50YXguc3BhY2UgJiYgbGFzdC5ncmFwaGVtZSAhPT0gU3ludGF4LnRhYilcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHVuaXRzLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodW5pdHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiBGYXVsdHMuRW1wdHlQYXR0ZXJuO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbGFzdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRjb25zdCBpc1RvdGFsID0gXG5cdFx0XHRcdFx0bGFzdCBpbnN0YW5jZW9mIFJlZ2V4R3JhcGhlbWUgJiZcblx0XHRcdFx0XHRsYXN0LnF1YW50aWZpZXIgPT09IG51bGwgJiZcblx0XHRcdFx0XHRsYXN0LmdyYXBoZW1lID09PSBSZWdleFN5bnRheERlbGltaXRlci5tYWluO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTmVlZCB0byBwb3Agb2ZmIHRoZSBcblx0XHRcdFx0aWYgKGlzVG90YWwpXG5cdFx0XHRcdFx0dW5pdHMucG9wKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBOb3cgcmVhZCB0aGUgYW5ub3RhdGlvbnMsIGluIG9yZGVyIHRvIGNvbXB1dGUgdGhlIFBhdHRlcm4ncyBoYXNoXG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IGZvdW5kSm9pbnRQb3NpdGlvbiA9IG1heWJlUmVhZEpvaW50KCk7XG5cdFx0XHRcdGlmIChmb3VuZEpvaW50UG9zaXRpb24gPCAwKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUGF0dGVybihPYmplY3QuZnJlZXplKHVuaXRzKSwgaXNUb3RhbCwgXCJcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhbm5vcyA9IHJlYWRBbm5vdGF0aW9ucyhbXSkuYW5ub3RhdGlvbnM7XG5cdFx0XHRcdGNvbnN0IGFubm9zQXJyYXlKb2luZWQgPSBBcnJheS5mcm9tKGFubm9zLnZhbHVlcygpKVxuXHRcdFx0XHRcdC5tYXAodiA9PiB2LnN1YmplY3QudG9TdHJpbmcoKSlcblx0XHRcdFx0XHQuam9pbihTeW50YXgudGVybWluYWwpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgaGFzaCA9IEhhc2guY2FsY3VsYXRlKGFubm9zQXJyYXlKb2luZWQpO1xuXHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBQYXR0ZXJuKE9iamVjdC5mcmVlemUodW5pdHMpLCBpc1RvdGFsLCBoYXNoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcmVhZFJlZ2V4VW5pdHMobmVzdGVkOiB0cnVlKTogVFBhcnNlRmF1bHQgfCAoUmVnZXhVbml0KVtdO1xuXHRcdFx0ZnVuY3Rpb24gcmVhZFJlZ2V4VW5pdHMobmVzdGVkOiBmYWxzZSk6IFRQYXJzZUZhdWx0IHwgKFJlZ2V4VW5pdCB8IEluZml4KVtdO1xuXHRcdFx0ZnVuY3Rpb24gcmVhZFJlZ2V4VW5pdHMobmVzdGVkOiBib29sZWFuKTogVFBhcnNlRmF1bHQgfCAoUmVnZXhVbml0IHwgSW5maXgpW11cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdW5pdHM6IChSZWdleFVuaXQgfCBJbmZpeClbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBzZXRPckdyb3VwID0gbWF5YmVSZWFkUmVnZXhTZXQoKSB8fCBtYXliZVJlYWRSZWdleEdyb3VwKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdChzZXRPckdyb3VwKSlcblx0XHRcdFx0XHRcdHJldHVybiBzZXRPckdyb3VwO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzZXRPckdyb3VwICE9PSBudWxsKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHF1YW50aWZpZXIgPSBtYXliZVJlYWRSZWdleFF1YW50aWZpZXIoKTtcblx0XHRcdFx0XHRcdGlmIChpc1BhcnNlRmF1bHQocXVhbnRpZmllcikpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBxdWFudGlmaWVyO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR1bml0cy5wdXNoKGFwcGVuZFF1YW50aWZpZXIoc2V0T3JHcm91cCwgcXVhbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChuZXN0ZWQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IpKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHBhcnNlci5wZWVrKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kKSlcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBJbmZpeGVzIGFyZSBub3Qgc3VwcG9ydGVkIGFueXdoZXJlIG90aGVyIFxuXHRcdFx0XHRcdFx0Ly8gdGhhbiBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSBwYXR0ZXJuLlxuXHRcdFx0XHRcdFx0Y29uc3QgaW5maXggPSBtYXliZVJlYWRJbmZpeCgpO1xuXHRcdFx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdChpbmZpeCkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbmZpeDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGluZml4ICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjb25zdCBxdWFudGlmaWVyID0gbWF5YmVSZWFkUmVnZXhRdWFudGlmaWVyKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChxdWFudGlmaWVyICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuSW5maXhIYXNRdWFudGlmaWVyO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dW5pdHMucHVzaChpbmZpeCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAocGVla0pvaW50KCkpXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBncmFwaGVtZSA9IG1heWJlUmVhZFJlZ2V4R3JhcGhlbWUoKTtcblx0XHRcdFx0XHRpZiAoIWdyYXBoZW1lKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGdyYXBoZW1lIHJlYWQgaXMgaW4gdGhlIFJlZ2V4U3ludGF4S25vd25TZXRcblx0XHRcdFx0XHQvLyBlbnVtZXJhdGlvbiwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBncmFwaGVtZSB0byBhXG5cdFx0XHRcdFx0Ly8gUmVnZXhTZXQgaW5zdGFuY2UsIGFuZCBwdXNoIHRoYXQgb24gdG8gdGhlIHVuaXRzIGFycmF5XG5cdFx0XHRcdFx0Ly8gaW5zdGVhZC5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZWdleEtub3duU2V0ID0gKCgpID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGdyYXBoZW1lLmNoYXJhY3RlciA9PT0gUmVnZXhTeW50YXhLbm93blNldC53aWxkICYmICFncmFwaGVtZS5lc2NhcGVkKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUmVnZXhTeW50YXhLbm93blNldC53aWxkO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoZ3JhcGhlbWUuZXNjYXBlZClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY2hhcmFjdGVyV2l0aEVzY2FwZSA9IGVzYyArIGdyYXBoZW1lLmNoYXJhY3Rlcjtcblx0XHRcdFx0XHRcdFx0Y29uc3Qga25vd25TZXQgPSBSZWdleFN5bnRheEtub3duU2V0LnJlc29sdmUoY2hhcmFjdGVyV2l0aEVzY2FwZSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoa25vd25TZXQgIT09IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGtub3duU2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHF1YW50aWZpZXIgPSBtYXliZVJlYWRSZWdleFF1YW50aWZpZXIoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaXNQYXJzZUZhdWx0KHF1YW50aWZpZXIpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHF1YW50aWZpZXI7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHJlZ2V4S25vd25TZXQgIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dW5pdHMucHVzaChuZXcgUmVnZXhTZXQoW3JlZ2V4S25vd25TZXRdLCBbXSwgW10sIFtdLCBmYWxzZSwgcXVhbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChncmFwaGVtZS51bmljb2RlQmxvY2tOYW1lKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHVibiA9IGdyYXBoZW1lLnVuaWNvZGVCbG9ja05hbWU7XG5cdFx0XHRcdFx0XHR1bml0cy5wdXNoKG5ldyBSZWdleFNldChbXSwgW10sIFt1Ym5dLCBbXSwgZmFsc2UsIHF1YW50aWZpZXIpKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZ3JhcGhlbWUuZXNjYXBlZClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBzaWduID0gUmVnZXhTeW50YXhTaWduLnJlc29sdmUoZXNjICsgZ3JhcGhlbWUuY2hhcmFjdGVyKTtcblx0XHRcdFx0XHRcdGlmIChzaWduICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR1bml0cy5wdXNoKG5ldyBSZWdleFNpZ24oc2lnbiwgcXVhbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBwb2ludCBpcyByZWFjaGVkLCBpdCdzIGJlY2F1c2UgdGhlcmUgd2FzIGEgdW5uZWNjZXNhcmlseVxuXHRcdFx0XHRcdFx0Ly8gZXNjYXBlZCBjaGFyYWN0ZXIgZm91bmQgaW4gdGhlIHBhcnNlIHN0cmVhbSwgc3VjaCBhcyBcIlxcYVwiLiBJblxuXHRcdFx0XHRcdFx0Ly8gdGhpcyBjYXNlLCB0aGUgcmF3IGNoYXJhY3RlciBjYW4ganVzdCBiZSBhZGRlZCBhcyBhIHJlZ2V4IHVuaXQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHVuaXRzLnB1c2gobmV3IFJlZ2V4R3JhcGhlbWUoXG5cdFx0XHRcdFx0XHRncmFwaGVtZS5jaGFyYWN0ZXIsXG5cdFx0XHRcdFx0XHRxdWFudGlmaWVyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB1bml0cztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgY2hhcmFjdGVyIHNldCBmcm9tIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0XHQgKiBFeGFtcGxlOiBbYS16MC05XVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRSZWdleFNldCgpOiBSZWdleFNldCB8IFRQYXJzZUZhdWx0IHwgbnVsbFxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLnNldFN0YXJ0KSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHJuZyA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLnJhbmdlO1xuXHRcdFx0XHRjb25zdCBrbm93bnM6IFJlZ2V4U3ludGF4S25vd25TZXRbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCByYW5nZXM6IFJlZ2V4Q2hhclJhbmdlW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgYmxvY2tzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBzaW5nbGVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBpc05lZ2F0ZWQgPSAhIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4TWlzYy5uZWdhdGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IGNsb3NlZCA9IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFN0b3JlcyBhbGwgR3JhcGhlbWVzIHJlYWQuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRjb25zdCBncmFwaGVtZXM6IChHcmFwaGVtZSB8IG51bGwpW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBTdG9yZXMgYm9vbGVhbnMgdGhhdCBhbGlnbiB3aXRoIHRoZSBpdGVtcyBpbiBcInF1ZXVlXCIsXG5cdFx0XHRcdCAqIHRoYXQgaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIHF1ZXVlZCBHcmFwaGVtZVxuXHRcdFx0XHQgKiBjYW4gcGFydGljaXBhdGUgaW4gYSByYW5nZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGNvbnN0IHJhbmdhYmxlUXVldWU6IGJvb2xlYW5bXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICg7Oylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGcgPSBtYXliZVJlYWRSZWdleEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGcgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWcuZXNjYXBlZCAmJiBnLmNoYXJhY3RlciA9PT0gUmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGcudW5pY29kZUJsb2NrTmFtZSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRibG9ja3MucHVzaChnLnVuaWNvZGVCbG9ja05hbWUpO1xuXHRcdFx0XHRcdFx0cmFuZ2FibGVRdWV1ZS5wdXNoKGZhbHNlKTtcblx0XHRcdFx0XHRcdGdyYXBoZW1lcy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGdGdWxsID0gZy5lc2NhcGVkID8gZXNjICsgZy5jaGFyYWN0ZXIgOiBnLmNoYXJhY3Rlcjtcblx0XHRcdFx0XHRjb25zdCBrbm93biA9IFJlZ2V4U3ludGF4S25vd25TZXQucmVzb2x2ZShnRnVsbCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGtub3duICE9PSBudWxsKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGtub3ducy5wdXNoKGtub3duKTtcblx0XHRcdFx0XHRcdHJhbmdhYmxlUXVldWUucHVzaChmYWxzZSk7XG5cdFx0XHRcdFx0XHRncmFwaGVtZXMucHVzaChudWxsKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRncmFwaGVtZXMucHVzaChnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyYW5nYWJsZVF1ZXVlLnB1c2goXG5cdFx0XHRcdFx0XHRnLmNoYXJhY3Rlci5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0XHRnLmNoYXJhY3RlciAhPT0gUmVnZXhTeW50YXhNaXNjLmJvdW5kYXJ5ICYmXG5cdFx0XHRcdFx0XHRnLmNoYXJhY3RlciAhPT0gUmVnZXhTeW50YXhNaXNjLmJvdW5kYXJ5Tm9uKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZy51bmljb2RlQmxvY2tOYW1lKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbGVuID0gZ3JhcGhlbWVzLmxlbmd0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobGVuIDwgMylcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG1heWJlUm5nID0gZ3JhcGhlbWVzW2xlbiAtIDJdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXliZVJuZyAhPT0gbnVsbCAmJiBtYXliZVJuZy5jaGFyYWN0ZXIgIT09IHJuZylcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghcmFuZ2FibGVRdWV1ZVtsZW4gLSAzXSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG1heWJlRnJvbSA9IGdyYXBoZW1lc1tsZW4gLSAzXTtcblx0XHRcdFx0XHRpZiAobWF5YmVGcm9tID09PSBudWxsKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gUGVlbCBiYWNrIHN5bWJvbCBxdWV1ZSwgYW5kIGFkZCBhIHJhbmdlXG5cdFx0XHRcdFx0Ly8gdG8gdGhlIGFscGhhYmV0IGJ1aWxkZXIgaWYgdGhlIHF1ZXVlIGdldHMgaW50b1xuXHRcdFx0XHRcdC8vIGEgc3RhdGUgd2hlcmUgaXQncyBlbmRpbmcgd2l0aCBzb21ldGhpbmdcblx0XHRcdFx0XHQvLyBsb29raW5nIGxpa2U6ID8tP1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGZyb20gPSBtYXliZUZyb20uY2hhcmFjdGVyLmNvZGVQb2ludEF0KDApIHx8IDA7XG5cdFx0XHRcdFx0Y29uc3QgdG8gPSBnLmNoYXJhY3Rlci5jb2RlUG9pbnRBdCgwKSB8fCAwO1xuXHRcdFx0XHRcdHJhbmdlcy5wdXNoKG5ldyBSZWdleENoYXJSYW5nZShmcm9tLCB0bykpO1xuXHRcdFx0XHRcdGdyYXBoZW1lcy5sZW5ndGggLT0gMztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFjbG9zZWQpXG5cdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5VbnRlcm1pbmF0ZWRDaGFyYWN0ZXJTZXQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGcgb2YgZ3JhcGhlbWVzKVxuXHRcdFx0XHRcdGlmIChnICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0c2luZ2xlcy5wdXNoKGcuY2hhcmFjdGVyKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHF1YW50aWZpZXIgPSBtYXliZVJlYWRSZWdleFF1YW50aWZpZXIoKTtcblx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdChxdWFudGlmaWVyKSlcblx0XHRcdFx0XHRyZXR1cm4gcXVhbnRpZmllcjtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnZXhTZXQoXG5cdFx0XHRcdFx0a25vd25zLFxuXHRcdFx0XHRcdHJhbmdlcyxcblx0XHRcdFx0XHRibG9ja3MsXG5cdFx0XHRcdFx0c2luZ2xlcyxcblx0XHRcdFx0XHRpc05lZ2F0ZWQsXG5cdFx0XHRcdFx0cXVhbnRpZmllcik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBhbiBhbHRlcm5hdGlvbiBncm91cCBmcm9tIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0XHQgKiBFeGFtcGxlOiAoQXxCfEMpXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFJlZ2V4R3JvdXAoKTogUmVnZXhHcm91cCB8IFRQYXJzZUZhdWx0IHwgbnVsbFxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwU3RhcnQpKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY2FzZXM6IChyZWFkb25seSBSZWdleFVuaXRbXSlbXSA9IFtdO1xuXHRcdFx0XHRsZXQgY2xvc2VkID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci5hbHRlcm5hdG9yKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci5ncm91cEVuZCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBzdWJVbml0cyA9IHJlYWRSZWdleFVuaXRzKHRydWUpO1xuXHRcdFx0XHRcdGlmIChpc1BhcnNlRmF1bHQoc3ViVW5pdHMpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN1YlVuaXRzO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBjYWxsIHRvIG1heWJlUmVhZFBhdHRlcm4gY2F1c2VzIHRoZSBjdXJzb3Jcblx0XHRcdFx0XHQvLyB0byByZWFjaCB0aGUgZW5kIG9mIHRlIHBhcnNlIHN0cmVhbSwgdGhlIGV4cHJlc3Npb25cblx0XHRcdFx0XHQvLyBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgd291bGQgbWVhbiB0aGUgaW5wdXQgbG9va3Ncblx0XHRcdFx0XHQvLyBzb21ldGhpbmcgbGlrZTogLyhhYXxiYlxuXHRcdFx0XHRcdGlmICghcGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuVW50ZXJtaW5hdGVkR3JvdXA7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQSBudWxsIHN1YlBhdHRlcm4gY291bGQgY29tZSBiYWNrIGluIHRoZSBjYXNlIHdoZW4gc29tZVxuXHRcdFx0XHRcdC8vIGJpemFycmUgc3ludGF4IGlzIGZvdW5kIGluIHRoZSBwYXR0ZXJuIHN1Y2ggYXM6IChhfHxiKVxuXHRcdFx0XHRcdGlmIChzdWJVbml0cyA9PT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2VzLnB1c2goT2JqZWN0LmZyZWV6ZShzdWJVbml0cykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWNsb3NlZClcblx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlVudGVybWluYXRlZEdyb3VwO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRpZiAoaXNQYXJzZUZhdWx0KHF1YW50aWZpZXIpKVxuXHRcdFx0XHRcdHJldHVybiBxdWFudGlmaWVyO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleEdyb3VwKE9iamVjdC5mcmVlemUoY2FzZXMpLCBxdWFudGlmaWVyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgcGF0dGVybiBxdWFudGlmaWVyIGZyb20gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlcywgd2hpY2ggaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIEphdmFTY3JpcHRcblx0XHRcdCAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGF2b3IgKGFuZCBvdGhlcnM/KSBjYW5ub3QgcGFyc2UgYW4gZXhwcmVzc2lvblxuXHRcdFx0ICogd2l0aCB0d28gY29uc2VjdXRpdmUgcXVhbnRpZmllcnMuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpOiBSZWdleFF1YW50aWZpZXIgfCBUUGFyc2VGYXVsdCB8IG51bGxcblx0XHRcdHtcblx0XHRcdFx0LyoqICovXG5cdFx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFF1YW50aWZpZXIoKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhNaXNjLnN0YXIpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFF1YW50aWZpZXIoMCwgSW5maW5pdHksIGlzUmVzdHJhaW5lZCgpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhNaXNjLnBsdXMpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFF1YW50aWZpZXIoMSwgSW5maW5pdHksIGlzUmVzdHJhaW5lZCgpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhNaXNjLnJlc3RyYWluZWQpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFF1YW50aWZpZXIoMCwgMSwgZmFsc2UpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghcGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclN0YXJ0KSlcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG1pbiA9IG1heWJlUmVhZEludGVnZXIoKTtcblx0XHRcdFx0XHRpZiAobWluICE9PSBudWxsKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHF1YW50RW5kID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllckVuZDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gezJ9XG5cdFx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQocXVhbnRFbmQpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcihtaW4sIG1pbiwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyB7Mix9IG9yIHsyLDN9IG9yIHsyLD8/P1xuXHRcdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJTZXBhcmF0b3IpKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQocXVhbnRFbmQpKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgUmVnZXhRdWFudGlmaWVyKG1pbiwgSW5maW5pdHksIGlzUmVzdHJhaW5lZCgpKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1heCA9IG1heWJlUmVhZEludGVnZXIoKTtcblx0XHRcdFx0XHRcdFx0aWYgKG1heCAhPT0gbnVsbCAmJiBwYXJzZXIucmVhZChxdWFudEVuZCkpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFF1YW50aWZpZXIobWluLCBtYXgsIGlzUmVzdHJhaW5lZCgpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0LyoqICovXG5cdFx0XHRcdGZ1bmN0aW9uIGlzUmVzdHJhaW5lZCgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gISFwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2MucmVzdHJhaW5lZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHF1YW50aWZpZXIgPSBtYXliZVJlYWRRdWFudGlmaWVyKCk7XG5cdFx0XHRcdGlmIChxdWFudGlmaWVyKVxuXHRcdFx0XHRcdGlmIChtYXliZVJlYWRRdWFudGlmaWVyKCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLkR1cGxpY2F0ZVF1YW50aWZpZXI7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcXVhbnRpZmllcjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkSW50ZWdlcigpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBpbnRlZ2VyVGV4dCA9IFwiXCI7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDE2ICYmIHBhcnNlci5tb3JlKCk7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRpZ2l0ID0gKCgpID0+XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgZGlnaXQgPSAwOyBkaWdpdCA8PSA5OyBkaWdpdCsrKVxuXHRcdFx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoZGlnaXQudG9TdHJpbmcoKSkpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGRpZ2l0LnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFkaWdpdClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGludGVnZXJUZXh0ICs9IGRpZ2l0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gaW50ZWdlclRleHQubGVuZ3RoID4gMCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoaW50ZWdlclRleHQsIDEwKSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkSW5maXgoKTogSW5maXggfCBUUGFyc2VGYXVsdCB8IG51bGxcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgbGhzRW50cmllczogQm91bmRhcnk8SWRlbnRpZmllcj5bXSA9IFtdO1xuXHRcdFx0XHRjb25zdCByaHNFbnRyaWVzOiBCb3VuZGFyeTxJZGVudGlmaWVyPltdID0gW107XG5cdFx0XHRcdGNvbnN0IGluZml4U3RhcnQgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGxldCBpbmZpeEZsYWdzOiBJbmZpeEZsYWdzID0gSW5maXhGbGFncy5ub25lO1xuXHRcdFx0XHRsZXQgcXVpdFRva2VuID0gSW5maXhTeW50YXguZW5kO1xuXHRcdFx0XHRsZXQgaGFzSm9pbnQgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChJbmZpeFN5bnRheC5ub21pbmFsU3RhcnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW5maXhGbGFncyB8PSBJbmZpeEZsYWdzLm5vbWluYWw7XG5cdFx0XHRcdFx0cXVpdFRva2VuID0gSW5maXhTeW50YXgubm9taW5hbEVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChwYXJzZXIucmVhZChJbmZpeFN5bnRheC5wYXR0ZXJuU3RhcnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW5maXhGbGFncyB8PSBJbmZpeEZsYWdzLnBhdHRlcm47XG5cdFx0XHRcdFx0cXVpdFRva2VuID0gSW5maXhTeW50YXgucGF0dGVybkVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChwYXJzZXIucmVhZChJbmZpeFN5bnRheC5zdGFydCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbmZpeEZsYWdzIHw9IEluZml4RmxhZ3MucG9wdWxhdGlvbjtcblx0XHRcdFx0XHRxdWl0VG9rZW4gPSBJbmZpeFN5bnRheC5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5qb2ludCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbmZpeEZsYWdzIHw9IEluZml4RmxhZ3MucG9ydGFiaWxpdHk7XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBib3VuZHNFbnRyeSBvZiByZWFkQW5ub3RhdGlvbnMoW3F1aXRUb2tlbl0pLmFubm90YXRpb25zKVxuXHRcdFx0XHRcdFx0cmhzRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0Ym91bmRzRW50cnkub2Zmc2V0U3RhcnQsXG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0Ym91bmRzRW50cnkuc3ViamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3QgYm91bmRzRW50cnkgb2YgcmVhZERlY2xhcmF0aW9ucyhbcXVpdFRva2VuXSkpXG5cdFx0XHRcdFx0XHRsaHNFbnRyaWVzLnB1c2goYm91bmRzRW50cnkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXliZVJlYWRKb2ludCgpID4gLTEpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aGFzSm9pbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgYm91bmRzRW50cnkgb2YgcmVhZEFubm90YXRpb25zKFtxdWl0VG9rZW5dKS5hbm5vdGF0aW9ucylcblx0XHRcdFx0XHRcdFx0cmhzRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0XHRib3VuZHNFbnRyeS5vZmZzZXRTdGFydCxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0Ym91bmRzRW50cnkuc3ViamVjdCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXZvaWQgcHJvZHVjaW5nIGFuIGluZml4IGluIHdlaXJkIGNhc2VzIHN1Y2ggYXM6XG5cdFx0XHRcdC8vIDwgOiA+ICA8LyAgLz4gIDw8Oj4+XG5cdFx0XHRcdGlmIChsaHNFbnRyaWVzLmxlbmd0aCArIHJoc0VudHJpZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGhhc0pvaW50KVxuXHRcdFx0XHRcdGluZml4RmxhZ3MgfD0gSW5maXhGbGFncy5oYXNKb2ludDtcblx0XHRcdFx0XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChxdWl0VG9rZW4pKVxuXHRcdFx0XHRcdHJldHVybiBGYXVsdHMuVW50ZXJtaW5hdGVkSW5maXg7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IEluZml4KFxuXHRcdFx0XHRcdGluZml4U3RhcnQsXG5cdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uLFxuXHRcdFx0XHRcdG5ldyBCb3VuZGFyeUdyb3VwKGxoc0VudHJpZXMpLFxuXHRcdFx0XHRcdG5ldyBCb3VuZGFyeUdyb3VwKHJoc0VudHJpZXMpLFxuXHRcdFx0XHRcdGluZml4RmxhZ3MpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgb25lIHNpbmdsZSBzeW1ib2wgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLFxuXHRcdFx0ICogd2hpbGUgcmVzcGVjdGluZyB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMsIGFuZCBlc2NhcGVkXG5cdFx0XHQgKiBjaGFyYWN0ZXJzLlxuXHRcdFx0ICogXG5cdFx0XHQgKiBAcmV0dXJucyBUaGUgcmVhZCBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgY2FzZSB3aGVuXG5cdFx0XHQgKiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGluIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFJlZ2V4R3JhcGhlbWUoKTogR3JhcGhlbWUgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghcGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIudXRmMTZHcm91cFN0YXJ0KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRlbGltID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIudXRmMTZHcm91cEVuZDtcblx0XHRcdFx0XHRjb25zdCB1bmljb2RlUmVmID0gcGFyc2VyLnJlYWRVbnRpbChkZWxpbSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSByZWFkVW50aWwgbWV0aG9kIHN0b3BwZWQgYmVjYXVzZSBpdFxuXHRcdFx0XHRcdC8vIGFjdHVhbGx5IGhpdCB0aGUgZGVsaW1pdGVyLCBhbmQgbm90IGJlY2F1c2UgaXQgcmFuIG91dFxuXHRcdFx0XHRcdC8vIG9mIGNoYXJhY3RlcnMuXG5cdFx0XHRcdFx0aWYgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cGFyc2VyLnJlYWQoZGVsaW0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoVW5pY29kZUJsb2Nrcy5oYXModW5pY29kZVJlZi50b0xvd2VyQ2FzZSgpKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBHcmFwaGVtZShcIlwiLCB1bmljb2RlUmVmLCB0cnVlKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3QgbGVuID0gdW5pY29kZVJlZi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpZiAobGVuID49IDEgJiYgbGVuIDw9IDUpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG51bSA9IHBhcnNlSW50KHVuaWNvZGVSZWYsIDE2KTtcblx0XHRcdFx0XHRcdFx0aWYgKG51bSA9PT0gbnVtKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBHcmFwaGVtZShjaGFyLCBcIlwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBTb21ldGhpbmcgY2FtZSBpbiB0aGF0IGxvb2tlZCBsaWtlIGEgdW5pY29kZSBlc2NhcGVcblx0XHRcdFx0XHQvLyBzZXF1ZW5jZSwgYnV0IHR1cm5lZCBvdXQgbm90IHRvIGJlLCBsaWtlOiBcXHVcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoZXNjKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJzZSBzdHJlYW0gZW5kcyB3aXRoIGEgYmFja3NsYXNoLCB3ZSBqdXN0XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBhY3R1YWwgYmFja3NsYXNoIGNoYXJhY3RlciBhcyBhIGNoYXJhY3Rlci5cblx0XHRcdFx0XHQvLyBUaGlzIGNvdmVycyByaWRpY3Vsb3VzIGJ1dCBwb3NzaWJsZSBjYXNlcyB3aGVyZSBhXG5cdFx0XHRcdFx0Ly8gYW4gdW5hbm5vdGF0ZWQgdHlwZSBpcyBuYW1lZCBzb21ldGhpbmcgbGlrZSBcIlRoaW5nXFxcIi5cblx0XHRcdFx0XHRpZiAoIXBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEdyYXBoZW1lKGVzYywgXCJcIiwgZmFsc2UpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGcgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0Y29uc3QgZGVjb2RlZCA9IFJlZ2V4U3ludGF4U2lnbi51bmVzY2FwZShlc2MgKyBnKSB8fCBnO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JhcGhlbWUoZGVjb2RlZCwgXCJcIiwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgR3JhcGhlbWUocGFyc2VyLnJlYWRHcmFwaGVtZSgpLCBcIlwiLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0ZnVuY3Rpb24gaXNQYXJzZUZhdWx0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUmVhZG9ubHk8RmF1bHRUeXBlPFN0YXRlbWVudD4+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEZhdWx0VHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgfVxuXHR9XG5cblxuXHQvKiogKi9cblx0Y2xhc3MgR3JhcGhlbWVcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIGNoYXJhY3RlciBmb3VuZCBpbiB0aGUgcGFyc2Ugc3RyZWFtIGluXG5cdFx0XHQgKiB0aGVpciB1bmVzY2FwZWQgZm9ybWF0LiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2Vcblx0XHRcdCAqIHdoZW4gdGhlIGZpZWxkIGlzIHJlZmVycmluZyB0byBhIHVuaWNvZGUgY2hhcmFjdGVyLFxuXHRcdFx0ICogdGhlIGZpZWxkIHdvdWxkIHN0b3JlIFwi8J+Qh1wiIC4uLiBub3QgXCJcXHUxRjQwN1wiLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBjaGFyYWN0ZXI6IHN0cmluZyxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBuYW1lIG9mIHRoZSB1bmljb2RlIGJsb2NrIHNwZWNpZmllZCxcblx0XHRcdCAqIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgZ3JhcGhlbWUgZG9lcyBub3QgcmVmZXJcblx0XHRcdCAqIHRvIGEgdW5pY29kZSBibG9jay5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgdW5pY29kZUJsb2NrTmFtZTogc3RyaW5nLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGUgZGlzY292ZXJlZCBncmFwaGVtZSB3YXNcblx0XHRcdCAqIGVzY2FwZWQgaW4gdGhlIHBhcnNlIHN0cmVhbS4gTm90ZSB0aGF0IGlmIHRoZVxuXHRcdFx0ICogZ3JhcGhlbWUgcmVmZXJzIHRvIGEgc3BlY2lhbCBjaGFyYWN0ZXIsIHN1Y2hcblx0XHRcdCAqIGFzIFwiXFxkXCIgZm9yIGFsbCBkaWdpdHMsIHRoaXMgd2lsbCBiZSB0cnVlLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBlc2NhcGVkOiBib29sZWFuKVxuXHRcdHsgfVxuXHR9XG5cblxuXHQvKipcblx0ICogU2xpZ2h0bHkgYXdrd2FyZCBoYWNrIGZ1bmN0aW9uIHRvIGF0dGFjaCBhIFBhdHRlcm5RdWFudGlmaWVyXG5cdCAqIHRvIGFuIGFscmVhZHkgZXhpc3RpbmcgUGF0dGVyblVuaXQgKHdpdGhvdXQgcmVzb3J0aW5nIHRvIG1ha2luZ1xuXHQgKiBxdWFudGlmaWVyIGEgbXV0YWJsZSBwcm9wZXJ0eS5cblx0ICovXG5cdGZ1bmN0aW9uIGFwcGVuZFF1YW50aWZpZXIodW5pdDogUmVnZXhVbml0LCBxdWFudGlmaWVyOiBSZWdleFF1YW50aWZpZXIgfCBudWxsID0gbnVsbClcblx0e1xuXHRcdGlmIChxdWFudGlmaWVyID09PSBudWxsKVxuXHRcdFx0cmV0dXJuIHVuaXQ7XG5cdFx0XG5cdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleFNldClcblx0XHRcdHJldHVybiBuZXcgUmVnZXhTZXQoXG5cdFx0XHRcdHVuaXQua25vd25zLFxuXHRcdFx0XHR1bml0LnJhbmdlcyxcblx0XHRcdFx0dW5pdC51bmljb2RlQmxvY2tzLFxuXHRcdFx0XHR1bml0LnNpbmdsZXMsXG5cdFx0XHRcdHVuaXQuaXNOZWdhdGVkLFxuXHRcdFx0XHRxdWFudGlmaWVyKTtcblx0XHRcblx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JvdXApXG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2V4R3JvdXAodW5pdC5jYXNlcywgcXVhbnRpZmllcik7XG5cdFx0XG5cdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWdleEdyYXBoZW1lKHVuaXQuZ3JhcGhlbWUsIHF1YW50aWZpZXIpO1xuXHRcdFxuXHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogUGxhY2Vob2xkZXIgb2JqZWN0IHRvIG1hcmsgdGhlIHBvc2l0aW9uIG9mXG5cdCAqIGFuIGFub255bW91cyB0eXBlIHdpdGhpbiBhIHN0YXRlbWVudC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBBbm9uXG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBOby1vcCBwcm9wZXJ0eSB1c2VkIGZvciBkZWJ1Z2dpbmdcblx0XHQgKiBwdXJwb3NlcywgYW5kIGFsc28gdG8gZG9kZ2Ugc3RydWN0dXJhbFxuXHRcdCAqIHR5cGUgY29tcGF0aWJpbGl0eSBidWdzIGluIFR5cGVTY3JpcHQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaWQgPSArK25leHRJZDtcblx0XHRcblx0XHQvKiogKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGBfX0FOT04ke3RoaXMuaWR9X19gO1xuXHRcdH1cblx0fVxuXG5cdGxldCBuZXh0SWQgPSAwO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIGxpbmUsIGFmdGVyIGJlaW5nIHBhcnNlZC5cblx0ICogQSBMaW5lIGlzIGRpZmZlcmVudCBmcm9tIGEgU3RhdGVtZW50IGluIHRoYXQgaXQgaGFzIG5vXG5cdCAqIHJlbGF0aW9uc2hpcCB0byBhIERvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIExpbmVcblx0e1xuXHRcdC8qKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHNvdXJjZVRleHQ6IHN0cmluZyxcblx0XHRcdHJlYWRvbmx5IGluZGVudDogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgZGVjbGFyYXRpb25zOiBCb3VuZGFyeUdyb3VwPERlY2xhcmF0aW9uU3ViamVjdD4sXG5cdFx0XHRyZWFkb25seSBhbm5vdGF0aW9uczogQm91bmRhcnlHcm91cDxBbm5vdGF0aW9uU3ViamVjdD4sXG5cdFx0XHRyZWFkb25seSBzdW06IHN0cmluZyxcblx0XHRcdHJlYWRvbmx5IGpvaW50UG9zaXRpb246IG51bWJlcixcblx0XHRcdHJlYWRvbmx5IGZsYWdzOiBMaW5lRmxhZ3MsXG5cdFx0XHRyZWFkb25seSBmYXVsdFR5cGU6IFJlYWRvbmx5PEZhdWx0VHlwZTxTdGF0ZW1lbnQ+PiB8IG51bGwpXG5cdFx0eyB9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBIGJpdCBmaWVsZCBlbnVtZXJhdGlvbiB1c2VkIHRvIGVmZmljaWVudGx5IHN0b3JlXG5cdCAqIG1ldGEgZGF0YSBhYm91dCBhIExpbmUgKG9yIGEgU3RhdGVtZW50KSBvYmplY3QuXG5cdCAqL1xuXHRleHBvcnQgZW51bSBMaW5lRmxhZ3Ncblx0e1xuXHRcdG5vbmUgPSAwLFxuXHRcdGlzUmVmcmVzaCA9IDEsXG5cdFx0aXNWYWN1b3VzID0gMixcblx0XHRpc0NvbW1lbnQgPSA0LFxuXHRcdGlzV2hpdGVzcGFjZSA9IDgsXG5cdFx0aXNEaXNwb3NlZCA9IDE2LFxuXHRcdGlzQ3J1ZnQgPSAzMixcblx0XHRoYXNVcmkgPSA2NCxcblx0XHRoYXNUb3RhbFBhdHRlcm4gPSAxMjgsXG5cdFx0aGFzUGFydGlhbFBhdHRlcm4gPSAyNTYsXG5cdFx0aGFzUGF0dGVybiA9IDUxMlxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogU3Rha2VzIG91dCBzdGFydGluZyBhbmQgZW5kaW5nIGNoYXJhY3RlciBwb3NpdGlvbnNcblx0ICogb2Ygc3ViamVjdHMgd2l0aGluIGEgZ2l2ZW4gcmVnaW9uLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEJvdW5kYXJ5R3JvdXA8VFN1YmplY3Q+XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihib3VuZGFyaWVzOiBCb3VuZGFyeTxUU3ViamVjdD5bXSlcblx0XHR7XG5cdFx0XHR0aGlzLmVudHJpZXMgPSBPYmplY3QuZnJlZXplKGJvdW5kYXJpZXMuc2xpY2UoKS5zb3J0KChlbnRyeUEsIGVudHJ5QikgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIGVudHJ5QS5vZmZzZXRTdGFydCAtIGVudHJ5Qi5vZmZzZXRTdGFydDtcblx0XHRcdH0pKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcylcblx0XHRcdFx0eWllbGQgZW50cnk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoU3ViamVjdCgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMpXG5cdFx0XHRcdHlpZWxkIGVudHJ5LnN1YmplY3Q7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGluc3BlY3Qob2Zmc2V0OiBudW1iZXIpOiBUU3ViamVjdCB8IG51bGxcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcylcblx0XHRcdFx0aWYgKG9mZnNldCA+PSBlbnRyeS5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gZW50cnkub2Zmc2V0RW5kKVxuXHRcdFx0XHRcdHJldHVybiBlbnRyeS5zdWJqZWN0O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Zmlyc3QoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgdGhpcylcblx0XHRcdFx0cmV0dXJuIGVudHJ5O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIEdldHMgdGhlIG51bWJlciBvZiBlbnRyaWVzIGRlZmluZWQgaW4gdGhlIGJvdW5kcy4gKi9cblx0XHRnZXQgbGVuZ3RoKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzLmxlbmd0aDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBlbnRyaWVzOiByZWFkb25seSBCb3VuZGFyeTxUU3ViamVjdD5bXTtcblx0fVxuXG5cblx0LyoqICovXG5cdGV4cG9ydCBjbGFzcyBCb3VuZGFyeTxUU3ViamVjdD5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgb2Zmc2V0U3RhcnQ6IG51bWJlcixcblx0XHRcdHJlYWRvbmx5IG9mZnNldEVuZDogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgc3ViamVjdDogVFN1YmplY3QpXG5cdFx0eyB9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFN0YXRlbWVudFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogTG9naWNhbCBjbG9jayB2YWx1ZSB1c2VkIHRvIG1ha2UgY2hyb25vbG9naWNhbCBcblx0XHQgKiBjcmVhdGlvbi10aW1lIGNvbXBhcmlzb25zIGJldHdlZW4gU3RhdGVtZW50cy5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzdGFtcCA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoZG9jdW1lbnQ6IERvY3VtZW50LCB0ZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgbGluZSA9IExpbmVQYXJzZXIucGFyc2UodGV4dCk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cdFx0XHR0aGlzLnNvdXJjZVRleHQgPSBsaW5lLnNvdXJjZVRleHQ7XG5cdFx0XHR0aGlzLnN1bSA9IGxpbmUuc3VtO1xuXHRcdFx0dGhpcy5pbmRlbnQgPSBsaW5lLmluZGVudDtcblx0XHRcdHRoaXMuZmxhZ3MgPSBsaW5lLmZsYWdzO1xuXHRcdFx0dGhpcy5qb2ludFBvc2l0aW9uID0gbGluZS5qb2ludFBvc2l0aW9uO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFsbERlY2xhcmF0aW9ucyA9IE9iamVjdC5mcmVlemUoQXJyYXkuZnJvbShsaW5lLmRlY2xhcmF0aW9ucylcblx0XHRcdFx0Lm1hcChib3VuZGFyeSA9PiBuZXcgU3Bhbih0aGlzLCBib3VuZGFyeSkpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hbGxBbm5vdGF0aW9ucyA9IE9iamVjdC5mcmVlemUoQXJyYXkuZnJvbShsaW5lLmFubm90YXRpb25zKVxuXHRcdFx0XHQubWFwKGJvdW5kYXJ5ID0+IG5ldyBTcGFuKHRoaXMsIGJvdW5kYXJ5KSkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBmYXVsdHM6IEZhdWx0W10gPSBbXTtcblx0XHRcdGNvbnN0IGNydWZ0T2JqZWN0cyA9IG5ldyBTZXQ8U3RhdGVtZW50IHwgU3BhbiB8IEluZml4U3Bhbj4oKTtcblx0XHRcdFxuXHRcdFx0aWYgKGxpbmUuZmF1bHRUeXBlICE9PSBudWxsKVxuXHRcdFx0XHRmYXVsdHMucHVzaChuZXcgRmF1bHQobGluZS5mYXVsdFR5cGUsIHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBmYXVsdCBvZiB0aGlzLmVhY2hQYXJzZUZhdWx0KCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChmYXVsdC50eXBlLnNldmVyaXR5ID09PSBGYXVsdFNldmVyaXR5LmVycm9yKVxuXHRcdFx0XHRcdGNydWZ0T2JqZWN0cy5hZGQoZmF1bHQuc291cmNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZhdWx0cy5wdXNoKGZhdWx0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBmYXVsdCBvZiBmYXVsdHMpXG5cdFx0XHRcdC8vIENoZWNrIG5lZWRlZCB0byBzdXBwb3J0IHRoZSB1bml0IHRlc3RzLCB0aGUgZmVlZFxuXHRcdFx0XHQvLyBmYWtlIGRvY3VtZW50IG9iamVjdHMgaW50byB0aGUgc3RhdGVtZW50IGNvbnN0cnVjdG9yLlxuXHRcdFx0XHRpZiAoZG9jdW1lbnQucHJvZ3JhbSAmJiBkb2N1bWVudC5wcm9ncmFtLmZhdWx0cylcblx0XHRcdFx0XHRkb2N1bWVudC5wcm9ncmFtLmZhdWx0cy5yZXBvcnQoZmF1bHQpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmNydWZ0T2JqZWN0cyA9IGNydWZ0T2JqZWN0cztcblx0XHRcdHRoaXMuZmF1bHRzID0gT2JqZWN0LmZyZWV6ZShmYXVsdHMpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByb2dyYW1TdGFtcCA9IGRvY3VtZW50LnByb2dyYW0gP1xuXHRcdFx0XHRkb2N1bWVudC5wcm9ncmFtLnZlcnNpb24gOlxuXHRcdFx0XHRWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdH1cblx0XHRcblx0XHRyZWFkb25seSBwcm9ncmFtU3RhbXA6IFZlcnNpb25TdGFtcDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlICplYWNoUGFyc2VGYXVsdCgpOiBJdGVyYWJsZUl0ZXJhdG9yPFJlYWRvbmx5PEZhdWx0PFRGYXVsdFNvdXJjZT4+PlxuXHRcdHtcblx0XHRcdC8vIENoZWNrIGZvciB0YWJzIGFuZCBzcGFjZXMgbWl4dHVyZVxuXHRcdFx0aWYgKHRoaXMuaW5kZW50ID4gMClcblx0XHRcdHtcblx0XHRcdFx0bGV0IGhhc1RhYnMgPSBmYWxzZTtcblx0XHRcdFx0bGV0IGhhc1NwYWNlcyA9IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCB0aGlzLmluZGVudDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBjaHIgPSB0aGlzLnNvdXJjZVRleHRbaV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNociA9PT0gU3ludGF4LnRhYilcblx0XHRcdFx0XHRcdGhhc1RhYnMgPSB0cnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjaHIgPT09IFN5bnRheC5zcGFjZSlcblx0XHRcdFx0XHRcdGhhc1NwYWNlcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChoYXNUYWJzICYmIGhhc1NwYWNlcylcblx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLlRhYnNBbmRTcGFjZXMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5hbGxEZWNsYXJhdGlvbnMubGVuZ3RoID4gMSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3ViamVjdHM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgdGhpcy5hbGxEZWNsYXJhdGlvbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBzdWJUZXh0ID0gc3Bhbi50b1N0cmluZygpO1xuXHRcdFx0XHRcdGlmIChzdWJqZWN0cy5pbmNsdWRlcyhzdWJUZXh0KSlcblx0XHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuRHVwbGljYXRlRGVjbGFyYXRpb24sIHNwYW4pO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHN1YmplY3RzLnB1c2goc3ViVGV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuYWxsQW5ub3RhdGlvbnMubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Ly8gVGhpcyBwZXJmb3JtcyBhbiBleHBlZGllbnQgY2hlY2sgZm9yIFwiTGlzdEludHJpbnNpY0V4dGVuZGluZ0xpc3RcIixcblx0XHRcdFx0Ly8gaG93ZXZlciwgZnVsbCB0eXBlIGFuYWx5c2lzIGlzIHJlcXVpcmVkIHRvIGNvdmVyIGFsbCBjYXNlcyB3aGVyZVxuXHRcdFx0XHQvLyB0aGlzIGZhdWx0IG1heSBiZSByZXBvcnRlZC5cblx0XHRcdFx0Y29uc3QgZ2V0TGlzdFNwYW5zID0gKHNwYW5zOiByZWFkb25seSBTcGFuW10pID0+IHNwYW5zLmZpbHRlcihzcGFuID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBzdWIgPSBzcGFuLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHRcdFx0cmV0dXJuIHN1YiBpbnN0YW5jZW9mIElkZW50aWZpZXIgJiYgc3ViLmlzTGlzdDtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBsaHNMaXN0U3BhbnMgPSBnZXRMaXN0U3BhbnModGhpcy5hbGxEZWNsYXJhdGlvbnMpO1xuXHRcdFx0XHRjb25zdCByaHNMaXN0U3BhbnMgPSBnZXRMaXN0U3BhbnModGhpcy5hbGxBbm5vdGF0aW9ucyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobGhzTGlzdFNwYW5zLmxlbmd0aCA+IDAgJiYgcmhzTGlzdFNwYW5zLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHJoc0xpc3RTcGFucylcblx0XHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuTGlzdEludHJpbnNpY0V4dGVuZGluZ0xpc3QsIHNwYW4pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXR0ZXJuID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmFsbERlY2xhcmF0aW9ucy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBocCA9IExpbmVGbGFncy5oYXNQYXR0ZXJuO1xuXHRcdFx0XHRpZiAoKHRoaXMuZmxhZ3MgJiBocCkgIT09IGhwKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc3ViamVjdCA9IHRoaXMuYWxsRGVjbGFyYXRpb25zWzBdLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHRcdHJldHVybiBzdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybiA/XG5cdFx0XHRcdFx0c3ViamVjdCA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXR0ZXJuID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGlmICghcGF0dGVybi5pc1ZhbGlkKVxuXHRcdFx0e1xuXHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLlBhdHRlcm5JbnZhbGlkLCB0aGlzKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5hbGxBbm5vdGF0aW9ucy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuUGF0dGVybldpdGhvdXRBbm5vdGF0aW9uLCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhdHRlcm4udGVzdChcIlwiKSlcblx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5QYXR0ZXJuQ2FuTWF0Y2hFbXB0eSwgdGhpcyk7XG5cdFx0XHRcblx0XHRcdGlmICghcGF0dGVybi5pc1RvdGFsKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHVuaXQgb2YgcGF0dGVybi5lYWNoVW5pdCgpKVxuXHRcdFx0XHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcmFwaGVtZSlcblx0XHRcdFx0XHRcdGlmICh1bml0LmdyYXBoZW1lID09PSBTeW50YXguY29tYmluYXRvcilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5QYXR0ZXJuUGFydGlhbFdpdGhDb21iaW5hdG9yLCB0aGlzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhdHRlcm5TcGFuID0gdGhpcy5hbGxEZWNsYXJhdGlvbnNbMF07XG5cdFx0XHRpZiAocGF0dGVyblNwYW4uaW5maXhlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5maXhTcGFuczogSW5maXhTcGFuW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeCBvZiBwYXR0ZXJuU3Bhbi5pbmZpeGVzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBsaHMgPSBBcnJheS5mcm9tKHBhdHRlcm5TcGFuLmVhY2hEZWNsYXJhdGlvbkZvckluZml4KGluZml4KSk7XG5cdFx0XHRcdGNvbnN0IHJocyA9IEFycmF5LmZyb20ocGF0dGVyblNwYW4uZWFjaEFubm90YXRpb25Gb3JJbmZpeChpbmZpeCkpO1xuXHRcdFx0XHRjb25zdCBhbGwgPSBsaHMuY29uY2F0KHJocyk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGlzIGlzIGEgYml0IG91dCBvZiBwbGFjZSAuLi4gYnV0IHdlIG5lZWQgdG8gcG9wdWxhdGUgdGhlXG5cdFx0XHRcdC8vIGluZml4U3BhbnMgYXJyYXkgYW5kIHRoaXMgaXMgcHJvYmFibHkgdGhlIG1vc3QgZWZmaWNpZW50XG5cdFx0XHRcdC8vIHBsYWNlIHRvIGRvIHRoYXQuXG5cdFx0XHRcdGluZml4U3BhbnMucHVzaCguLi5hbGwpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgYWxsKVxuXHRcdFx0XHRcdGlmIChpbmZpeFNwYW4uYm91bmRhcnkuc3ViamVjdC5pc0xpc3QpXG5cdFx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLkluZml4VXNpbmdMaXN0T3BlcmF0b3IsIGluZml4U3Bhbik7XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCAqZGVkdXBJbmZpeFN1YmplY3RzKGxocyk7XG5cdFx0XHRcdHlpZWxkICpkZWR1cEluZml4U3ViamVjdHMocmhzKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGxoc0lkZW50aWZpZXJzID0gbGhzLm1hcChuZnhTcGFuID0+IFxuXHRcdFx0XHRcdG5meFNwYW4uYm91bmRhcnkuc3ViamVjdC50b1N0cmluZygpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIHJocylcblx0XHRcdFx0XHRpZiAobGhzSWRlbnRpZmllcnMuaW5jbHVkZXMoaW5maXhTcGFuLmJvdW5kYXJ5LnN1YmplY3QudG9TdHJpbmcoKSkpXG5cdFx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLkluZml4SGFzU2VsZlJlZmVyZW50aWFsVHlwZSwgaW5maXhTcGFuKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpbmZpeC5pc1BvcHVsYXRpb24pXG5cdFx0XHRcdFx0Zm9yIChsZXQgaWR4ID0gMTsgaWR4IDwgbGhzLmxlbmd0aDsgaWR4KyspXG5cdFx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLkluZml4UG9wdWxhdGlvbkNoYWluaW5nLCBsaHNbaWR4XSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCAqZXhwZWRpZW50TGlzdENoZWNrKGxocyk7XG5cdFx0XHRcdHlpZWxkICpleHBlZGllbnRMaXN0Q2hlY2socmhzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgZGVkdXBJbmZpeGVzQWNyb3NzSW5maXhlcyhcblx0XHRcdFx0cGF0dGVyblNwYW4sXG5cdFx0XHRcdGluZml4ID0+IHBhdHRlcm5TcGFuLmVhY2hEZWNsYXJhdGlvbkZvckluZml4KGluZml4KSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpbmZpeFNwYW4uY29udGFpbmluZ0luZml4LmlzUG9wdWxhdGlvbilcblx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoXG5cdFx0XHRcdFx0XHRGYXVsdHMuUG9wdWxhdGlvbkluZml4SGFzTXVsdGlwbGVEZWZpbml0aW9ucyxcblx0XHRcdFx0XHRcdGluZml4U3Bhbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIGRlZHVwSW5maXhlc0Fjcm9zc0luZml4ZXMoXG5cdFx0XHRcdHBhdHRlcm5TcGFuLFxuXHRcdFx0XHRpbmZpeCA9PiBwYXR0ZXJuU3Bhbi5lYWNoQW5ub3RhdGlvbkZvckluZml4KGluZml4KSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpbmZpeFNwYW4uY29udGFpbmluZ0luZml4LmlzUG9ydGFiaWxpdHkpXG5cdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KFxuXHRcdFx0XHRcdFx0RmF1bHRzLlBvcnRhYmlsaXR5SW5maXhIYXNNdWx0aXBsZURlZmluaXRpb25zLCBcblx0XHRcdFx0XHRcdGluZml4U3Bhbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX2luZml4U3BhbnMgPSBPYmplY3QuZnJlZXplKGluZml4U3BhbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhlIGpvaW50IG9wZXJhdG9yIGV4aXN0cyBhdCB0aGVcblx0XHQgKiBlbmQgb2YgdGhlIHN0YXRlbWVudCwgZm9yY2luZyB0aGUgc3RhdGVtZW50J3Ncblx0XHQgKiBkZWNsYXJhdGlvbnMgdG8gYmUgXCJyZWZyZXNoIHR5cGVzXCIuXG5cdFx0ICovXG5cdFx0Z2V0IGlzUmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc1JlZnJlc2g7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoZSBzdGF0ZW1lbnQgY29udGFpbnMgbm90aGluZ1xuXHRcdCAqIG90aGVyIHRoYW4gYSBzaW5nbGUgam9pbnQgb3BlcmF0b3IuXG5cdFx0ICovXG5cdFx0Z2V0IGlzVmFjdW91cygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc1ZhY3VvdXM7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoZSBzdGF0ZW1lbnQgaXMgYSBjb21tZW50LlxuXHRcdCAqL1xuXHRcdGdldCBpc0NvbW1lbnQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGYgPSBMaW5lRmxhZ3MuaXNDb21tZW50O1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgZikgPT09IGY7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGUgc3RhdGVtZW50IGNvbnRhaW5zXG5cdFx0ICogbm8gbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cblx0XHQgKi9cblx0XHRnZXQgaXNXaGl0ZXNwYWNlKClcblx0XHR7XG5cdFx0XHRjb25zdCBmID0gTGluZUZsYWdzLmlzV2hpdGVzcGFjZTtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIGYpID09PSBmO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhlIHN0YXRlbWVudCBpcyBhIGNvbW1lbnQgb3Igd2hpdGVzcGFjZS5cblx0XHQgKi9cblx0XHRnZXQgaXNOb29wKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0NvbW1lbnQgfHwgdGhpcy5pc1doaXRlc3BhY2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGUgc3RhdGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBpdCdzXG5cdFx0ICogY29udGFpbmluZyBkb2N1bWVudC4gUmVtb3ZhbCBvY2N1cnMgYWZ0ZXIgdGhlIHN0YXRlbWVudFxuXHRcdCAqIGhhcyBiZWVuIGludmFsaWRhdGVkLiBUaGVyZWZvcmUsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBmYWxzZVxuXHRcdCAqIGJlZm9yZSB0aGUgaW52YWxpZGF0aW9uIHBoYXNlIGhhcyBvY2N1cmVkLCBldmVuIGlmIGl0IHdpbGwgYmVcblx0XHQgKiBkaXNwb3NlZCBpbiB0aGUgY3VycmVudCBlZGl0IHRyYW5zYWN0aW9uLlxuXHRcdCAqL1xuXHRcdGdldCBpc0Rpc3Bvc2VkKClcblx0XHR7XG5cdFx0XHRjb25zdCBmID0gTGluZUZsYWdzLmlzRGlzcG9zZWQ7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0IGlzQ3J1ZnQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGYgPSBMaW5lRmxhZ3MuaXNDcnVmdDtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIGYpID09PSBmO1xuXHRcdH1cblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0cHJpdmF0ZSBmbGFncyA9IExpbmVGbGFncy5ub25lO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGZhdWx0czogcmVhZG9ubHkgRmF1bHRbXTtcblx0XHRcblx0XHQvKiogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoaXMgc3RhdGVtZW50LiAqL1xuXHRcdHJlYWRvbmx5IGRvY3VtZW50OiBEb2N1bWVudDtcblx0XHRcblx0XHQvKiogU3RvcmVzIHRoZSBpbmRlbnQgbGV2ZWwgb2YgdGhlIHN0YXRlbWVudC4gKi9cblx0XHRyZWFkb25seSBpbmRlbnQ6IG51bWJlcjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHNldCBvZiBvYmplY3RzIHRoYXQgYXJlIGNvbnRhaW5lZCBieSB0aGlzIFN0YXRlbWVudCwgXG5cdFx0ICogYW5kIGFyZSBtYXJrZWQgYXMgY3J1ZnQuIE5vdGUgdGhhdCB0aGUgb25seSBTdGF0ZW1lbnQgb2JqZWN0XG5cdFx0ICogdGhhdCBtYXkgYmUgbG9jYXRlZCBpbiB0aGlzIHNldCBpcyB0aGlzIFN0YXRlbWVudCBvYmplY3QgaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGNydWZ0T2JqZWN0czogUmVhZG9ubHlTZXQ8U3RhdGVtZW50IHwgU3BhbiB8IEluZml4U3Bhbj47XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgbGluZSBudW1iZXIgb2YgdGhpcyBzdGF0ZW1lbnQgaW4gaXQncyBjb250YWluaW5nXG5cdFx0ICogZG9jdW1lbnQsIG9yIC0xIGlmIHRoZSBzdGF0ZW1lbnQgaXMgZGlzcG9zZWQgYW5kL29yIGlzIG5vdFxuXHRcdCAqIGluIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRnZXQgaW5kZXgoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmlzRGlzcG9zZWQpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudCA/XG5cdFx0XHRcdHRoaXMuZG9jdW1lbnQuZ2V0TGluZU51bWJlcih0aGlzKSA6XG5cdFx0XHRcdC0xO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IG9mIHNwYW5zIGluIHRoYXQgcmVwcmVzZW50IHRoZSBkZWNsYXJhdGlvbnNcblx0XHQgKiBvZiB0aGlzIHN0YXRlbWVudCwgZXhjbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZFxuXHRcdCAqIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRnZXQgZGVjbGFyYXRpb25zKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jcnVmdE9iamVjdHMuc2l6ZSA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWxsRGVjbGFyYXRpb25zO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBvdXQ6IFNwYW5bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgdGhpcy5hbGxEZWNsYXJhdGlvbnMpXG5cdFx0XHRcdGlmICghdGhpcy5jcnVmdE9iamVjdHMuaGFzKHNwYW4pKVxuXHRcdFx0XHRcdG91dC5wdXNoKHNwYW4pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHNwYW5zIHRoYXQgcmVwcmVzZW50IHRoZSBkZWNsYXJhdGlvbnNcblx0XHQgKiBvZiB0aGlzIHN0YXRlbWVudCwgaW5jbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZFxuXHRcdCAqIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBhbGxEZWNsYXJhdGlvbnM6IHJlYWRvbmx5IFNwYW5bXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgbGlzdCBvZiBhbGwgaW5maXhlcyBkZWZpbmVkIGluIHRoZSBwYXR0ZXJuIG9mIHRoaXMgc3RhdGVtZW50LlxuXHRcdCAqL1xuXHRcdGdldCBpbmZpeFNwYW5zKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW5maXhTcGFucztcblx0XHR9XG5cdFx0cHJpdmF0ZSBfaW5maXhTcGFuczogcmVhZG9ubHkgSW5maXhTcGFuW10gPSBPYmplY3QuZnJlZXplKFtdKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IG9mIHNwYW5zIGluIHRoYXQgcmVwcmVzZW50IHRoZSBhbm5vdGF0aW9uc1xuXHRcdCAqIG9mIHRoaXMgc3RhdGVtZW50LCBmcm9tIGxlZnQgdG8gcmlnaHQsIGV4Y2x1ZGluZyB0aG9zZSB0aGF0XG5cdFx0ICogaGF2ZSBiZWVuIG1hcmtlZCBhcyBvYmplY3QtbGV2ZWwgY3J1ZnQuXG5cdFx0ICovXG5cdFx0Z2V0IGFubm90YXRpb25zKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jcnVmdE9iamVjdHMuc2l6ZSA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWxsQW5ub3RhdGlvbnM7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dDogU3BhbltdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbEFubm90YXRpb25zKVxuXHRcdFx0XHRpZiAoIXRoaXMuY3J1ZnRPYmplY3RzLmhhcyhzcGFuKSlcblx0XHRcdFx0XHRvdXQucHVzaChzcGFuKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob3V0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBhcnJheSBvZiBzcGFucyB0aGF0IHJlcHJlc2VudCB0aGUgYW5ub3RhdGlvbnNcblx0XHQgKiBvZiB0aGlzIHN0YXRlbWVudCwgaW5jbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZFxuXHRcdCAqIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBhbGxBbm5vdGF0aW9uczogcmVhZG9ubHkgU3BhbltdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgb2Ygc3BhbnMgaW4gdGhhdCByZXByZXNlbnQgYm90aCB0aGUgZGVjbGFyYXRpb25zXG5cdFx0ICogYW5kIHRoZSBhbm5vdGF0aW9ucyBvZiB0aGlzIHN0YXRlbWVudCwgZXhjbHVkaW5nIHRob3NlIHRoYXQgaGF2ZVxuXHRcdCAqIGJlZW4gbWFya2VkIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRnZXQgc3BhbnMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmlzQ3J1ZnQgP1xuXHRcdFx0XHRbXSA6XG5cdFx0XHRcdHRoaXMuZGVjbGFyYXRpb25zLmNvbmNhdCh0aGlzLmFubm90YXRpb25zKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0IGFsbFNwYW5zKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnMuY29uY2F0KHRoaXMuYW5ub3RhdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBqb2ludCBvcGVyYXRvciBleGlzdHNcblx0XHQgKiBpbiB0aGUgc3RhdGVtZW50LiBBIG5lZ2F0aXZlIG51bWJlciBpbmRpY2F0ZXMgdGhhdFxuXHRcdCAqIHRoZSBqb2ludCBvcGVyYXRvciBkb2VzIG5vdCBleGlzdCBpbiB0aGUgc3RhdGVtZW50LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGpvaW50UG9zaXRpb246IG51bWJlcjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHVucHJvY2Vzc2VkIHRleHQgY29udGVudCBvZiB0aGUgc3RhdGVtZW50LCBcblx0XHQgKiBhcyBpdCBhcHBlYXJzIGluIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzb3VyY2VUZXh0OiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBzdGF0ZW1lbnQncyB0ZXh0dWFsICpzdW0qLCB3aGljaCBpcyB0aGVcblx0XHQgKiByYXcgdGV4dCBvZiB0aGUgc3RhdGVtZW50J3MgYW5ub3RhdGlvbnMsIHdpdGggd2hpdGVzcGFjZVxuXHRcdCAqIHRyaW1tZWQuIFRoZSBzdW0gaXMgc3VpdGFibGUgYXMgYW4gaW5wdXQgdG8gYSB0b3RhbFxuXHRcdCAqIHBhdHRlcm4uXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgc3VtOiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGVcblx0XHQgKiBzdGF0ZW1lbnQgY29udGFpbnMgYSBkZWNsYXJhdGlvbiBvZiBhIHBhdHRlcm4uXG5cdFx0ICovXG5cdFx0Z2V0IGhhc1BhdHRlcm4oKVxuXHRcdHtcblx0XHRcdGNvbnN0IGQgPSB0aGlzLmFsbERlY2xhcmF0aW9ucztcblx0XHRcdHJldHVybiBkLmxlbmd0aCA9PT0gMSAmJiBkWzBdLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBNYXJrcyB0aGUgc3RhdGVtZW50IGFzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdCdzIGNvbnRhaW5pbmcgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0ZGlzcG9zZSgpXG5cdFx0e1xuXHRcdFx0dGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBMaW5lRmxhZ3MuaXNEaXNwb3NlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGtpbmQgb2YgU3RhdGVtZW50UmVnaW9uIHRoYXQgZXhpc3RzXG5cdFx0ICogYXQgdGhlIGdpdmVuIGNoYXJhY3RlciBvZmZzZXQgd2l0aGluIHRoZSBTdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0UmVnaW9uKG9mZnNldDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmlzQ29tbWVudCB8fCBvZmZzZXQgPCB0aGlzLmluZGVudCB8fCB0aGlzLmlzQ3J1ZnQpXG5cdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRSZWdpb24udm9pZDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNXaGl0ZXNwYWNlKVxuXHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50UmVnaW9uLndoaXRlc3BhY2U7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmhhc1BhdHRlcm4pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGJuZCA9IHRoaXMuYWxsRGVjbGFyYXRpb25zWzBdLmJvdW5kYXJ5O1xuXHRcdFx0XHRpZiAob2Zmc2V0ID49IGJuZC5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gYm5kLm9mZnNldEVuZClcblx0XHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50UmVnaW9uLnBhdHRlcm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChvZmZzZXQgPD0gdGhpcy5qb2ludFBvc2l0aW9uIHx8IHRoaXMuam9pbnRQb3NpdGlvbiA8IDApXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbERlY2xhcmF0aW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGJuZCA9IHNwYW4uYm91bmRhcnk7XG5cdFx0XHRcdFx0aWYgKG9mZnNldCA+PSBibmQub2Zmc2V0U3RhcnQgJiYgb2Zmc2V0IDw9IGJuZC5vZmZzZXRFbmQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50UmVnaW9uLmRlY2xhcmF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gU3RhdGVtZW50UmVnaW9uLmRlY2xhcmF0aW9uVm9pZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuYWxsQW5ub3RhdGlvbnMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGJuZCA9IHNwYW4uYm91bmRhcnk7XG5cdFx0XHRcdGlmIChvZmZzZXQgPj0gYm5kLm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBibmQub2Zmc2V0RW5kKVxuXHRcdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRSZWdpb24uYW5ub3RhdGlvbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFN0YXRlbWVudFJlZ2lvbi5hbm5vdGF0aW9uVm9pZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0U3ViamVjdChvZmZzZXQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXREZWNsYXJhdGlvbihvZmZzZXQpIHx8IHRoaXMuZ2V0QW5ub3RhdGlvbihvZmZzZXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHNwYW4gdG8gdGhlIGRlY2xhcmF0aW9uIHN1YmplY3QgYXQgdGhlIFxuXHRcdCAqIHNwZWNpZmllZCBvZmZzZXQsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZSB3YXMgZm91bmQuXG5cdFx0ICovXG5cdFx0Z2V0RGVjbGFyYXRpb24ob2Zmc2V0OiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuZGVjbGFyYXRpb25zKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBibmQgPSBzcGFuLmJvdW5kYXJ5O1xuXHRcdFx0XHRpZiAob2Zmc2V0ID49IGJuZC5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gYm5kLm9mZnNldEVuZClcblx0XHRcdFx0XHRyZXR1cm4gc3Bhbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3BhbiB0byB0aGUgYW5ub3RhdGlvbiBzdWJqZWN0IGF0IHRoZSBcblx0XHQgKiBzcGVjaWZpZWQgb2Zmc2V0LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUgd2FzIGZvdW5kLlxuXHRcdCAqL1xuXHRcdGdldEFubm90YXRpb24ob2Zmc2V0OiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGJuZCA9IHNwYW4uYm91bmRhcnk7XG5cdFx0XHRcdGlmIChvZmZzZXQgPj0gYm5kLm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBibmQub2Zmc2V0RW5kKVxuXHRcdFx0XHRcdHJldHVybiBzcGFuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgaW5uZXIgY29tbWVudCB0ZXh0IG9mXG5cdFx0ICogdGhpcyBzdGF0ZW1lbnQsIGV4Y2x1ZGluZyB0aGUgY29tbWVudCBzeW50YXggdG9rZW4uXG5cdFx0ICogSWYgdGhlIHN0YXRlbWVudCBpc24ndCBhIGNvbW1lbnQsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRnZXRDb21tZW50VGV4dCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNDb21tZW50ID9cblx0XHRcdFx0dGhpcy5zb3VyY2VUZXh0LnNsaWNlKHRoaXMuaW5kZW50ICsgU3ludGF4LmNvbW1lbnQubGVuZ3RoKS50cmltKCkgOlxuXHRcdFx0XHRcIlwiO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGUgc3RhdGVtZW50IHRvIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhpbmNsdWRlSW5kZW50ID0gZmFsc2UpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc2VyaWFsaXplU3BhbnMgPSAoXG5cdFx0XHRcdHNwYW5zOiByZWFkb25seSBTcGFuW10sXG5cdFx0XHRcdGVzY1N0eWxlOiBJZGVudGlmaWVyRXNjYXBlS2luZCkgPT5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHNwYW5zXG5cdFx0XHRcdFx0LmZpbHRlcihzcCA9PiAhKHNwLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBBbm9uKSlcblx0XHRcdFx0XHQubWFwKHNwID0+IFN1YmplY3RTZXJpYWxpemVyLmZvckV4dGVybmFsKHNwLCBlc2NTdHlsZSkpXG5cdFx0XHRcdFx0LmpvaW4oU3ludGF4LmNvbWJpbmF0b3IgKyBTeW50YXguc3BhY2UpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5kZW50ID0gaW5jbHVkZUluZGVudCA/IFN5bnRheC50YWIucmVwZWF0KHRoaXMuaW5kZW50KSA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzQ3J1ZnQpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQgKyBcIihjcnVmdClcIjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNXaGl0ZXNwYWNlKVxuXHRcdFx0XHRyZXR1cm4gaW5kZW50O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc1ZhY3VvdXMpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQgKyBTeW50YXguam9pbnQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlY2xzID0gc2VyaWFsaXplU3BhbnModGhpcy5hbGxEZWNsYXJhdGlvbnMsIElkZW50aWZpZXJFc2NhcGVLaW5kLmRlY2xhcmF0aW9uKTtcblx0XHRcdGNvbnN0IGFubm9zID0gc2VyaWFsaXplU3BhbnModGhpcy5hbGxBbm5vdGF0aW9ucywgSWRlbnRpZmllckVzY2FwZUtpbmQuYW5ub3RhdGlvbik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGpvaW50ID0gYW5ub3MubGVuZ3RoID4gMCB8fCB0aGlzLmlzUmVmcmVzaCA/IFN5bnRheC5qb2ludCA6IFwiXCI7XG5cdFx0XHRjb25zdCBqb2ludEwgPSBkZWNscy5sZW5ndGggPiAwICYmIGpvaW50ICE9PSBcIlwiID8gU3ludGF4LnNwYWNlIDogXCJcIjtcblx0XHRcdGNvbnN0IGpvaW50UiA9IGFubm9zLmxlbmd0aCA+IDAgPyBTeW50YXguc3BhY2UgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gaW5kZW50ICsgZGVjbHMgKyBqb2ludEwgKyBqb2ludCArIGpvaW50UiArIGFubm9zO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIERlZmluZXMgdGhlIGFyZWFzIG9mIGEgc3RhdGVtZW50IHRoYXQgYXJlIHNpZ25pZmljYW50bHlcblx0ICogZGlmZmVyZW50IHdoZW4gcGVyZm9ybWluZyBpbnNwZWN0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGVudW0gU3RhdGVtZW50UmVnaW9uXG5cdHtcblx0XHQvKipcblx0XHQgKiBSZWZlcnMgdG8gdGhlIGFyZWEgd2l0aGluIGEgY29tbWVudCBzdGF0ZW1lbnQsXG5cdFx0ICogb3IgdGhlIHdoaXRlc3BhY2UgcHJlY2VlZGluZyBhIG5vbi1uby1vcC5cblx0XHQgKi9cblx0XHR2b2lkLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlZmVycyB0byB0aGUgYXJlYSBpbiB0aGUgaW5kZW50YXRpb24gYXJlYS5cblx0XHQgKi9cblx0XHR3aGl0ZXNwYWNlLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlZmVycyB0byB0aGUgXG5cdFx0ICovXG5cdFx0cGF0dGVybixcblx0XHRcblx0XHQvKiogKi9cblx0XHRkZWNsYXJhdGlvbixcblx0XHRcblx0XHQvKiogKi9cblx0XHRhbm5vdGF0aW9uLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGRlY2xhcmF0aW9uVm9pZCxcblx0XHRcblx0XHQvKiogKi9cblx0XHRhbm5vdGF0aW9uVm9pZFxuXHR9XG5cblxuXHQvKipcblx0ICogWWllbGRzIGZhdWx0cyBvbiBpbmZpeCBzcGFucyBpbiB0aGUgY2FzZSB3aGVuIGFuIGlkZW50aWZpZXJcblx0ICogaGFzIGJlZW4gcmUtZGVjbGFyZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lIGluZml4LlxuXHQgKi9cblx0ZnVuY3Rpb24gKmRlZHVwSW5maXhTdWJqZWN0cyhzaWRlOiBJbmZpeFNwYW5bXSlcblx0e1xuXHRcdGlmIChzaWRlLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblx0XHRcblx0XHRjb25zdCBzdWJqZWN0czogc3RyaW5nW10gPSBbXTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IG5meFNwYW4gb2Ygc2lkZSlcblx0XHR7XG5cdFx0XHRjb25zdCBzdWJUZXh0ID0gbmZ4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAoc3ViamVjdHMuaW5jbHVkZXMoc3ViVGV4dCkpXG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuSW5maXhIYXNEdXBsaWNhdGVJZGVudGlmaWVyLCBuZnhTcGFuKTtcblx0XHRcdH1cblx0XHRcdGVsc2Ugc3ViamVjdHMucHVzaChzdWJUZXh0KTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBZaWVsZHMgZmF1bHRzIG9uIGluZml4IHNwYW5zIGluIHRoZSBjYXNlIHdoZW4gYW4gaWRlbnRpZmllclxuXHQgKiBoYXMgYmVlbiByZS1kZWNsYXJlZCBtdWx0aXBsZSB0aW1lcyBhY3Jvc3MgdGhlIGluZml4ZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiAqZGVkdXBJbmZpeGVzQWNyb3NzSW5maXhlcyhcblx0XHRzcGFuOiBTcGFuLFxuXHRcdGluZml4Rm46IChuZng6IEluZml4KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPEluZml4U3Bhbj4pXG5cdHtcblx0XHRjb25zdCBpZGVudGlmaWVyczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdGZvciAoY29uc3QgaW5maXggb2Ygc3Bhbi5pbmZpeGVzKVxuXHRcdHtcblx0XHRcdGNvbnN0IGluZml4U3BhbnMgPSBBcnJheS5mcm9tKGluZml4Rm4oaW5maXgpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgaW5maXhTcGFucylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdGV4dCA9IGluZml4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGlmIChpZGVudGlmaWVycy5pbmNsdWRlcyh0ZXh0KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpZWxkIGluZml4U3Bhbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlkZW50aWZpZXJzLnB1c2godGV4dCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogWWllbGRzIHdoZW4gc3VjY2Vzc2l2ZSBlcXVpdmFsZW50IGluc3RhbmNlcyBhcmUgZGlzY292ZXJlZFxuXHQgKiBpbiB0aGUgc3BlY2lmaWVkIGl0ZXJhdG9yLlxuXHQgKi9cblx0ZnVuY3Rpb24gKmRlZHVwPFQ+KFxuXHRcdGl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+LFxuXHRcdGVxdWFsaXR5Rm46IChhOiBULCBiOiBUKSA9PiBib29sZWFuKVxuXHR7XG5cdFx0Y29uc3QgeWllbGRlZDogVFtdID0gW107XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIGl0ZXJhdG9yKVxuXHRcdHtcblx0XHRcdGlmICh5aWVsZGVkLmluY2x1ZGVzKGl0ZW0pKVxuXHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR5aWVsZGVkLnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogUGVyZm9ybXMgYSBxdWljayBhbmQgZGlydHkgY2hlY2sgdG8gc2VlIGlmIHRoZSBpbmZpeCBpcyByZWZlcmVuY2luZ1xuXHQgKiBhIGxpc3QsIGJ5IGxvb2tpbmcgdG8gc2VlIGlmIGl0IGhhcyB0aGUgbGlzdCBvcGVyYXRvci4gQSBmdWxsIGNoZWNrIG5lZWRzXG5cdCAqIHRvIHBlcmZvcm0gdHlwZSBpbnNwZWN0aW9uIHRvIHNlZSBpZiBhbnkgb2YgdGhlIHR5cGVzIHRoYXQgY29ycmVzcG9uZFxuXHQgKiB0byB0aGUgaWRlbnRpZmllcnMgc3BlY2lmaWVkIGFyZSBhY3R1YWxseSBsaXN0cy5cblx0ICovXG5cdGZ1bmN0aW9uICpleHBlZGllbnRMaXN0Q2hlY2soc2lkZTogSW5maXhTcGFuW10pXG5cdHtcblx0XHRpZiAoc2lkZS5sZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBuZnhTcGFuIG9mIHNpZGUpXG5cdFx0XHRpZiAobmZ4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LmlzTGlzdClcblx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5JbmZpeFVzaW5nTGlzdE9wZXJhdG9yLCBuZnhTcGFuKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFBhdHRlcm5cblx0e1xuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHVuaXRzOiByZWFkb25seSAoUmVnZXhVbml0IHwgSW5maXgpW10sXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoZSBwYXR0ZXJuIGlzIGNvbnNpZGVyZWQgdG8gYmUgXCJUb3RhbFwiXG5cdFx0XHQgKiBvciBcIlBhcnRpYWxcIi4gVG90YWwgcGF0dGVybnMgbXVzdCBtYXRjaCBhbiBlbnRpcmUgYW5ub3RhdGlvblxuXHRcdFx0ICogc2V0ICh0aGUgZW50aXJlIHN0cmlwIG9mIGNvbnRlbnQgdG8gdGhlIHJpZ2h0IG9mIGEgam9pbnQsIGFmdGVyXG5cdFx0XHQgKiBiZWluZyB0cmltbWVkKS4gUGFydGlhbCBwYXR0ZXJucyBtYXRjaCBpbmRpdmlkdWFsbHkgXG5cdFx0XHQgKiBzcGVjaWZpZWQgc3ViamVjdHMgKHNlcGFyYXRlZCBieSBjb21tYXMpLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBpc1RvdGFsOiBib29sZWFuLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgYSBoYXNoIHdoaWNoIGlzIGNvbXB1dGVkIGZyb20gdGhlIHNldCBvZlxuXHRcdFx0ICogYW5ub3RhdGlvbnMgc3BlY2lmaWVkIHRvIHRoZSByaWdodCBvZiB0aGUgcGF0dGVybi5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgaGFzaDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHRoaXMuY29tcGlsZWRSZWdFeHAgPSBQYXR0ZXJuUHJlY29tcGlsZXIuZXhlYyh0aGlzKTtcblx0XHRcdHRoaXMuaXNWYWxpZCA9IHRoaXMuY29tcGlsZWRSZWdFeHAgaW5zdGFuY2VvZiBSZWdFeHA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoZSBpbnRlcm5hbCByZWd1bGFyIGV4cHJlc3Npb25cblx0XHQgKiB3YXMgY29tcGlsZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlzVmFsaWQ6IGJvb2xlYW47XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlbHkgZW51bWVyYXRlcyB0aHJvdWdoIHRoaXMgUGF0dGVybidzIHVuaXQgc3RydWN0dXJlLlxuXHRcdCAqL1xuXHRcdCplYWNoVW5pdCgpXG5cdFx0e1xuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2UodW5pdHM6IHJlYWRvbmx5IChSZWdleFVuaXQgfCBJbmZpeClbXSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB1bml0IG9mIHVuaXRzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWllbGQgdW5pdDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JvdXApXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHVuaXRDYXNlIG9mIHVuaXQuY2FzZXMpXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2UodW5pdENhc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHlpZWxkICpyZWN1cnNlKHRoaXMudW5pdHMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlclxuXHRcdCAqIHRoaXMgUGF0dGVybiBoYXMgYXQgbGVhc3Qgb25lIGluZml4LCBvZiBhbnkgdHlwZS5cblx0XHQgKi9cblx0XHRoYXNJbmZpeGVzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy51bml0cy5zb21lKHUgPT4gdSBpbnN0YW5jZW9mIEluZml4KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5maXhlcyBvZiB0aGVcblx0XHQgKiBzcGVjaWZpZWQgdHlwZSB0aGF0IGFyZSBkZWZpbmVkIGluIHRoaXMgUGF0dGVybi5cblx0XHQgKiBJZiB0aGUgYXJndW1lbnQgaXMgb21pdHRlZCwgYWxsIGluZml4ZXMgb2YgYW55IHR5cGVcblx0XHQgKiBkZWZpbmVkIG9uIHRoaXMgUGF0dGVybiBhcmUgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0Z2V0SW5maXhlcyh0eXBlID0gSW5maXhGbGFncy5ub25lKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnVuaXRzXG5cdFx0XHRcdC5maWx0ZXIoKHUpOiB1IGlzIEluZml4ID0+IHUgaW5zdGFuY2VvZiBJbmZpeClcblx0XHRcdFx0LmZpbHRlcihuZnggPT4gKG5meC5mbGFncyAmIHR5cGUpID09PSB0eXBlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgYW4gXCJleHBlZGllbnRcIiB0ZXN0IHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZVxuXHRcdCAqIHNwZWNpZmllZCBpbnB1dCBoYXMgYSBjaGFuY2Ugb2YgYmVpbmcgbWF0Y2hlZCBieSB0aGlzIHBhdHRlcm4uXG5cdFx0ICogVGhlIGNoZWNrIGlzIGNvbnNpZGVyZWQgZXhwZWRpZW50LCByYXRoZXIgdGhhbiB0aG9yb3VnaCxcblx0XHQgKiBiZWNhdXNlIGFueSBpbmZpeGVzIHRoYXQgZXhpc3QgaW4gdGhpcyBwYXR0ZXJuIGFyZSByZXBsYWNlZFxuXHRcdCAqIHdpdGggXCJjYXRjaCBhbGxcIiByZWd1bGFyIGV4cHJlc3Npb24gc2VxdWVuY2UsIHJhdGhlciB0aGFuXG5cdFx0ICogZW1iZWRkaW5nIHRoZSBwYXR0ZXJuIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgaW5maXguXG5cdFx0ICovXG5cdFx0dGVzdChpbnB1dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJlZ0V4cCA9IHRoaXMuY29tcGlsZWRSZWdFeHA7XG5cdFx0XHRpZiAocmVnRXhwID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGlucHV0VHJpbW1lZCA9IGlucHV0LnRyaW0oKTtcblx0XHRcdGlmIChpbnB1dFRyaW1tZWQgPT09IFwiXCIpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlZ0V4cC50ZXN0KGlucHV0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXhlY3V0ZXMgdGhlIHBhdHRlcm4gKGxpa2UgYSBmdW5jdGlvbikgdXNpbmcgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0cmluZyBhcyB0aGUgaW5wdXQuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBSZWFkb25seU1hcCB3aG9zZSBrZXlzIGFsaWduIHdpdGggdGhlIGluZml4ZXNcblx0XHQgKiBjb250YWluZWQgaW4gdGhpcyBQYXR0ZXJuLCBhbmQgd2hvc2UgdmFsdWVzIGFyZSBzdHJpbmdzIHRoYXRcblx0XHQgKiBhcmUgdGhlIGV4dHJhY3RlZCBcImlucHV0c1wiLCBmb3VuZCBpbiB0aGUgcGxhY2Ugb2YgZWFjaCBpbmZpeC4gXG5cdFx0ICogSWYgdGhpcyBQYXR0ZXJuIGhhcyBubyBpbmZpeGVzLCBhbiBlbXB0eSBtYXAgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0ZXhlYyhwYXR0ZXJuUGFyYW1ldGVyOiBzdHJpbmcpOiBSZWFkb25seU1hcDxJbmZpeCwgc3RyaW5nPlxuXHRcdHtcblx0XHRcdGNvbnN0IHJlZ0V4cCA9IHRoaXMuY29tcGlsZWRSZWdFeHA7XG5cdFx0XHRpZiAocmVnRXhwID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gbmV3IE1hcCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByZXN1bHQgPSBuZXcgTWFwPEluZml4LCBzdHJpbmc+KCk7XG5cdFx0XHRjb25zdCBpbmZpeGVzID0gdGhpcy5nZXRJbmZpeGVzKCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmdldEluZml4ZXMoKS5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGluZml4Q2FwdHVyZUdyb3VwSW5kZXhlcyA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBpZHhBcnJheTogbnVtYmVyW10gPSBbXTtcblx0XHRcdFx0bGV0IGlkeCA9IDA7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHVuaXQgb2YgdGhpcy5lYWNoVW5pdCgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBJbmZpeClcblx0XHRcdFx0XHRcdGlkeEFycmF5LnB1c2goKytpZHgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcm91cClcblx0XHRcdFx0XHRcdGlkeCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLy9NYWtlIHN1cmUgdGhlIGFib3ZlIHByb2R1Y2VzIHRoZSBzYW1lIGJlaGF2aW9yIGJlZm9yZSBkZWxldGluZ1xuXHRcdFx0XHQvLy9jb25zdCByZWN1cnNlVW5pdHMgPSAodW5pdHM6IHJlYWRvbmx5IChSZWdleFVuaXQgfCBJbmZpeD4pW10pID0+XG5cdFx0XHRcdC8vL3tcblx0XHRcdFx0Ly8vXHRmb3IgKGNvbnN0IHVuaXQgb2YgdW5pdHMpXG5cdFx0XHRcdC8vL1x0e1xuXHRcdFx0XHQvLy9cdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBJbmZpeClcblx0XHRcdFx0Ly8vXHRcdHtcblx0XHRcdFx0Ly8vXHRcdFx0aWR4QXJyYXkucHVzaCgrK2lkeCk7XG5cdFx0XHRcdC8vL1x0XHR9XG5cdFx0XHRcdC8vL1x0XHRlbHNlIGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcm91cClcblx0XHRcdFx0Ly8vXHRcdHtcblx0XHRcdFx0Ly8vXHRcdFx0KytpZHg7XG5cdFx0XHRcdC8vL1x0XHRcdGZvciAoY29uc3QgdW5pdENhc2Ugb2YgdW5pdC5jYXNlcylcblx0XHRcdFx0Ly8vXHRcdFx0XHRyZWN1cnNlVW5pdHModW5pdENhc2UpO1xuXHRcdFx0XHQvLy9cdFx0fVxuXHRcdFx0XHQvLy9cdH1cblx0XHRcdFx0Ly8vfVxuXHRcdFx0XHQvLy9yZWN1cnNlVW5pdHModGhpcy51bml0cyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gaWR4QXJyYXk7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByZWcgPSBuZXcgUmVnRXhwKHJlZ0V4cC5zb3VyY2UsIHJlZ0V4cC5mbGFncyk7XG5cdFx0XHRjb25zdCBtYXRjaGVzID0gcmVnLmV4ZWMocGF0dGVyblBhcmFtZXRlcik7XG5cdFx0XHRcblx0XHRcdGlmIChtYXRjaGVzID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtpZHgsIGluZml4XSBvZiBpbmZpeGVzLmVudHJpZXMoKSlcblx0XHRcdFx0cmVzdWx0LnNldChpbmZpeCwgbWF0Y2hlc1tpbmZpeENhcHR1cmVHcm91cEluZGV4ZXNbaWR4XV0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGNvbXBpbGVkUmVnRXhwOiBSZWdFeHAgfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIFBhdHRlcm4gdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdFx0ICogKE5vdGUgdGhhdCB0aGUgc2VyaWFsaXplZCBwYXR0ZXJuIGNhbm5vdCBiZSB1c2VkXG5cdFx0ICogYXMgYSBwYXJhbWV0ZXIgdG8gYSBKYXZhU2NyaXB0IFJlZ0V4cCBvYmplY3QuKVxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBpbmNsdWRlSGFzaFByZWZpeCBJZiB0cnVlLCB0aGUgUGF0dGVybidzIGhhc2hcblx0XHQgKiBwcmVmaXggd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIHNlcmlhbGl6ZWQgcmVzdWx0LlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKGluY2x1ZGVIYXNoUHJlZml4PzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRjb25zdCBwcmVmaXggPSBpbmNsdWRlSGFzaFByZWZpeCA/IGVzY2FwZSh0aGlzLmhhc2gpIDogXCJcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVsaW0gPSBSZWdleFN5bnRheERlbGltaXRlci5tYWluLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gZGVsaW0gKyBwcmVmaXggK1xuXHRcdFx0XHR0aGlzLnVuaXRzLm1hcCh1ID0+IHUudG9TdHJpbmcoKSkuam9pbihcIlwiKSArIFxuXHRcdFx0XHQodGhpcy5pc1RvdGFsID8gZGVsaW0gOiBcIlwiKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKiAqL1xuXHRleHBvcnQgY2xhc3MgUGF0dGVyblByZWNvbXBpbGVyXG5cdHtcblx0XHQvKipcblx0XHQgKiBDb21waWxlcyB0aGUgc3BlY2lmaWVkIHBhdHRlcm4gaW50byBhIEpTLW5hdGl2ZVxuXHRcdCAqIFJlZ0V4cCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBleGVjdXRlIHJlZ3VsYXJcblx0XHQgKiBleHByZXNzaW9uIHByZS1tYXRjaGluZyAoaS5lLiBjaGVja3MgdGhhdCBlc3NlbnRpYWxseVxuXHRcdCAqIGlnbm9yZSBhbnkgaW5maXhlcyB0aGF0IHRoZSBwYXR0ZXJuIG1heSBoYXZlKS5cblx0XHQgKi9cblx0XHRzdGF0aWMgZXhlYyhwYXR0ZXJuOiBQYXR0ZXJuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB1bml0IG9mIHBhdHRlcm4udW5pdHMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcmFwaGVtZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChNdXN0RXNjYXBlQ2hhcnMuaW5jbHVkZXModW5pdC5ncmFwaGVtZSkpXG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaChTeW50YXguZXNjYXBlQ2hhciArIHVuaXQuZ3JhcGhlbWUpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKHVuaXQuZ3JhcGhlbWUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh1bml0LnF1YW50aWZpZXIpXG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCh1bml0LnF1YW50aWZpZXIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodW5pdCBpbnN0YW5jZW9mIEluZml4KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goRXhwZWRpZW50SW5maXhQYXR0ZXJuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCh1bml0LnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJlc3VsdC51bnNoaWZ0KFwiXlwiKTtcblx0XHRcdHJlc3VsdC5wdXNoKFwiJFwiKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVnVGV4dCA9IHJlc3VsdC5qb2luKFwiXCIpO1xuXHRcdFx0XG5cdFx0XHR0cnlcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAocmVnVGV4dCwgXCJ1XCIpO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgbGlzdCBvZiBjaGFyYWN0ZXJzIHRoYXQgbXVzdCBiZSBlc2NhcGVkXG5cdCAqIGluIG9yZGVyIGZvciB0aGUgVHJ1dGggcmVndWxhciBleHByZXNzaW9uIGZsYXZvciB0b1xuXHQgKiBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGVuZ2luZSBidWlsZCBpbnRvIEphdmFTY3JpcHQuXG5cdCAqL1xuXHRjb25zdCBNdXN0RXNjYXBlQ2hhcnMgPSBbXCIkXCIsIFwiXlwiLCBcIntcIiwgXCJ9XCJdO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHBhdHRlcm4gdGhhdCBpcyBmZWQgaW50byBhIHBhdHRlcm4gaW5cblx0ICogcGxhY2Ugb2Ygd2hlcmUgaW5maXhlcyBhcmUsIGluIG9yZGVyIHRvIGJlIGFibGUgdG9cblx0ICogZG8gZWFybHkgdGVzdHMgb24gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRob3V0XG5cdCAqIGRvaW5nIGEgZnVsbCByZXNvbHV0aW9uIG9mIHRoZSB0eXBlcyB0aGF0IHRoZSBpbmZpeGVzXG5cdCAqIHJlZmVyZW5jZS4gVGhlIHBhdHRlcm4gZXNzZW50aWFsbHkgbWVhbnM6XG5cdCAqIFxuXHQgKiBcIk1hdGNoIG9uZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIsIG9yIGEgc2VyaWVzXG5cdCAqIG9mIGNoYXJhY3RlcnMsIHByb3ZpZGVkIHRoYXQgdGhlIHN0cmluZyBvZiBjaGFyYWN0ZXJzXG5cdCAqIGRvbid0IGJlZ2luIG9yIGVuZCB3aXRoIHdoaXRlc3BhY2UuXCJcblx0ICovXG5cdGNvbnN0IEV4cGVkaWVudEluZml4UGF0dGVybiA9IFwiKFxcXFxTKyhcXFxccytcXFxcUyspKilcIjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBbWJpZW50IHVuaWZpZXIgZm9yIGFsbCBQYXR0ZXJuVW5pdCBpbnN0YW5jZXNcblx0ICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWdleFVuaXRcblx0e1xuXHRcdGNvbnN0cnVjdG9yKHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpIHsgfVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZztcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlZ2V4U2V0IGV4dGVuZHMgUmVnZXhVbml0XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGtub3duczogcmVhZG9ubHkgUmVnZXhTeW50YXhLbm93blNldFtdLFxuXHRcdFx0cmVhZG9ubHkgcmFuZ2VzOiByZWFkb25seSBSZWdleENoYXJSYW5nZVtdLFxuXHRcdFx0cmVhZG9ubHkgdW5pY29kZUJsb2NrczogcmVhZG9ubHkgc3RyaW5nW10sXG5cdFx0XHRyZWFkb25seSBzaW5nbGVzOiByZWFkb25seSBzdHJpbmdbXSxcblx0XHRcdHJlYWRvbmx5IGlzTmVnYXRlZDogYm9vbGVhbixcblx0XHRcdHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIocXVhbnRpZmllcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBrTGVuID0gdGhpcy5rbm93bnMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgckxlbiA9IHRoaXMucmFuZ2VzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHVMZW4gPSB0aGlzLnVuaWNvZGVCbG9ja3MubGVuZ3RoO1xuXHRcdFx0Y29uc3QgY0xlbiA9IHRoaXMuc2luZ2xlcy5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNldFRleHQgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGtMZW4gPT09IDEgJiYgckxlbiArIHVMZW4gKyBjTGVuID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmtub3duc1swXS50b1N0cmluZygpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHVMZW4gPT09IDEgJiYga0xlbiArIHJMZW4gKyBjTGVuID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRTdGFydCArIFxuXHRcdFx0XHRcdFx0c2VyaWFsaXplVW5pY29kZUJsb2NrKHRoaXMudW5pY29kZUJsb2Nrc1swXSkgK1xuXHRcdFx0XHRcdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kXG5cdFx0XHRcdFx0XS5qb2luKFwiXCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNMZW4gPT09IDEgJiYga0xlbiArIHJMZW4gKyB1TGVuID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnNpbmdsZXNbMF07XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLnNldFN0YXJ0LFxuXHRcdFx0XHRcdC4uLnRoaXMua25vd25zLFxuXHRcdFx0XHRcdC4uLnRoaXMucmFuZ2VzLm1hcChyID0+IGVzYyhyLmZyb20pICsgXCItXCIgKyBlc2Moci50bykpLFxuXHRcdFx0XHRcdC4uLnRoaXMudW5pY29kZUJsb2Nrcy5tYXAoc2VyaWFsaXplVW5pY29kZUJsb2NrKSxcblx0XHRcdFx0XHQuLi5lc2NNYW55KHRoaXMuc2luZ2xlcyksXG5cdFx0XHRcdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kXG5cdFx0XHRcdF0uam9pbihcIlwiKTtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZXRUZXh0ICsgKHRoaXMucXVhbnRpZmllciA/IHRoaXMucXVhbnRpZmllci50b1N0cmluZygpIDogXCJcIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXHRcdHRvQWxwaGFiZXQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGFscGhhYmV0QnVpbGRlciA9IG5ldyBBbHBoYWJldEJ1aWxkZXIoKTtcblx0XHRcdGNvbnN0IGd0ID0gKGNoYXI6IHN0cmluZykgPT4gY2hhci5jaGFyQ29kZUF0KDApICsgMTtcblx0XHRcdGNvbnN0IGx0ID0gKGNoYXI6IHN0cmluZykgPT4gY2hhci5jaGFyQ29kZUF0KDApIC0gMTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBrbm93biBvZiB0aGlzLmtub3ducylcblx0XHRcdHtcblx0XHRcdFx0c3dpdGNoIChrbm93bilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5kaWdpdDpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoXCIwXCIsIFwiOVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5kaWdpdE5vbjpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMCwgbHQoXCIwXCIpKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoZ3QoXCI5XCIpLCBVbmljb2RlTWF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5hbHBoYW51bWVyaWM6XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKFwiMFwiLCBcIjlcIik7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKFwiQVwiLCBcIlpcIik7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKFwiYVwiLCBcInpcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4S25vd25TZXQuYWxwaGFudW1lcmljTm9uOlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgwLCBsdChcIjBcIikpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZChndChcIjlcIiksIGx0KFwiQVwiKSk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKGd0KFwiWlwiKSwgbHQoXCJhXCIpKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoZ3QoXCJ6XCIpLCBVbmljb2RlTWF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC53aGl0ZXNwYWNlOlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg5LCAxMyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDE2MCk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDU3NjApO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MTkyLCA4MjAyKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIzMik7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMzMpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjM5KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODI4Nyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDEyMjg4KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoNjUyNzkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheEtub3duU2V0LndoaXRlc3BhY2VOb246XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDAsIDgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgxNCwgMTU5KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMTYxLCA1NzU5KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoNTc2MSwgODE5MSk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMDMsIDgyMzEpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjMyKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIzMyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMzQsIDgyMzgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjQwLCA4Mjg2KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODI4OCwgMTIyODcpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgxMjI4OSwgNjUyNzgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg2NTI4MCwgVW5pY29kZU1heCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4S25vd25TZXQud2lsZDpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGRXaWxkKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzaW5nbGUgb2YgdGhpcy5zaW5nbGVzKVxuXHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKHNpbmdsZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBhbHBoYWJldEJ1aWxkZXIudG9BbHBoYWJldCh0aGlzLmlzTmVnYXRlZCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhDaGFyUmFuZ2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgZnJvbTogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgdG86IG51bWJlcilcblx0XHR7IH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlZ2V4R3JvdXAgZXh0ZW5kcyBSZWdleFVuaXRcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgY2FzZXM6IHJlYWRvbmx5IChyZWFkb25seSBSZWdleFVuaXRbXSlbXSxcblx0XHRcdHJlYWRvbmx5IHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIocXVhbnRpZmllcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jYXNlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdGFydCA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwU3RhcnQ7XG5cdFx0XHRjb25zdCBtaWQgPSB0aGlzLmNhc2VzXG5cdFx0XHRcdC5tYXAoY2EgPT4gY2EubWFwKHVuaXQgPT4gZXNjKHVuaXQudG9TdHJpbmcoKSkpLmpvaW4oXCJcIikpXG5cdFx0XHRcdC5qb2luKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBlbmQgPSBSZWdleFN5bnRheERlbGltaXRlci5ncm91cEVuZDtcblx0XHRcdGNvbnN0IHF1YW50ID0gdGhpcy5xdWFudGlmaWVyID8gdGhpcy5xdWFudGlmaWVyLnRvU3RyaW5nKCkgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc3RhcnQgKyBtaWQgKyBlbmQgKyBxdWFudDtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBIHBhdHRlcm4gXCJncmFwaGVtZVwiIGlzIGEgcGF0dGVybiB1bml0IGNsYXNzIHRoYXRcblx0ICogcmVwcmVzZW50czpcblx0ICogXG5cdCAqIGEpIEEgXCJMaXRlcmFsXCIsIHdoaWNoIGlzIGEgc2luZ2xlIHVuaWNvZGUtYXdhcmUgY2hhcmFjdGVyLFxuXHQgKiB3aXRoIHBvc3NpYmxlIHJlcHJlc2VudGF0aW9ucyBiZWluZyBhbiBhc2NpaSBjaGFyYWN0ZXIsXG5cdCAqIGEgdW5pY29kZSBjaGFyYWN0ZXIsIG9yIGFuIGFzY2lpIG9yIHVuaWNvZGUgZXNjYXBlXG5cdCAqIHNlcXVlbmNlLlxuXHQgKiBcblx0ICogb3IgYikgQSBcIlNwZWNpYWxcIiwgd2hpY2ggaXMgYSBzZXF1ZW5jZSB0aGF0IG1hdGNoZXNcblx0ICogc29tZXRoaW5nIG90aGVyIHRoYW4gdGhlIGNoYXJhY3RlciBzcGVjaWZpZWQsXG5cdCAqIHN1Y2ggYXMgLiBcXGIgXFxzXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhHcmFwaGVtZSBleHRlbmRzIFJlZ2V4VW5pdFxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBncmFwaGVtZTogc3RyaW5nLFxuXHRcdFx0cmVhZG9ubHkgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbClcblx0XHR7XG5cdFx0XHRzdXBlcihxdWFudGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHEgPSB0aGlzLnF1YW50aWZpZXI7XG5cdFx0XHRjb25zdCBxRXNjID0gcSA9PT0gbnVsbCA/IFwiXCIgOiBlc2MocS50b1N0cmluZygpKTtcblx0XHRcdGNvbnN0IGcgPSB0aGlzLmdyYXBoZW1lLnRvU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBlc2NhcGFibGVHcmFwaGVtZXMuaW5jbHVkZXMoZykgP1xuXHRcdFx0XHRcIlxcXFxcIiArIGcgKyBxRXNjIDpcblx0XHRcdFx0ZyArIHFFc2M7XG5cdFx0fVxuXHR9XG5cblx0LyoqICovXG5cdGNvbnN0IGVzY2FwYWJsZUdyYXBoZW1lczogc3RyaW5nW10gPSBbXG5cdFx0UmVnZXhTeW50YXhNaXNjLnN0YXIsXG5cdFx0UmVnZXhTeW50YXhNaXNjLnBsdXMsXG5cdFx0UmVnZXhTeW50YXhNaXNjLm5lZ2F0ZSxcblx0XHRSZWdleFN5bnRheE1pc2MucmVzdHJhaW5lZCxcblx0XHRSZWdleFN5bnRheERlbGltaXRlci5ncm91cFN0YXJ0LFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kLFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0U3RhcnQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kLFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJTdGFydCxcblx0XHRSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyRW5kXG5cdF07XG5cblx0LyoqXG5cdCAqIEEgUmVnZXggXCJTaWduXCIgcmVmZXJzIHRvIGFuIGVzY2FwZSBzZXF1ZW5jZSB0aGF0IHJlZmVyc1xuXHQgKiB0byBvbmUgb3RoZXIgY2hhcmFjdGVyLCBhcyBvcHBvc2VkIHRvIHRoYXQgY2hhcmFjdGVyXG5cdCAqIGJlaW5nIHdyaXR0ZW4gZGlyZWN0bHkgaW4gdGhlIHBhcnNlIHN0cmVhbS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBSZWdleFNpZ24gZXh0ZW5kcyBSZWdleFVuaXRcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgc2lnbjogUmVnZXhTeW50YXhTaWduLFxuXHRcdFx0cmVhZG9ubHkgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbClcblx0XHR7XG5cdFx0XHRzdXBlcihxdWFudGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHEgPSB0aGlzLnF1YW50aWZpZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5zaWduLnRvU3RyaW5nKCkgKyAocSA9PT0gbnVsbCA/IFwiXCIgOiBlc2MocS50b1N0cmluZygpKSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogQSBwYXR0ZXJuIHVuaXQgY2xhc3MgdGhhdCByZXByZXNlbnRzICssICosIFxuXHQgKiBhbmQgZXhwbGljaXQgcXVhbnRpZmllcnMgc3VjaCBhcyB7MSwyfS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBSZWdleFF1YW50aWZpZXJcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBxdWFudGlmaWVyLCBcblx0XHRcdCAqIG9yIHRoZSBmZXdlc3QgbnVtYmVyIG9mIGdyYXBoZW1lcyB0byBiZSBtYXRjaGVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBtaW46IG51bWJlciA9IDAsXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIHF1YW50aWZpZXIsIFxuXHRcdFx0ICogb3IgdGhlIG1vc3QgbnVtYmVyIG9mIGdyYXBoZW1lcyB0byBiZSBtYXRjaGVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBtYXg6IG51bWJlciA9IEluZmluaXR5LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGUgdGhlIHF1YW50aWZpZXIgaXMgcmVzdHJhaW5lZCxcblx0XHRcdCAqIGluIHRoYXQgaXQgbWF0Y2hlcyB0aGUgZmV3ZXN0IHBvc3NpYmxlIG51bWJlclxuXHRcdFx0ICogb2YgY2hhcmFjdGVycy5cblx0XHRcdCAqIFxuXHRcdFx0ICogKFNvbWUgcmVndWxhciBleHByZXNzaW9uIGZsYXZvdXJzIGF3a3dhcmRseVxuXHRcdFx0ICogcmVmZXIgdG8gdGhpcyBhcyBcIm5vbi1ncmVlZHlcIi4pXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHJlc3RyYWluZWQ6IGJvb2xlYW4pXG5cdFx0eyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydHMgdGhlIHJlZ2V4IHF1YW50aWZpZXIgdG8gYW4gb3B0aW1pemVkIHN0cmluZy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcnN0ID0gdGhpcy5yZXN0cmFpbmVkID8gUmVnZXhTeW50YXhNaXNjLnJlc3RyYWluZWQgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5taW4gPT09IDAgJiYgdGhpcy5tYXggPT09IEluZmluaXR5KVxuXHRcdFx0XHRyZXR1cm4gUmVnZXhTeW50YXhNaXNjLnN0YXIgKyByc3Q7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLm1pbiA9PT0gMSAmJiB0aGlzLm1heCA9PT0gSW5maW5pdHkpXG5cdFx0XHRcdHJldHVybiBSZWdleFN5bnRheE1pc2MucGx1cyArIHJzdDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubWluID09PSAwICYmIHRoaXMubWF4ID09PSAxKVxuXHRcdFx0XHRyZXR1cm4gUmVnZXhTeW50YXhNaXNjLnJlc3RyYWluZWQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHFzID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclN0YXJ0O1xuXHRcdFx0Y29uc3QgcXAgPSBSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyU2VwYXJhdG9yO1xuXHRcdFx0Y29uc3QgcWUgPSBSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyRW5kO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5taW4gPT09IHRoaXMubWF4ID9cblx0XHRcdFx0cXMgKyB0aGlzLm1pbiArIHFlIDpcblx0XHRcdFx0cXMgKyB0aGlzLm1pbiArIHFwICsgKHRoaXMubWF4ID09PSBJbmZpbml0eSA/IFwiXCIgOiB0aGlzLm1heC50b1N0cmluZygpKSArIHFlO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZG91YmxlIGVzY2FwZVxuXHQgKiBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgYmFja3NsYXNoLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXNjKG1heWJlQmFja3NsYXNoOiBzdHJpbmcgfCBudW1iZXIpXG5cdHtcblx0XHRpZiAobWF5YmVCYWNrc2xhc2ggPT09IDkyIHx8IG1heWJlQmFja3NsYXNoID09PSBcIlxcXFxcIilcblx0XHRcdHJldHVybiBcIlxcXFxcXFxcXCI7XG5cdFx0XG5cdFx0aWYgKHR5cGVvZiBtYXliZUJhY2tzbGFzaCA9PT0gXCJudW1iZXJcIilcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChtYXliZUJhY2tzbGFzaCk7XG5cdFx0XG5cdFx0cmV0dXJuIG1heWJlQmFja3NsYXNoO1xuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRmdW5jdGlvbiBlc2NNYW55KGFycmF5OiByZWFkb25seSAoc3RyaW5nIHwgbnVtYmVyKVtdKVxuXHR7XG5cdFx0cmV0dXJuIGFycmF5Lm1hcChlc2MpLmpvaW4oXCJcIik7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZVVuaWNvZGVCbG9jayhibG9ja05hbWU6IHN0cmluZylcblx0e1xuXHRcdGNvbnN0IGJsb2NrID0gVW5pY29kZUJsb2Nrcy5nZXQoYmxvY2tOYW1lLnRvTG93ZXJDYXNlKCkpOyBcblx0XHRpZiAoYmxvY2sgPT09IHVuZGVmaW5lZClcblx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcblx0XHRjb25zdCBybmcgPSBSZWdleFN5bnRheERlbGltaXRlci5yYW5nZTtcblx0XHRjb25zdCBmcm9tID0gYmxvY2tbMF0udG9TdHJpbmcoMTYpO1xuXHRcdGNvbnN0IHRvID0gYmxvY2tbMV0udG9TdHJpbmcoMTYpO1xuXHRcdHJldHVybiBgXFxcXHV7JHtmcm9tfX0ke3JuZ31cXFxcdXske3RvfX1gO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwb3J0aW9uIG9mIHRoZSBjb250ZW50IFxuXHQgKiB3aXRoaW4gYW4gSW5maXggdGhhdCBzcGFucyBhIHR5cGUgcmVmZXJlbmNlLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEluZml4XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBsZWZ0LW1vc3QgY2hhcmFjdGVyIHBvc2l0aW9uIG9mIHRoZSBJbmZpeFxuXHRcdFx0ICogKGJlZm9yZSB0aGUgZGVsaW1pdGVyKSwgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgc3RhdGVtZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBvZmZzZXRTdGFydDogbnVtYmVyLFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgbGVmdC1tb3N0IGNoYXJhY3RlciBwb3NpdGlvbiBvZiB0aGUgSW5maXhcblx0XHRcdCAqIChhZnRlciB0aGUgZGVsaW1pdGVyKSwgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgc3RhdGVtZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBvZmZzZXRFbmQ6IG51bWJlcixcblx0XHRcdFxuXHRcdFx0LyoqIFxuXHRcdFx0ICogU3RvcmVzIHRoZSBCb3VuZHMgb2JqZWN0IHRoYXQgbWFya3Mgb3V0IHRoZSBwb3NpdGlvbnNcblx0XHRcdCAqIG9mIHRoZSBpZGVudGlmaWVycyBpbiB0aGUgSW5maXggdGhhdCBhcmUgbG9jYXRlZCBiZWZvcmVcblx0XHRcdCAqIGFueSBKb2ludCBvcGVyYXRvci5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgbGhzOiBCb3VuZGFyeUdyb3VwPElkZW50aWZpZXI+LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgQm91bmRzIG9iamVjdCB0aGF0IG1hcmtzIG91dCB0aGUgcG9zaXRpb25zXG5cdFx0XHQgKiBvZiB0aGUgaWRlbnRpZmllcnMgaW4gdGhlIEluZml4IHRoYXQgYXJlIGxvY2F0ZWQgYWZ0ZXJcblx0XHRcdCAqIGFueSBKb2ludCBvcGVyYXRvci5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcmhzOiBCb3VuZGFyeUdyb3VwPElkZW50aWZpZXI+LFxuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdHJlYWRvbmx5IGZsYWdzOiBJbmZpeEZsYWdzKVxuXHRcdHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGlzIEluZml4IGlzIG9mIHRoZSBcInBhdHRlcm5cIiB2YXJpZXR5LlxuXHRcdCAqL1xuXHRcdGdldCBpc1BhdHRlcm4oKVxuXHRcdHtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIEluZml4RmxhZ3MucGF0dGVybikgPT09IEluZml4RmxhZ3MucGF0dGVybjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgSW5maXggaXMgb2YgdGhlIFwicG9ydGFiaWxpdHlcIiB2YXJpZXR5LlxuXHRcdCAqL1xuXHRcdGdldCBpc1BvcnRhYmlsaXR5KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBJbmZpeEZsYWdzLnBvcnRhYmlsaXR5KSA9PT0gSW5maXhGbGFncy5wb3J0YWJpbGl0eTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgSW5maXggaXMgb2YgdGhlIFwicG9wdWxhdGlvblwiIHZhcmlldHkuXG5cdFx0ICovXG5cdFx0Z2V0IGlzUG9wdWxhdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgSW5maXhGbGFncy5wb3B1bGF0aW9uKSA9PT0gSW5maXhGbGFncy5wb3B1bGF0aW9uO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBJbmZpeCBoYXMgdGhlIFwibm9taW5hbFwiIG9wdGlvbiBzZXQuXG5cdFx0ICovXG5cdFx0Z2V0IGlzTm9taW5hbCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgSW5maXhGbGFncy5ub21pbmFsKSA9PT0gSW5maXhGbGFncy5ub21pbmFsO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZGVsaW1MID1cblx0XHRcdFx0dGhpcy5pc1BhdHRlcm4gPyBJbmZpeFN5bnRheC5wYXR0ZXJuU3RhcnQgOlxuXHRcdFx0XHR0aGlzLmlzTm9taW5hbCA/IEluZml4U3ludGF4Lm5vbWluYWxTdGFydCA6XG5cdFx0XHRcdHRoaXMuaXNQb3J0YWJpbGl0eSA/IEluZml4U3ludGF4LnN0YXJ0ICsgU3ludGF4LnNwYWNlICsgU3ludGF4LmpvaW50ICsgU3ludGF4LnNwYWNlIDpcblx0XHRcdFx0SW5maXhTeW50YXguc3RhcnQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlbGltUiA9IFxuXHRcdFx0XHR0aGlzLmlzUGF0dGVybiA/IEluZml4U3ludGF4LnBhdHRlcm5FbmQgOlxuXHRcdFx0XHR0aGlzLmlzTm9taW5hbCA/IEluZml4U3ludGF4Lm5vbWluYWxFbmQgOlxuXHRcdFx0XHRJbmZpeFN5bnRheC5lbmQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGpvaW4gPSAoc3BhbnM6IEJvdW5kYXJ5R3JvdXA8SWRlbnRpZmllcj4pID0+XG5cdFx0XHRcdEFycmF5LmZyb20oc3BhbnMpXG5cdFx0XHRcdFx0Lm1hcChlbnRyeSA9PiBlbnRyeS5zdWJqZWN0KVxuXHRcdFx0XHRcdC5qb2luKFN5bnRheC5jb21iaW5hdG9yICsgU3ludGF4LnNwYWNlKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNQb3J0YWJpbGl0eSlcblx0XHRcdFx0cmV0dXJuIGpvaW4odGhpcy5yaHMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc1BhdHRlcm4pXG5cdFx0XHRcdHJldHVybiBqb2luKHRoaXMubGhzKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgam9pbnQgPSB0aGlzLnJocy5sZW5ndGggPiAwID9cblx0XHRcdFx0U3ludGF4LnNwYWNlICsgU3ludGF4LmpvaW50ICsgU3ludGF4LnNwYWNlIDpcblx0XHRcdFx0XCJcIjtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGRlbGltTCArIGpvaW4odGhpcy5saHMpICsgam9pbnQgKyBqb2luKHRoaXMucmhzKSArIGRlbGltUjtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBlbnVtIEluZml4RmxhZ3Ncblx0e1xuXHRcdG5vbmUgPSAwLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IHRoZSBqb2ludCB3YXMgc3BlY2lmaWVkIHdpdGhpblxuXHRcdCAqIHRoZSBpbmZpeC4gQ2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbmZpeFxuXHRcdCAqIGNvbnRhaW5zIHNvbWUgKGVycm9uZW91cykgc3ludGF4IHJlc2VtYmluZ1xuXHRcdCAqIGEgcmVmcmVzaCB0eXBlLCBlZyAtIC88VHlwZSA6ID4vXG5cdFx0ICovXG5cdFx0aGFzSm9pbnQgPSAxLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IHRoZSA8L1BhdHRlcm4vPiBzeW50YXggd2FzXG5cdFx0ICogdXNlZCB0byBlbWJlZCB0aGUgcGF0dGVybnMgYXNzb2NpYXRlZFxuXHRcdCAqIHdpdGggYSBzcGVjaWZpZWQgdHlwZS5cblx0XHQgKi9cblx0XHRwYXR0ZXJuID0gMixcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgaW5maXggaXMgb2YgdGhlIFwicG9ydGFiaWl0eVwiXG5cdFx0ICogdmFyaWV0eSwgdXNpbmcgdGhlIHN5bnRheCA8IDogVHlwZT5cblx0XHQgKi9cblx0XHRwb3J0YWJpbGl0eSA9IDQsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgdGhlIGluZml4IGlzIG9mIHRoZSBcInBvcHVhdGlvblwiXG5cdFx0ICogdmFyaWV0eSwgdXNpbmcgdGhlIHN5bnRheCA8RGVjbGFyYXRpb24gOiBBbm5vdGF0aW9uPlxuXHRcdCAqIG9yIDxEZWNsYXJhdGlvbj5cblx0XHQgKi9cblx0XHRwb3B1bGF0aW9uID0gOCxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgPDxEb3VibGU+PiBhbmdsZSBicmFja2V0XG5cdFx0ICogc3ludGF4IHdhcyB1c2VkIHRvIG9ubHkgbWF0Y2ggbmFtZWQgdHlwZXMsXG5cdFx0ICogcmF0aGVyIHRoYW4gYWxpYXNlcy5cblx0XHQgKi9cblx0XHRub21pbmFsID0gMTZcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2luZ2xlIHN1YmplY3QgaW4gYSBTdGF0ZW1lbnQuXG5cdCAqIENvbnN1bWVycyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgZXhwZWN0IFN1YmplY3Qgb2JqZWN0c1xuXHQgKiB0byBiZSBsb25nLWxpdmVkLCBhcyB0aGV5IGFyZSBkaXNjYXJkZWQgcmVndWxhcmx5IGFmdGVyIGVkaXRcblx0ICogdHJhbnNhY3Rpb25zIGNvbXBsZXRlLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIElkZW50aWZpZXJcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHRleHQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCBsaXN0VG9rID0gU3ludGF4Lmxpc3Q7XG5cdFx0XHRjb25zdCB0b2tMZW4gPSBsaXN0VG9rLmxlbmd0aDtcblx0XHRcdHRoaXMuaXNMaXN0ID0gdGV4dC5sZW5ndGggPiB0b2tMZW4gKyAxICYmIHRleHQuc2xpY2UoLXRva0xlbikgPT09IGxpc3RUb2s7XG5cdFx0XHR0aGlzLmZ1bGxOYW1lID0gdGV4dDtcblx0XHRcdHRoaXMudHlwZU5hbWUgPSB0aGlzLmlzTGlzdCA/IHRleHQuc2xpY2UoMCwgLXRva0xlbikgOiB0ZXh0O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBmdWxsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3ViamVjdCwgXG5cdFx0ICogYXMgaXQgYXBwZWFycyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZnVsbE5hbWU6IHN0cmluZztcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5hbWUgb2YgdGhlXG5cdFx0ICogdHlwZSB0byB3aGljaCB0aGUgc3ViamVjdCByZWZlcnMsIHdpdGhvdXQgYW55IExpc3Rcblx0XHQgKiBvcGVyYXRvciBzdWZmaXguXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdHlwZU5hbWU6IHN0cmluZztcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBpc0xpc3Q6IGJvb2xlYW47XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29udmVydHMgdGhpcyBTdWJqZWN0IHRvIGl0J3Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBcblx0XHQgKiBAcGFyYW0gZXNjYXBlIElmIHRydWUsIHByZXNlcnZlcyBhbnkgbmVjZXNzYXJ5XG5cdFx0ICogZXNjYXBpbmcgcmVxdWlyZWQgdG8gZW5zdXJlIHRoZSBpZGVudGlmaWVyIHN0cmluZ1xuXHRcdCAqIGlzIGluIGEgcGFyc2FibGUgZm9ybWF0LlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKGVzY2FwZSA9IElkZW50aWZpZXJFc2NhcGVLaW5kLm5vbmUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdmFsID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHN3aXRjaCAoZXNjYXBlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2FzZSBJZGVudGlmaWVyRXNjYXBlS2luZC5ub25lOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMudHlwZU5hbWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBJZGVudGlmaWVyRXNjYXBlS2luZC5kZWNsYXJhdGlvbjpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBSZWdleCBkZWxpbWl0ZXJzIGFyZSBlc2NhcGVkIGlmIGFuZCBvbmx5IGlmIFxuXHRcdFx0XHRcdFx0Ly8gdGhleSdyZSB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIGFuIElkZW50aWZpZXIuXG5cdFx0XHRcdFx0XHRjb25zdCBkbG1SZWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbik7XG5cdFx0XHRcdFx0XHRjb25zdCBqbnRSZWdTID0gbmV3IFJlZ0V4cChTeW50YXguam9pbnQgKyBTeW50YXguc3BhY2UpO1xuXHRcdFx0XHRcdFx0Y29uc3Qgam50UmVnVCA9IG5ldyBSZWdFeHAoU3ludGF4LmpvaW50ICsgU3ludGF4LnRhYik7XG5cdFx0XHRcdFx0XHRjb25zdCBjbWJSZWcgPSBuZXcgUmVnRXhwKFN5bnRheC5jb21iaW5hdG9yKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMudHlwZU5hbWVcblx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoZGxtUmVnLCBTeW50YXguZXNjYXBlQ2hhciArIFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW4pXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKGpudFJlZ1MsIFN5bnRheC5lc2NhcGVDaGFyICsgU3ludGF4LmpvaW50ICsgU3ludGF4LnNwYWNlKVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZShqbnRSZWdULCBTeW50YXguZXNjYXBlQ2hhciArIFN5bnRheC5qb2ludCArIFN5bnRheC50YWIpXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKGNtYlJlZywgU3ludGF4LmVzY2FwZUNoYXIgKyBTeW50YXguY29tYmluYXRvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgSWRlbnRpZmllckVzY2FwZUtpbmQuYW5ub3RhdGlvbjpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCByZWcgPSBuZXcgUmVnRXhwKFN5bnRheC5jb21iaW5hdG9yKTtcblx0XHRcdFx0XHRcdGNvbnN0IHJlcCA9IFN5bnRheC5lc2NhcGVDaGFyICsgU3ludGF4LmNvbWJpbmF0b3I7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy50eXBlTmFtZS5yZXBsYWNlKHJlZywgcmVwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB2YWwgKyAodGhpcy5pc0xpc3QgPyBTeW50YXgubGlzdCA6IFwiXCIpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgZGVzY3JpYmVzIHRoZSB2YXJpb3VzIHdheXNcblx0ICogdG8gaGFuZGxlIGVzY2FwaW5nIHdoZW4gc2VyaWFsaXppbmcgYW4gaWRlbnRpZmllci5cblx0ICogVGhpcyBlbnVtZXJhdGlvbiBpcyB1c2VkIHRvIGFkZHJlc3MgdGhlIGRpZmZlcmVuY2VzXG5cdCAqIGluIHRoZSB3YXkgaWRlbnRpZmllcnMgY2FuIGJlIHNlcmlhbGl6ZWQsIHdoaWNoIGNhbiBcblx0ICogZGVwZW5kIG9uIHdoZXRoZXIgdGhlIGlkZW50aWZpZXIgaXMgYSBkZWNsYXJhdGlvbiBvclxuXHQgKiBhbiBhbm5vdGF0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gSWRlbnRpZmllckVzY2FwZUtpbmRcblx0e1xuXHRcdG5vbmUgPSAwLFxuXHRcdGRlY2xhcmF0aW9uID0gMSxcblx0XHRhbm5vdGF0aW9uID0gMlxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiBhIHN0YXRlbWVudC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBTcGFuXG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBMb2dpY2FsIGNsb2NrIHZhbHVlIHVzZWQgdG8gbWFrZSBjaHJvbm9sb2dpY2FsIFxuXHRcdCAqIGNyZWF0aW9uLXRpbWUgY29tcGFyaXNvbnMgYmV0d2VlbiBTcGFucy5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzdGFtcCA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyBhIHJlZmVyZW5jZSB0byB0aGUgU3RhdGVtZW50IHRoYXQgY29udGFpbnMgdGhpcyBTcGFuLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzdGF0ZW1lbnQ6IFN0YXRlbWVudCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIHN1YmplY3QsIGFuZCB0aGUgbG9jYXRpb24gb2YgaXQgaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBib3VuZGFyeTogQm91bmRhcnk8U3ViamVjdD4pXG5cdFx0e1xuXHRcdFx0dGhpcy5uYW1lID0gXG5cdFx0XHRcdFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKGJvdW5kYXJ5KSArIFxuXHRcdFx0XHRgICgke2JvdW5kYXJ5Lm9mZnNldFN0YXJ0fSwgJHtib3VuZGFyeS5vZmZzZXRFbmR9KWA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFNwYW4sIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIEluZml4ZXMgc3RvcmVkIHdpdGhpbiB0aGlzIFNwYW4sIGluIHRoZSBjYXNlIHdoZW5cblx0XHQgKiB0aGUgU3BhbiBjb3JyZXNwb25kcyB0byBhIFBhdHRlcm4uIEluIG90aGVyIGNhc2VzLCBhbmRcblx0XHQgKiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRnZXQgaW5maXhlcygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2luZml4ZXMgfHwgKHRoaXMuX2luZml4ZXMgPSBPYmplY3QuZnJlZXplKCgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ib3VuZGFyeS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybiA/XG5cdFx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLmJvdW5kYXJ5LnN1YmplY3QuZ2V0SW5maXhlcygpKSA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9KSgpKSk7XG5cdFx0fVxuXHRcdHByaXZhdGUgX2luZml4ZXM6IHJlYWRvbmx5IEluZml4W10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHQqZWFjaERlY2xhcmF0aW9uRm9ySW5maXgoaW5maXg6IEluZml4KVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5pbmZpeGVzLmluY2x1ZGVzKGluZml4KSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRDYWxsKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHsgbGhzIH0gPSB0aGlzLnF1ZXJ5SW5maXhTcGFuVGFibGUoaW5maXgpO1xuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgbGhzKVxuXHRcdFx0XHR5aWVsZCBpbmZpeFNwYW47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoQW5ub3RhdGlvbkZvckluZml4KGluZml4OiBJbmZpeClcblx0XHR7XG5cdFx0XHRpZiAoIXRoaXMuaW5maXhlcy5pbmNsdWRlcyhpbmZpeCkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQ2FsbCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB7IHJocyB9ID0gdGhpcy5xdWVyeUluZml4U3BhblRhYmxlKGluZml4KTtcblx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIHJocylcblx0XHRcdFx0eWllbGQgaW5maXhTcGFuO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHF1ZXJ5SW5maXhTcGFuVGFibGUoaW5maXg6IEluZml4KVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmluZml4U3BhblRhYmxlLmdldChpbmZpeCkgfHwgKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxoczogSW5maXhTcGFuW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgcmhzOiBJbmZpeFNwYW5bXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBib3VuZGFyeSBvZiBpbmZpeC5saHMpXG5cdFx0XHRcdFx0bGhzLnB1c2gobmV3IEluZml4U3Bhbih0aGlzLCBpbmZpeCwgYm91bmRhcnkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgYm91bmRhcnkgb2YgaW5maXgucmhzKVxuXHRcdFx0XHRcdHJocy5wdXNoKG5ldyBJbmZpeFNwYW4odGhpcywgaW5maXgsIGJvdW5kYXJ5KSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4geyBsaHMsIHJocyB9O1xuXHRcdFx0fSkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBpbmZpeFNwYW5UYWJsZSA9IG5ldyBNYXA8SW5maXgsIHsgbGhzOiBJbmZpeFNwYW5bXTsgcmhzOiBJbmZpeFNwYW5bXSB9PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgb2Ygc3RhdGVtZW50cyB0aGF0IHJlcHJlc2VudCB0aGUgc3RhdGVtZW50XG5cdFx0ICogY29udGFpbm1lbnQgcHJvZ3Jlc3Npb24sIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGNvbnRhaW5pbmdcblx0XHQgKiBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRnZXQgYW5jZXN0cnkoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9hbmNlc3RyeSlcblx0XHRcdFx0aWYgKHRoaXMuX2FuY2VzdHJ5LmV2ZXJ5KHNtdCA9PiAhc210LmlzRGlzcG9zZWQpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9hbmNlc3RyeTtcblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIGFuY2VzdHJ5IGhhcyBubyB5ZXQgYmVlbiBjb21wdXRlZCwgb3IgaXQgaGFzLCBidXQgYXQgbGVhc3Qgb2Zcblx0XHRcdC8vIGl0J3Mgc3RhdGVtZW50cyBoYXZlIGJlZW4gZGlzcG9zZWQsIHRoZW4gaXQgbXVzdCBiZSByZWNvbXB1dGVkLlxuXHRcdFx0dGhpcy5fYW5jZXN0cnkgPSB0aGlzLnN0YXRlbWVudC5kb2N1bWVudC5nZXRBbmNlc3RyeSh0aGlzLnN0YXRlbWVudCk7XG5cdFx0XHRpZiAoIXRoaXMuX2FuY2VzdHJ5KVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9hbmNlc3RyeTtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfYW5jZXN0cnk6IHJlYWRvbmx5IFN0YXRlbWVudFtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3BsaXRzIGFwYXJ0IHRoZSBncm91cHMgc3ViamVjdHMgc3BlY2lmaWVkIGluIHRoZSBjb250YWluaW5nXG5cdFx0ICogc3RhdGVtZW50J3MgYW5jZXN0cnksIGFuZCBnZW5lcmF0ZXMgYSBzZXJpZXMgb2Ygc3BpbmVzLCBcblx0XHQgKiBlYWNoIGluZGljYXRpbmcgYSBzZXBhcmF0ZSBwYXRod2F5IG9mIGRlY2xhcmF0aW9ucyB0aHJvdWdoXG5cdFx0ICogdGhlIGFuY2VzdHJ5IHRoYXQgcmVhY2ggdGhlIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudFxuXHRcdCAqIHJlZmVyZW5jZWQgYnkgdGhpcyBnbG9iYWwgc3BhbiBvYmplY3QuXG5cdFx0ICogXG5cdFx0ICogVGhlIGdlbmVyYXRlZCBzcGluZXMgYXJlIHJlZmVyZW50aWFsbHkgb3BhcXVlLiBSdW5uaW5nIHRoaXNcblx0XHQgKiBtZXRob2Qgb24gdGhlIHNhbWUgU3BhbiBvYmplY3QgYWx3YXlzIHJldHVybnMgdGhlIHNhbWVcblx0XHQgKiBTcGluZSBpbnN0YW5jZS5cblx0XHQgKi9cblx0XHRmYWN0b3IoKTogcmVhZG9ubHkgU3BpbmVbXVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmZhY3RvcmVkU3BpbmVzKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5mYWN0b3JlZFNwaW5lcztcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNDcnVmdCB8fCB0aGlzLnN0YXRlbWVudC5pc0NydWZ0KVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5mYWN0b3JlZFNwaW5lcyA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5hbmNlc3RyeS5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiB0aGlzLmZhY3RvcmVkU3BpbmVzID0gT2JqZWN0LmZyZWV6ZShbbmV3IFNwaW5lKFt0aGlzXSldKTtcblx0XHRcdFxuXHRcdFx0Ly8gV2UgbmVlZCB0byBmYWN0b3IgdGhlIGFuY2VzdHJ5LiBUaGlzIG1lYW5zIHdlJ3JlIHRha2luZyB0aGVcblx0XHRcdC8vIHNwZWNpZmllZCBhbmNlc3RyeSBwYXRoLCBhbmQgc3BsaXR0aW5nIHdoZXJlIGFueSBoYXMtYSBzaWRlIHVuaW9uc1xuXHRcdFx0Ly8gZXhpc3QsIGluIGVmZmVjdCBjcmVhdGluZyBhbGwgcG9zc2libGUgcGF0aHMgdG8gdGhlIHNwZWNpZmllZCB0aXAuXG5cdFx0XHQvLyBJdCdzIHBvc3NpYmxlIHRvIGhhdmUgc3RhdGVtZW50cyBpbiB0aGUgc3BhbiBwYXRoIGluIHRoZSBjYXNlXG5cdFx0XHQvLyB3aGVuIHRoZSBzdGF0ZW1lbnQgaGFzIGJlZW4gZGVlbWVkIGFzIGNydWZ0LCBhbmQgdGhlcmVmb3JlLFxuXHRcdFx0Ly8gaXMgaW1wb3NzaWJsZSB0byBleHRyYWN0IGFueSBzcGFucyBmcm9tIGl0LlxuXHRcdFx0Y29uc3QgZmFjdG9yZWRTcGFuUGF0aHM6IChTcGFuIHwgU3RhdGVtZW50KVtdW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gQW4gYXJyYXkgb2YgYXJyYXlzLiBUaGUgZmlyc3QgZGltZW5zaW9uIGNvcnJlc3BvbmRzIHRvIGEgc3RhdGVtZW50LiBcblx0XHRcdC8vIFRoZSBzZWNvbmQgZGltZW5zaW9uIHN0b3JlcyB0aGUgZGVjbGFyYXRpb24gc3BhbnMgdGhlbXNlbHZlcy5cblx0XHRcdGNvbnN0IGFuY2VzdHJ5TWF0cml4ID0gdGhpcy5hbmNlc3RyeS5tYXAoc210ID0+IEFycmF5LmZyb20oc210LmRlY2xhcmF0aW9ucykpO1xuXHRcdFx0XG5cdFx0XHQvLyBBbiBhcnJheSB0aGF0IHN0b3JlcyB0aGUgbnVtYmVyIG9mIGRlY2xhcmF0aW9uIHNwYW5zIGluIGVhY2ggc3RhdGVtZW50LlxuXHRcdFx0Y29uc3QgYW5jZXN0cnlMZW5ndGhzID0gYW5jZXN0cnlNYXRyaXgubWFwKHNwYW4gPT4gc3Bhbi5sZW5ndGgpO1xuXHRcdFx0XG5cdFx0XHQvLyBNdWx0aXBseWluZyB0b2dldGhlciB0aGUgbnVtYmVyIG9mIHNwYW5zIGluIGVhY2ggc3RhdGVtZW50IHdpbGxcblx0XHRcdC8vIGdpdmUgdGhlIHRvdGFsIG51bWJlciBvZiB1bmlxdWUgc3BpbmVzIHRoYXQgd2lsbCBiZSBwcm9kdWNlZC5cblx0XHRcdGNvbnN0IG51bVNwaW5lcyA9IGFuY2VzdHJ5TGVuZ3Rocy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RhcnQgd2l0aCBhbiBhcnJheSBvZiAwJ3MsIHdob3NlIGxlbmd0aCBtYXRjaGVzIHRoZSBudW1iZXJcblx0XHRcdC8vIG9mIHN0YXRlbWVudHMgaW4gdGhlIGFuY2VzdHJ5LiBFYWNoIG51bWJlciBpbiB0aGlzIGFycmF5IHdpbGwgYmUgXG5cdFx0XHQvLyBpbmNyZW1lbnRlZCBieSAxLCBmcm9tIHJpZ2h0IHRvIGxlZnQsIGVhY2ggbnVtYmVyIG1heGluZyBvdXQgYXRcblx0XHRcdC8vIHRoZSBudW1iZXIgb2YgZGVjbGFyYXRpb25zIGluIHRoZSBhbmNlc3Rvci4gQWZ0ZXIgZWFjaCBpbmNyZW1lbnRhdGlvbixcblx0XHRcdC8vIHRoZSBwcm9ncmVzc2lvbiBvZiBudW1iZXJzIHdpbGwgcnVuIHRocm91Z2ggYWxsIGluZGV4ZXMgcmVxdWlyZWQgdG9cblx0XHRcdC8vIHBlcmZvcm0gYSBmdWxsIGZhY3Rvcml6YXRpb24gb2YgdGhlIHRlcm1zIGluIHRoZSBhbmNlc3RyeS4gVGhpcyBhcnJheVxuXHRcdFx0Ly8gdGVsbHMgdGhlIGFsZ29yaXRobSB3aGljaCBpbmRleGVzIGluIGFuY2VzdHJ5TWF0cml4IHRvIHB1bGwgd2hlblxuXHRcdFx0Ly8gY29uc3RydWN0aW5nIGEgc3BpbmUuXG5cdFx0XHRjb25zdCBjaGVycnlQaWNrSW5kZXhlcyA9IGFuY2VzdHJ5TGVuZ3Rocy5tYXAoKCkgPT4gMCk7XG5cdFx0XHRcblx0XHRcdC8vIFN0b3JlcyB0aGUgcG9zaXRpb24gaW4gY2hlcnJ5UGlja0luZGV4ZXMgdGhhdCB3ZSdyZSBjdXJyZW50bHlcblx0XHRcdC8vIGluY3JlbWVudGluZy4gTW92ZXMgYmFja3dhcmQgd2hlbiB0aGUgbnVtYmVyIGF0IFxuXHRcdFx0Ly8gdGhlIHRhcmdldCBwb3NpdGlvbiBpcyA+PSB0aGUgbnVtYmVyIG9mIHRlcm1zIGF0IHRoYXQgcG9zaXRpb24uXG5cdFx0XHRsZXQgdGFyZ2V0SW5jTGV2ZWwgPSAwO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IG51bVNwaW5lczspXG5cdFx0XHR7XG5cdFx0XHRcdC8vIERvIGFuIGluc2VydGlvbiBhdCB0aGUgaW5kZXhlcyBzcGVjaWZpZWQgYnkgaW5zZXJ0aW9uSW5kZXhlc1xuXHRcdFx0XHRjb25zdCBzcGFuUGF0aDogKFNwYW4gfCBTdGF0ZW1lbnQpW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZXJyeSBwaWNrIGEgc2VyaWVzIG9mIHRlcm1zIGZyb20gdGhlIGFuY2VzdHJ5IHRlcm1zLFxuXHRcdFx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIGluZGV4IHNldCB3ZSdyZSBjdXJyZW50bHkgb24uXG5cdFx0XHRcdGZvciAobGV0IGxldmVsID0gLTE7ICsrbGV2ZWwgPCB0aGlzLmFuY2VzdHJ5Lmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBzdGF0ZW1lbnQgPSB0aGlzLmFuY2VzdHJ5W2xldmVsXTtcblx0XHRcdFx0XHRpZiAoc3RhdGVtZW50LmlzQ3J1ZnQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c3BhblBhdGgucHVzaChzdGF0ZW1lbnQpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHNwYW5zRm9yU3RhdGVtZW50ID0gYW5jZXN0cnlNYXRyaXhbbGV2ZWxdO1xuXHRcdFx0XHRcdGNvbnN0IHNwYW5JbmRleCA9IGNoZXJyeVBpY2tJbmRleGVzW2xldmVsXTtcblx0XHRcdFx0XHRjb25zdCBzcGFuID0gc3BhbnNGb3JTdGF0ZW1lbnRbc3BhbkluZGV4XTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIXNwYW4pXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0c3BhblBhdGgucHVzaChzcGFuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhlIHRpcCBzcGFuIHNwZWNpZmllZCBpbiB0aGUgbWV0aG9kIGFyZ3VtZW50c1xuXHRcdFx0XHQvLyBpcyBhZGRlZCBhdCB0aGUgZW5kIG9mIGFsbCBnZW5lcmF0ZWQgc3BhbiBwYXRocy5cblx0XHRcdFx0c3BhblBhdGgucHVzaCh0aGlzKTtcblx0XHRcdFx0ZmFjdG9yZWRTcGFuUGF0aHMucHVzaChzcGFuUGF0aCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBCdW1wIHVwIHRoZSBjdXJyZW50IGNoZXJyeSBwaWNrIGluZGV4LCBcblx0XHRcdFx0Ly8gb3IgaWYgd2UgaGl0IHRoZSByb29mLCBtb3ZlIHRvIHRoZSBuZXh0IGxldmVsLFxuXHRcdFx0XHQvLyBhbmQga2VlcCBkb2luZyB0aGlzIHVudGlsIHdlIGZpbmQgYSBudW1iZXJcblx0XHRcdFx0Ly8gdG8gaW5jcmVtZW50LlxuXHRcdFx0XHR3aGlsZSAoY2hlcnJ5UGlja0luZGV4ZXNbdGFyZ2V0SW5jTGV2ZWxdID49IGFuY2VzdHJ5TGVuZ3Roc1t0YXJnZXRJbmNMZXZlbF0gLSAxKVxuXHRcdFx0XHRcdHRhcmdldEluY0xldmVsKys7XG5cdFx0XHRcdFxuXHRcdFx0XHRjaGVycnlQaWNrSW5kZXhlc1t0YXJnZXRJbmNMZXZlbF0rKztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZmFjdG9yZWRTcGluZXMgPSBcblx0XHRcdFx0T2JqZWN0LmZyZWV6ZShmYWN0b3JlZFNwYW5QYXRocy5tYXAoc3BhblBhdGggPT4gXG5cdFx0XHRcdFx0bmV3IFNwaW5lKHNwYW5QYXRoKSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogICovXG5cdFx0cHJpdmF0ZSBmYWN0b3JlZFNwaW5lczogcmVhZG9ubHkgU3BpbmVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBTcGFuIGlzIGNvbnNpZGVyZWRcblx0XHQgKiBvYmplY3QtbGV2ZWwgY3J1ZnQsIGFuZCBzaG91bGQgdGhlcmVmb3JlIGJlIGlnbm9yZWQgZHVyaW5nIHR5cGUgYW5hbHlzaXMuXG5cdFx0ICovXG5cdFx0Z2V0IGlzQ3J1ZnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXRlbWVudC5jcnVmdE9iamVjdHMuaGFzKHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIFNwYW4gdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGluY2x1ZGVIYXNoUHJlZml4IElmIHRoZSBzdWJqZWN0IGluc2lkZSB0aGlzIFNwYW4gaXMgYVxuXHRcdCAqIFBhdHRlcm4sIGFuZCB0aGlzIGFyZ3VtZW50IGlzIHRydWUsIHRoZSBQYXR0ZXJuJ3MgaGFzaCBwcmVmaXhcblx0XHQgKiB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgc2VyaWFsaXplZCByZXN1bHQuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoaW5jbHVkZUhhc2hQcmVmaXg/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN1YiA9IHRoaXMuYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdHJldHVybiBzdWIgaW5zdGFuY2VvZiBQYXR0ZXJuID9cblx0XHRcdFx0c3ViLnRvU3RyaW5nKCEhaW5jbHVkZUhhc2hQcmVmaXgpIDpcblx0XHRcdFx0c3ViLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IG1hbmFnZXMgYW4gYXJyYXkgb2YgU3BhbiBvYmplY3RzIHRoYXRcblx0ICogcmVwcmVzZW50IGEgc3BlY2lmaWMgc3BpbmUgb2YgZGVjbGFyYXRpb25zLCBzdGFydGluZyBhdFxuXHQgKiBhIGRvY3VtZW50LCBwYXNzaW5nIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3BhbnMsXG5cdCAqIGFuZCBlbmRpbmcgYXQgYSB0aXAgc3Bhbi5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBTcGluZVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IodmVydGVicmFlOiAoU3BhbiB8IFN0YXRlbWVudClbXSlcblx0XHR7XG5cdFx0XHRpZiAodmVydGVicmFlLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRDYWxsKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMudmVydGVicmFlID0gdmVydGVicmFlLm1hcCh2ID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh2IGluc3RhbmNlb2YgU3Bhbilcblx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGV4aXN0Q3J1ZnRNYXJrZXIgPSBDcnVmdE1hcmtlcnMuZ2V0KHYpO1xuXHRcdFx0XHRpZiAoZXhpc3RDcnVmdE1hcmtlciAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHJldHVybiBleGlzdENydWZ0TWFya2VyO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbmV3Q3J1ZnRNYXJrZXIgPSBuZXcgQ3J1ZnRNYXJrZXIodik7XG5cdFx0XHRcdENydWZ0TWFya2Vycy5zZXQodiwgbmV3Q3J1ZnRNYXJrZXIpO1xuXHRcdFx0XHRyZXR1cm4gbmV3Q3J1ZnRNYXJrZXI7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdGlwID0gdGhpcy52ZXJ0ZWJyYWVbdmVydGVicmFlLmxlbmd0aCAtIDFdO1xuXHRcdFx0aWYgKHRpcCBpbnN0YW5jZW9mIENydWZ0TWFya2VyKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZENhbGwoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy50aXAgPSB0aXA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgdGhlIGxhc3Qgc3BhbiBpbiB0aGUgYXJyYXkgb2Ygc2VnbWVudHMuICovXG5cdFx0cmVhZG9ubHkgdGlwOiBTcGFuO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBzdGF0ZW1lbnQoKSB7IHJldHVybiB0aGlzLnRpcC5zdGF0ZW1lbnQ7IH1cblx0XHRcblx0XHQvKiogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdGhhdCBzaXRzIGF0IHRoZSB0b3Agb2YgdGhlIHNwaW5lLiAqL1xuXHRcdGdldCBkb2N1bWVudCgpIHsgcmV0dXJuIHRoaXMuc3RhdGVtZW50LmRvY3VtZW50OyB9XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyBhbiBhcnJheSBvZiB0aGUgU3BhbnMgdGhhdCBjb21wb3NlIHRoZSBTcGluZS4gKi9cblx0XHRyZWFkb25seSB2ZXJ0ZWJyYWU6IHJlYWRvbmx5IChTcGFuIHwgQ3J1ZnRNYXJrZXIpW10gPSBbXTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCBhY3RzIGFzIGEgc3RhbmQtaW4gZm9yIGEgc3RhdGVtZW50IHRoYXQgaGFzIGJlZW5cblx0ICogbWFya2VkIGFzIGNydWZ0LCBzdWl0YWJsZSBmb3IgdXNhZ2UgaW4gYSBTcGluZS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDcnVmdE1hcmtlclxuXHR7XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdGNvbnN0cnVjdG9yKHJlYWRvbmx5IHN0YXRlbWVudDogU3RhdGVtZW50KSB7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIGNydWZ0IG1hcmtlciB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbixcblx0XHQgKiB3aGljaCBpcyBkZXJpdmVkIGZyb20gYSBoYXNoIGNhbGN1bGF0ZWQgZnJvbSB0aGlzXG5cdFx0ICogbWFya2VyJ3MgdW5kZXJseWluZyBzdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdHJldHVybiBcIuKJiFwiICsgSGFzaC5jYWxjdWxhdGUodGhpcy5zdGF0ZW1lbnQuc291cmNlVGV4dCk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgQ3J1ZnRNYXJrZXJzID0gbmV3IFdlYWtNYXA8U3RhdGVtZW50LCBDcnVmdE1hcmtlcj4oKTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKiAqL1xuXHRleHBvcnQgdHlwZSBTdWJqZWN0ID0gRGVjbGFyYXRpb25TdWJqZWN0IHwgQW5ub3RhdGlvblN1YmplY3Q7XG5cblx0LyoqXG5cdCAqIFN0b3JlcyBhIG1hcCBvZiB0aGUgY2hhcmFjdGVyIG9mZnNldHMgd2l0aGluIGEgU3RhdGVtZW50XG5cdCAqIHRoYXQgcmVwcmVzZW50IHRoZSBzdGFydGluZyBwb3NpdGlvbnMgb2YgdGhlIHN0YXRlbWVudCdzXG5cdCAqIGRlY2xhcmFydGlvbnMuXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBEZWNsYXJhdGlvblN1YmplY3QgPSBJZGVudGlmaWVyIHwgUGF0dGVybiB8IFVyaSB8IEFub247XG5cblx0LyoqXG5cdCAqIFN0b3JlcyBhIG1hcCBvZiB0aGUgY2hhcmFjdGVyIG9mZnNldHMgd2l0aGluIGEgU3RhdGVtZW50XG5cdCAqIHRoYXQgcmVwcmVzZW50IHRoZSBzdGFydGluZyBwb3NpdGlvbnMgb2YgdGhlIHN0YXRlbWVudCdzXG5cdCAqIGFubm90YXRpb25zLlxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgQW5ub3RhdGlvblN1YmplY3QgPSBJZGVudGlmaWVyO1xuXG5cblx0LyoqICovXG5cdGV4cG9ydCBjbGFzcyBTdWJqZWN0U2VyaWFsaXplclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogVW5pdmVyc2FsIG1ldGhvZCBmb3Igc2VyaWFsaXppbmcgYSBzdWJqZWN0IHRvIGEgc3RyaW5nLFxuXHRcdCAqIHVzZWZ1bCBmb3IgZGVidWdnaW5nIGFuZCBzdXBwb3J0aW5nIHRlc3RzLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBmb3JFeHRlcm5hbChcblx0XHRcdHRhcmdldDogU3ViamVjdENvbnRhaW5lcixcblx0XHRcdGVzY2FwZVN0eWxlOiBJZGVudGlmaWVyRXNjYXBlS2luZCA9IElkZW50aWZpZXJFc2NhcGVLaW5kLm5vbmUpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3ViamVjdCA9IHRoaXMucmVzb2x2ZVN1YmplY3QodGFyZ2V0KTtcblx0XHRcdHJldHVybiB0aGlzLnNlcmlhbGl6ZShzdWJqZWN0LCBlc2NhcGVTdHlsZSwgZmFsc2UpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTZXJpYWxpemVzIGEgc3ViamVjdCwgb3IgYSBrbm93biBzdWJqZWN0IGNvbnRhaW5pbmcgb2JqZWN0IGZvciBpbnRlcm5hbCB1c2UuXG5cdFx0ICovXG5cdFx0c3RhdGljIGZvckludGVybmFsKHRhcmdldDogU3ViamVjdENvbnRhaW5lcilcblx0XHR7XG5cdFx0XHRjb25zdCBzdWJqZWN0ID0gdGhpcy5yZXNvbHZlU3ViamVjdCh0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VyaWFsaXplKHN1YmplY3QsIElkZW50aWZpZXJFc2NhcGVLaW5kLm5vbmUsIHRydWUpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyByZXNvbHZlU3ViamVjdCh0YXJnZXQ6IFN1YmplY3RDb250YWluZXIpOiBTdWJqZWN0XG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIEJvdW5kYXJ5ID8gdGFyZ2V0LnN1YmplY3QgOlxuXHRcdFx0XHR0YXJnZXQgaW5zdGFuY2VvZiBTcGFuID8gdGFyZ2V0LmJvdW5kYXJ5LnN1YmplY3QgOlxuXHRcdFx0XHR0YXJnZXQgaW5zdGFuY2VvZiBJbmZpeFNwYW4gPyB0YXJnZXQuYm91bmRhcnkuc3ViamVjdCA6XG5cdFx0XHRcdHRhcmdldDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgc2VyaWFsaXplKFxuXHRcdFx0c3ViamVjdDogU3ViamVjdENvbnRhaW5lcixcblx0XHRcdGVzY2FwZVN0eWxlOiBJZGVudGlmaWVyRXNjYXBlS2luZCxcblx0XHRcdGluY2x1ZGVIYXNoOiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGlmIChzdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcilcblx0XHRcdFx0cmV0dXJuIHN1YmplY3QudG9TdHJpbmcoZXNjYXBlU3R5bGUpO1xuXHRcdFx0XG5cdFx0XHRlbHNlIGlmIChzdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0cmV0dXJuIHN1YmplY3QudG9TdHJpbmcoaW5jbHVkZUhhc2gpO1xuXHRcdFx0XG5cdFx0XHRlbHNlIGlmIChzdWJqZWN0IGluc3RhbmNlb2YgVXJpKVxuXHRcdFx0XHRyZXR1cm4gc3ViamVjdC50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRlbHNlIGlmIChzdWJqZWN0IGluc3RhbmNlb2YgQW5vbilcblx0XHRcdFx0cmV0dXJuIHN1YmplY3QudG9TdHJpbmcoKTtcblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBJZGVudGlmaWVzIGEgVHlwZSB0aGF0IGlzIG9yIGNvbnRhaW5zIGEgU3ViamVjdC4gKi9cblx0ZXhwb3J0IHR5cGUgU3ViamVjdENvbnRhaW5lciA9IFN1YmplY3QgfCBCb3VuZGFyeTxTdWJqZWN0PiB8IFNwYW4gfCBJbmZpeFNwYW47XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgSHlwZXJHcmFwaFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogVGVzdC1vbmx5IGZpZWxkIHVzZWQgdG8gZGlzYWJsZSB0aGUgZnVuY3Rpb25zIG9mIHRoZSBHcmFwaC5cblx0XHQgKi9cblx0XHRzdGF0aWMgZGlzYWJsZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cdFx0XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHR0aGlzLm5vZGVJbmRleCA9IG5ldyBOb2RlSW5kZXgodGhpcy5wcm9ncmFtKTtcblx0XHRcdFxuXHRcdFx0aWYgKEh5cGVyR3JhcGguZGlzYWJsZWQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5kb2N1bWVudHMuZWFjaCgpXG5cdFx0XHRcdC5mb3JFYWNoKHRoaXMuaW5jbHVkZS5iaW5kKHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZURvY3VtZW50Q3JlYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuaW5jbHVkZShkYXRhLmRvY3VtZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlRG9jdW1lbnREZWxldGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5leGNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VJbnZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnBhcmVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRcdHRoaXMuZXhjbHVkZShzbXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdGhpcy5leGNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VSZXZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnBhcmVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIGRhdGEucGFyZW50cylcblx0XHRcdFx0XHRcdHRoaXMuaW5jbHVkZShzbXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdGhpcy5pbmNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlYWRzIGEgcm9vdCBOb2RlIHdpdGggdGhlIHNwZWNpZmllZFxuXHRcdCAqIG5hbWUgb3V0IG9mIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZChkb2N1bWVudDogRG9jdW1lbnQsIG5hbWU6IHN0cmluZyk6IE5vZGUgfCBudWxsXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IGRvY3VtZW50LnNvdXJjZVVyaVxuXHRcdFx0XHQuZXh0ZW5kVHlwZShuYW1lKVxuXHRcdFx0XHQudG9TdHJpbmcoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMubm9kZUluZGV4LmdldE5vZGVCeVVyaSh1cmlUZXh0KSB8fCBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlIG9iamVjdHNcblx0XHQgKiB0aGF0IGFyZSBkZWZpbmVkIGF0IHRoZSByb290IGxldmVsIG9mIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBkb2N1bWVudC5cblx0XHQgKi9cblx0XHQqcmVhZFJvb3RzKGRvY3VtZW50OiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2RlSW5kZXguZWFjaE5vZGUoKSlcblx0XHRcdFx0aWYgKG5vZGUuY29udGFpbmVyID09PSBudWxsKVxuXHRcdFx0XHRcdGlmIChub2RlLmRvY3VtZW50ID09PSBkb2N1bWVudClcblx0XHRcdFx0XHRcdHlpZWxkIG5vZGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgYSBkb2N1bWVudC1sZXZlbCBleGNsdXNpb24sIHdoaWNoIGlzIHRoZSByZW1vdmFsIFxuXHRcdCAqIG9mIGEgc2VjdGlvbiBvZiBTcGFucyB3aXRoaW4gYSBkb2N1bWVudCwgb3IgcG9zc2libHkgdGhlXG5cdFx0ICogZW50aXJlIGRvY3VtZW50IGl0c2VsZi5cblx0XHQgKi9cblx0XHRwcml2YXRlIGV4Y2x1ZGUocm9vdDogRG9jdW1lbnQgfCBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgeyBkb2N1bWVudCwgaXRlcmF0b3IgfSA9IHRoaXMubWV0aG9kU2V0dXAocm9vdCk7XG5cdFx0XHRjb25zdCB0eG4gPSBuZXcgR3JhcGhUcmFuc2FjdGlvbigpO1xuXHRcdFx0Ly8vY29uc3QgbWF5YmVEZXN0YWJpbGl6ZWRFZGdlczogSHlwZXJFZGdlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB7IHN0YXRlbWVudCB9IG9mIGl0ZXJhdG9yKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIHN0YXRlbWVudC5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBhc3NvY2lhdGVkTm9kZXMgPSBuZXcgU2V0KGRlY2xhcmF0aW9uXG5cdFx0XHRcdFx0XHQuZmFjdG9yKClcblx0XHRcdFx0XHRcdC5tYXAoc3BpbmUgPT4gVXJpLmNsb25lKHNwaW5lKSlcblx0XHRcdFx0XHRcdC5tYXAodXJpID0+IHRoaXMubm9kZUluZGV4LmdldE5vZGVCeVVyaSh1cmkpKVxuXHRcdFx0XHRcdFx0LmZpbHRlcigobik6IG4gaXMgTm9kZSA9PiBuIGluc3RhbmNlb2YgTm9kZSkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgYXNzb2NpYXRlZE5vZGUgb2YgYXNzb2NpYXRlZE5vZGVzKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGFzc29jaWF0ZWROb2RlLnJlbW92ZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGFzc29jaWF0ZWROb2RlLmRlY2xhcmF0aW9ucy5zaXplID09PSAwKVxuXHRcdFx0XHRcdFx0XHR0eG4uZGVzdGFiaWxpemVkTm9kZXMucHVzaChhc3NvY2lhdGVkTm9kZSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoY29uc3Qgb2Igb2YgYXNzb2NpYXRlZE5vZGUub3V0Ym91bmRzKVxuXHRcdFx0XHRcdFx0XHRpZiAob2IuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdFx0XHR0eG4uZGVzdGFibGl6ZWRFZGdlcy5wdXNoKG9iKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8vZm9yIChjb25zdCBpYiBvZiBhc3NvY2lhdGVkTm9kZS5pbmJvdW5kcylcblx0XHRcdFx0XHRcdC8vL1x0bWF5YmVEZXN0YWJpbGl6ZWRFZGdlcy5wdXNoKGliKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8vZm9yIChjb25zdCBlZGdlIG9mIG1heWJlRGVzdGFiaWxpemVkRWRnZXMpXG5cdFx0XHQvLy9cdGlmIChlZGdlLnN1Y2Nlc3NvcnMuZXZlcnkoc2NzciA9PiB0eG4uZGVzdGFiaWxpemVkTm9kZXMuaW5jbHVkZXMoc2Nzci5ub2RlKSkpXG5cdFx0XHQvLy9cdFx0dHhuLmRlc3RhYmxpemVkRWRnZXMucHVzaChlZGdlKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hY3RpdmVUcmFuc2FjdGlvbnMuc2V0KGRvY3VtZW50LCB0eG4pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhIHJldmFsaWRhdGlvbiBvZiB0aGUgTm9kZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZVxuXHRcdCAqIGlucHV0IGFyZ3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSByb290IFRoZSByb290IG9iamVjdCB1bmRlciB3aGljaCB3aGljaCByZXZhbGlkYXRpb25cblx0XHQgKiBzaG91bGQgb2NjdXIuIEluIHRoZSBjYXNlIHdoZW4gYSBEb2N1bWVudCBpbnN0YW5jZSBpcyBwYXNzZWQsXG5cdFx0ICogYWxsIE5vZGVzIHByZXNlbnQgd2l0aGluIHRoZSBkb2N1bWVudCBhcmUgcmV2YWxpZGF0ZWQuIEluIHRoZSBcblx0XHQgKiBjYXNlIHdoZW4gYSBTdGF0ZW1lbnQgaW5zdGFuY2UgaXMgcGFzc2VkLCB0aGUgTm9kZXMgdGhhdFxuXHRcdCAqIGNvcnJlc3BvbmQgdG8gdGhlIFN0YXRlbWVudCwgYW5kIGFsbCBvZiBpdCdzIGNvbnRlbnRzIGFyZVxuXHRcdCAqIHJldmFsaWRhdGVkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgaW5jbHVkZShyb290OiBEb2N1bWVudCB8IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHRjb25zdCB7IGRvY3VtZW50LCBpdGVyYXRvciB9ID0gdGhpcy5tZXRob2RTZXR1cChyb290KTtcblx0XHRcdGNvbnN0IHR4biA9IHRoaXMuYWN0aXZlVHJhbnNhY3Rpb25zLmdldChkb2N1bWVudCk7XG5cdFx0XHRcblx0XHRcdC8vIFN0b3JlcyBhbGwgdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGFmZmVjdGVkIGJ5IGEgbmV3XG5cdFx0XHQvLyBmcmFnbWVudCBlaXRoZXIgYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIGl0LlxuXHRcdFx0Y29uc3QgYWZmZWN0ZWROb2RlczogTm9kZVtdID0gW107XG5cdFx0XHRcblx0XHRcdC8vIFN0b3JlcyBhIHN1YnNldCBvZiB0aGUgYWZmZWN0ZWROb2RlcyBhcnJheS4gQ29udGFpbnNcblx0XHRcdC8vIG9ubHkgdGhlIG5vZGVzIHRoYXQgYXJlIGF0IHRoZSBoaWdoZXN0IGxldmVsIG9mIGRlcHRoXG5cdFx0XHQvLyB3aXRoaW4gdGhlIG5vZGUgc2V0IChub3QgbmVjZXNzYXJpbHkgdGhlIGRvY3VtZW50IHJvb3QpLlxuXHRcdFx0Y29uc3QgYWZmZWN0ZWROb2Rlc0FwZXhlczogTm9kZVtdID0gW107XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMgVGhlIGNvbnRhaW5pbmcgbm9kZSB0aGF0XG5cdFx0XHQgKiBjb3JyZXNwb25kcyB0byB0aGUgc3BlY2lmaWVkIFVSSS5cblx0XHRcdCAqLyBcblx0XHRcdGNvbnN0IGZpbmROb2RlID0gKHVyaTogVXJpKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodXJpLnR5cGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZEFyZ3VtZW50KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBleGlzdGluZ05vZGUgPSBhZmZlY3RlZE5vZGVzLmZpbmQobm9kZSA9PiBcblx0XHRcdFx0XHRub2RlLnVyaS5lcXVhbHModXJpLCB0cnVlKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZXhpc3RpbmdOb2RlKVxuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZ05vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjYWNoZWROb2RlID0gdGhpcy5ub2RlSW5kZXguZ2V0Tm9kZUJ5VXJpKHVyaSk7XG5cdFx0XHRcdGlmIChjYWNoZWROb2RlKVxuXHRcdFx0XHRcdHJldHVybiBjYWNoZWROb2RlO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0aGF0IHRoZXNlIGRlY2xhcmF0aW9ucyBhcmUgZW51bWVyYXRlZFxuXHRcdFx0Ly8gaW4gYnJlYWR0aC1maXJzdCBvcmRlciwgc28gdGhhdCBkZWVwZXIgbm9kZXMgaGF2ZSBhIFxuXHRcdFx0Ly8gY29udGFpbmVyIHRoYXQgdGhleSBjYW4gcmVmZXJlbmNlIGR1cmluZyBjb25zdHJ1Y3Rpb25cblx0XHRcdC8vIHRpbWUuIEJlZm9yZSBub2RlIGNvbnN0cnVjdGlvbiBjYW4gaGFwcGVuLCB0aGUgbmV3IFxuXHRcdFx0Ly8gU3BhbnMgbmVlZCB0byBiZSBvcmdhbml6ZWQgaW4gYSBkYXRhIHN0cnVjdHVyZSB0aGF0IFxuXHRcdFx0Ly8gbWFrZXMgYnJlYWR0aC1maXJzdCB0cmF2ZXJzYWwgZWFzeS5cblx0XHRcdC8vIFxuXHRcdFx0Ly8gVGhlIGJyZWFkdGhGaXJzdE9yZ2FuaXplciBoYXMgMyBsZXZlbHMgb2Ygb3JnYW5pemF0aW9uOlxuXHRcdFx0Ly9cblx0XHRcdC8vICgxKSBBbiBhcnJheSBvZiBtdWx0aS1tYXBzIHdoaWNoIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGVcblx0XHRcdC8vIGxldmVsIG9mIGRlcHRoIGluIHRoZSBoaWVyYXJjaHkgYmVpbmcgdHJhdmVyc2VkICh3aGljaFxuXHRcdFx0Ly8gY291bGQgcG9zc2libHkgZXh0ZW5kIGFjcm9zcyBtdWx0aXBsZSBsb2NhbGl0aWVzIGluIHRoZVxuXHRcdFx0Ly8gZG9jdW1lbnQpLlxuXHRcdFx0Ly9cblx0XHRcdC8vICgyKSBBIG11bHRpLW1hcCwgdGhhdCBpcyBrZXllZCBieSBhIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb25cblx0XHRcdC8vIG9mIG9uZSBzaW5nbGUgc3BpbmUgZm91bmQgaW4gdGhlIGhpZXJhcmNoeSwgYW5kIHdob3NlXG5cdFx0XHQvLyB2YWx1ZXMgYXJlLi4uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gKDMpIEEgdW5pcXVlIFNwYW4gb2JqZWN0IHRoYXQgY29ycmVzcG9uZHMgdG8gYSB1bnFpdWVcblx0XHRcdC8vIG9jY3VyZW5jZSBvZiBhIHN1YmplY3QgaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aW50ZXJmYWNlIElCcmVhZHRoRmlyc3RFbnRyeSB7IHVyaTogVXJpOyBkZWNsYXJhdGlvbjogU3BhbiB8IEluZml4U3BhbiB9XG5cdFx0XHRjb25zdCBicmVhZHRoRmlyc3RPcmdhbml6ZXI6IEFycmF5PE11bHRpTWFwPHN0cmluZywgSUJyZWFkdGhGaXJzdEVudHJ5Pj4gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB7IGxldmVsLCBzdGF0ZW1lbnQgfSBvZiBpdGVyYXRvcilcblx0XHRcdHtcblx0XHRcdFx0Ly8gUG9zc2libHkgYXBwZW5kIGEgYnVuY2ggb2YgZW1wdHkgbXVsdGktbWFwc1xuXHRcdFx0XHQvLyBhdCB0aGUgZW5kIG9mIHRoZSBvcmdhbml6ZXIsIHNvIHRoYXQgd2UgZG9uJ3Rcblx0XHRcdFx0Ly8gYWNjZXNzIGFuIHVuaW5pdGlhbGl6ZWQgaW5kZXggZG93biBiZWxvdy5cblx0XHRcdFx0d2hpbGUgKGJyZWFkdGhGaXJzdE9yZ2FuaXplci5sZW5ndGggPCBsZXZlbCArIDEpXG5cdFx0XHRcdFx0YnJlYWR0aEZpcnN0T3JnYW5pemVyLnB1c2gobmV3IE11bHRpTWFwPHN0cmluZywgSUJyZWFkdGhGaXJzdEVudHJ5PigpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZW4gdGhlIGN1cnJlbnQgc3RhdGVtZW50IGhhcyBiZWVuIGRlZW1lZFxuXHRcdFx0XHQvLyBhcyBjcnVmdCwgaXQncyBPSyB0byBqdXN0IGNvbnRpbnVlLCBiZWNhdXNlIHRoZSBicmVhZHRoLWZpcnN0XG5cdFx0XHRcdC8vIG9yZ2FuaXplciB3aWxsIGVuZCB1cCB3aXRoIGFuIGVtcHR5IG11bHRpLW1hcCBpbiB0aGUgY2FzZVxuXHRcdFx0XHQvLyB3aGVuIHRoZSBwb3J0aW9uIG9mIHRoZSBoaWVyYXJjaHkgYmVpbmcgdHJhdmVyc2VkIGxvb2tzIFxuXHRcdFx0XHQvLyBsaWtlOlxuXHRcdFx0XHQvLyBcblx0XHRcdFx0Ly8gRm9vXG5cdFx0XHRcdC8vIFx0W0NydWZ0XSAgICA8PT09IFdpbGwgY29ycmVzcG9uZCB0byBhbiBlbXB0eSBtdWx0aS1tYXBcblx0XHRcdFx0Ly8gXHRcdEJhclxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBPciwgaXQgd2lsbCBlbmQgdXAgd2l0aCBhIHBvcHVsYXRlZCBtdWx0aS1tYXAgaW4gdGhlIGNhc2Vcblx0XHRcdFx0Ly8gd2hlbiB0aGVyZSBpcyBhbm90aGVyIHN0YXRlbWVudCBhdCBbQ3J1ZnRdJ3MgbGV2ZWwgb2YgZGVwdGguXG5cdFx0XHRcdC8vIEVpdGhlciB3YXksIHRoZXJlIGFyZSBubyBzcGFucyB0aGF0IG5lZWQgdG8gYmUgYWRkZWQgZnJvbVxuXHRcdFx0XHQvLyBzdGF0ZW1lbnRzIG1hcmtlZCBhcyBjcnVmdC4gVGhlIHRyYXZlcnNhbCB3aWxsIHN0aWxsIHJlYWNoXG5cdFx0XHRcdC8vIHRoZSBjcnVmdHkgc3RhdGVtZW50J3MgY29udGVudHMsIGNhdXNpbmcgdGhlIHNwaW5lcyB0byBzdGlsbFxuXHRcdFx0XHQvLyBiZSBjb21wdXRlZC5cblx0XHRcdFx0aWYgKHN0YXRlbWVudC5pc0NydWZ0KVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbXVsdGlNYXAgPSBicmVhZHRoRmlyc3RPcmdhbml6ZXJbbGV2ZWxdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBkZWNsIG9mIHN0YXRlbWVudC5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNwaW5lIG9mIGRlY2wuZmFjdG9yKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgdXJpID0gVXJpLmNsb25lKHNwaW5lKTtcblx0XHRcdFx0XHRcdGNvbnN0IHR5cGVOYW1lcyA9IHNwaW5lLnZlcnRlYnJhZS5tYXAodiA9PiB2LnRvU3RyaW5nKHRydWUpKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bXVsdGlNYXAuYWRkKFxuXHRcdFx0XHRcdFx0XHR0eXBlTmFtZXMuam9pbihTeW50YXgudGVybWluYWwpLFxuXHRcdFx0XHRcdFx0XHR7IHVyaSwgZGVjbGFyYXRpb246IGRlY2wgfSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBkZWNsYXJhdGlvbiBoYXMgcG9wdWxhdGlvbiBpbmZpeGVzLCB0aGVzZVxuXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgbWFwIGFzIHRob3VnaCB0aGV5XG5cdFx0XHRcdFx0XHQvLyB3ZXJlIHJlZ3VsYXIgZGVjbGFyYXRpb25zLlxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBwb3BJbmZpeGVzID0gZGVjbC5pbmZpeGVzLmZpbHRlcihuZnggPT4gbmZ4LmlzUG9wdWxhdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAocG9wSW5maXhlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGluZml4IG9mIHBvcEluZml4ZXMpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgaW5maXhTcGFuIG9mIGRlY2wuZWFjaERlY2xhcmF0aW9uRm9ySW5maXgoaW5maXgpKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmZ4VGV4dCA9IFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKGluZml4U3Bhbik7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgaW5maXhTcGluZVBhcnRzID0gdHlwZU5hbWVzLmNvbmNhdChuZnhUZXh0KTtcblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRtdWx0aU1hcC5hZGQoXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmZpeFNwaW5lUGFydHMuam9pbihTeW50YXgudGVybWluYWwpLFxuXHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1cmk6IHVyaS5leHRlbmRUeXBlKG5meFRleHQpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvbjogaW5maXhTcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBUaGUgZm9sbG93aW5nIGJsb2NrIHBvcHVsYXRlcyB0aGUgYXBwcm9wcmlhdGUgTm9kZXNcblx0XHRcdC8vIGluIHRoZSBncmFwaCB3aXRoIHRoZSBuZXcgU3BhbiBvYmplY3RzIHRoYXQgd2VyZSBzZW50XG5cdFx0XHQvLyBpbiB0aHJvdWdoIHRoZSBcInJvb3RcIiBwYXJhbWV0ZXIuIE5ldyBOb2RlIG9iamVjdHNcblx0XHRcdC8vIGFyZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeS5cblx0XHRcdGZvciAoY29uc3QgbXVsdGlNYXAgb2YgYnJlYWR0aEZpcnN0T3JnYW5pemVyKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIG11bHRpTWFwLnZhbHVlcygpKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgeyB1cmksIGRlY2xhcmF0aW9uIH0gb2YgZW50cnkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3Qgbm9kZUF0VXJpID0gZmluZE5vZGUodXJpKTtcblx0XHRcdFx0XHRcdGlmIChub2RlQXRVcmkpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFmZmVjdGVkTm9kZXMucHVzaChub2RlQXRVcmkpO1xuXHRcdFx0XHRcdFx0XHRub2RlQXRVcmkuYWRkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3QgY29udGFpbmVyID0gdXJpLnR5cGVzLmxlbmd0aCA+IDEgP1xuXHRcdFx0XHRcdFx0XHRmaW5kTm9kZSh1cmkucmV0cmFjdFR5cGUoMSkpIDpcblx0XHRcdFx0XHRcdFx0bnVsbDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHVyaS50eXBlcy5sZW5ndGggPiAxICYmIGNvbnRhaW5lciA9PT0gbnVsbClcblx0XHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBOb3RlIHRoYXQgd2hlbiBjcmVhdGluZyBhIE5vZGUsIGl0J3Ncblx0XHRcdFx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgYm91bmQgdG8gaXQncyBjb250YWluZXIuXG5cdFx0XHRcdFx0XHRjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUoY29udGFpbmVyLCBkZWNsYXJhdGlvbik7XG5cdFx0XHRcdFx0XHRhZmZlY3RlZE5vZGVzLnB1c2gobmV3Tm9kZSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFBvcHVsYXRlIHRoZSB0b3BNb3N0QWZmZWN0ZWROb2RlcyBhcnJheSwgXG5cdFx0XHRcdFx0XHQvLyB3aGljaCBpcyBuZWVkZWQgdG8gZmluZCB0aGUgbm9kZXMgdGhhdCBhcmVcblx0XHRcdFx0XHRcdC8vIGFmZmVjdGVkIGJ5IHRoZSBjaGFuZ2UsIGJ1dCBhcmUgbm90IGxvY2F0ZWRcblx0XHRcdFx0XHRcdC8vIGRpcmVjdGx5IHdpdGhpbiB0aGUgcGF0Y2guXG5cdFx0XHRcdFx0XHRpZiAoYWZmZWN0ZWROb2Rlc0FwZXhlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFmZmVjdGVkTm9kZXNBcGV4ZXMucHVzaChuZXdOb2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UndmUgZW5jb3VudGVyZWQgYSBub2RlIHRoYXQgaXMgaGlnaGVyXG5cdFx0XHRcdFx0XHRcdC8vIHRoYW4gdGhlIGxldmVsIG9mIGRlcHRoIGRlZmluZWQgaW4gdGhlIG5vZGVzIGN1cnJlbnRseVxuXHRcdFx0XHRcdFx0XHQvLyBpbiB0aGUgYWZmZWN0ZWROb2Rlc0FwZXhlcyBhcnJheS5cblx0XHRcdFx0XHRcdFx0Y29uc3QgaGlnaGVzdERlcHRoID0gYWZmZWN0ZWROb2Rlc1swXS51cmkudHlwZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBub2RlRGVwdGggPSBuZXdOb2RlLnVyaS50eXBlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAobm9kZURlcHRoIDwgaGlnaGVzdERlcHRoKVxuXHRcdFx0XHRcdFx0XHRcdGFmZmVjdGVkTm9kZXNBcGV4ZXMubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChub2RlRGVwdGggPD0gaGlnaGVzdERlcHRoKVxuXHRcdFx0XHRcdFx0XHRcdGFmZmVjdGVkTm9kZXNBcGV4ZXMucHVzaChuZXdOb2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYWxsIG5ldyBIeXBlckVkZ2VzIGJ5IGZlZWRpbmcgaW4gYWxsXG5cdFx0XHQvLyBhbm5vdGF0aW9uIHNwYW5zIGZvciBlYWNoIGRlY2xhcmF0aW9uIHNwYW4uXG5cdFx0XHQvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBpbiBhIHNlY29uZCBwYXNzIGJlY2F1c2Vcblx0XHRcdC8vIGFsbCBuZXcgbm9kZXMgbmVlZCB0byBiZSBjcmVhdGVkIGFuZCBwb3NpdGlvbmVkXG5cdFx0XHQvLyBpbiB0aGUgZ3JhcGggYmVmb3JlIG5ldyBcIkh5cGVyRWRnZSBzcGFuc1wiIGNhbiBiZSBhZGRlZCxcblx0XHRcdC8vIGJlY2F1c2UgZG9pbmcgdGhpcyBjYXVzZXMgcmVzb2x1dGlvbiB0byBvY2N1ci5cblx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiBhZmZlY3RlZE5vZGVzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIG5vZGUuZGVjbGFyYXRpb25zKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgU3Bhbilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGFubm90YXRpb24gb2YgZGVjbGFyYXRpb24uc3RhdGVtZW50LmFubm90YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRub2RlLmFkZEVkZ2VGcmFnbWVudChhbm5vdGF0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IG5meCA9IGRlY2xhcmF0aW9uLmNvbnRhaW5pbmdJbmZpeDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBib3VuZGFyeSBvZiBuZngucmhzKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRub2RlLmFkZEVkZ2VGcmFnbWVudChuZXcgSW5maXhTcGFuKFxuXHRcdFx0XHRcdFx0XHRcdGRlY2xhcmF0aW9uLmNvbnRhaW5pbmdTcGFuLFxuXHRcdFx0XHRcdFx0XHRcdG5meCxcblx0XHRcdFx0XHRcdFx0XHRib3VuZGFyeSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBUaGlzIGlzIGRvaW5nIHRoZSByZXZlcnNlIG9mIHdoYXQgdGhlIGFib3ZlIGFmZmVjdGVkTm9kZXNcblx0XHRcdC8vIGxvb3AgaXMgZG9pbmcgLi4uIHRoaXMgaXMgY29ubmVjdGluZyBvdGhlciBub2RlcyB0byB0aGUgYWZmZWN0ZWRcblx0XHRcdC8vIG5vZGVzLCB3aGVyZWFzIHRoZSBsb29wIGFib3ZlIGlzIGNvbm5lY3RpbmcgYWZmZWN0ZWROb2Rlc1xuXHRcdFx0Ly8gdG8gb3RoZXJzLlxuXHRcdFx0aWYgKGFmZmVjdGVkTm9kZXNBcGV4ZXMubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Ly8gU3RvcmVzIHRoZSBzZXJpZXMgb2YgY29udGFpbmVycyB0aGF0IGFueSBvZiB0aGUgbmV3bHkgZGlzY292ZXJlZFxuXHRcdFx0XHQvLyBwb3NzaWJseSBhZmZlY3RlZCBub2RlcyBtdXN0IGhhdmUgaW4gdGhlaXIgY29udGFpbm1lbnQgbGlzdFxuXHRcdFx0XHQvLyBpbiBvcmRlciB0byBiZSBpbmNsdWRlZCBpbiB0aGUgXCJhZmZlY3RlZE5vZGVzXCIgYXJyYXkuXG5cdFx0XHRcdGNvbnN0IGFwZXhDb250YWluZXJzID0gYWZmZWN0ZWROb2Rlc0FwZXhlc1xuXHRcdFx0XHRcdC5tYXAobm9kZSA9PiBub2RlLmNvbnRhaW5lcilcblx0XHRcdFx0XHQuZmlsdGVyKChub2RlKTogbm9kZSBpcyBOb2RlID0+IG5vZGUgIT09IG51bGwpXG5cdFx0XHRcdFx0LmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNoZWNrUm9vdCA9IGFwZXhDb250YWluZXJzLmxlbmd0aCA9PT0gMDtcblx0XHRcdFx0Y29uc3QgaXNCZWxvd0FuQXBleENvbnRhaW5lciA9IChub2RlOiBOb2RlKSA9PlxuXHRcdFx0XHRcdG5vZGUuY29udGFpbm1lbnQuc29tZShuID0+IGFwZXhDb250YWluZXJzLmluY2x1ZGVzKG4pKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3Qgc2Nzck5vZGUgb2YgYWZmZWN0ZWROb2Rlc0FwZXhlcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIFBhdHRlcm4gYW5kIFVSSSByZXNvbHV0aW9uIGRvZXNuJ3Qgb2NjdXIgaW4gdGhlXG5cdFx0XHRcdFx0Ly8gTm9kZSBncmFwaCwgc28gd2hlbiB0aGUgbm9kZSdzIHN1YmplY3QgaXNuJ3QgXG5cdFx0XHRcdFx0Ly8gYW4gaWRlbnRpZmllciwgd2UgZG9uJ3QgYWRkIGFueSBlZGdlcyB0byBpdC5cblx0XHRcdFx0XHRpZiAoIShzY3NyTm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcikpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBpZGVudHMgPSB0aGlzLm5vZGVJbmRleC5nZXRBc3NvY2lhdGVkSWRlbnRpZmllcnMoc2Nzck5vZGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgaWRlbnQgb2YgaWRlbnRzKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHByZWRlY2Vzc29ycyA9IHRoaXMubm9kZUluZGV4LmdldE5vZGVzQnlJZGVudGlmaWVyKGlkZW50KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBwcmVkZWNlc3NvciBvZiBwcmVkZWNlc3NvcnMpXG5cdFx0XHRcdFx0XHRcdGlmIChjaGVja1Jvb3QgfHwgaXNCZWxvd0FuQXBleENvbnRhaW5lcihwcmVkZWNlc3NvcikpXG5cdFx0XHRcdFx0XHRcdFx0cHJlZGVjZXNzb3IuYWRkRWRnZVN1Y2Nlc3NvcihzY3NyTm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZXJlJ3Mgbm8gYWN0aXZlIHRyYW5zYWN0aW9uIHRoZSBjb3JyZXNwb25kcyB0byB0aGUgaW5wdXRcblx0XHRcdC8vIGRvY3VtZW50LCB0aGUgbW9zdCBsaWtlbHkgcmVhc29uIGlzIHRoYXQgYW4gZW50aXJlIGRvY3VtZW50XG5cdFx0XHQvLyBpcyBiZWluZyBpbmNsdWRlZCBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdFx0XHRpZiAodHhuKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IG1heWJlRGVhZEVkZ2Ugb2YgdHhuLmRlc3RhYmxpemVkRWRnZXMpXG5cdFx0XHRcdFx0aWYgKG1heWJlRGVhZEVkZ2UuZnJhZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0XHRtYXliZURlYWRFZGdlLnByZWRlY2Vzc29yLmRpc3Bvc2VFZGdlKG1heWJlRGVhZEVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBtYXliZURlYWROb2RlIG9mIHR4bi5kZXN0YWJpbGl6ZWROb2Rlcylcblx0XHRcdFx0XHRpZiAobWF5YmVEZWFkTm9kZS5kZWNsYXJhdGlvbnMuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRtYXliZURlYWROb2RlLmRpc3Bvc2UoKTtcblx0XHRcdFx0XHRcdHRoaXMubm9kZUluZGV4LmRlbGV0ZShtYXliZURlYWROb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFBvcHVsYXRlIG5vZGVDYWNoZSB3aXRoIGFueSBuZXdseSBjcmVhdGVkIG5vZGVzLlxuXHRcdFx0Zm9yIChjb25zdCBhZmZlY3RlZE5vZGUgb2YgYWZmZWN0ZWROb2Rlcylcblx0XHRcdHtcblx0XHRcdFx0YWZmZWN0ZWROb2RlLnNvcnRPdXRib3VuZHMoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGFmZmVjdGVkVXJpID0gYWZmZWN0ZWROb2RlLnVyaS50b1N0cmluZygpO1xuXHRcdFx0XHRjb25zdCBjYWNoZWROb2RlID0gdGhpcy5ub2RlSW5kZXguZ2V0Tm9kZUJ5VXJpKGFmZmVjdGVkVXJpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjYWNoZWROb2RlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNhY2hlZE5vZGUgIT09IGFmZmVjdGVkTm9kZSlcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLm5vZGVJbmRleC51cGRhdGUoYWZmZWN0ZWROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLm5vZGVJbmRleC5zZXQoYWZmZWN0ZWRVcmksIGFmZmVjdGVkTm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuc2FuaXRpemUoYWZmZWN0ZWROb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBsb2coKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUubG9nKFwiLS0tLSBJTlRFUk5BTCBHUkFQSCBSRVBSRVNFTlRBVElPTiAtLS0tXCIpO1xuXHRcdFx0Zm9yIChjb25zdCBub2RlIG9mIHRoaXMubm9kZUluZGV4LmVhY2hOb2RlKCkpXG5cdFx0XHRcdGNvbnNvbGUubG9nKG5vZGUudG9TdHJpbmcodHJ1ZSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBzZXR1cCBmb3IgdGhlIGludmFsaWRhdGUgYW5kIHJldmFsaWRhdGUgbWV0aG9kcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIG1ldGhvZFNldHVwKHJvb3Q6IERvY3VtZW50IHwgU3RhdGVtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IGRvY3VtZW50ID0gcm9vdCBpbnN0YW5jZW9mIERvY3VtZW50ID9cblx0XHRcdFx0cm9vdCA6XG5cdFx0XHRcdHJvb3QuZG9jdW1lbnQ7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gcm9vdCBpbnN0YW5jZW9mIERvY3VtZW50ID9cblx0XHRcdFx0ZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQoKSA6XG5cdFx0XHRcdGRvY3VtZW50LmVhY2hEZXNjZW5kYW50KHJvb3QsIHRydWUpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4geyBkb2N1bWVudCwgaXRlcmF0b3IgfTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogUmVwb3J0cyBhbnkgTm9kZS1sZXZlbCBmYXVsdHMgZGV0ZWN0ZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBzYW5pdGl6ZShub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdC8vIENoZWNrIGZvciBmYXVsdHkgcmVmcmVzaCB0eXBlc1xuXHRcdFx0Ly8gVGhpcyBjYW4gb25seSBoYXBwZW4gb24gbm9uLWluZml4IHNwYW5zXG5cdFx0XHRpZiAoIShub2RlLmRlY2xhcmF0aW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgaW5zdGFuY2VvZiBTcGFuKSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzbXRzID0gbm9kZS5zdGF0ZW1lbnRzO1xuXHRcdFx0Y29uc3Qgc210c1JlZnJlc2ggPSBzbXRzLmZpbHRlcihzbXQgPT4gc210LmlzUmVmcmVzaCk7XG5cdFx0XHRjb25zdCBzbXRzQW5ub3RhdGVkID0gc210cy5maWx0ZXIoc210ID0+IHNtdC5hbGxBbm5vdGF0aW9ucy5sZW5ndGggPiAwKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNtdHNSZWZyZXNoLmxlbmd0aCA+IDAgJiYgc210c0Fubm90YXRlZC5sZW5ndGggPiAwKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzbXRzUmVmcmVzaClcblx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChuZXcgRmF1bHQoXG5cdFx0XHRcdFx0XHRGYXVsdHMuVHlwZUNhbm5vdEJlUmVmcmVzaGVkLFxuXHRcdFx0XHRcdFx0c210KSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCBvZiBhbGwgbm9kZXMgdGhhdFxuXHRcdCAqIGhhdmUgYmVlbiBsb2FkZWQgaW50byB0aGUgcHJvZ3JhbSwgaW5kZXhlZFxuXHRcdCAqIGJ5IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0J3MgVVJJLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgbm9kZUluZGV4OiBOb2RlSW5kZXg7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgR3JhcGhUcmFuc2FjdGlvbiBpbnN0YW5jZSBpbiB0aGUgY2FzZVxuXHRcdCAqIHdoZW4gYW4gZWRpdCB0cmFuc2FjdGlvbiBpcyB1bmRlcndheS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGFjdGl2ZVRyYW5zYWN0aW9ucyA9IG5ldyBNYXA8RG9jdW1lbnQsIEdyYXBoVHJhbnNhY3Rpb24+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VyaWFsaXplcyB0aGUgR3JhcGggaW50byBhIGZvcm1hdCBzdWl0YWJsZVxuXHRcdCAqIGZvciBkZWJ1Z2dpbmcgYW5kIGNvbXBhcmluZyBhZ2FpbnN0IGJhc2VsaW5lcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZUluZGV4LnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRjbGFzcyBHcmFwaFRyYW5zYWN0aW9uXG5cdHtcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gYXJyYXkgb2YgTm9kZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBhbnlcblx0XHQgKiB1bmRlcmx5aW5nIFNwYW4gb2JqZWN0cywgZHVlIHRvIHRoZWlyIHJlbW92YWwgaW5cblx0XHQgKiB0aGUgaW52YWxpZGF0aW9uIHBoYXNlLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGRlc3RhYmlsaXplZE5vZGVzOiBOb2RlW10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gYXJyYXkgb2YgRmFucyB0aGF0IG5vIGxvbmdlciBoYXZlIGFueVxuXHRcdCAqIHVuZGVybHlpbmcgU3BhbiBvYmplY3RzLCBkdWUgdG8gdGhlaXIgcmVtb3ZhbCBpblxuXHRcdCAqIHRoZSBpbnZhbGlkYXRpb24gcGhhc2UuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZGVzdGFibGl6ZWRFZGdlczogSHlwZXJFZGdlW10gPSBbXTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBEZWJ1ZyB1dGlsaXR5LlxuXHQgKi9cblx0ZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXM6IE5vZGVbXSlcblx0e1xuXHRcdHJldHVybiBcIlxcblwiICsgbm9kZXMubWFwKG5vZGUgPT4gbm9kZS50b1N0cmluZyh0cnVlKSkuam9pbihcIlxcblwiKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2luZ2xlIE5vZGUgY29udGFpbmVkIHdpdGhpblxuXHQgKiB0aGUgUHJvZ3JhbSdzIEdyYXBoLiBOb2RlcyBhcmUgbG9uZy1saXZlZCwgcmVmZXJlbnRpYWxseVxuXHQgKiBzaWduaWZpY2FudCBvYmplY3RzIHRoYXQgcGVyc2lzdCBiZXR3ZWVuIGVkaXQgZnJhbWVzLlxuXHQgKiBcblx0ICogTm9kZXMgYXJlIGNvbm5lY3RlZCBpbiBhIGdyYXBoIG5vdCBieSBlZGdlcywgYnV0IGJ5XG5cdCAqIEh5cGVyRWRnZXMuIEEgSHlwZXJFZGdlIChmcm9tIGdyYXBoIHRoZW9yeSkgaXMgc2ltaWxhciBcblx0ICogdG8gYSBkaXJlY3RlZCBlZGdlIGluIHRoYXQgaXQgaGFzIGEgc2luZ2xlIHByZWRlY2Vzc29yLFxuXHQgKiBidXQgZGlmZmVycyBpbiB0aGF0IGl0IGhhcyBtdWx0aXBsZSBzdWNjZXNzb3JzLlxuXHQgKiBcblx0ICogSXQgaXMgbmVjZXNzYXJ5IGZvciBOb2RlcyB0byBiZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlclxuXHQgKiBpbiB0aGlzIHdheSwgaW4gb3JkZXIgZm9yIGZ1cnRoZXIgcGhhc2VzIGluIHRoZSBwaXBlbGluZVxuXHQgKiB0byBleGVjdXRlIHRoZSB2YXJpb3VzIGtpbmRzIG9mIHBvbHltb3JwaGljIHR5cGVcblx0ICogcmVzb2x1dGlvbi5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBOb2RlXG5cdHtcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRjb250YWluZXI6IE5vZGUgfCBudWxsLFxuXHRcdFx0ZGVjbGFyYXRpb246IFNwYW4gfCBJbmZpeFNwYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3BhbiA9IGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgU3BhbiA/XG5cdFx0XHRcdGRlY2xhcmF0aW9uIDogXG5cdFx0XHRcdGRlY2xhcmF0aW9uLmNvbnRhaW5pbmdTcGFuO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSBzcGFuLnN0YXRlbWVudC5kb2N1bWVudDtcblx0XHRcdHRoaXMuc3RhbXAgPSB0aGlzLmRvY3VtZW50LnZlcnNpb247XG5cdFx0XHR0aGlzLl9kZWNsYXJhdGlvbnMgPSBuZXcgU2V0KFtkZWNsYXJhdGlvbl0pO1xuXHRcdFx0dGhpcy5zdWJqZWN0ID0gZGVjbGFyYXRpb24uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdHRoaXMubmFtZSA9IFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKHRoaXMuc3ViamVjdCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuaXNMaXN0SW50cmluc2ljID0gXG5cdFx0XHRcdHRoaXMuc3ViamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIgJiZcblx0XHRcdFx0dGhpcy5zdWJqZWN0LmlzTGlzdDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29udGFpbmVyVHlwZVBhdGggPSBjb250YWluZXIgIT09IG51bGwgP1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50LnNsaWNlKCkucmV2ZXJzZSgpLm1hcChuID0+IG4ubmFtZSkgOlxuXHRcdFx0XHRbXTtcblx0XHRcdFxuXHRcdFx0dGhpcy50eXBlUGF0aCA9IGNvbnRhaW5lclR5cGVQYXRoLmNvbmNhdCh0aGlzLm5hbWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5kZWNsYXJhdGlvbnMuc2l6ZSA9PT0gMClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRoaXMuY29udGFpbmVyKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmFkZFJvb3ROb2RlKHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5jb250YWluZXIuX2NvbnRlbnRzLnNldCh0aGlzLm5hbWUsIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHQvLy9pZiAoIShkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIFNwYW4pKVxuXHRcdFx0Ly8vXHRyZXR1cm4gdGhpcztcblx0XHRcdC8vL1xuXHRcdFx0Ly8vY29uc3QgaWRlbnRpZmllciA9IGRlY2xhcmF0aW9uLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmICghKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSlcblx0XHRcdC8vL1x0cmV0dXJuIHRoaXM7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2NvbnN0IGNvbnRhaW5lclBhdHRlcm4gPSAoKCkgPT5cblx0XHRcdC8vL3tcblx0XHRcdC8vL1x0Zm9yIChjb25zdCBkZWNsIG9mIHRoaXMuY29udGFpbmVyLmRlY2xhcmF0aW9ucylcblx0XHRcdC8vL1x0XHRpZiAoZGVjbC5ib3VuZGFyeS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdC8vL1x0XHRcdHJldHVybiBkZWNsLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHQvLy99KSgpO1xuXHRcdFx0Ly8vXG5cdFx0XHQvLy9pZiAoIWNvbnRhaW5lclBhdHRlcm4pXG5cdFx0XHQvLy9cdHJldHVybiB0aGlzO1xuXHRcdFx0Ly8vXG5cdFx0XHQvLy9mb3IgKGNvbnN0IG5meCBvZiBjb250YWluZXJQYXR0ZXJuLmdldEluZml4ZXMoSW5maXhGbGFncy5wb3B1bGF0aW9uKSlcblx0XHRcdC8vL1x0Zm9yIChjb25zdCBpZGVudCBvZiBuZngubGhzLmVhY2hTdWJqZWN0KCkpXG5cdFx0XHQvLy9cdFx0aWYgKGlkZW50LmZ1bGxOYW1lID09PSBpZGVudGlmaWVyLmZ1bGxOYW1lKVxuXHRcdFx0Ly8vXHRcdFx0Ly9yZXR1cm4gKHRoaXMuY29udGFpbmVySW5maXggPSBuZngpLCB0aGlzO1xuXHRcdFx0Ly8vXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgdGhpcyBOb2RlLCBhbmQgYWxsIGl0cyBjb250ZW50cyBmcm9tIHRoZSBncmFwaC5cblx0XHQgKi9cblx0XHRkaXNwb3NlKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jb250YWluZXIgPT09IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcCA9IE5vZGUucm9vdE5vZGVzLmdldCh0aGlzLmRvY3VtZW50KTtcblx0XHRcdFx0aWYgKG1hcClcblx0XHRcdFx0XHRtYXAuZGVsZXRlKHRoaXMubmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHRoaXMuY29udGFpbmVyLl9jb250ZW50cy5kZWxldGUodGhpcy5uYW1lKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpYiBvZiB0aGlzLl9pbmJvdW5kcylcblx0XHRcdFx0aWIucmVtb3ZlU3VjY2Vzc29yKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiByZWN1cnNlKG5vZGU6IE5vZGUpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgZWRnZSBvZiBub2RlLl9vdXRib3VuZHMpXG5cdFx0XHRcdFx0bm9kZS5kaXNwb3NlRWRnZShlZGdlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgY29udGFpbmVkTm9kZSBvZiBub2RlLl9jb250ZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0XHRyZWN1cnNlKGNvbnRhaW5lZE5vZGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTWFudWFsIG1lbW9yeSBtYW5hZ2VtZW50IGdvaW5nIG9uIGhlcmUuXG5cdFx0XHRcdC8vIENsZWFyaW5nIG91dCB0aGUgU2V0cyBpcyBwcm9iYWJseSB1bm5lY2Vzc2FyeVxuXHRcdFx0XHQvLyBiZWNhdXNlIHRoZSBHQyB3b3VsZCBjYXRjaCBpdCBhbnl3YXlzLCBidXRcblx0XHRcdFx0Ly8gdGhlc2UgY2FsbHMgYXJlIGhlcmUganVzdCB0byBiZSBzYWZlLlxuXHRcdFx0XHQvLyBJdCdzIHN0aWxsIHJlcXVpcmVkIHRoYXQgd2UgY2xlYXIgb3V0IHRoZSBpbmJvdW5kc1xuXHRcdFx0XHQvLyBmcm9tIHRoZSBub2RlcyB0byB3aGljaCB0aGlzIG9uZSBpcyBjb25uZWN0ZWQuXG5cdFx0XHRcdG5vZGUuX2RlY2xhcmF0aW9ucy5jbGVhcigpO1xuXHRcdFx0XHRub2RlLl9pbmJvdW5kcy5jbGVhcigpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZWN1cnNlKHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgSHlwZXJFZGdlIGZyb20gdGhpcyBOb2RlJ3Ncblx0XHQgKiBzZXQgb2Ygb3V0Ym91bmRzLlxuXHRcdCAqIFxuXHRcdCAqIEB0aHJvd3MgSW4gdGhlIGNhc2Ugd2hlbiB0aGUgc3BlY2lmaWVkIEh5cGVyRWRnZSBpc1xuXHRcdCAqIG5vdCBvd25lZCBieSB0aGlzIE5vZGUuXG5cdFx0ICovXG5cdFx0ZGlzcG9zZUVkZ2UoZWRnZTogSHlwZXJFZGdlKVxuXHRcdHtcblx0XHRcdGlmIChlZGdlLnByZWRlY2Vzc29yICE9PSB0aGlzKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZEFyZ3VtZW50KCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGlkeCA9IHRoaXMuX291dGJvdW5kcy5pbmRleE9mKGVkZ2UpO1xuXHRcdFx0dGhpcy5fb3V0Ym91bmRzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNjc3Igb2YgZWRnZS5zdWNjZXNzb3JzKVxuXHRcdFx0XHRzY3NyLm5vZGUuX2luYm91bmRzLmRlbGV0ZShlZGdlKTtcblx0XHRcdFxuXHRcdFx0ZWRnZS5jbGVhckZyYWdtZW50cygpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBjb250YWluZXI6IE5vZGUgfCBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluIHRoZSBjYXNlIHdoZW4gdGhpcyBub2RlIGlzIGEgZGlyZWN0IGRlc2NlbmRlbnQgb2YgYVxuXHRcdCAqIHBhdHRlcm4gbm9kZSwgYW5kIHRoYXQgcGF0dGVybiBoYXMgcG9wdWxhdGlvbiBpbmZpeGVzLFxuXHRcdCAqIGFuZCB0aGlzIG5vZGUgZGlyZWN0bHkgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRob3NlIGluZml4ZXMsXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSBnZXRzIGEgcmVmZXJlbmNlIHRvIHNhaWQgY29ycmVzcG9uZGluZyBpbmZpeC5cblx0XHQgKi9cblx0XHRnZXQgY29udGFpbmVySW5maXgoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGZsYWcgPSBJbmZpeEZsYWdzLnBvcHVsYXRpb247XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmNvbnRhaW5lciAhPT0gbnVsbClcblx0XHRcdFx0aWYgKHRoaXMuY29udGFpbmVyLnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgbmZ4IG9mIHRoaXMuY29udGFpbmVyLnN1YmplY3QuZ2V0SW5maXhlcyhmbGFnKSlcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgaWRlbnQgb2YgbmZ4Lmxocy5lYWNoU3ViamVjdCgpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmZ4O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IHN1YmplY3Q6IFN1YmplY3Q7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IHVyaSgpXG5cdFx0e1xuXHRcdFx0Ly8gQmVjYXVzZSB0aGUgVVJJIG9mIHRoZSBkb2N1bWVudCBjYW4gY2hhbmdlLCB3ZSBuZWVkIHRvIFxuXHRcdFx0Ly8gbWFrZSBzdXJlIGl0J3Mgbm90IGhhcmQgY29kZWQgaW50byB0aGUgbm9kZSBpbnN0YW5jZS5cblx0XHRcdGNvbnN0IG91dFVyaSA9IHRoaXMuZG9jdW1lbnQuc291cmNlVXJpLmV4dGVuZFR5cGUodGhpcy50eXBlUGF0aCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmxhc3RVcmkgIT09IG51bGwpXG5cdFx0XHRcdGlmIChvdXRVcmkuZXF1YWxzKHRoaXMubGFzdFVyaSkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubGFzdFVyaTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMubGFzdFVyaSA9IG91dFVyaTtcblx0XHR9XG5cdFx0XG5cdFx0cHJpdmF0ZSBsYXN0VXJpOiBVcmkgfCBudWxsID0gbnVsbDtcblx0XHRwcml2YXRlIHJlYWRvbmx5IHR5cGVQYXRoOiByZWFkb25seSBzdHJpbmdbXTtcblx0XHRcblx0XHQvKiogU3RvcmVzIHRoZSBkb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoaXMgTm9kZS4gKi9cblx0XHRyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQ7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgc3RhbXA6IFZlcnNpb25TdGFtcDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGlzIE5vZGUgaGFzIGJlZW4gZXhwbGljaXRseSBkZWZpbmVkIGFzXG5cdFx0ICogYSBsaXN0IGludHJpbnNpYy5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc0xpc3RJbnRyaW5zaWM6IGJvb2xlYW47XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgTm9kZSBoYXMgYmVlbiBleHBsaWNpdGx5IGRlZmluZWQgYXMgYSBsaXN0XG5cdFx0ICogZXh0cmluc2ljLiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB0aGlzIHByb3BlcnR5IGluIGFuZCBvZiBpdHNlbGYgaXNcblx0XHQgKiBub3Qgc3VmZmljaWVudCB0byBkZXRlcm1pbmUgd2hldGhlciBhbnkgY29ycmVzcG9uZGluZyB0eXBlIGlzXG5cdFx0ICogYWN0dWFsbHkgYSBsaXN0IChmdWxsIHR5cGUgYW5hbHlzaXMgaXMgcmVxdWlyZWQgdG8gbWFrZSB0aGlzIGNvbmNsdXNpb24pLlxuXHRcdCAqL1xuXHRcdGdldCBpc0xpc3RFeHRyaW5zaWMoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgb2Igb2YgdGhpcy5vdXRib3VuZHMpXG5cdFx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIG9iLmZyYWdtZW50cylcblx0XHRcdFx0XHRpZiAoc291cmNlLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBJZGVudGlmaWVyKVxuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZS5ib3VuZGFyeS5zdWJqZWN0LmlzTGlzdClcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgXCJvcHBvc2l0ZSBzaWRlIG9mIHRoZSBsaXN0XCIuXG5cdFx0ICogXG5cdFx0ICogSWYgdGhpcyBOb2RlIHJlcHJlc2VudHMgYSBsaXN0IGludHJpbnNpYyB0eXBlLCB0aGlzIHByb3BlcnR5IGdldHNcblx0XHQgKiBhIHJlZmVyZW5jZSB0byB0aGUgTm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvcnJlc3BvbmRpbmdcblx0XHQgKiBleHRyaW5zaWMgc2lkZS5cblx0XHQgKiBcblx0XHQgKiBJZiB0aGlzIE5vZGUgcmVwcmVzZW50cyBhbnl0aGluZyB0aGF0ICppc24ndCogYSBsaXN0IGludHJpbnNpYyB0eXBlLFxuXHRcdCAqIHRoZSBwcm9wZXJ0eSBnZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBOb2RlIHRoYXQgcmVwcmVzZW50cyB0aGVcblx0XHQgKiBjb3JyZXNwb25kaW5nIGludHJpbnNpYyBzaWRlICh3aGV0aGVyIHRoZSBub2RlIGlzIGEgbGlzdCBvciBub3QpLlxuXHRcdCAqIFxuXHRcdCAqIEdldHMgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgbGlzdCBpbnRyaW5zaWNcblx0XHQgKiBvciBleHRyaW5zaWMgTm9kZSB0byBjb25uZWN0LlxuXHRcdCAqL1xuXHRcdGdldCBpbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UoKTogTm9kZSB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5zdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcilcblx0XHRcdFx0Zm9yIChjb25zdCBhZGphY2VudCBvZiB0aGlzLmFkamFjZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0XHRpZiAoYWRqYWNlbnQuc3ViamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIpXG5cdFx0XHRcdFx0XHRpZiAoYWRqYWNlbnQuc3ViamVjdC50eXBlTmFtZSA9PT0gdGhpcy5zdWJqZWN0LnR5cGVOYW1lKVxuXHRcdFx0XHRcdFx0XHRpZiAoYWRqYWNlbnQuc3ViamVjdC5pc0xpc3QgIT09IHRoaXMuaXNMaXN0SW50cmluc2ljKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBhZGphY2VudDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc2V0IG9mIGRlY2xhcmF0aW9uLXNpZGUgU3BhbiBpbnN0YW5jZXMgdGhhdFxuXHRcdCAqIGNvbXBvc2UgdGhpcyBOb2RlLiBJZiB0aGlzIHRoZSBzaXplIG9mIHRoaXMgc2V0IHdlcmUgdG9cblx0XHQgKiByZWFjaCB6ZXJvLCB0aGUgTm9kZSB3b3VsZCBiZSBtYXJrZWQgZm9yIGRlbGV0aW9uLlxuXHRcdCAqIChOb2RlIGNsZWFudXAgdXNlcyBhIHJlZmVyZW5jZSBjb3VudGVkIGNvbGxlY3Rpb25cblx0XHQgKiBtZWNoYW5pc20gdGhhdCB1c2VzIHRoZSBzaXplIG9mIHRoaXMgc2V0IGFzIGl0J3MgZ3VpZGUpLlxuXHRcdCAqIFxuXHRcdCAqIE5vdGUgdGhhdCBhbHRob3VnaCB0aGUgdHlwZSBvZiB0aGlzIGZpZWxkIGlzIGRlZmluZWQgYXNcblx0XHQgKiBcIlNldDxTcGFuIHwgSW5maXhTcGFuPlwiLCBpbiBwcmFjdGljZSwgaXQgaXMgZWl0aGVyIGEgc2V0XG5cdFx0ICogb2YgU3BhbiBpbnN0YW5jZXMsIG9yIGEgc2V0IGNvbnRhaW5pbmcgb25lIHNpbmdsZVxuXHRcdCAqIEluZml4U3BhbiBpbnN0YW5jZS4gVGhpcyBpcyBiZWNhdXNlIGl0J3MgcG9zc2libGUgdG8gaGF2ZVxuXHRcdCAqIGZyYWdtZW50cyBvZiBhIHR5cGUgZGVjbGFyZWQgaW4gbXVsdGlwbGUgcGxhY2VzIGluXG5cdFx0ICogYSBkb2N1bWVudCwgaG93ZXZlciwgSW5maXhTcGFucyBjYW4gb25seSBleGlzdCBpbiBvbmVcblx0XHQgKiBwbGFjZS5cblx0XHQgKi9cblx0XHRnZXQgZGVjbGFyYXRpb25zKCk6IFJlYWRvbmx5U2V0PFNwYW4gfCBJbmZpeFNwYW4+XG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RlY2xhcmF0aW9ucztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfZGVjbGFyYXRpb25zOiBTZXQ8U3BhbiB8IEluZml4U3Bhbj47XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkRGVjbGFyYXRpb24oc3BhbjogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHR0aGlzLl9kZWNsYXJhdGlvbnMuYWRkKHNwYW4pO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZW1vdmVEZWNsYXJhdGlvbihzcGFuOiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHdhc0RlbGV0ZWQgPSB0aGlzLl9kZWNsYXJhdGlvbnMuZGVsZXRlKHNwYW4pO1xuXHRcdFx0aWYgKHdhc0RlbGV0ZWQpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbGwgb2YgdGhlIGFubm90YXRpb25zIHRoYXQgZXhpc3Qgb24gdGhlIHNhbWVcblx0XHRcdFx0Ly8gc3RhdGVtZW50IGFzIHRoZSBvbmUgdGhhdCBjb250YWlucyB0aGUgZGVjbGFyYXRpb24gdGhhdFxuXHRcdFx0XHQvLyB3YXMgcmVtb3ZlZC4gTm90ZSB0aGF0IHRoaXMgd29uJ3QgbWVzcyB1cCBmcmFnbWVudGVkXG5cdFx0XHRcdC8vIHR5cGVzLiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhlIHNpdHVhdGlvbiB3aGVuIHRoZSBmaXJzdFxuXHRcdFx0XHQvLyBzdGF0ZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBmb2xsb3dpbmcgZG9jdW1lbnQ6XG5cdFx0XHRcdC8vIFxuXHRcdFx0XHQvLyBBLCBCIDogWCwgWVxuXHRcdFx0XHQvLyBBLCBDIDogWCwgWVxuXHRcdFx0XHQvLyBcblx0XHRcdFx0Ly8gU3RhdGVtZW50cyBhcmUgcmVtb3ZlZCBhdG9taWNhbGx5LCBzbyB3aGVuIHRoZSBzdGF0ZW1lbnRcblx0XHRcdFx0Ly8gaXMgcmVtb3ZlZCwgdGhpcyB3aWxsIHJlc3VsdCBpbiAyIGNhbGxzIHRvIHRoaXMgbWV0aG9kOiBvbmUgZm9yXG5cdFx0XHRcdC8vIHRoZSBmaXJzdCBcIkFcIiwgYW5kIG9uZSBmb3IgdGhlIFwiQlwiLiBXaGVuIHRoZSBzZWNvbmQgY2FsbCBpcyBtYWRlLFxuXHRcdFx0XHQvLyB0aGUgYXNzb2NpYXRlZCBhbm5vdGF0aW9ucyB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHJlbW92ZWQuXG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gdGhpcy5fb3V0Ym91bmRzLmxlbmd0aDsgaS0tID4gMDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBvYiA9IHRoaXMuX291dGJvdW5kc1tpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGFubm8gb2Ygc3Bhbi5zdGF0ZW1lbnQuYWxsQW5ub3RhdGlvbnMpXG5cdFx0XHRcdFx0XHRvYi5yZW1vdmVGcmFnbWVudChhbm5vKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAob2IuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdHRoaXMuX291dGJvdW5kcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdGF0ZW1lbnRzIHRoYXRcblx0XHQgKiBjb250YWluIHRoaXMgTm9kZS5cblx0XHQgKi9cblx0XHRnZXQgc3RhdGVtZW50cygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoXG5cdFx0XHRcdEFycmF5LmZyb20odGhpcy5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdFx0Lm1hcChkZWNsID0+IGRlY2wuc3RhdGVtZW50KVxuXHRcdFx0XHRcdC5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgcmVhZG9ubHkgbWFwIG9mIE5vZGVzIHRoYXQgYXJlIGNvbnRhaW5lZFxuXHRcdCAqIGJ5IHRoaXMgbm9kZSBpbiB0aGUgY29udGFpbm1lbnQgaGllcmFyY2h5LlxuXHRcdCAqL1xuXHRcdGdldCBjb250ZW50cygpOiBOb2RlTWFwXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnRzO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9jb250ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBOb2RlPigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSByZWFkb25seSBuYW1lIG9mIE5vZGVzIHRoYXQgYXJlIGFkamFjZW50XG5cdFx0ICogdG8gdGhpcyBOb2RlIGluIHRoZSBjb250YWlubWVudCBoaWVyYXJjaHkuXG5cdFx0ICovXG5cdFx0Z2V0IGFkamFjZW50cygpOiBOb2RlTWFwXG5cdFx0e1xuXHRcdFx0Y29uc3QgYWRqYWNlbnROb2RlcyA9IHRoaXMuY29udGFpbmVyID9cblx0XHRcdFx0dGhpcy5jb250YWluZXIuY29udGVudHMgOlxuXHRcdFx0XHR0aGlzLmdldFJvb3ROb2RlcygpO1xuXHRcdFx0XG5cdFx0XHQvLyBGaWx0ZXIgdGhpcyBub2RlIG91dCBvZiB0aGUgcmVzdWx0IHNldCwgYmVjYXVzZVxuXHRcdFx0Ly8gTm9kZXMgY2Fubm90IGJlIGFkamFjZW50IHRvIHRoZW1zZWx2ZXMuXG5cdFx0XHRjb25zdCBvdXQgPSBuZXcgTWFwPHN0cmluZywgTm9kZT4oKTtcblx0XHRcdGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIGFkamFjZW50Tm9kZXMpXG5cdFx0XHRcdGlmIChub2RlICE9PSB0aGlzKVxuXHRcdFx0XHRcdG91dC5zZXQobmFtZSwgbm9kZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSAyLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mXG5cdFx0ICogdGhlIHBvcnRhYmlsaXR5IGluZml4ZXMgdGhhdCBoYXZlIGJlZW4gZGVmaW5lZCB3aXRoaW5cblx0XHQgKiB0aGlzIG5vZGUsIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBjb3JyZXNwb25kaW5nIHRvXG5cdFx0ICogYSB1bmlxdWUgcG9ydGFiaWxpdHkgaW5maXgsIGFuZCB0aGUgc2Vjb25kIGRpbWVuc2lvblxuXHRcdCAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG5hbWVzIGRlZmluZWQgd2l0aGluIHRoYXQgaW5maXguXG5cdFx0ICogXG5cdFx0ICogRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcblx0XHQgKiAvPCA6IEEsIEIsIEM+PCA6IEQsIEUsIEY+IDogPz8/XG5cdFx0ICogXG5cdFx0ICogVGhlIGZvbGxvd2luZyByZXN1bHQgd291bGQgYmUgcHJvZHVjZWQ6XG5cdFx0ICogW1tcIkFcIiwgXCJCXCIsIFwiQ1wiXSwgW1wiRFwiLCBcIkVcIiwgXCJGXCJdXVxuXHRcdCAqL1xuXHRcdGdldCBwb3J0YWJpbGl0eVRhcmdldHMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9wb3J0YWJpbGl0eVRhcmdldHMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wb3J0YWJpbGl0eVRhcmdldHM7XG5cdFx0XHRcblx0XHRcdGlmICghKHRoaXMuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcG9ydGFiaWxpdHlUYXJnZXRzID0gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IGlkZW50aWZpZXJBcnJheXMgPSB0aGlzLnN1YmplY3Rcblx0XHRcdFx0LmdldEluZml4ZXMoSW5maXhGbGFncy5wb3J0YWJpbGl0eSlcblx0XHRcdFx0Lm1hcChuZnggPT4gT2JqZWN0LmZyZWV6ZShBcnJheS5mcm9tKG5meC5yaHMuZWFjaFN1YmplY3QoKSlcblx0XHRcdFx0XHQubWFwKGlkZW50ID0+IGlkZW50LnR5cGVOYW1lKSkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5fcG9ydGFiaWxpdHlUYXJnZXRzID0gT2JqZWN0LmZyZWV6ZShpZGVudGlmaWVyQXJyYXlzKTtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfcG9ydGFiaWxpdHlUYXJnZXRzOiByZWFkb25seSAocmVhZG9ubHkgc3RyaW5nW10pW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHNldCBvZiBub2RlcyB0aGF0IGFyZSBtYXRjaGVkIGJ5XG5cdFx0ICogcGF0dGVybnMgb2YgYWRqYWNlbnQgbm9kZXMuXG5cdFx0ICogXG5cdFx0ICogKE5vdGUgdGhhdCB0aGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgYW5ub3RhdGlvbnNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIGEgcGF0dGVybiBjYW5ub3QgYmVcblx0XHQgKiBwb2x5bW9ycGhpYylcblx0XHQgKi9cblx0XHRnZXRQYXR0ZXJuTm9kZXNNYXRjaGluZyhub2RlczogTm9kZVtdKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dE5vZGVzOiBOb2RlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoaXMgZG9lc24ndCB3b3JrIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBpZlxuXHRcdFx0Ly8gYSBub2RlIGhhcyBiZWVuIG1hcmtlZCBhcyBjcnVmdCBhdCB0aGlzIHBvaW50LlxuXHRcdFx0Ly8gVGhpcyBtZXRob2QgbWF5IHJldHVybiBqdW5rIHJlc3VsdHMgaW4gdGhlXG5cdFx0XHQvLyBjYXNlIHdoZW4gb25lIG9mIHRoZSByZXF1aXJlZCBub2RlcyBoYXNcblx0XHRcdC8vIGJlZW4gbWFya2VkIGFzIGNydWZ0IChidXQgdGhlbiwgd291bGRuJ3QgdGhlXG5cdFx0XHQvLyBpbmNvbWluZyBub2RlIGFsc28gYmUgY3J1ZnQ/KVxuXHRcdFx0Ly9cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBub2RlIG9mIHRoaXMuYWRqYWNlbnRzLnZhbHVlcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAobm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHVub3JwaGFuZWQgPSBub2RlLm91dGJvdW5kc1xuXHRcdFx0XHRcdFx0LmZpbHRlcihvYiA9PiBvYi5zdWNjZXNzb3JzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0XHQubWFwKG9iID0+IG9iLnN1Y2Nlc3NvcnNbMF0ubm9kZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVub3JwaGFuZWQubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVub3JwaGFuZWQubGVuZ3RoID09PSBub2Rlcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRpZiAodW5vcnBoYW5lZC5ldmVyeShub2RlID0+IG5vZGVzLmluY2x1ZGVzKG5vZGUpKSlcblx0XHRcdFx0XHRcdFx0b3V0Tm9kZXMucHVzaCguLi51bm9ycGhhbmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0Tm9kZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gaW1tdXRhYmxlIHNldCBvZiBIeXBlckVkZ2VzIGZyb20gYWRqYWNlbnRcblx0XHQgKiBvciBjb250YWluZWQgTm9kZXMgdGhhdCByZWZlcmVuY2UgdGhpcyBOb2RlLiBcblx0XHQgKiBcblx0XHQgKiAoVGhlIG9yZGVyaW5nIG9mIGluYm91bmRzIGlzbid0IGltcG9ydGFudCwgYXNcblx0XHQgKiB0aGV5IGhhdmUgbm8gcGh5c2ljYWwgcmVwcmVzZW50YXRpb24gaW4gdGhlXG5cdFx0ICogZG9jdW1lbnQsIHdoaWNoIGlzIHdoeSB0aGV5J3JlIHN0b3JlZCBpbiBhIFNldFxuXHRcdCAqIHJhdGhlciB0aGFuIGFuIGFycmF5Lilcblx0XHQgKi9cblx0XHRnZXQgaW5ib3VuZHMoKTogUmVhZG9ubHlTZXQ8SHlwZXJFZGdlPlxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9pbmJvdW5kcztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfaW5ib3VuZHMgPSBuZXcgU2V0PEh5cGVyRWRnZT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IG9mIEh5cGVyRWRnZXMgdGhhdCBjb25uZWN0IHRoaXMgTm9kZSB0b1xuXHRcdCAqIG90aGVycywgYmVpbmcgZWl0aGVyIGFkamFjZW50cywgb3IgTm9kZXMgdGhhdFxuXHRcdCAqIGV4aXN0cyBzb21ld2hlcmUgaW4gdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeS5cblx0XHQgKi9cblx0XHRnZXQgb3V0Ym91bmRzKCk6IHJlYWRvbmx5IEh5cGVyRWRnZVtdXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX291dGJvdW5kcztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfb3V0Ym91bmRzOiBIeXBlckVkZ2VbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIFNvcnRzIHRoZSBvdXRib3VuZCBIeXBlckVkZ2VzLCBzbyB0aGF0IHRoZXkncmUgb3JkZXJpbmdcblx0XHQgKiBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHdheSB0aGVpciBjb3JyZXNwb25kaW5nXG5cdFx0ICogYW5ub3RhdGlvbnMgYXBwZWFyIGluIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHNvcnRPdXRib3VuZHMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9vdXRib3VuZHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9vdXRib3VuZHMubGVuZ3RoID09PSAxKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBlZGdlID0gdGhpcy5fb3V0Ym91bmRzWzBdO1xuXHRcdFx0XHRpZiAoZWRnZS5mcmFnbWVudHMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZWRnZUxvb2t1cCA9IG5ldyBNYXA8SHlwZXJFZGdlLCBbU3RhdGVtZW50LCBudW1iZXJdPigpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5fb3V0Ym91bmRzKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHNyYyBvZiBlZGdlLmZyYWdtZW50cy52YWx1ZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHNtdCA9IHNyYy5zdGF0ZW1lbnQ7XG5cdFx0XHRcdFx0Y29uc3QgbGluZU51bSA9IHNtdC5kb2N1bWVudC5nZXRMaW5lTnVtYmVyKHNtdCk7XG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdUdXBsZSA9IGVkZ2VMb29rdXAuZ2V0KGVkZ2UpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChleGlzdGluZ1R1cGxlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdTdG10ID0gZXhpc3RpbmdUdXBsZVswXTtcblx0XHRcdFx0XHRcdGNvbnN0IGV4aXN0aW5nU3RtdElkeCA9IGV4aXN0aW5nVHVwbGVbMV07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChsaW5lTnVtIDwgZXhpc3RpbmdTdG10SWR4KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRleGlzdGluZ1R1cGxlWzBdID0gZXhpc3RpbmdTdG10O1xuXHRcdFx0XHRcdFx0XHRleGlzdGluZ1R1cGxlWzFdID0gZXhpc3RpbmdTdG10SWR4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRnZUxvb2t1cC5zZXQoZWRnZSwgW3NtdCwgbGluZU51bV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTb3J0IHRoZSBvdXRwdXQgZWRnZXMgaW4gdGhlIGFycmF5LCBzbyB0aGF0IHRoZSBzb3J0aW5nIG9mXG5cdFx0XHQvLyB0aGUgYXJyYXkgYWxpZ25zIHdpdGggdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHVuZGVybHlpbmdcblx0XHRcdC8vIHNwYW5zIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdHRoaXMuX291dGJvdW5kcy5zb3J0KChlZGdlQSwgZWRnZUIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHR1cGxlQSA9IGVkZ2VMb29rdXAuZ2V0KGVkZ2VBKTtcblx0XHRcdFx0Y29uc3QgdHVwbGVCID0gZWRnZUxvb2t1cC5nZXQoZWRnZUIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgb2JzID0gdGhpcy5fb3V0Ym91bmRzO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHR1cGxlQSA9PT0gdW5kZWZpbmVkIHx8IHR1cGxlQiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IFtzbXRBLCBzbXRJZHhBXSA9IHR1cGxlQTtcblx0XHRcdFx0Y29uc3QgW3NtdEIsIHNtdElkeEJdID0gdHVwbGVCO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgdGhlIHRvcC1tb3N0IHNwYW4gb2YgdGhlIHByZWRlY2Vzc29ycyBvZlxuXHRcdFx0XHQvLyB0aGUgZWRnZXMgYXJlIGxvY2F0ZWQgaW4gZGlmZmVyZW50IHN0YXRlbWVudHMsXG5cdFx0XHRcdC8vIGEgc2ltcGxlIGNvbXBhcmlzb24gb2YgdGhlIHN0YXRlbWVudCBpbmRleGVzXG5cdFx0XHRcdC8vIGlzIHBvc3NpYmxlLlxuXHRcdFx0XHRpZiAoc210SWR4QSA8IHNtdElkeEIpXG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNtdElkeEIgPCBzbXRJZHhBKVxuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgc3RhdGVtZW50IEEgYW5kIHN0YXRlbWVudCBCIFxuXHRcdFx0XHQvLyBhcmUgYWN0dWFsbHkgZXF1YWwuXG5cdFx0XHRcdGlmIChzbXRBICE9PSBzbXRCKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhbm5vcyA9IHNtdEEuYW5ub3RhdGlvbnM7XG5cdFx0XHRcdGNvbnN0IGZpbmRNaW5JbmRleCA9IChlZGdlOiBIeXBlckVkZ2UpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsZXQgbWluSWR4ID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzcmMgb2YgZWRnZS5mcmFnbWVudHMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHNyYyBpbnN0YW5jZW9mIEluZml4U3Bhbilcblx0XHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBpZHggPSBhbm5vcy5pbmRleE9mKHNyYyk7XG5cdFx0XHRcdFx0XHRpZiAoaWR4IDwgbWluSWR4KVxuXHRcdFx0XHRcdFx0XHRtaW5JZHggPSBpZHg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtaW5JZHggPT09IEluZmluaXR5KVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBtaW5JZHg7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBlZGdlQUlkeCA9IGZpbmRNaW5JbmRleChlZGdlQSk7XG5cdFx0XHRcdGNvbnN0IGVkZ2VCSWR4ID0gZmluZE1pbkluZGV4KGVkZ2VCKTtcblx0XHRcdFx0cmV0dXJuIGVkZ2VBSWR4IC0gZWRnZUJJZHg7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogQWRkcyBhIG5ldyBlZGdlIHRvIHRoZSBub2RlLCBvciB1cGRhdGVzIGFuIGV4aXN0aW5nIG9uZSB3aXRoXG5cdFx0ICogYSBuZXcgZnJhZ21lbnQuXG5cdFx0ICogXG5cdFx0ICogSWYgbm8gZWRnZSBleGlzdHMgZm9yIHRoZSBuZXcgZnJhZ21lbnQsIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuXHRcdCAqL1xuXHRcdGFkZEVkZ2VGcmFnbWVudChmcmFnbWVudDogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHRjb25zdCBpZGVudGlmaWVyID0gZnJhZ21lbnQuYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdGlmICghKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgaW5wdXQgc291cmNlIGlzIFwiYWxvbmVcIiwgaXQgbWVhbnMgdGhhdCBpdCByZWZlcnMgdG9cblx0XHRcdC8vIGEgc3RhdGVtZW50LWxldmVsIGFubm90YXRpb24gdGhhdCBoYXMgbm8gb3RoZXIgYW5ub3RhdGlvbnNcblx0XHRcdC8vIGJlc2lkZSBpdCAoZS5nLiBpbiBhbiBhbm5vdGF0aW9uIHN0cnVjdHVyZSBsb29raW5nIGxpa2UgXCJEOiBBMSwgQTJcIilcblx0XHRcdC8vIFRoaXMgaXMgcmVsZXZhbnQsIGJlY2F1c2UgaWYgdGhlIHNvdXJjZSBpcyBhbG9uZSwgaXQgYWxzbyBuZWVkc1xuXHRcdFx0Ly8gdG8gYmUgY29tcGFyZWQgYWdhaW5zdCBhbnkgdmlzaWJsZSB0b3RhbCBwYXR0ZXJucy5cblx0XHRcdGNvbnN0IHNvdXJjZUlzQWxvbmUgPVxuXHRcdFx0XHRmcmFnbWVudCBpbnN0YW5jZW9mIFNwYW4gJiYgXG5cdFx0XHRcdGZyYWdtZW50LnN0YXRlbWVudC5hbm5vdGF0aW9ucy5sZW5ndGggPT09IDE7XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkcyBhIGVkZ2UgdG8gaXQncyB0d28gYXBwbGljYWJsZSBzdWNjZXNzb3Igbm9kZXMuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGFwcGVuZCA9IChlZGdlOiBIeXBlckVkZ2UpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX291dGJvdW5kcy5wdXNoKGVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBzdWMgb2YgZWRnZS5zdWNjZXNzb3JzKVxuXHRcdFx0XHRcdHN1Yy5ub2RlLl9pbmJvdW5kcy5hZGQoZWRnZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGV4aXN0aW5nIG91dGJvdW5kIEh5cGVyRWRnZSwgd2UgY2FuXG5cdFx0XHQvLyBhZGQgdGhlIG5ldyBTcGFuIHRvIHRoZSBlZGdlJ3MgbGlzdCBvZiBTcGFucywgYW5kIHF1aXQuXG5cdFx0XHQvLyBUaGlzIHdvcmtzIHdoZXRoZXIgdGhlIGVkZ2UgaXMgZm9yIGEgdHlwZSBvciBwYXR0ZXJuLlxuXHRcdFx0Y29uc3QgZXhpc3RpbmdFZGdlID0gdGhpcy5fb3V0Ym91bmRzLmZpbmQoZWRnZSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZWRnZS5pZGVudGlmaWVyLnR5cGVOYW1lID09PSBpZGVudGlmaWVyLnR5cGVOYW1lO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGlmIChleGlzdGluZ0VkZ2UpXG5cdFx0XHR7XG5cdFx0XHRcdGV4aXN0aW5nRWRnZS5hZGRGcmFnbWVudChmcmFnbWVudCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN1Y2Nlc3NvcnM6IFN1Y2Nlc3NvcltdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGxldmVsIG9mIHRoaXMuZW51bWVyYXRlQ29udGFpbm1lbnQoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN1Y2Nlc3Nvck5vZGUgPSBcblx0XHRcdFx0XHRcdGxldmVsLmNvbnRhaW5lciAhPT0gbnVsbCAmJiBcblx0XHRcdFx0XHRcdGxldmVsLmNvbnRhaW5lciAhPT0gdGhpcyAmJlxuXHRcdFx0XHRcdFx0bGV2ZWwuY29udGFpbmVyLm5hbWUgPT09IGlkZW50aWZpZXIudHlwZU5hbWUgP1xuXHRcdFx0XHRcdFx0XHRsZXZlbC5jb250YWluZXIgOlxuXHRcdFx0XHRcdFx0XHRsZXZlbC5hZGphY2VudHMuZ2V0KGlkZW50aWZpZXIudHlwZU5hbWUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzdWNjZXNzb3JOb2RlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c3VjY2Vzc29ycy5wdXNoKG5ldyBTdWNjZXNzb3IoXG5cdFx0XHRcdFx0XHRcdHN1Y2Nlc3Nvck5vZGUsXG5cdFx0XHRcdFx0XHRcdGxldmVsLmxvbmdpdHVkZURlbHRhKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgYSBzaW5nbGUgc3VjY2Vzc29yIGluIHRoZSBjYXNlIHdoZW5cblx0XHRcdFx0XHRcdC8vIHRoZSBub2RlIGlzIGEgcGF0dGVybiBub2RlLCBiZWNhdXNlIHRoZSBhbm5vdGF0aW9ucyAod2hpY2hcblx0XHRcdFx0XHRcdC8vIGFyZSBldmVudHVhbGx5IGJlY29tZSBiYXNlcykgb2YgdGhlc2Ugbm9kZXMgZG8gbm90IGhhdmVcblx0XHRcdFx0XHRcdC8vIHBvbHltb3JwaGljIGJlaGF2aW9yLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0YXBwZW5kKG5ldyBIeXBlckVkZ2UodGhpcywgZnJhZ21lbnQsIHN1Y2Nlc3NvcnMpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gXG5cdFx0XHQvLyBSZWZyZXNoIHRoZSBzdW1zIGJlZm9yZSBxdWl0dGluZy5cblx0XHRcdC8vIFxuXHRcdFx0XG5cdFx0XHQvLy9jb25zdCBzdW1FZGdlRm9ySW5wdXRTcGFuSWR4ID0gdGhpcy5fb3V0Ym91bmRzLmZpbmRJbmRleChlZGdlID0+IFxuXHRcdFx0Ly8ve1xuXHRcdFx0Ly8vXHRpZiAoZWRnZS5raW5kID09PSBIeXBlckVkZ2VLaW5kLnN1bW1hdGlvbilcblx0XHRcdC8vL1x0XHRmb3IgKGNvbnN0IHNyYyBvZiBlZGdlLnNvdXJjZXMpXG5cdFx0XHQvLy9cdFx0XHRyZXR1cm4gc3JjLnN0YXRlbWVudCA9PT0gc210O1xuXHRcdFx0Ly8vXHRcblx0XHRcdC8vL1x0cmV0dXJuIGZhbHNlO1xuXHRcdFx0Ly8vfSk7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmIChzdW1FZGdlRm9ySW5wdXRTcGFuSWR4ID4gLTEpXG5cdFx0XHQvLy9cdHRoaXMuX291dGJvdW5kcy5zcGxpY2Uoc3VtRWRnZUZvcklucHV0U3BhbklkeCwgMSk7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmICghc291cmNlSXNBbG9uZSlcblx0XHRcdC8vL1x0Zm9yIChjb25zdCB7IGxvbmdpdHVkZURlbHRhLCBhZGphY2VudHMgfSBvZiB0aGlzLmVudW1lcmF0ZUNvbnRhaW5tZW50KCkpXG5cdFx0XHQvLy9cdFx0Zm9yIChjb25zdCBhZGphY2VudE5vZGUgb2YgYWRqYWNlbnRzLnZhbHVlcygpKVxuXHRcdFx0Ly8vXHRcdFx0aWYgKGFkamFjZW50Tm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdC8vL1x0XHRcdFx0aWYgKGFkamFjZW50Tm9kZS5zdWJqZWN0LmlzVG90YWwpXG5cdFx0XHQvLy9cdFx0XHRcdFx0aWYgKGFkamFjZW50Tm9kZS5zdWJqZWN0LnRlc3Qoc210LnN1bSkpXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRhcHBlbmQobmV3IEh5cGVyRWRnZShcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0c210LnN1bSxcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0W25ldyBTdWNjZXNzb3IoXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRcdFx0YWRqYWNlbnROb2RlLFxuXHRcdFx0Ly8vXHRcdFx0XHRcdFx0XHRcdGxvbmdpdHVkZURlbHRhKV0sXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRcdEh5cGVyRWRnZUtpbmQuc3VtbWF0aW9uKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGFkZEVkZ2VTdWNjZXNzb3Ioc3VjY2Vzc29yTm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCBpZGVudGlmaWVyID0gc3VjY2Vzc29yTm9kZS5zdWJqZWN0IGFzIElkZW50aWZpZXI7XG5cdFx0XHRpZiAoIShpZGVudGlmaWVyIGluc3RhbmNlb2YgSWRlbnRpZmllcikpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBvYiBvZiB0aGlzLm91dGJvdW5kcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKG9iLmlkZW50aWZpZXIudHlwZU5hbWUgIT09IHN1Y2Nlc3Nvck5vZGUubmFtZSlcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHNjc3JMb25nID0gc3VjY2Vzc29yTm9kZS51cmkudHlwZXMubGVuZ3RoO1xuXHRcdFx0XHRjb25zdCBwcmVkTG9uZyA9IG9iLnByZWRlY2Vzc29yLnVyaS50eXBlcy5sZW5ndGg7XG5cdFx0XHRcdG9iLmFkZFN1Y2Nlc3NvcihzdWNjZXNzb3JOb2RlLCBwcmVkTG9uZyAtIHNjc3JMb25nKTtcblx0XHRcdFx0c3VjY2Vzc29yTm9kZS5faW5ib3VuZHMuYWRkKG9iKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBlbnVtZXJhdGVPdXRib3VuZHMoKVxuXHRcdHtcblx0XHRcdC8vL2NvbnN0IHJlY3Vyc2UgPSAobm9kZTogTm9kZSkgPT5cblx0XHRcdC8vL3tcblx0XHRcdC8vL1x0Zm9yIChjb25zdCBlZGdlIG9mIG5vZGUub3V0Ym91bmRzKVxuXHRcdFx0Ly8vXHRcdGZvciAoY29uc3Qgc3VjY2Vzc29yIG9mIGVkZ2Uuc3VjY2Vzc29ycylcblx0XHRcdC8vL1x0XHRcdC8veWllbGQgeyBub2RlOiBcblx0XHRcdC8vL31cblx0XHRcdC8vL1xuXHRcdFx0Ly8veWllbGQgKnJlY3Vyc2UodGhpcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVudW1lcmF0ZXMgdXB3YXJkcyB0aHJvdWdoIHRoZSBjb250YWlubWVudFxuXHRcdCAqIGhpZXJhcmNoeSBvZiB0aGUgTm9kZXMgcHJlc2VudCBpbiB0aGlzIE5vZGUnc1xuXHRcdCAqIGNvbnRhaW5pbmcgZG9jdW1lbnQsIHlpZWxkaW5nIHRoZSBhZGphY2VudHMgYXRcblx0XHQgKiBldmVyeSBsZXZlbCwgYW5kIHRoZW4gY29udGludWVzIHRocm91Z2ggdG8gdGhlXG5cdFx0ICogcm9vdCBsZXZlbCBhZGphY2VudHMgb2YgZWFjaCBvZiB0aGUgZG9jdW1lbnQnc1xuXHRcdCAqIGRlcGVuZGVuY2llcy5cblx0XHQgKi9cblx0XHQqZW51bWVyYXRlQ29udGFpbm1lbnQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRvYyA9IHRoaXMuZG9jdW1lbnQ7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gZG9jLnByb2dyYW07XG5cdFx0XHRjb25zdCBkZXBzID0gcHJvZ3JhbS5kb2N1bWVudHMuZ2V0RGVwZW5kZW5jaWVzKGRvYyk7XG5cdFx0XHRsZXQgY3VycmVudExldmVsOiBOb2RlIHwgbnVsbCA9IHRoaXM7XG5cdFx0XHRsZXQgbG9uZ2l0dWRlQ291bnQgPSAwO1xuXHRcdFx0XG5cdFx0XHRkb1xuXHRcdFx0e1xuXHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0c291cmNlRG9jdW1lbnQ6IGRvYyxcblx0XHRcdFx0XHRjb250YWluZXI6IDxOb2RlIHwgbnVsbD5jdXJyZW50TGV2ZWwsXG5cdFx0XHRcdFx0YWRqYWNlbnRzOiBjdXJyZW50TGV2ZWwuYWRqYWNlbnRzLFxuXHRcdFx0XHRcdGxvbmdpdHVkZURlbHRhOiBsb25naXR1ZGVDb3VudCsrXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoKGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbC5jb250YWluZXIpICE9PSBudWxsKTtcblx0XHRcdFxuXHRcdFx0Ly8gTk9URTogVGhpcyBpcyBicm9rZW4uIEl0IG5lZWRzIHRvIGJlIHJlY3Vyc2l2ZS5cblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IGRlcHMubGVuZ3RoOyAtLWkgPiAwOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc291cmNlRG9jdW1lbnQgPSBkZXBzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdHNvdXJjZURvY3VtZW50LFxuXHRcdFx0XHRcdGNvbnRhaW5lcjogbnVsbCxcblx0XHRcdFx0XHRhZGphY2VudHM6IHRoaXMuZ2V0Um9vdE5vZGVzKHNvdXJjZURvY3VtZW50KSxcblx0XHRcdFx0XHRsb25naXR1ZGVEZWx0YTogbG9uZ2l0dWRlQ291bnRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgdGhhdCBzdG9yZXMgdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeVxuXHRcdCAqIG9mIHRoZSBOb2RlcyBwcmVzZW50IGluIHRoaXMgTm9kZSdzIGNvbnRhaW5pbmcgZG9jdW1lbnQsXG5cdFx0ICogeWllbGRpbmcgZWFjaCBjb250YWluZXJvZiB0aGlzIE5vZGUuXG5cdFx0ICovXG5cdFx0Z2V0IGNvbnRhaW5tZW50KClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fY29udGFpbm1lbnQgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jb250YWlubWVudDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRsZXQgY3VycmVudExldmVsOiBOb2RlIHwgbnVsbCA9IHRoaXM7XG5cdFx0XHR3aGlsZSAoKGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbC5jb250YWluZXIpICE9PSBudWxsKVxuXHRcdFx0XHRub2Rlcy5wdXNoKGN1cnJlbnRMZXZlbCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9jb250YWlubWVudCA9IE9iamVjdC5mcmVlemUobm9kZXMpO1xuXHRcdH1cblx0XHRwcml2YXRlIF9jb250YWlubWVudDogcmVhZG9ubHkgTm9kZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVtb3ZlRWRnZVNvdXJjZShzcmM6IFNwYW4gfCBJbmZpeFNwYW4pXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgaSA9IHRoaXMuX291dGJvdW5kcy5sZW5ndGg7IC0taSA+IDA7KVxuXHRcdFx0XHR0aGlzLl9vdXRib3VuZHNbaV0ucmVtb3ZlRnJhZ21lbnQoc3JjKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoaW5jbHVkZVBhdGggPSB0cnVlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlY2xzID0gQXJyYXkuZnJvbSh0aGlzLmRlY2xhcmF0aW9ucyk7XG5cdFx0XHRjb25zdCBzcGFucyA9IGRlY2xzLmZpbHRlcigocyk6IHMgaXMgU3BhbiA9PiBzIGluc3RhbmNlb2YgU3Bhbik7XG5cdFx0XHRjb25zdCBhbmNob3JzID0gZGVjbHMuZmlsdGVyKChhKTogYSBpcyBJbmZpeFNwYW4gPT4gYSBpbnN0YW5jZW9mIEluZml4U3Bhbik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNwYW5zVGV4dCA9IHNwYW5zLm1hcChzID0+IFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKHMpKS5qb2luKFwiLCBcIik7XG5cdFx0XHRjb25zdCBhbmNob3JUZXh0ID0gYW5jaG9ycy5tYXAoYSA9PiBTdWJqZWN0U2VyaWFsaXplci5mb3JJbnRlcm5hbChhKSkuam9pbihcIiwgXCIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBvYiA9IHRoaXMub3V0Ym91bmRzLmxlbmd0aDtcblx0XHRcdGNvbnN0IGliID0gdGhpcy5pbmJvdW5kcy5zaXplO1xuXHRcdFx0Y29uc3QgcGF0aCA9IGluY2x1ZGVQYXRoID8gdGhpcy51cmkudHlwZXMuam9pbihcIi9cIikgKyBcIiBcIiA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNpbXBsZSA9IFtcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0c3BhbnNUZXh0Lmxlbmd0aCA/IFwic3BhbnM9XCIgKyBzcGFuc1RleHQgOiBcIlwiLFxuXHRcdFx0XHRhbmNob3JUZXh0Lmxlbmd0aCA/IFwiYW5jaG9yPVwiICsgYW5jaG9yVGV4dCA6IFwiXCIsXG5cdFx0XHRcdFwib3V0PVwiICsgb2IsXG5cdFx0XHRcdFwiaW49XCIgKyBpYlxuXHRcdFx0XS5maWx0ZXIocyA9PiBzLnRyaW0oKSkuam9pbihcIiwgXCIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBmbXQgPSAoc3RyOiBzdHJpbmcpID0+IHN0ci5zcGxpdChcIlxcblwiKS5tYXAocyA9PiBcIlxcdFxcdFwiICsgcykuam9pbihcIlxcblwiKTtcblx0XHRcdGNvbnN0IG9ic1ZlcmJvc2UgPSB0aGlzLm91dGJvdW5kc1xuXHRcdFx0XHQubWFwKG9iID0+IGZtdChvYi50b1N0cmluZygpKSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGlic1ZlcmJvc2UgPSBBcnJheS5mcm9tKHRoaXMuaW5ib3VuZHMudmFsdWVzKCkpXG5cdFx0XHRcdC5tYXAoaWIgPT4gZm10KGliLnRvU3RyaW5nKCkpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdmVyYm9zZSA9IFxuXHRcdFx0XHRcIlxcblxcdE91dHM6XFxuXCIgKyBvYnNWZXJib3NlLmpvaW4oXCJcXG5cXG5cIikgK1xuXHRcdFx0XHRcIlxcblxcdEluczpcXG5cIiArIGlic1ZlcmJvc2Uuam9pbihcIlxcblxcblwiKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNpbXBsZSArIHZlcmJvc2U7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgYWRkUm9vdE5vZGUobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCBleGlzdGluZ1NldCA9IE5vZGUucm9vdE5vZGVzLmdldChub2RlLmRvY3VtZW50KTtcblx0XHRcdGlmIChleGlzdGluZ1NldClcblx0XHRcdHtcblx0XHRcdFx0ZXhpc3RpbmdTZXQuc2V0KG5vZGUubmFtZSwgbm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcCA9IG5ldyBNYXA8c3RyaW5nLCBOb2RlPigpO1xuXHRcdFx0XHRtYXAuc2V0KG5vZGUubmFtZSwgbm9kZSk7XG5cdFx0XHRcdE5vZGUucm9vdE5vZGVzLnNldChub2RlLmRvY3VtZW50LCBtYXApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlbW92ZVJvb3ROb2RlKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXhpc3RpbmdTZXQgPSBOb2RlLnJvb3ROb2Rlcy5nZXQobm9kZS5kb2N1bWVudCk7XG5cdFx0XHRpZiAoZXhpc3RpbmdTZXQpXG5cdFx0XHR7XG5cdFx0XHRcdGV4aXN0aW5nU2V0LmRlbGV0ZShub2RlLm5hbWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhpcyBpcyBzb21ld2hhdCByZWR1bmRhbnQgYXMgdGhlIHNldFxuXHRcdFx0XHQvLyBpcyBsaWtlbHkgZ29pbmcgdG8gYmUgR0MnZCBhd2F5IGFueXdheSBpblxuXHRcdFx0XHQvLyB0aGlzIGNhc2UuIEl0J3MgaGVyZSBmb3IgY29tcGxldGVuZXNzIHNha2UuXG5cdFx0XHRcdGlmIChleGlzdGluZ1NldC5zaXplID09PSAwKVxuXHRcdFx0XHRcdE5vZGUucm9vdE5vZGVzLmRlbGV0ZShub2RlLmRvY3VtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBnZXRSb290Tm9kZXMoZnJvbURvY3VtZW50PzogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZnJvbURvYyA9IGZyb21Eb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50O1xuXHRcdFx0Y29uc3Qgb3V0ID0gTm9kZS5yb290Tm9kZXMuZ2V0KGZyb21Eb2MpIHx8IG5ldyBNYXA8c3RyaW5nLCBOb2RlPigpO1xuXHRcdFx0cmV0dXJuIEhpZ2hlck9yZGVyLmNvcHkob3V0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgcm9vdE5vZGVzID0gbmV3IFdlYWtNYXA8RG9jdW1lbnQsIE1hcDxzdHJpbmcsIE5vZGU+PigpO1xuXHR9XG5cblx0dHlwZSBOb2RlTWFwID0gUmVhZG9ubHlNYXA8c3RyaW5nLCBOb2RlPjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBOb2RlSW5kZXhcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZURvY3VtZW50VXJpQ2hhbmdlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgZW50aXJlIGNhY2hlIHdoZW4gdGhlIFVSSSBvZiBhbnkgZG9jdW1lbnQgY2hhbmdlcy5cblx0XHRcdFx0Y29uc3QgbmV3VXJpU3RvcmUgPSBkYXRhLm5ld1VyaS5yZXRyYWN0VHlwZVRvKDApO1xuXHRcdFx0XHRjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLnVyaVRvTm9kZU1hcC5lbnRyaWVzKCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBbb2xkVXJpVGV4dCwgbm9kZV0gb2YgZW50cmllcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChub2RlLmRvY3VtZW50ICE9PSBkYXRhLmRvY3VtZW50KVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgb2xkVXJpID0gTm90Lm51bGwoVXJpLnRyeVBhcnNlKG9sZFVyaVRleHQpKTtcblx0XHRcdFx0XHRjb25zdCBuZXdVcmlUZXh0ID0gbmV3VXJpU3RvcmVcblx0XHRcdFx0XHRcdC5leHRlbmRUeXBlKG9sZFVyaS50eXBlcy5tYXAodCA9PiB0LnZhbHVlKSlcblx0XHRcdFx0XHRcdC50b1N0cmluZygpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMudXJpVG9Ob2RlTWFwLmRlbGV0ZShvbGRVcmlUZXh0KTtcblx0XHRcdFx0XHR0aGlzLnVyaVRvTm9kZU1hcC5zZXQobmV3VXJpVGV4dCwgbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBFbnVtZXJhdGVzIHRocm91Z2ggYWxsIE5vZGUgaW5zdGFuY2VzIHN0b3JlZFxuXHRcdCAqIGluIHRoZSBpbmRleC5cblx0XHQgKi9cblx0XHQqZWFjaE5vZGUoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLnVyaVRvTm9kZU1hcC52YWx1ZXMoKSlcblx0XHRcdFx0eWllbGQgbm9kZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgbnVtYmVyIG9mIG5vZGVzIHN0b3JlZCBpbiB0aGUgaW5kZXguXG5cdFx0ICovXG5cdFx0Z2V0IGNvdW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy51cmlUb05vZGVNYXAuc2l6ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgaW5kZXgsIGVzdGFibGlzaGluZyBhIGNhY2hlZCByZWxhdGlvbnNoaXBcblx0XHQgKiBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgdXJpIGFuZCB0aGUgc3BlY2lmaWVkIG5vZGUuXG5cdFx0ICovXG5cdFx0c2V0KHVyaTogVXJpIHwgc3RyaW5nLCBub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHVyaVRleHQgPSB0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiID8gdXJpIDogdXJpLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLnVyaVRvTm9kZU1hcC5zZXQodXJpVGV4dCwgbm9kZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZShub2RlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIFVwZGF0ZXMgdGhlIGluZGV4IGJ5IHJlZnJlc2hpbmcgaW4gdGhlIHNldCBvZiBpZGVudGlmaWVyc1xuXHRcdCAqIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIG5vZGUuXG5cdFx0ICovXG5cdFx0dXBkYXRlKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcGFzdElkZW50aWZpZXJzID0gdGhpcy5ub2Rlc1RvSWRlbnRpZmllcnNNYXAuZ2V0KG5vZGUpO1xuXHRcdFx0Y29uc3QgcHJlc2VudElkZW50aWZpZXJzID0gdGhpcy5nZXRBc3NvY2lhdGVkSWRlbnRpZmllcnMobm9kZSk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXN0SWRlbnRpZmllcnMgIT09IHVuZGVmaW5lZClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbaWR4LCBpZGVudF0gb2YgcGFzdElkZW50aWZpZXJzLmVudHJpZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChwcmVzZW50SWRlbnRpZmllcnMuaW5jbHVkZXMoaWRlbnQpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cGFzdElkZW50aWZpZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG1hcCA9IHRoaXMuaWRlbnRpZmllclRvTm9kZXNNYXAuZ2V0KGlkZW50KTtcblx0XHRcdFx0XHRpZiAobWFwID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRtYXAuZGVsZXRlKG5vZGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChtYXAuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRcdHRoaXMuaWRlbnRpZmllclRvTm9kZXNNYXAuZGVsZXRlKGlkZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGlkZW50aWZpZXIgb2YgcHJlc2VudElkZW50aWZpZXJzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBub2Rlc0ZvcklkZW50ID0gdGhpcy5pZGVudGlmaWVyVG9Ob2Rlc01hcC5nZXQoaWRlbnRpZmllcikgfHwgKCgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBvdXQgPSBuZXcgU2V0PE5vZGU+KCk7XG5cdFx0XHRcdFx0dGhpcy5pZGVudGlmaWVyVG9Ob2Rlc01hcC5zZXQoaWRlbnRpZmllciwgb3V0KTtcblx0XHRcdFx0XHRyZXR1cm4gb3V0O1xuXHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZXNGb3JJZGVudC5hZGQobm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMubm9kZXNUb0lkZW50aWZpZXJzTWFwLnNldChub2RlLCBwcmVzZW50SWRlbnRpZmllcnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXROb2RlQnlVcmkodXJpOiBVcmkgfCBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIgPyB1cmkgOiB1cmkudG9TdHJpbmcoKTtcblx0XHRcdHJldHVybiB0aGlzLnVyaVRvTm9kZU1hcC5nZXQodXJpVGV4dCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIG5vZGVzIHRoYXQgYXJlIGFzc29jaWF0ZWRcblx0XHQgKiB3aXRoIHRoZSBzcGVjaWZpZWQgaWRlbnRpZmllciB0aGF0IGV4aXN0IGF0IG9yIGJlbG93IHRoZSBzcGVjaWZpZWRcblx0XHQgKiBkZXB0aC4gXCJBc3NvY2lhdGVkXCIgbWVhbnMgdGhhdCB0aGUgaWRlbnRpZmllciBpcyBlaXRoZXIgZXF1aXZhbGVudFxuXHRcdCAqIHRvIHRoZSBOb2RlJ3MgbWFpbiBzdWJqZWN0LCBvciBpdCBpcyByZWZlcmVuY2VkIGluIG9uZSBvZiBpdCdzIGVkZ2VzLlxuXHRcdCAqL1xuXHRcdGdldE5vZGVzQnlJZGVudGlmaWVyKGlkZW50aWZlcjogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IHRoaXMuaWRlbnRpZmllclRvTm9kZXNNYXAuZ2V0KGlkZW50aWZlcik7XG5cdFx0XHRyZXR1cm4gb3V0ID8gQXJyYXkuZnJvbShvdXQpIDogW107XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBub2RlIGZyb20gdGhlIGluZGV4LCBpZiBpdCBleGlzdHMuXG5cdFx0ICovXG5cdFx0ZGVsZXRlKGRlYWROb2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgW3VyaSwgbm9kZV0gb2YgdGhpcy51cmlUb05vZGVNYXApXG5cdFx0XHRcdGlmIChub2RlID09PSBkZWFkTm9kZSlcblx0XHRcdFx0XHR0aGlzLnVyaVRvTm9kZU1hcC5kZWxldGUodXJpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZXhpc3RpbmdJZGVudGlmaWVycyA9IHRoaXMubm9kZXNUb0lkZW50aWZpZXJzTWFwLmdldChkZWFkTm9kZSk7XG5cdFx0XHRpZiAoZXhpc3RpbmdJZGVudGlmaWVycyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaWRlbnRpZmllciBvZiBleGlzdGluZ0lkZW50aWZpZXJzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBub2RlcyA9IHRoaXMuaWRlbnRpZmllclRvTm9kZXNNYXAuZ2V0KGlkZW50aWZpZXIpO1xuXHRcdFx0XHRpZiAobm9kZXMgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdG5vZGVzLmRlbGV0ZShkZWFkTm9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobm9kZXMuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHR0aGlzLmlkZW50aWZpZXJUb05vZGVzTWFwLmRlbGV0ZShpZGVudGlmaWVyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5ub2Rlc1RvSWRlbnRpZmllcnNNYXAuZGVsZXRlKGRlYWROb2RlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGlkZW50aWZpZXJzIGFzc29jaWF0ZWQgd2l0aFxuXHRcdCAqIHRoZSBzcGVjaWZpZWQgTm9kZS5cblx0XHQgKi9cblx0XHRnZXRBc3NvY2lhdGVkSWRlbnRpZmllcnMobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCBpZGVudGlmaWVyczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUuc3ViamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIpXG5cdFx0XHRcdGlkZW50aWZpZXJzLnB1c2gobm9kZS5zdWJqZWN0LnR5cGVOYW1lKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzbXQgb2Ygbm9kZS5zdGF0ZW1lbnRzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGFubm8gb2Ygc210LmFsbEFubm90YXRpb25zKVxuXHRcdFx0XHRcdGlmIChhbm5vLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBJZGVudGlmaWVyKVxuXHRcdFx0XHRcdFx0aWRlbnRpZmllcnMucHVzaChhbm5vLmJvdW5kYXJ5LnN1YmplY3QudHlwZU5hbWUpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gaWRlbnRpZmllcnM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCBvZiBhbGwgbm9kZXMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkIGludG8gdGhlIHByb2dyYW0sXG5cdFx0ICogaW5kZXhlZCBieSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdCdzIFVSSS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHVyaVRvTm9kZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBOb2RlPigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCB3aGljaCBpcyBpbmRleGVkIGJ5IGEgdW5pcXVlIGlkZW50aWZpZXIsIGFuZCB3aGljaCBhc1xuXHRcdCAqIHZhbHVlcyB0aGF0IGFyZSB0aGUgbm9kZXMgdGhhdCB1c2UgdGhhdCBpZGVudGlmaWVyLCBlaXRoZXIgYXMgYSBkZWNsYXJhdGlvblxuXHRcdCAqIG9yIGFuIGFubm90YXRpb24uXG5cdFx0ICogXG5cdFx0ICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjYWNoZSBpcyB0byBnZXQgYSBxdWljayBhbnN3ZXIgdG8gdGhlIHF1ZXN0aW9uOlxuXHRcdCAqIFwiV2UgYWRkZWQgYSBuZXcgaWRlbnRpZmllciBhdCBwb3NpdGlvbiBYIC4uLiB3aGF0IG5vZGVzIG1pZ2h0IHBvc3NpYmx5XG5cdFx0ICogaGF2ZSBiZWVuIGFmZmVjdGVkIGJ5IHRoaXM/XCJcblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGlkZW50aWZpZXJUb05vZGVzTWFwID0gbmV3IE1hcDxzdHJpbmcsIFNldDxOb2RlPj4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBtYXAgd2hpY2ggaXMgZXNzZW50aWFsbHkgYSByZXZlcnNlIG9mIGlkZW50aWZpZXJUb05vZGVzTWFwLlxuXHRcdCAqIFRoaXMgaXMgc28gdGhhdCB3aGVuIG5vZGVzIG5lZWQgdG8gYmUgZGVsZXRlZCBvciB1cGRhdGVkLCB3ZSBjYW5cblx0XHQgKiBxdWlja2x5IGZpbmQgdGhlIHBsYWNlIGluIGlkZW50aWZpZXJUb05vZGVzTWFwIHdoZXJlIHRoZSBub2RlIGhhc1xuXHRcdCAqIGJlZW4gcmVmZXJlbmNlZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IG5vZGVzVG9JZGVudGlmaWVyc01hcCA9IG5ldyBXZWFrTWFwPE5vZGUsIHN0cmluZ1tdPigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNlcmlhbGl6ZXMgdGhlIGluZGV4IGludG8gYSBmb3JtYXQgc3VpdGFibGVcblx0XHQgKiBmb3IgZGVidWdnaW5nIGFuZCBjb21wYXJpbmcgYWdhaW5zdCBiYXNlbGluZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnVyaVRvTm9kZU1hcC5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gXCIoZW1wdHkpXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dDogc3RyaW5nW10gPSBbXTtcblx0XHRcdGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHRoaXMudXJpVG9Ob2RlTWFwLmtleXMoKSkubWFwKHMgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdXJpID0gVXJpLnRyeVBhcnNlKHMpO1xuXHRcdFx0XHRyZXR1cm4gdXJpID8gdXJpLnRvU3RyaW5nKCkgOiBzO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20odGhpcy51cmlUb05vZGVNYXAudmFsdWVzKCkpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IGtleXMubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbaV0udG9TdHJpbmcoZmFsc2UpO1xuXHRcdFx0XHRvdXQucHVzaChgJHtrZXl9XFxuXFx0JHt2YWx1ZX1cXG5gKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0b3V0LnB1c2goXCIoSWRlbnRpZmllciBDYWNoZSlcIik7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2lkZW50aWZpZXIsIG5vZGVzXSBvZiB0aGlzLmlkZW50aWZpZXJUb05vZGVzTWFwKVxuXHRcdFx0e1xuXHRcdFx0XHRvdXQucHVzaChcIlxcdFwiICsgaWRlbnRpZmllcik7XG5cdFx0XHRcdG91dC5wdXNoKFwiXFx0XFx0OiBcIiArIEFycmF5LmZyb20obm9kZXMpXG5cdFx0XHRcdFx0Lm1hcChub2RlID0+IG5vZGUudXJpLnRvVHlwZVN0cmluZygpKVxuXHRcdFx0XHRcdC5qb2luKFwiLCBcIikpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0LmpvaW4oXCJcXG5cIikudHJpbSgpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgSHlwZXJFZGdlIGNvbm5lY3RzIGFuIG9yaWdpbiBwcmVkZWNlc3NvciBOb2RlIHRvIGEgc2VyaWVzIG9mXG5cdCAqIHN1Y2Nlc3NvciBOb2Rlcy4gRnJvbSBncmFwaCB0aGVvcnksIGEgXCJoeXBlciBlZGdlXCIgaXMgZGlmZmVyZW50XG5cdCAqIGZyb20gYW4gXCJlZGdlXCIgaW4gdGhhdCBpdCBjYW4gaGF2ZSBtYW55IHN1Y2Nlc3NvcnM6XG5cdCAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0h5cGVyZ3JhcGhcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBIeXBlckVkZ2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgTm9kZSBmcm9tIHdoZXJlIHRoZSBIeXBlckVkZ2UgY29ubmVjdGlvbiBiZWdpbnMuXG5cdFx0XHQgKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBkb2N1bWVudDpcblx0XHRcdCAqIFxuXHRcdFx0ICogRm9vXG5cdFx0XHQgKiBcdEJhciA6IEZvb1xuXHRcdFx0ICogXG5cdFx0XHQgKiBUd28gTm9kZSBvYmplY3RzIHdvdWxkIGJlIGNyZWF0ZWQsIG9uZSBmb3IgdGhlIGZpcnN0IGluc3RhbmNlXG5cdFx0XHQgKiBvZiBcIkZvb1wiLCBhbmQgYW5vdGhlciBmb3IgdGhlIGluc3RhbmNlIG9mIFwiQmFyXCIuIEEgSHlwZXJFZGdlXG5cdFx0XHQgKiB3b3VsZCBiZSBjcmVhdGVkIGJldHdlZW4gXCJCYXJcIiBhbmQgXCJGb29cIiwgYW5kIGl0J3Ncblx0XHRcdCAqIHByZWNlZGVzc29yIHdvdWxkIHJlZmVyIHRvIHRoZSBOb2RlIHJlcHJlc2VudGluZyB0aGVcblx0XHRcdCAqIG9jY3VyZW5jZSBvZiBcIkJhclwiLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBwcmVkZWNlc3NvcjogTm9kZSxcblx0XHRcdHNvdXJjZTogU3BhbiB8IEluZml4U3Bhbixcblx0XHRcdHN1Y2Nlc3NvcnM6IHJlYWRvbmx5IFN1Y2Nlc3NvcltdKVxuXHRcdHtcblx0XHRcdGlmICghKHNvdXJjZS5ib3VuZGFyeS5zdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcikpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3VjY2Vzc29yTm9kZXMgPSBzdWNjZXNzb3JzXG5cdFx0XHRcdC5tYXAoc2NzciA9PiBzY3NyLm5vZGUpXG5cdFx0XHRcdC5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG5cdFx0XHRcblx0XHRcdGlmIChzdWNjZXNzb3JOb2Rlcy5sZW5ndGggIT09IHN1Y2Nlc3NvcnMubGVuZ3RoKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuaWRlbnRpZmllciA9IHNvdXJjZS5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0dGhpcy5mcmFnbWVudHNNdXRhYmxlID0gW3NvdXJjZV07XG5cdFx0XHR0aGlzLnN1Y2Nlc3NvcnNNdXRhYmxlID0gc3VjY2Vzc29ycy5zbGljZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byBhZGQgYW5vdGhlciBmcmFnbWVudCB0byB0aGUgSHlwZXJFZGdlLlxuXHRcdCAqIFJlcG9ydHMgYSBmYXVsdCBpbnN0ZWFkIGluIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBcblx0XHQgKiBsaXN0IGNvbmZsaWN0IGJldHdlZW4gdGhlIHNvdXJjZSBwcm92aWRlZCBhbmQgdGhlXG5cdFx0ICogZXhpc3Rpbmcgc291cmNlcy4gKEkuZS4gb25lIG9mIHRoZSBzb3VyY2VzIGlzIGRlZmluZWRcblx0XHQgKiBhcyBhIGxpc3QsIGFuZCBhbm90aGVyIGlzIG5vdCkuXG5cdFx0ICovXG5cdFx0YWRkRnJhZ21lbnQoZnJhZ21lbnQ6IFNwYW4gfCBJbmZpeFNwYW4pXG5cdFx0e1xuXHRcdFx0Ly8vY29uc3QgaXNQYXR0ZXJuID0gdGhpcy5wcmVkZWNlc3Nvci5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybjtcblx0XHRcdC8vL2NvbnN0IGlzSW5maXggPSBzb3VyY2UgaW5zdGFuY2VvZiBJbmZpeFNwYW47XG5cdFx0XHQvLy9pZiAoaXNQYXR0ZXJuICE9PSBpc0luZml4KVxuXHRcdFx0Ly8vXHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZENhbGwoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZnJhZ21lbnRzTXV0YWJsZS5pbmNsdWRlcyhmcmFnbWVudCkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Ly8hIFRoZSBvcmRlcmluZyBvZiB0aGUgc291cmNlcyBpcyBub3QgYmVpbmcgaGFuZGxlZCBoZXJlLlxuXHRcdFx0XG5cdFx0XHR0aGlzLmZyYWdtZW50c011dGFibGUucHVzaChmcmFnbWVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBhbm5vdGF0aW9uLXNpZGUgU3BhbiBvciBJbmZpeFNwYW5cblx0XHQgKiBmcm9tIHRoaXMgZWRnZS5cblx0XHQgKi9cblx0XHRyZW1vdmVGcmFnbWVudChmcmFnbWVudDogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHRjb25zdCBmcmFnUG9zID0gdGhpcy5mcmFnbWVudHNNdXRhYmxlLmluZGV4T2YoZnJhZ21lbnQpO1xuXHRcdFx0aWYgKGZyYWdQb3MgPj0gMClcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNNdXRhYmxlLnNwbGljZShmcmFnUG9zLCAxKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y2xlYXJGcmFnbWVudHMoKVxuXHRcdHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzTXV0YWJsZS5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBzZXQgb2YgYW5ub3RhdGlvbi1zaWRlIFNwYW5zIG9yIGFubm90YXRpb24tc2lkZVxuXHRcdCAqIEluZml4U3BhbnMgdGhhdCBhcmUgcmVzcG9uc2libGUgZm9yIHRoZSBjb25jZXB0aW9uIG9mIHRoaXNcblx0XHQgKiBIeXBlckVkZ2UuXG5cdFx0ICogXG5cdFx0ICogVGhlIGFycmF5IGNvbnRhaW5zIGVpdGhlciBTcGFuIGluc3RhbmNlcyBvciBJbmZpeFNwYW4gaW5zdGFuY2VzLFxuXHRcdCAqIGJ1dCBuZXZlciBib3RoLiBJbiB0aGUgY2FzZSB3aGVuIHRoZSBhcnJheSBzdG9yZXMgU3BhbiBpbnN0YW5jZXMsXG5cdFx0ICogdGhlIGxvY2F0aW9uIG9mIHRob3NlIFNwYW5zIGFyZSBwb3RlbnRpYWxseSBzY2F0dGVyZWQgYWNyb3NzIG1hbnlcblx0XHQgKiBzdGF0ZW1lbnRzLlxuXHRcdCAqL1xuXHRcdGdldCBmcmFnbWVudHMoKTogcmVhZG9ubHkgKFNwYW4gfCBJbmZpeFNwYW4pW11cblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNNdXRhYmxlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGZyYWdtZW50c011dGFibGU6IChTcGFuIHwgSW5maXhTcGFuKVtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGFkZFN1Y2Nlc3Nvcihub2RlOiBOb2RlLCBsb25naXR1ZGU6IG51bWJlcilcblx0XHR7XG5cdFx0XHRpZiAoIXRoaXMuc3VjY2Vzc29yc011dGFibGUuZmluZChzY3NyID0+IHNjc3Iubm9kZSA9PT0gbm9kZSkpXG5cdFx0XHRcdHRoaXMuc3VjY2Vzc29yc011dGFibGUucHVzaChuZXcgU3VjY2Vzc29yKG5vZGUsIGxvbmdpdHVkZSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRyZW1vdmVTdWNjZXNzb3Iobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5zdWNjZXNzb3JzTXV0YWJsZS5sZW5ndGg7IGktLSA+IDA7KVxuXHRcdFx0XHRpZiAodGhpcy5zdWNjZXNzb3JzTXV0YWJsZVtpXS5ub2RlID09PSBub2RlKVxuXHRcdFx0XHRcdHRoaXMuc3VjY2Vzc29yc011dGFibGUuc3BsaWNlKGksIDEpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYWxsIHBvc3NpYmxlIHN1Y2Nlc3MgTm9kZXMgdG8gd2hpY2ggdGhlIHByZWRlY2Vzc29yIFxuXHRcdCAqIE5vZGUgaXMgcHJlZW1wdGl2ZWx5IGNvbm5lY3RlZCB2aWEgdGhpcyBIeXBlckVkZ2UuIFRoZSBcblx0XHQgKiBjb25uZWN0aW9uIGlzIHNhaWQgdG8gYmUgcHJlZW1wdGl2ZSwgYmVjYXVzZSB0aGUgY29ubmVjdGlvblxuXHRcdCAqIG1pZ2h0IGJlIGlnbm9yZWQgZHVyaW5nIHBvbHltb3JwaGljIG5hbWUgcmVzb2x1dGlvbi5cblx0XHQgKi9cblx0XHRnZXQgc3VjY2Vzc29ycygpOiByZWFkb25seSBTdWNjZXNzb3JbXVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN1Y2Nlc3NvcnNNdXRhYmxlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHN1Y2Nlc3NvcnNNdXRhYmxlOiBTdWNjZXNzb3JbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBIeXBlckVkZ2UgaGFzIG5vIGltbWVkaWF0ZWx5IHJlc29sdmFibGVcblx0XHQgKiBzdWNjZXNzb3JzLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHN1YmplY3QgYmVpbmcgcmVmZXJyZWQgdG8gYnlcblx0XHQgKiB0aGlzIEh5cGVyRWRnZSBpcyBlaXRoZXIgYSB0eXBlIGFsaWFzIHdoaWNoIHdpbGwgYmUgbWF0Y2hlZCBieVxuXHRcdCAqIGEgcGF0dGVybiwgb3IganVzdCBhIHBsYWluIG9sZCBmYXVsdC5cblx0XHQgKi9cblx0XHRnZXQgaXNEYW5nbGluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3VjY2Vzc29ycy5sZW5ndGggPT09IDA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzb3VyY2VzIG9mIHRoZSBlZGdlXG5cdFx0ICogY2F1c2VzIGluY3JlbWVudGF0aW9uIG9mIHRoZSBsaXN0IGRpbWVuc2lvbmFsaXR5IG9mIHRoZSB0eXBlXG5cdFx0ICogdGhhdCBjb3JyZXNwb25uZHMgdG8gdGhpcyBIeXBlckVkZ2UncyBwcmVkZWNlc3NvciBOb2RlLlxuXHRcdCAqIFxuXHRcdCAqIChOb3RlIHRoYXQgYWxsIHNvdXJjZXMgbmVlZCB0byBhZ3JlZSBvbiB0aGlzIHZhbHVlLCBhbmQgdGhlIFxuXHRcdCAqIG5lY2Vzc2FyeSBmYXVsdHMgYXJlIGdlbmVyYXRlZCB0byBlbnN1cmUgdGhhdCB0aGlzIGlzIGFsd2F5c1xuXHRcdCAqIHRoZSBjYXNlLilcblx0XHQgKi9cblx0XHRnZXQgaXNMaXN0KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHNvdXJjZSBvZiB0aGlzLmZyYWdtZW50cylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3ViID0gc291cmNlLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHRcdHJldHVybiBzdWIgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmIHN1Yi5pc0xpc3Q7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHR1YWwgdmFsdWUgb2YgYW4gRWRnZSByZXByZXNlbnRzIGRpZmZlcmVudCB0aGluZ3Ncblx0XHQgKiBkZXBlbmRpbmcgb24gdGhlIEVkZ2UncyAqa2luZCogcHJvcGVydHkuXG5cdFx0ICogXG5cdFx0ICogSWYgKmtpbmQqIGlzICpsaXRlcmFsKiwgdGhlIHRleHR1YWwgdmFsdWUgaXMgdGhlIGdpdmVuIG5hbWVcblx0XHQgKiBvZiB0aGUgdHlwZSBiZWluZyByZWZlcmVuY2VkLCBmb3IgZXhhbXBsZSBcIlN0cmluZ1wiIG9yXG5cdFx0ICogXCJFbXBsb3llZVwiLlxuXHRcdCAqIFxuXHRcdCAqIElmICpraW5kKiBpcyAqY2F0ZWdvcmljYWwqLCB0aGUgdGV4dHVhbCB2YWx1ZSBpcyBhbiBhbGlhcyB0aGF0XG5cdFx0ICogd2lsbCBsYXRlciBiZSByZXNvbHZlZCB0byBhIHNwZWNpZmljIHR5cGUsIG9yIHNldCBvZiB0eXBlcywgZm9yXG5cdFx0ICogZXhhbXBsZSBcIjEwY21cIiAocHJlc3VtYWJseSByZXNvbHZpbmcgdG8gXCJVbml0XCIpIG9yXG5cdFx0ICogXCJ1c2VyQGVtYWlsLmNvbVwiIChwcmVzdW1hYmxlIHJlc29sdmluZyB0byBcIkVtYWlsXCIpLlxuXHRcdCAqIFxuXHRcdCAqIElmICpraW5kKiBpcyAqc3VtbWF0aW9uKiAsIHRoZSB0ZXh0dWFsIHZhbHVlIGlzIHRoZSByYXdcblx0XHQgKiBsaXRlcmFsIHRleHQgb2YgdGhlIGFubm90YXRpb24gZm91bmQgaW4gdGhlIGRvY3VtZW50LiBGb3Jcblx0XHQgKiBleGFtcGxlLCBpZiB0aGUgZG9jdW1lbnQgaGFkIHRoZSBjb250ZW50OlxuXHRcdCAqIFxuXHRcdCAqIEZvbywgQmFyIDogZm9vLCBiYXJcblx0XHQgKiBcblx0XHQgKiBUaGlzIHdvdWxkIHJlc3VsdCBpbiB0d28gbm9kZXMgbmFtZWQgXCJGb29cIiBhbmQgXCJCYXJcIixcblx0XHQgKiBlYWNoIHdpdGggdGhlaXIgb3duIEh5cGVyRWRnZXMgd2hvc2UgdGV4dHVhbCB2YWx1ZXNcblx0XHQgKiB3b3VsZCBib3RoIGJlOiBcImZvbywgYmFyXCIuIEluIHRoZSBjYXNlIG9mIGEgZnJhZ21lbnRlZFxuXHRcdCAqIHR5cGUsIHRoZSBsYXN0IHN1bSBpbiBkb2N1bWVudCBvcmRlciBpcyBjb3VudGVkIGFzIHRoZVxuXHRcdCAqIHRleHR1YWwgdmFsdWUuIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZm9sbG93aW5nXG5cdFx0ICogZG9jdW1lbnQ6XG5cdFx0ICogXG5cdFx0ICogVCA6IGFhLCBiYlxuXHRcdCAqIFQgOiB4eCwgeXlcblx0XHQgKiBcblx0XHQgKiBUaGUgXCJUXCIgbm9kZSB3b3VsZCBoYXZlIGEgSHlwZXJFZGdlIHdpdGggYSB0ZXh0dWFsIFxuXHRcdCAqIHZhbHVlIGJlaW5nIFwieHgsIHl5XCIuXG5cdFx0ICogXG5cdFx0ICogVGhlICotb3ZlcmxheSBraW5kcyBoYXZlIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpZGVudGlmaWVyOiBJZGVudGlmaWVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgc3BlY2lmaWMgcGFydCBvZiB0aGVcblx0XHQgKiBwcmVkZWNlc3NvciB3aGVyZSB0aGlzIEh5cGVyRWRnZSBiZWdpbnMuXG5cdFx0ICovXG5cdFx0Z2V0IHByZWRlY2Vzc29yT3JpZ2luKCk6IEh5cGVyRWRnZU9yaWdpblxuXHRcdHtcblx0XHRcdC8vISBJcyB0aGlzIHN0aWxsIG5lY2Vzc2FyeT9cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZnJhZ21lbnRzTXV0YWJsZS5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy5mcmFnbWVudHNNdXRhYmxlWzBdO1xuXHRcdFx0aWYgKHNyYyBpbnN0YW5jZW9mIFNwYW4pXG5cdFx0XHRcdHJldHVybiBIeXBlckVkZ2VPcmlnaW4uc3RhdGVtZW50O1xuXHRcdFx0XG5cdFx0XHRpZiAoc3JjLmNvbnRhaW5pbmdJbmZpeC5pc1BvcnRhYmlsaXR5KVxuXHRcdFx0XHRyZXR1cm4gSHlwZXJFZGdlT3JpZ2luLnBvcnRhYmlsaXR5SW5maXg7XG5cdFx0XHRcblx0XHRcdGlmIChzcmMuY29udGFpbmluZ0luZml4LmlzUG9wdWxhdGlvbilcblx0XHRcdFx0cmV0dXJuIEh5cGVyRWRnZU9yaWdpbi5wb3B1bGF0aW9uSW5maXg7XG5cdFx0XHRcblx0XHRcdGlmIChzcmMuY29udGFpbmluZ0luZml4LmlzUGF0dGVybilcblx0XHRcdFx0cmV0dXJuIEh5cGVyRWRnZU9yaWdpbi5wYXR0ZXJuSW5maXg7XG5cdFx0XHRcblx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBIeXBlckVkZ2UsXG5cdFx0ICogc3VpdGFibGUgZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XCJWYWx1ZT1cIiArIHRoaXMuaWRlbnRpZmllcixcblx0XHRcdFx0XCJQcmVkZWNlc3NvcnM9XCIgKyB0aGlzLnByZWRlY2Vzc29yLm5hbWUsXG5cdFx0XHRcdFwiU3VjY2Vzc29ycz1cIiArIHRoaXMuc3VjY2Vzc29yc1xuXHRcdFx0XHRcdC5tYXAobiA9PiBuLm5vZGUubmFtZSArIFwiIDw8IFwiICsgbi5sb25naXR1ZGUpXG5cdFx0XHRcdFx0LmpvaW4oXCIsIFwiKSxcblx0XHRcdFx0XCJTb3VyY2VzPVwiICsgQXJyYXkuZnJvbSh0aGlzLmZyYWdtZW50cylcblx0XHRcdFx0XHQubWFwKHNyYyA9PiBzcmMuYm91bmRhcnkuc3ViamVjdCkuam9pbihcIiwgXCIpLFxuXHRcdFx0XHRcIi0tLVwiXG5cdFx0XHRdLmpvaW4oXCJcXG5cIik7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgU3VjY2Vzc29yXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IG5vZGU6IE5vZGUsXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSB0aGUgbnVtYmVyIG9mIGxldmVscyBvZiBkZXB0aCBpbiB0aGUgY29udGFpbm1lbnRcblx0XHRcdCAqIGhpZXJhcmNoeSB0aGF0IG5lZWQgdG8gYmUgY3Jvc3NlZCBpbiBvcmRlciBmb3IgdGhlIGNvbnRhaW5pbmdcblx0XHRcdCAqIEh5cGVyRWRnZSB0byBiZSBlc3RhYmxpc2hlZCBiZXR3ZWVuIHRoZSBwcmVkZWNlc3NvciBhbmRcblx0XHRcdCAqIHRoaXMgc3VjY2Vzc29yLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBsb25naXR1ZGU6IG51bWJlcilcblx0XHR7IH1cblx0XHRcblx0XHRyZWFkb25seSBzdGFtcCA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHBsYWNlIGluIGEgc3RhdGVtZW50IHdoZXJlIGEgSHlwZXJFZGdlIHN0YXJ0cy5cblx0ICogKEh5cGVyRWRnZXMgY2FuIHN0YXJ0IGVpdGhlciBhdCB0aGUgc3RhdGVtZW50IGxldmVsLCBvciB3aXRoaW5cblx0ICogdmFyaW91cyBraW5kcyBvZiBpbmZpeGVzLilcblx0ICovXG5cdGV4cG9ydCBlbnVtIEh5cGVyRWRnZU9yaWdpblxuXHR7XG5cdFx0c3RhdGVtZW50LFxuXHRcdHBvcHVsYXRpb25JbmZpeCxcblx0XHRwb3J0YWJpbGl0eUluZml4LFxuXHRcdHBhdHRlcm5JbmZpeFxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IG1hcmtzIG91dCB0aGUgbG9jYXRpb24gb2YgYW4gaW5maXggSWRlbnRpZmVyIHdpdGhpblxuXHQgKiBpdCdzIGNvbnRhaW5pbmcgSW5maXgsIGl0J3MgY29udGFpbmluZyBTcGFuLCBhbmQgdGhlbiBpdCdzIGNvbnRhaW5pbmdcblx0ICogU3RhdGVtZW50LCBEb2N1bWVudCwgYW5kIFByb2dyYW0uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgSW5maXhTcGFuXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGNvbnRhaW5pbmdTcGFuOiBTcGFuLFxuXHRcdFx0cmVhZG9ubHkgY29udGFpbmluZ0luZml4OiBJbmZpeCxcblx0XHRcdHJlYWRvbmx5IGJvdW5kYXJ5OiBCb3VuZGFyeTxJZGVudGlmaWVyPilcblx0XHR7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBTdGF0ZW1lbnQgdGhhdCBjb250YWlucyB0aGlzIEFuY2hvci5cblx0XHQgKi9cblx0XHRnZXQgc3RhdGVtZW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250YWluaW5nU3Bhbi5zdGF0ZW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBJbmZpeFNwYW5cblx0XHQgKiBpcyBjb25zaWRlcmVkIG9iamVjdC1sZXZlbCBjcnVmdCwgYW5kIHNob3VsZCB0aGVyZWZvcmUgYmVcblx0XHQgKiBpZ25vcmVkIGR1cmluZyB0eXBlIGFuYWx5c2lzLlxuXHRcdCAqL1xuXHRcdGdldCBpc0NydWZ0KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250YWluaW5nU3Bhbi5zdGF0ZW1lbnQuY3J1ZnRPYmplY3RzLmhhcyh0aGlzKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIHdvcmtlciBjbGFzcyB0aGF0IGhhbmRsZXMgdGhlIGNvbnN0cnVjdGlvbiBvZiBuZXR3b3Jrc1xuXHQgKiBvZiBQYXJhbGxlbCBpbnN0YW5jZXMsIHdoaWNoIGFyZSBldmVudHVhbGx5IHRyYW5zZm9ybWVkXG5cdCAqIGludG8gdHlwZSBvYmplY3RzLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIENvbnN0cnVjdGlvbldvcmtlclxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtKVxuXHRcdHtcblx0XHRcdHRoaXMuY3J1ZnQgPSBuZXcgQ3J1ZnRDYWNoZSh0aGlzLnByb2dyYW0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb25zdHJ1Y3RzIHRoZSBjb3JyZXNwb25kaW5nIFBhcmFsbGVsIGluc3RhbmNlcyBmb3Jcblx0XHQgKiBhbGwgc3BlY2lmaWVkIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluIHRoZSBwcm92aWRlZCBEb2N1bWVudCxcblx0XHQgKiBvciBiZWxvdyB0aGUgcHJvdmlkZWQgU3BlY2lmaWVkUGFyYWxsZWwuXG5cdFx0ICovXG5cdFx0ZXhjYXZhdGUoZnJvbTogRG9jdW1lbnQgfCBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5leGNhdmF0ZWQuaGFzKGZyb20pKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0dGhpcy5leGNhdmF0ZWQuYWRkKGZyb20pO1xuXHRcdFx0Y29uc3QgcXVldWU6IFNwZWNpZmllZFBhcmFsbGVsW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJvY2Vzc05vZGVzID0gKGl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPE5vZGU+KSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgaXRlcmF0b3IpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkcmlsbGVkUGFyYWxsZWwgPSB0aGlzLmRyaWxsRnJvbU5vZGUobm9kZSk7XG5cdFx0XHRcdFx0aWYgKGRyaWxsZWRQYXJhbGxlbCAhPT0gbnVsbClcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goZHJpbGxlZFBhcmFsbGVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGZyb20gaW5zdGFuY2VvZiBEb2N1bWVudClcblx0XHRcdFx0cHJvY2Vzc05vZGVzKHRoaXMucHJvZ3JhbS5ncmFwaC5yZWFkUm9vdHMoZnJvbSkpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRxdWV1ZS5wdXNoKGZyb20pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGN1cnJlbnRQYXJhbGxlbCBvZiBxdWV1ZSlcblx0XHRcdFx0cHJvY2Vzc05vZGVzKGN1cnJlbnRQYXJhbGxlbC5ub2RlLmNvbnRlbnRzLnZhbHVlcygpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBleGNhdmF0ZWQgPSBuZXcgV2Vha1NldDxTcGVjaWZpZWRQYXJhbGxlbCB8IERvY3VtZW50PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdHMgdGhlIGZld2VzdCBwb3NzaWJsZSBQYXJhbGxlbCBpbnN0YW5jZXNcblx0XHQgKiB0byBhcnJpdmUgYXQgdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IHRoZSBkaXJlY3RpdmUuXG5cdFx0ICovXG5cdFx0ZHJpbGwoZGlyZWN0aXZlOiBVcmkpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5kcmlsbEZyb21VcmkoZGlyZWN0aXZlKTtcblx0XHRcdHRoaXMuZHJpbGxRdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBkcmlsbEZyb21VcmkoZGlyZWN0aXZlOiBVcmkpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucGFyYWxsZWxzLmhhcyhkaXJlY3RpdmUpKVxuXHRcdFx0XHRyZXR1cm4gTm90LnVuZGVmaW5lZCh0aGlzLnBhcmFsbGVscy5nZXQoZGlyZWN0aXZlKSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHR5cGVQYXRoID0gZGlyZWN0aXZlLnR5cGVzLnNsaWNlKCkubWFwKHQgPT4gdC52YWx1ZSk7XG5cdFx0XHRpZiAodHlwZVBhdGgubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZEFyZ3VtZW50KCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNvdXJjZURvYyA9IHRoaXMucHJvZ3JhbS5kb2N1bWVudHMuZ2V0KGRpcmVjdGl2ZSk7XG5cdFx0XHRpZiAoc291cmNlRG9jID09PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uZG9jdW1lbnROb3RMb2FkZWQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3VyZmFjZU5vZGUgPSB0aGlzLnByb2dyYW0uZ3JhcGgucmVhZChcblx0XHRcdFx0c291cmNlRG9jLFxuXHRcdFx0XHR0eXBlUGF0aFswXSk7XG5cdFx0XHRcblx0XHRcdGlmIChzdXJmYWNlTm9kZSA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGxldCB0eXBlSWR4ID0gMDtcblx0XHRcdGxldCBsYXN0U2VlZCA9IFxuXHRcdFx0XHR0aGlzLnBhcmFsbGVscy5nZXQoZGlyZWN0aXZlLnJldHJhY3RUeXBlVG8oMSkpIHx8XG5cdFx0XHRcdHRoaXMucmFrZSh0aGlzLnBhcmFsbGVscy5jcmVhdGUoc3VyZmFjZU5vZGUsIHRoaXMuY3J1ZnQpKTtcblx0XHRcdFxuXHRcdFx0Ly8gV2UgY2FuIHBhc3MgYnkgYW55IFBhcmFsbGVsIGluc3RhbmNlcyB0aGF0IGhhdmUgYWxyZWFkeVxuXHRcdFx0Ly8gYmVlbiBjb25zdHJ1Y3RlZC4gVGhlIHJlYWwgd29yayBiZWdpbnMgd2hlbiB3ZSBnZXQgdG9cblx0XHRcdC8vIHRoZSBmaXJzdCBwb2ludCBpbiB0aGUgVVJJIHdoZXJlIHRoZXJlIGlzIG5vIGNvbnN0cnVjdGVkXG5cdFx0XHQvLyBQYXJhbGxlbCBpbnN0YW5jZS5cblx0XHRcdGZvciAoOzspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHVyaSA9IGRpcmVjdGl2ZS5yZXRyYWN0VHlwZVRvKHR5cGVJZHggKyAxKTtcblx0XHRcdFx0aWYgKCF0aGlzLnBhcmFsbGVscy5oYXModXJpKSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGxhc3RTZWVkID0gTm90LnVuZGVmaW5lZCh0aGlzLnBhcmFsbGVscy5nZXQodXJpKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKyt0eXBlSWR4ID49IHR5cGVQYXRoLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gbGFzdFNlZWQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGRvXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHR5cGVOYW1lID0gdHlwZVBhdGhbdHlwZUlkeF07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkZXNjZW5kZWQgPSB0aGlzLmRlc2NlbmQobGFzdFNlZWQsIHR5cGVOYW1lKTtcblx0XHRcdFx0aWYgKGRlc2NlbmRlZCA9PT0gbnVsbClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGxhc3RTZWVkID0gdGhpcy5yYWtlKGRlc2NlbmRlZCk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoKyt0eXBlSWR4IDwgdHlwZVBhdGgubGVuZ3RoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxhc3RTZWVkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBbiBlbnRyeXBvaW50IGludG8gdGhlIGRyaWxsIGZ1bmN0aW9uIHRoYXQgb3BlcmF0ZXNcblx0XHQgKiBvbiBhIE5vZGUgaW5zdGVhZCBvZiBhIFVyaS4gRXNzZW50aWFsbHksIHRoaXMgbWV0aG9kXG5cdFx0ICogY2FsbHMgXCJkcmlsbEZyb21VcmkoKVwiIHNhZmVseSAobWVhbmluZyB0aGF0IGl0IGRldGVjdHNcblx0XHQgKiBjaXJjdWxhciBpbnZva2F0aW9ucywgYW5kIHJldHVybnMgbnVsbCBpbiB0aGVzZSBjYXNlcykuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBkcmlsbEZyb21Ob2RlKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Ly8gQ2lyY3VsYXIgZHJpbGxpbmcgaXMgb25seSBhIHByb2JsZW0gaWYgd2UncmVcblx0XHRcdC8vIGRyaWxsaW5nIG9uIHRoZSBzYW1lIGxldmVsLlxuXHRcdFx0Y29uc3QgcSA9IHRoaXMuZHJpbGxRdWV1ZTtcblx0XHRcdFxuXHRcdFx0aWYgKHEubGVuZ3RoID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHRxLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChxWzBdLmNvbnRhaW5lciA9PT0gbm9kZS5jb250YWluZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChxLmluY2x1ZGVzKG5vZGUpKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRxLmxlbmd0aCA9IDA7XG5cdFx0XHRcdHEucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZHJpbGxSZXN1bHQgPSB0aGlzLmRyaWxsRnJvbVVyaShub2RlLnVyaSk7XG5cdFx0XHRpZiAoZHJpbGxSZXN1bHQgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoZHJpbGxSZXN1bHQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbCkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGRyaWxsUmVzdWx0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogQSBjYWxsIHF1ZXVlIHVzZWQgdG8gcHJldmVudCBjaXJjdWxhciBkcmlsbGluZy4gKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGRyaWxsUXVldWU6IE5vZGVbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFwiUmFraW5nXCIgYSBQYXJhbGxlbCBpcyB0aGUgcHJvY2VzcyBvZiBkZWVwbHkgdHJhdmVyc2luZyBpdCdzXG5cdFx0ICogUGFyYWxsZWwgR3JhcGggKGRlcHRoIGZpcnN0KSwgYW5kIGZvciBlYWNoIHZpc2l0ZWQgUGFyYWxsZWwsXG5cdFx0ICogZGVlcGx5IHRyYXZlcnNpbmcgaXQncyBCYXNlIEdyYXBoIGFzIHdlbGwgKGFsc28gZGVwdGggZmlyc3QpLlxuXHRcdCAqIFRocm91Z2ggdGhpcyBkb3VibGUtdHJhdmVyc2FsIHByb2Nlc3MsIHRoZSBQYXJhbGxlbCdzIGVkZ2VzXG5cdFx0ICogYXJlIGNvbnN0cnVjdGVkIGludG8gYSB0cmF2ZXJzYWJsZSBncmFwaC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2Uoc2VlZDogUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Ly8gSWYgdGhlIHNlZWQncyBjb250YWluZXIgaXMgbnVsbCwgdGhpcyBtZWFucyB0aGF0IHRoZSBzZWVkXG5cdFx0XHQvLyBpcyByb290LWxldmVsLCBhbmQgc28gaXQgY2Fubm90IGhhdmUgYW55IFBhcmFsbGVsIHR5cGVzLlxuXHRcdFx0Ly8gSXQgbWF5IGhvd2V2ZXIgaGF2ZSBCYXNlIHR5cGVzLCBhbmQgdGhlc2UgbmVlZCB0byBiZVxuXHRcdFx0Ly8gaGFuZGxlZC5cblx0XHRcdGlmIChzZWVkLmNvbnRhaW5lciA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCEoc2VlZCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKSlcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnJha2VTcGVjaWZpZWRQYXJhbGxlbChzZWVkKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgdGhpcy5yYWtlUGFyYWxsZWxHcmFwaChzZWVkKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGRpZ3MgdGhyb3VnaCB0aGUgcGFyYWxsZWwgZ3JhcGgsXG5cdFx0ICogYW5kIHJha2VzIGFsbCBTcGVjaWZpZWRQYXJhbGxlbHMgdGhhdCBhcmUgZGlzY292ZXJlZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VQYXJhbGxlbEdyYXBoKHBhcjogUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBlZGdlUGFyIG9mIHBhci5nZXRQYXJhbGxlbHMoKSlcblx0XHRcdFx0dGhpcy5yYWtlUGFyYWxsZWxHcmFwaChlZGdlUGFyKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhciBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHR0aGlzLnJha2VTcGVjaWZpZWRQYXJhbGxlbChwYXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTcGxpdHRlciBtZXRob2QgdGhhdCByYWtlcyBib3RoIGEgcGF0dGVybiBhbmQgYSBub24tcGF0dGVyblxuXHRcdCAqIGNvbnRhaW5pbmcgU3BlY2lmaWVkUGFyYWxsZWwuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByYWtlU3BlY2lmaWVkUGFyYWxsZWwocGFyOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5yYWtlZFBhcmFsbGVscy5oYXMocGFyKSlcblx0XHRcdFx0cmV0dXJuIHBhcjtcblx0XHRcdFxuXHRcdFx0dGhpcy5yYWtlZFBhcmFsbGVscy5hZGQocGFyKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhci5wYXR0ZXJuKVxuXHRcdFx0XHR0aGlzLnJha2VQYXR0ZXJuQmFzZXMocGFyKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5yYWtlQmFzZUdyYXBoKHBhcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IGZvbGxvd3MgdGhlIGJhc2VzIG9mIHRoZSBzcGVjaWZpZWQgc291cmNlIE5vZGUuXG5cdFx0ICogUGFyYWxsZWwgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGZvciBhbnkgdmlzaXRlZCBOb2RlIGluc3RhbmNlXG5cdFx0ICogdGhhdCBkb2VzIG5vdCBoYXZlIG9uZSBhbHJlYWR5IGNyZWF0ZWQuXG5cdFx0ICogQWx0aG91Z2ggdGhlIGFsZ29yaXRobSBpcyBjYXJlZnVsIHRvIGF2b2lkIGNpcmN1bGFyIGJhc2VzLCBpdCdzXG5cdFx0ICogdG9vIGVhcmx5IGluIHRoZSBwcm9jZXNzaW5nIHBpcGVsaW5lIHRvIHJlcG9ydCB0aGVzZSBjaXJjdWxhclxuXHRcdCAqIGJhc2VzIGFzIGZhdWx0cy4gVGhpcyBpcyBiZWNhdXNlIHBvbHltb3JwaGljIG5hbWUgcmVzb2x1dGlvblxuXHRcdCAqIG5lZWRzIHRvIHRha2UgcGxhY2UgYmVmb3JlIHRoZSBzeXN0ZW0gY2FuIGJlIHN1cmUgdGhhdCBhIFxuXHRcdCAqIHNlZW1pbmdseS1jaXJjdWxhciBiYXNlIHN0cnVjdHVyZSBpcyBpbiBmYWN0IHdoYXQgaXQgc2VlbXMuXG5cdFx0ICogVHJ1ZSBjaXJjdWxhciBiYXNlIGRldGVjdGlvbiBpcyB0aGVyZWZvcmUgaGFuZGxlZCBhdCBhIGZ1dHVyZVxuXHRcdCAqIHBvaW50IGluIHRoZSBwaXBlbGluZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VCYXNlR3JhcGgoc3JjUGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmIChzcmNQYXJhbGxlbC5wYXR0ZXJuKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaHlwZXJFZGdlIG9mIHNyY1BhcmFsbGVsLm5vZGUub3V0Ym91bmRzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5jcnVmdC5oYXMoaHlwZXJFZGdlKSlcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHBvc3NpYmlsaXRpZXMgPSBoeXBlckVkZ2Uuc3VjY2Vzc29yc1xuXHRcdFx0XHRcdC5maWx0ZXIoc2NzciA9PiAhdGhpcy5jcnVmdC5oYXMoc2Nzci5ub2RlKSlcblx0XHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5sb25naXR1ZGUgLSBiLmxvbmdpdHVkZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocG9zc2liaWxpdGllcy5sZW5ndGggPiAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyB3aGVyZSB0aGUgcG9seW1vcnBoaWMgbmFtZSByZXNvbHV0aW9uIGFsZ29yaXRobVxuXHRcdFx0XHRcdC8vIHRha2VzIHBsYWNlLiBUaGUgYWxnb3JpdGhtIG9wZXJhdGVzIGJ5IHdvcmtpbmcgaXQncyB3YXlcblx0XHRcdFx0XHQvLyB1cCB0aGUgbGlzdCBvZiBub2RlcyAoYWthIHRoZSBzY29wZSBjaGFpbiksIGxvb2tpbmcgZm9yXG5cdFx0XHRcdFx0Ly8gYSBwb3NzaWJsZSByZXNvbHV0aW9uIHRhcmdldCB3aGVyZSB0aGUgYWN0IG9mIGFwcGx5aW5nIHRoZVxuXHRcdFx0XHRcdC8vIGFzc29jaWF0ZWQgUGFyYWxsZWwgYXMgYSBiYXNlLCBjYXVzZXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBcblx0XHRcdFx0XHQvLyBjb25kaXRpb25zIG9uIHRoZSBjb250cmFjdCB0byBiZSBzYXRpc2ZpZWQuIE9yLCBpbiB0aGUgY2FzZVxuXHRcdFx0XHRcdC8vIHdoZW4gdGhlcmUgYXJlIG5vIGNvbmRpdGlvbnMgb24gdGhlIGNvbnRyYWN0LCB0aGUgbm9kZVxuXHRcdFx0XHRcdC8vIHRoYXQgaXMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgaXMgdXNlZC5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBvc3NpYmxlU2NzciBvZiBwb3NzaWJpbGl0aWVzKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHBvc3NpYmxlTm9kZSA9IHBvc3NpYmxlU2Nzci5ub2RlO1xuXHRcdFx0XHRcdFx0Y29uc3QgYmFzZVBhcmFsbGVsID0gdGhpcy5kcmlsbEZyb21Ob2RlKHBvc3NpYmxlTm9kZSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIGJhc2VQYXJhbGxlbCB3aWxsIGJlIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiBhIGNpcmN1bGFyXG5cdFx0XHRcdFx0XHQvLyByZWxhdGlvbnNoaXAgaGFzIGJlZW4gZGV0ZWN0ZWQgKGFuZCBxdWl0dGluZyBpc1xuXHRcdFx0XHRcdFx0Ly8gcmVxdWlyZWQgaGVyZSBpbiBvcmRlciB0byBhdm9pZCBhIHN0YWNrIG92ZXJmbG93KS5cblx0XHRcdFx0XHRcdGlmIChiYXNlUGFyYWxsZWwgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR0aGlzLnJha2VTcGVjaWZpZWRQYXJhbGxlbChiYXNlUGFyYWxsZWwpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBUaGVyZSBhcmUgY2FzZXMgd2hlbiBhbiBlbnRpcmUgcGFyYWxsZWwgbmVlZHMgdG8gYmVcblx0XHRcdFx0XHRcdC8vIFwiZXhjYXZhdGVkXCIsIG1lYW5pbmcgdGhhdCB0aGUgUGFyYWxsZWwncyBlbnRpcmUgc3VidHJlZVxuXHRcdFx0XHRcdFx0Ly8gb2YgY29udGVudHMgbmVlZHMgdG8gYmUgYW5hbHl6ZWQgYW5kIGNvbnZlcnRlZCBpbnRvXG5cdFx0XHRcdFx0XHQvLyBwYXJhbGxlbHMuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYSBmdWxseSBkZWZpbmVkIHNldFxuXHRcdFx0XHRcdFx0Ly8gb2YgcGFyYWxsZWxzIGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGRldGVjdCBkaXNjcmVwYW50XG5cdFx0XHRcdFx0XHQvLyB1bmlvbnMgKGFuZCB0aGVyZWZvcmUsIHJlcG9ydCB0aGUgYXR0ZW1wdCBhdCBhIHR5cGVcblx0XHRcdFx0XHRcdC8vIHVuaW9uIGFzIGZhdWx0eSkuXG5cdFx0XHRcdFx0XHRpZiAoc3JjUGFyYWxsZWwuYmFzZUNvdW50ID4gMClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKHNyY1BhcmFsbGVsLmJhc2VDb3VudCA9PT0gMSlcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmV4Y2F2YXRlKHNyY1BhcmFsbGVsLmZpcnN0QmFzZSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR0aGlzLmV4Y2F2YXRlKGJhc2VQYXJhbGxlbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICghc3JjUGFyYWxsZWwudHJ5QWRkTGl0ZXJhbEJhc2UoYmFzZVBhcmFsbGVsLCBoeXBlckVkZ2UpKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlZEh5cGVyRWRnZXMuaGFzKGh5cGVyRWRnZSkpXG5cdFx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dGhpcy5oYW5kbGVkSHlwZXJFZGdlcy5hZGQoaHlwZXJFZGdlKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSd2ZSBkaXNjb3ZlcmVkIGFuIGFubm90YXRpb24gdGhhdCB3ZSdyZVxuXHRcdFx0XHRcdC8vIGdvaW5nIHRvIHRyeSB0byByZXNvbHZlIGFzIGFuIGFsaWFzLiBJZiB0aGlzIGRvZXNuJ3Qgd29yayxcblx0XHRcdFx0XHQvLyB0aGUgZWRnZSB3aWxsIGJlIG1hcmtlZCBhcyBjcnVmdC4gUG9zc2libHkgYSBmdXR1cmUgdmVyc2lvblxuXHRcdFx0XHRcdC8vIG9mIHRoaXMgY29tcGlsZXIgd2lsbCBhbGxvdyBvdGhlciBhZ2VudHMgdG8gaG9vayBpbnRvIHRoaXNcblx0XHRcdFx0XHQvLyBwcm9jZXNzIGFuZCBhdWdtZW50IHRoZSByZXNvbHV0aW9uIHN0cmF0ZWd5LlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGNhbmRpZGF0ZVBhdHRlcm5QYXJzOiBTcGVjaWZpZWRQYXJhbGxlbFtdID0gW107XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCB7IHBhdHRlcm5QYXJhbGxlbCB9IG9mIHRoaXMuYXNjZW5kKHNyY1BhcmFsbGVsKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLnJha2VQYXR0ZXJuQmFzZXMocGF0dGVyblBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZVBhdHRlcm5QYXJzLnB1c2gocGF0dGVyblBhcmFsbGVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNhbmRpZGF0ZVBhdHRlcm5QYXJzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgaWRlbnRpZmllcnMgPSBoeXBlckVkZ2UuZnJhZ21lbnRzXG5cdFx0XHRcdFx0XHRcdC5tYXAoc3JjID0+IHNyYy5ib3VuZGFyeS5zdWJqZWN0KVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKChzKTogcyBpcyBJZGVudGlmaWVyID0+IHMgaW5zdGFuY2VvZiBJZGVudGlmaWVyKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGlkZW50aWZpZXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IGFsaWFzID0gaWRlbnRpZmllcnNbMF0uZnVsbE5hbWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChzcmNQYXJhbGxlbC50cnlBZGRBbGlhc2VkQmFzZShjYW5kaWRhdGVQYXR0ZXJuUGFycywgaHlwZXJFZGdlLCBhbGlhcykpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHRoaXMuaGFuZGxlZEh5cGVyRWRnZXMuYWRkKGh5cGVyRWRnZSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIXRoaXMuaGFuZGxlZEh5cGVyRWRnZXMuaGFzKGh5cGVyRWRnZSkpXG5cdFx0XHRcdFx0XHR0aGlzLmNydWZ0LmFkZChoeXBlckVkZ2UsIEZhdWx0cy5VbnJlc29sdmVkQW5ub3RhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFzcmNQYXJhbGxlbC5pc0NvbnRyYWN0U2F0aXNmaWVkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzcmNQYXJhbGxlbC5ub2RlLnN0YXRlbWVudHMpXG5cdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmZhdWx0cy5yZXBvcnQobmV3IEZhdWx0KFxuXHRcdFx0XHRcdFx0RmF1bHRzLkNvbnRyYWN0VmlvbGF0aW9uLFxuXHRcdFx0XHRcdFx0c210KSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzcmNQYXJhbGxlbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZHMgdGhlIHNldCBvZiBiYXNlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm92aWRlZFxuXHRcdCAqIHBhdHRlcm4tY29udGFpbmluZyBTcGVjaWZpZWRQYXJhbGxlbCBpbnN0YW5jZSwgYW5kIGF0dGVtcHRzXG5cdFx0ICogdG8gaGF2ZSB0aGVtIGFwcGxpZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByYWtlUGF0dGVybkJhc2VzKHBhdHRlcm5QYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKCFwYXR0ZXJuUGFyYWxsZWwucGF0dGVybilcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBiYXNlcyA9IG5ldyBNYXA8U3BlY2lmaWVkUGFyYWxsZWwsIEh5cGVyRWRnZT4oKTtcblx0XHRcdGNvbnN0IG9icyA9IHBhdHRlcm5QYXJhbGxlbC5ub2RlLm91dGJvdW5kcztcblx0XHRcdGNvbnN0IG5hbWVPZiA9IChlZGdlOiBIeXBlckVkZ2UpID0+XG5cdFx0XHRcdFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKGVkZ2UuZnJhZ21lbnRzWzBdKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBvYnMubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaHlwZXJFZGdlID0gb2JzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMuY3J1ZnQuaGFzKGh5cGVyRWRnZSkpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBsZW4gPSBoeXBlckVkZ2Uuc3VjY2Vzc29ycy5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBCZWNhdXNlIHJlc29sdmluZyBwYXR0ZXJuIGJhc2VzIGhhcyBub24tcG9seW1vcnBoaWMgYmVoYXZpb3IsIFxuXHRcdFx0XHQvLyB3ZSBjYW4gZ2V0IGF3YXkgd2l0aCBjaGVja2luZyBmb3IgdGhlc2UgZmF1bHRzIGhlcmUgd2l0aG91dCBnb2luZ1xuXHRcdFx0XHQvLyB0aHJvdWdoIHRoZSB3aG9sZSBkcmlsbGluZyBwcm9jZXNzLlxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxlbiA9PT0gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGh5cGVyRWRnZSwgRmF1bHRzLlVucmVzb2x2ZWRBbm5vdGF0aW9uKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9icy5maW5kSW5kZXgoZSA9PiBuYW1lT2YoZSkgPT09IG5hbWVPZihoeXBlckVkZ2UpKSAhPT0gaSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGh5cGVyRWRnZSwgRmF1bHRzLklnbm9yZWRBbm5vdGF0aW9uKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxlbiA+IDEpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYmFzZU5vZGUgPSBoeXBlckVkZ2Uuc3VjY2Vzc29yc1swXS5ub2RlO1xuXHRcdFx0XHRjb25zdCBiYXNlUGFyYWxsZWwgPSB0aGlzLmRyaWxsRnJvbU5vZGUoYmFzZU5vZGUpO1xuXHRcdFx0XHRpZiAoYmFzZVBhcmFsbGVsICE9PSBudWxsKVxuXHRcdFx0XHRcdGJhc2VzLnNldChiYXNlUGFyYWxsZWwsIGh5cGVyRWRnZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIENpcmN1bGFyIGJhc2VzIHN0aWxsIG5lZWQgdG8gYmUgY2hlY2tlZC4gSXQncyB1bmNsZWFyIGhvdyBhbmRcblx0XHRcdC8vIHdoZXJlIHRvIGFjdHVhbGx5IGRvIHRoaXMsIHdoaWxlIGZhY3RvcmluZyBpbiB0aGUgY29uc3RyYWludFxuXHRcdFx0Ly8gdGhhdCB0aGVzZSBjYW4gYmUgY2F1c2VkIHRocm91Z2ggdGhlIHVzZSBvZiBhbGlhc2VzLlxuXHRcdFx0XG5cdFx0XHQvLyBBbnl0aGluZyB0aGF0IGlzIGEgbGlzdCAod2l0aCBhbnkgZGltZW5zaW9uYWxpdHkpIG5lZWRzIHRvIGJlXG5cdFx0XHQvLyBjdXQgb2ZmLCBiZWNhdXNlIHRoZXNlIGJhc2VzIGNhbid0IGJlIGFwcGxpZWQgdG8gcGF0dGVybnMuXG5cdFx0XHRmb3IgKGNvbnN0IFtiYXNlLCB2aWFdIG9mIGJhc2VzKVxuXHRcdFx0XHRpZiAoYmFzZS5nZXRMaXN0RGltZW5zaW9uYWxpdHkoKSA+IDApXG5cdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQodmlhLCBGYXVsdHMuUGF0dGVybk1hdGNoaW5nTGlzdCk7XG5cdFx0XHRcblx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIGRldGVybWluZSBpZiBhbnkgb2YgdGhlc2UgYmFzZXMgYXJlIHJlZHVuZGFudC5cblx0XHRcdC8vIFRoaXMgaXMgZG9uZSBieSBjaGVja2luZyB0byBzZWUgaWYgYW55IG9mIHRoZSBiYXNlcyBhcmUgc3BlY2lmaWVkXG5cdFx0XHQvLyBzb21ld2hlcmUgaW4gdGhlIGJhc2UgZ3JhcGggb2YgYWxsIG90aGVycy5cblx0XHRcdGZvciAoY29uc3QgW2Jhc2VBXSBvZiBiYXNlcylcblx0XHRcdFx0Zm9yIChjb25zdCBbYmFzZUIsIHZpYV0gb2YgYmFzZXMpXG5cdFx0XHRcdFx0aWYgKGJhc2VBICE9PSBiYXNlQilcblx0XHRcdFx0XHRcdGlmIChiYXNlQS5oYXNCYXNlKGJhc2VCKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQodmlhLCBGYXVsdHMuSWdub3JlZEFubm90YXRpb24pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXR0ZXJuID0gcGF0dGVyblBhcmFsbGVsLm5vZGUuc3ViamVjdCBhcyBQYXR0ZXJuO1xuXHRcdFx0Y29uc3Qgc3BhbiA9IHBhdHRlcm5QYXJhbGxlbC5ub2RlLmRlY2xhcmF0aW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgYXMgU3Bhbjtcblx0XHRcdGNvbnN0IHBvcnRJbmZpeGVzID0gcGF0dGVybi5nZXRJbmZpeGVzKEluZml4RmxhZ3MucG9ydGFiaWxpdHkpO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9ydEluZml4ZXMubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdmFsaWRQb3J0YWJpbGl0eUluZml4ZXM6IEluZml4W10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgcG9ydEluZml4IG9mIHBvcnRJbmZpeGVzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmZ4QW5ub3NJdGVyID0gc3Bhbi5lYWNoQW5ub3RhdGlvbkZvckluZml4KHBvcnRJbmZpeCk7XG5cdFx0XHRcdFx0Y29uc3QgbmZ4QW5ub3MgPSBBcnJheS5mcm9tKG5meEFubm9zSXRlcik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5meEFubm9zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBBdCB0aGlzIHRpbWUsIHdlJ3JlIGN1cnJlbnRseSBnZW5lcmF0aW5nIGEgZmF1bHQgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdFx0XHRcdC8vIGEgcG9ydGFiaWxpdHkgaW5maXggaGFzIG11bHRpcGxlIGRlZmluaXRpb25zLiBBbHRob3VnaCB0aGUgcGFyc2VyXG5cdFx0XHRcdFx0Ly8gYW5kIHRoZSBHcmFwaC1sZXZlbCBpbmZyYXN0cnVjdHVyZSBzdXBwb3J0cyB0aGlzLCBtb3JlIHN0dWR5IGlzXG5cdFx0XHRcdFx0Ly8gcmVxdWlyZWQgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBjaGFyYWN0ZXJpc3RpYyBvZiBUcnV0aC5cblx0XHRcdFx0XHRpZiAobmZ4QW5ub3MubGVuZ3RoID4gMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG5meCBvZiBuZnhBbm5vcy5zbGljZSgxKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQobmZ4LCBGYXVsdHMuUG9ydGFiaWxpdHlJbmZpeEhhc1VuaW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB2YWxpZFBvcnRhYmlsaXR5SW5maXhlcy5wdXNoKHBvcnRJbmZpeCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoaXMgY29kZSBjaGVja3MgZm9yIG92ZXJsYXBwaW5nIHR5cGVzLiBUaGUgYWxnb3JpdGhtIHVzZWQgaGVyZSBpc1xuXHRcdFx0XHQvLyBzaW1pbGFyIHRvIHRoZSByZWR1bmRhbnQgYmFzZXMgY2hlY2sgdXNlZCBhYm92ZS4gSG93ZXZlciwgaW4gdGhlIGNhc2Vcblx0XHRcdFx0Ly8gb2YgaW5maXhlcywgdGhlc2UgYXJlbid0IGp1c3QgcmVkdW5kYW50LCB0aGV5IHdvdWxkIGJlIHByb2JsZW1hdGljIGlmXG5cdFx0XHRcdC8vIGxlZnQgaW4uIFRvIGV4cGxhaW4gd2h5LCB0cnkgdG8gZmlndXJlIG91dCBob3cgYSBTdHJpbmcgdHlwZSB3b3VsZCBkcmF3XG5cdFx0XHRcdC8vIGl0J3MgZGF0YSBvdXQgb2YgYW4gYWxpYXMgbWF0Y2hpbmcgdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuXHRcdFx0XHQvLyBcdC88IDogRW1haWw+PCA6IFN0cmluZz4gOiBUeXBlXG5cdFx0XHRcdC8vIChoaW50OiBpdCBkb2Vzbid0IHdvcmspXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyEgTm90IGltcGxlbWVudGVkXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRPRE86IENoZWNrIGZvciB1c2Ugb2YgbGlzdHMgd2l0aGluIGFueSBraW5kIG9mIGluZml4LlxuXHRcdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3Igbm8gY29sbGVjdGVkIGJhc2VzIHRvIGJlIHJldHVybmVkXG5cdFx0XHQvLyBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIHdlcmUgYWN0dWFsbHkgYW5ub3RhdGlvbnNcblx0XHRcdC8vIHNwZWNpZmllZCB3aXRoaW4gdGhlIGZpbGUsIGJ1dCB0aGV5IHdlcmUgYWxsIGZvdW5kIHRvXG5cdFx0XHQvLyBiZSBjcnVmdC5cblx0XHRcdGlmIChiYXNlcy5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdHBhdHRlcm5QYXJhbGxlbC50cnlBcHBseVBhdHRlcm5CYXNlcyhiYXNlcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgd29ya3MgaXRzIHdheSB1cHdhcmRzLCBzdGFydGluZyBhdCB0aGVcblx0XHQgKiBwcm92aWRlZCBTcGVjaWZpZWRQYXJhbGxlbC4gVGhlIGZ1bmN0aW9uIHlpZWxkcyB0aGUgc2VyaWVzIG9mXG5cdFx0ICogUGFyYWxsZWxzIHRoYXQgY29udGFpbiBQYXR0ZXJucyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBwcm92aWRlZFxuXHRcdCAqIHNyY1BhcmFsbGVsLiBUaGUgYmFzZXMgb2YgdGhlc2UgcGFyYWxsZWxzIGhhdmUgbm90IG5lY2Vzc2FyaWx5XG5cdFx0ICogYmVlbiBhcHBsaWVkLlxuXHRcdCAqIFxuXHRcdCAqIFRoZSBvcmRlcmluZyBvZiB0aGUgUGFyYWxsZWxzIHlpZWxkZWQgaXMgcmVsZXZhbnQuIFRoZSBpbnN0YW5jZXNcblx0XHQgKiB0aGF0IHdlcmUgeWllbGRlZCBjbG9zZXIgdG8gdGhlIGJlZ2lubmluZyB0YWtlIHByZXNjZWRlbmNlIG92ZXJcblx0XHQgKiB0aGUgb25lcyB5aWVsZGVkIGF0IHRoZSBlbmQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSAqYXNjZW5kKHNyY1BhcmFsbGVsOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRjb25zdCBkaXNjb3ZlcmVkUGF0dGVybk5vZGVzID0gbmV3IFNldDxOb2RlPigpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB5aWVsZGFibGUgPSAocGF0dGVybk5vZGU6IE5vZGUpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGRpc2NvdmVyZWRQYXR0ZXJuTm9kZXMuYWRkKHBhdHRlcm5Ob2RlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBOb3QubnVsbChcblx0XHRcdFx0XHR0aGlzLnBhcmFsbGVscy5nZXQocGF0dGVybk5vZGUpIHx8XG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuY3JlYXRlKHBhdHRlcm5Ob2RlLCB0aGlzLmNydWZ0KSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiAqcmVjdXJzZShjdXJyZW50OiBTcGVjaWZpZWRQYXJhbGxlbCk6IFxuXHRcdFx0XHRJdGVyYWJsZUl0ZXJhdG9yPElQYXR0ZXJuUGFyYWxsZWw+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgY3VycmVudC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlKGJhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgY3VycmVudC5ub2RlLmNvbnRlbnRzLnZhbHVlcygpKVxuXHRcdFx0XHRcdFx0aWYgKG5vZGUuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0XHRcdGlmICghZGlzY292ZXJlZFBhdHRlcm5Ob2Rlcy5oYXMobm9kZSkpXG5cdFx0XHRcdFx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybjogbm9kZS5zdWJqZWN0LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVyblBhcmFsbGVsOiB5aWVsZGFibGUobm9kZSlcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBUaGUgcHJvY2VzcyBzdGFydHMgYXQgdGhlIGNvbnRhaW5lciBvZiB0aGUgY3VycmVudCBwYXJhbGxlbCxcblx0XHRcdC8vIGV2ZW4gdGhvdWdoIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8geWllbGQgb3RoZXIgcGFyYWxsZWxzIHRoYXRcblx0XHRcdC8vIGFyZSBhZGphY2VudCB0byBzcmNQYXJhbGxlbCwgYmVjYXVzZSB3ZSByZWFjaCBiYWNrIGludG8gdGhlXG5cdFx0XHQvLyBhZGphY2VudHMgZnJvbSB0aGUgY29udGFpbmVyLlxuXHRcdFx0Zm9yIChsZXQgY3VycmVudCA9IHNyY1BhcmFsbGVsLmNvbnRhaW5lcjtcblx0XHRcdFx0Y3VycmVudCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsOylcblx0XHRcdHtcblx0XHRcdFx0eWllbGQgKnJlY3Vyc2UoY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LmNvbnRhaW5lcjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCByb290IG9mIHRoaXMucHJvZ3JhbS5ncmFwaC5yZWFkUm9vdHMoc3JjUGFyYWxsZWwubm9kZS5kb2N1bWVudCkpXG5cdFx0XHRcdGlmIChyb290LnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuKVxuXHRcdFx0XHRcdGlmICghZGlzY292ZXJlZFBhdHRlcm5Ob2Rlcy5oYXMocm9vdCkpXG5cdFx0XHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IHJvb3Quc3ViamVjdCxcblx0XHRcdFx0XHRcdFx0cGF0dGVyblBhcmFsbGVsOiB5aWVsZGFibGUocm9vdClcblx0XHRcdFx0XHRcdH07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgZm9yIHNhZmV0eSBwdXJwb3NlcyB0byBjYXRjaCB1bmV4cGVjdGVkIGJlaGF2aW9yLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgaGFuZGxlZEh5cGVyRWRnZXMgPSBuZXcgV2Vha1NldDxIeXBlckVkZ2U+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29uc3RydWN0cyBhbmQgcmV0dXJucyBhIG5ldyBzZWVkIFBhcmFsbGVsIGZyb20gdGhlIHNwZWNpZmllZFxuXHRcdCAqIHplbml0aCBQYXJhbGxlbCwgbmF2aWdhdGluZyBkb3dud2FyZHMgdG8gdGhlIHNwZWNpZmllZCB0eXBlIG5hbWUuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBkZXNjZW5kKHplbml0aDogUGFyYWxsZWwsIHR5cGVOYW1lOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcmV0dXJucyBBIG5ldyBQYXJhbGxlbCAoZWl0aGVyIGJlaW5nIGEgU3BlY2lmaWVkUGFyYWxsZWxcblx0XHRcdCAqIG9yIGFuIFVuc3BlY2lmaWVkUGFyYWxsZWwgaW5zdGFuY2UpLCB0aGF0IGNvcnJlc3BvbmRzIHRvXG5cdFx0XHQgKiB0aGUgc3BlY2lmaWVkIHplbml0aCBwYXJhbGxlbC5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgZGVzY2VuZE9uZSA9ICh6ZW5pdGg6IFBhcmFsbGVsKTogUGFyYWxsZWwgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHplbml0aCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dE5vZGUgPSB6ZW5pdGgubm9kZS5jb250ZW50cy5nZXQodHlwZU5hbWUpO1xuXHRcdFx0XHRcdGlmIChuZXh0Tm9kZSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBvdXQgPSB0aGlzLnBhcmFsbGVscy5nZXQobmV4dE5vZGUpIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMucGFyYWxsZWxzLmNyZWF0ZShuZXh0Tm9kZSwgdGhpcy5jcnVmdCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHRoaXMudmVyaWZ5RGVzY2VuZCh6ZW5pdGgsIG91dCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbmV4dFVyaSA9IHplbml0aC51cmkuZXh0ZW5kVHlwZSh0eXBlTmFtZSk7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuZ2V0KG5leHRVcmkpIHx8XG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuY3JlYXRlKG5leHRVcmkpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFjdFxuXHRcdFx0ICogb2YgZGVzY2VuZGluZyBmcm9tIHRoZSBzcGVjaWZpZWQgUGFyYWxsZWwgdG8gdGhlIHR5cGVOYW1lXG5cdFx0XHQgKiBwYXNzZWQgdG8gdGhlIGNvbnRhaW5pbmcgbWV0aG9kIGlzIGdvaW5nIHRvIHJlc3VsdCBpbiBhXG5cdFx0XHQgKiBTcGVjaWZpZWRQYXJhbGxlbCBpbnN0YW5jZS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gY2FuRGVzY2VuZFRvU3BlY2lmaWVkKHBhcmFsbGVsOiBQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRwYXJhbGxlbCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsICYmXG5cdFx0XHRcdFx0cGFyYWxsZWwubm9kZS5jb250ZW50cy5oYXModHlwZU5hbWUpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly9cblx0XHRcdC8vIFRPRE86IFRoZXNlIGZ1bmN0aW9ucyBjYW4gcHJvYmFibHkgYmUgcmVwbGFjZWQgd2l0aFxuXHRcdFx0Ly8gYSBjYWxsIHRvIE1pc2MucmVkdWNlUmVjdXJzaXZlKClcblx0XHRcdC8vXG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlUGFyYWxsZWxzKHBhcjogUGFyYWxsZWwpOiBJdGVyYWJsZUl0ZXJhdG9yPFBhcmFsbGVsPlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHBhckVkZ2Ugb2YgcGFyLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlUGFyYWxsZWxzKHBhckVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQgcGFyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiAqcmVjdXJzZUJhc2VzKHBhcjogU3BlY2lmaWVkUGFyYWxsZWwpOiBJdGVyYWJsZUl0ZXJhdG9yPFBhcmFsbGVsPlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIHBhci5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlQmFzZXMoYmFzZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCBwYXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlKHBhcjogUGFyYWxsZWwpOiBJdGVyYWJsZUl0ZXJhdG9yPFBhcmFsbGVsPlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHBhcmFsbGVsRWRnZSBvZiByZWN1cnNlUGFyYWxsZWxzKHBhcikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocGFyYWxsZWxFZGdlIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGJhc2VFZGdlIG9mIHJlY3Vyc2VCYXNlcyhwYXJhbGxlbEVkZ2UpKVxuXHRcdFx0XHRcdFx0XHR5aWVsZCBiYXNlRWRnZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR5aWVsZCBwYXJhbGxlbEVkZ2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGZvbGxvd2luZyBhbGdvcml0aG0gcGVyZm9ybXMgYSByZWN1cnNpdmUgcmVkdWN0aW9uIG9uXG5cdFx0XHQvLyB0aGUgemVuaXRoLCBhbmQgcHJvZHVjZXMgYSBzZXQgb2YgUGFyYWxsZWxzIHRvIHBydW5lIGZyb20gdGhlXG5cdFx0XHQvLyBkZXNjZW5zaW9uIHByb2Nlc3MuIFRoZSBQYXJhbGxlbHMgdGhhdCBlbmQgdXAgZ2V0dGluZyBwcnVuZWRcblx0XHRcdC8vIGFyZSB0aGUgb25lcyB0aGF0LCBpZiB1bnBydW5lZCwgd291bGQgcmVzdWx0IGluIGEgbGF5ZXIgdGhhdFxuXHRcdFx0Ly8gaGFzIFVuc3BlY2lmaWVkUGFyYWxsZWxzIHRoYXQgc2hvdWxkbid0IGFjdHVhbGx5IGV4aXN0LiBGb3Jcblx0XHRcdC8vIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZG9jdW1lbnQ6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gQ2xhc3Ncblx0XHRcdC8vIFxuXHRcdFx0Ly8gU3ViQ2xhc3MgOiBDbGFzc1xuXHRcdFx0Ly8gXHRDaGlsZFxuXHRcdFx0Ly8gXG5cdFx0XHQvLyBcIkNsYXNzXCIgc2hvdWxkIG5vdCBoYXZlIGFuIFVuc3BlY2lmaWVkUGFyYWxsZWwgY2FsbGVkIFwiQ2hpbGRcIixcblx0XHRcdC8vIGJlY2F1c2UgdGhhdCB3YXMgaW50cm9kdWNlZCBpbiB0aGUgZGVyaXZlZCBcIlN1YkNsYXNzXCIgdHlwZS5cblx0XHRcdC8vIEFuZCBzbyB0aGlzIGFsZ29yaXRobSBzdGFrZXMgb3V0IGN1dCBvZmYgcG9pbnRzIHNvIHRoYXQgd2UgZG9uJ3Rcblx0XHRcdC8vIGJsaW5kbHkganVzdCBkZXNjZW5kIGFsbCBQYXJhbGxlbHMgaW4gdGhlIGxheWVyLlxuXHRcdFx0Y29uc3QgcHJ1bmVkUGFyYWxsZWxzID0gbmV3IFNldDxQYXJhbGxlbD4oKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJ1bmVQYXJhbGxlbHNGb2xsb3dGbiA9IChwYXI6IFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1cHBlclBhcmFsbGVscyA9IHBhci5nZXRQYXJhbGxlbHMoKS5zbGljZSgpO1xuXHRcdFx0XHRpZiAocGFyIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBwYXIuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHRcdHVwcGVyUGFyYWxsZWxzLnB1c2goYmFzZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gdXBwZXJQYXJhbGxlbHM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBoYXNTcGVjaWZpZWRDb250ZW50cyA9IE1pc2MucmVkdWNlUmVjdXJzaXZlKFxuXHRcdFx0XHR6ZW5pdGgsXG5cdFx0XHRcdHBydW5lUGFyYWxsZWxzRm9sbG93Rm4sXG5cdFx0XHRcdChjdXJyZW50LCByZXN1bHRzOiByZWFkb25seSBib29sZWFuW10pID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBwcnVuZSA9IFxuXHRcdFx0XHRcdFx0cmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gIXJlc3VsdCkgJiZcblx0XHRcdFx0XHRcdCFjYW5EZXNjZW5kVG9TcGVjaWZpZWQoY3VycmVudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBydW5lKVxuXHRcdFx0XHRcdFx0cHJ1bmVkUGFyYWxsZWxzLmFkZChjdXJyZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gIXBydW5lO1xuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlbiB0aGUgbWV0aG9kIGlzIGF0dGVtcHRpbmcgdG8gZGVzY2VuZFxuXHRcdFx0Ly8gdG8gYSBsZXZlbCB3aGVyZSB0aGVyZSBhcmUgbm8gbm9kZXMgd2hvc2UgbmFtZSBtYXRjaFxuXHRcdFx0Ly8gdGhlIHR5cGUgbmFtZSBzcGVjaWZpZWQgKGkuZS4gdGhlIHdob2xlIGxheWVyIHdvdWxkIGJlIFxuXHRcdFx0Ly8gdW5zcGVjaWZpZWQgcGFyYWxsZWxzKSwgbnVsbCBpcyByZXR1cm5lZCBiZWNhdXNlIGEgZGVzY2VuZFxuXHRcdFx0Ly8gd291bGRuJ3QgbWFrZSBzZW5zZS5cblx0XHRcdGlmICghaGFzU3BlY2lmaWVkQ29udGVudHMpXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkZXNjZW5kUGFyYWxsZWxzRm9sbG93Rm4gPSAocGFyOiBQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCEocGFyIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpKVxuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJhc2VzID0gQXJyYXkuZnJvbShwYXIuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHQubWFwKGVudHJ5ID0+IDxQYXJhbGxlbD5lbnRyeS5iYXNlKVxuXHRcdFx0XHRcdC5zbGljZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYmFzZXNcblx0XHRcdFx0XHQuY29uY2F0KHBhci5nZXRQYXJhbGxlbHMoKSlcblx0XHRcdFx0XHQuZmlsdGVyKHBhciA9PiAhcHJ1bmVkUGFyYWxsZWxzLmhhcyhwYXIpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzZWVkID0gTWlzYy5yZWR1Y2VSZWN1cnNpdmUoXG5cdFx0XHRcdHplbml0aCxcblx0XHRcdFx0ZGVzY2VuZFBhcmFsbGVsc0ZvbGxvd0ZuLFxuXHRcdFx0XHQoY3VycmVudCwgbmVzdGVkOiByZWFkb25seSBQYXJhbGxlbFtdKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dFBhciA9IGRlc2NlbmRPbmUoY3VycmVudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBlZGdlIG9mIG5lc3RlZClcblx0XHRcdFx0XHRcdG5leHRQYXIuYWRkUGFyYWxsZWwoZWRnZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5leHRQYXI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgdmVyaWZpY2F0aW9uIG9uIHRoZSBkZXNjZW5kIG9wZXJhdGlvbi5cblx0XHQgKiBSZXBvcnRzIGFueSBmYXVsdHMgdGhhdCBjYW4gb2NjdXIgZHVyaW5nIHRoaXMgcHJvY2Vzcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHZlcmlmeURlc2NlbmQoXG5cdFx0XHR6ZW5pdGhQYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwsXG5cdFx0XHRkZXNjZW5kUGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmIChkZXNjZW5kUGFyYWxsZWwubm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgQW5vbilcblx0XHRcdFx0aWYgKHplbml0aFBhcmFsbGVsLmlzTGlzdEludHJpbnNpYylcblx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChuZXcgRmF1bHQoXG5cdFx0XHRcdFx0XHRGYXVsdHMuQW5vbnltb3VzSW5MaXN0SW50cmluc2ljLFxuXHRcdFx0XHRcdFx0ZGVzY2VuZFBhcmFsbGVsLm5vZGUuc3RhdGVtZW50c1swXSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHBhcmFsbGVscyA9IG5ldyBQYXJhbGxlbENhY2hlKCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBzZXQgb2YgUGFyYWxsZWwgaW5zdGFuY2VzIHRoYXQgaGF2ZSBiZWVuIFwicmFrZWRcIixcblx0XHQgKiB3aGljaCBtZWFucyB0aGF0IHRoYXQgaGF2ZSBnb25lIHRocm91Z2ggdGhlIHByb2Nlc3Mgb2Zcblx0XHQgKiBoYXZpbmcgdGhlaXIgcmVxdWVzdGVkIGJhc2VzIGFwcGxpZWQuXG5cdFx0ICogXG5cdFx0ICogVGhpcyBzZXQgbWF5IGluY2x1ZGUgYm90aCBwYXR0ZXJuIGFuZCBub24tcGF0dGVybnMgUGFyYWxsZWxzLFxuXHRcdCAqIChldmVuIHRob3VnaCB0aGVpciByYWtpbmcgcHJvY2Vzc2VzIGFyZSBjb21wbGV0ZWx5IGRpZmZlcmVudCkuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSByYWtlZFBhcmFsbGVscyA9IG5ldyBXZWFrU2V0PFBhcmFsbGVsPigpO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgY3J1ZnQ6IENydWZ0Q2FjaGU7XG5cdH1cblx0XG5cdC8qKiAqL1xuXHRpbnRlcmZhY2UgSVBhdHRlcm5QYXJhbGxlbFxuXHR7XG5cdFx0cmVhZG9ubHkgcGF0dGVybjogUGF0dGVybjtcblx0XHRyZWFkb25seSBwYXR0ZXJuUGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsO1xuXHR9XG5cblx0LyoqICovXG5cdGV4cG9ydCB0eXBlIFRCYXNlVGFibGUgPSBSZWFkb25seU1hcDxTcGVjaWZpZWRQYXJhbGxlbCwgSHlwZXJFZGdlPjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYXJhbGxlbFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW52b2tlZCBieSBQYXJhbGxlbENhY2hlLiBEbyBub3QgY2FsbC5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHVyaTogVXJpLFxuXHRcdFx0cmVhZG9ubHkgY29udGFpbmVyOiBQYXJhbGxlbCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhpcy5uYW1lID0gdXJpLnRvVHlwZVN0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5uYW1lLnN0YXJ0c1dpdGgoXCIvXCIpKVxuXHRcdFx0XHR0aGlzLm5hbWUgPSB1bmVzY2FwZSh0aGlzLm5hbWUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoY29udGFpbmVyICE9PSBudWxsKVxuXHRcdFx0XHRjb250YWluZXIuX2NvbnRlbnRzLnNldCh1cmkudHlwZXMuc2xpY2UoLTEpWzBdLnZhbHVlLCB0aGlzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUGFyYWxsZWwsXG5cdFx0ICogdXNlZnVsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGlzIGluc3RhbmNlLFxuXHRcdCAqIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGdldCBjb250ZW50cygpOiBSZWFkb25seU1hcDxzdHJpbmcsIFBhcmFsbGVsPlxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9jb250ZW50cztcblx0XHR9XG5cdFx0cHJpdmF0ZSBfY29udGVudHMgPSBuZXcgTWFwPHN0cmluZywgUGFyYWxsZWw+KCk7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0UGFyYWxsZWxzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZSh0aGlzLl9wYXJhbGxlbHMuc2xpY2UoKSk7XG5cdFx0fVxuXHRcdHByaXZhdGUgcmVhZG9ubHkgX3BhcmFsbGVsczogUGFyYWxsZWxbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBoYXNQYXJhbGxlbHMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9wYXJhbGxlbHMubGVuZ3RoID4gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkUGFyYWxsZWwocGFyYWxsZWw6IFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5fcGFyYWxsZWxzLmluY2x1ZGVzKHBhcmFsbGVsKSlcblx0XHRcdFx0dGhpcy5fcGFyYWxsZWxzLnB1c2gocGFyYWxsZWwpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFNwZWNpZmllZFBhcmFsbGVsIGV4dGVuZHMgUGFyYWxsZWxcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEludm9rZWQgYnkgUGFyYWxsZWxDYWNoZS4gRG8gbm90IGNhbGwuXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRub2RlOiBOb2RlLFxuXHRcdFx0Y29udGFpbmVyOiBTcGVjaWZpZWRQYXJhbGxlbCB8IG51bGwsXG5cdFx0XHRjcnVmdDogQ3J1ZnRDYWNoZSlcblx0XHR7XG5cdFx0XHRzdXBlcihub2RlLnVyaSwgY29udGFpbmVyKTtcblx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHR0aGlzLmNydWZ0ID0gY3J1ZnQ7XG5cdFx0XHRcblx0XHRcdG5vZGUuZG9jdW1lbnQucHJvZ3JhbS5mYXVsdHMuaW5mb3JtKG5vZGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIE5vZGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGlzXG5cdFx0ICogU3BlY2lmaWVkUGFyYWxsZWwgaW5zdGFuY2UuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgbm9kZTogTm9kZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgaXNDb250cmFjdFNhdGlzZmllZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY29udHJhY3QudW5zYXRpc2ZpZWRDb25kaXRpb25zLnNpemUgPT09IDA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgZ2V0IGNvbnRyYWN0KCk6IENvbnRyYWN0XG5cdFx0e1xuXHRcdFx0Ly8gSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbnRyYWN0IGlzIGNvbXB1dGVkIGxhemlseSwgYmVjYXVzZVxuXHRcdFx0Ly8gaWYgeW91IHRyeSB0byBjb21wdXRlIGl0IGluIHRoZSBjb25zdHJ1Y3RvciwgdGhlIFBhcmFsbGVsIGdyYXBoXG5cdFx0XHQvLyB3b24ndCBiZSBjb25zdHJ1Y3RlZCwgYW5kIHlvdSdsbCBlbmQgdXAgd2l0aCBhbiBlbXB0eSBjb250cmFjdC5cblx0XHRcdGlmICh0aGlzLl9jb250cmFjdCA9PT0gbnVsbClcblx0XHRcdFx0dGhpcy5fY29udHJhY3QgPSBuZXcgQ29udHJhY3QodGhpcyk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9jb250cmFjdDtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfY29udHJhY3Q6IENvbnRyYWN0IHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjcnVmdDogQ3J1ZnRDYWNoZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBmaXJzdCBiYXNlIGNvbnRhaW5lZCBieSB0aGlzIGluc3RhbmNlLlxuXHRcdCAqIEB0aHJvd3MgSW4gdGhlIGNhc2Ugd2hlbiB0aGlzIGluc3RhbmNlIGNvbnRhaW5zIG5vIGJhc2VzLlxuXHRcdCAqL1xuXHRcdGdldCBmaXJzdEJhc2UoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgYmFzZUVudHJ5IG9mIHRoaXMuX2Jhc2VzLnZhbHVlcygpKVxuXHRcdFx0XHRyZXR1cm4gYmFzZUVudHJ5LnBhcmFsbGVsc1swXTtcblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhIHNoYWxsb3cgdHJhdmVyc2FsIG9uIHRoZSBub24tY3J1ZnQgYmFzZXNcblx0XHQgKiBkZWZpbmVkIGRpcmVjdGx5IG9uIHRoaXMgUGFyYWxsZWwuXG5cdFx0ICovXG5cdFx0KmVhY2hCYXNlKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IFtlZGdlLCBiYXNlRW50cnldIG9mIHRoaXMuX2Jhc2VzKVxuXHRcdFx0XHRpZiAoIXRoaXMuY3J1ZnQuaGFzKGVkZ2UpKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgYmFzZSBvZiBiYXNlRW50cnkucGFyYWxsZWxzKVxuXHRcdFx0XHRcdFx0eWllbGQgeyBiYXNlLCBlZGdlLCBhbGlhc2VkOiBiYXNlRW50cnkuYWxpYXNlZCB9O1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9iYXNlcyA9IG5ldyBNYXA8SHlwZXJFZGdlLCBJQmFzZUVudHJ5PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYWRkQmFzZUVudHJ5KFxuXHRcdFx0YmFzZTogU3BlY2lmaWVkUGFyYWxsZWwsXG5cdFx0XHRlZGdlOiBIeXBlckVkZ2UsXG5cdFx0XHRhbGlhc2VkOiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYmFzZXMuZ2V0KGVkZ2UpO1xuXHRcdFx0aWYgKGV4aXN0aW5nKVxuXHRcdFx0XHRleGlzdGluZy5wYXJhbGxlbHMucHVzaChiYXNlKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5fYmFzZXMuc2V0KGVkZ2UsIHsgcGFyYWxsZWxzOiBbYmFzZV0sIGFsaWFzZWQgfSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgZGVlcCB0cmF2ZXJzYWwgb24gdGhlIG5vbi1jcnVmdCBiYXNlc1xuXHRcdCAqIGRlZmluZWQgb24gdGhpcyBQYXJhbGxlbC5cblx0XHQgKi9cblx0XHQqZWFjaEJhc2VEZWVwKClcblx0XHR7XG5cdFx0XHRjb25zdCBxdWV1ZSA9IEFycmF5LmZyb20odGhpcy5lYWNoQmFzZSgpKS5tYXAoZSA9PiBlLmJhc2UpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZVtpXTtcblx0XHRcdFx0eWllbGQgY3VycmVudDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgY3VycmVudC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdGlmICghcXVldWUuaW5jbHVkZXMoYmFzZSkpXG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGJhc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcHJvdmlkZWRcblx0XHQgKiBTcGVjaWZpZWRQYXJhbGxlbCBpbnN0YW5jZSBleGlzdHMgc29tZXdoZXJlLCBwb3NzaWJseSBuZXN0ZWQsXG5cdFx0ICogaW4gdGhlIGJhc2UgZ3JhcGggb2YgdGhpcyBpbnN0YW5jZS5cblx0XHQgKi9cblx0XHRoYXNCYXNlKHRlc3RCYXNlOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRjb25zdCBxdWV1ZSA9IEFycmF5LmZyb20odGhpcy5lYWNoQmFzZSgpKS5tYXAoZSA9PiBlLmJhc2UpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZVtpXTtcblx0XHRcdFx0aWYgKGN1cnJlbnQgPT09IHRlc3RCYXNlKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBjdXJyZW50LmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0aWYgKCFxdWV1ZS5pbmNsdWRlcyhiYXNlKSlcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goYmFzZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gYWRkIHRoZSBwcm92aWRlZCBTcGVjaWZpZWRQYXJhbGxlbCBhcyBhIGJhc2Ugb2Zcblx0XHQgKiB0aGlzIGluc3RhbmNlLiBJZiB0aGUgYWRkaXRpb24gb2YgdGhlIG5ldyBiYXNlIHdvdWxkIG5vdCBnZW5lcmF0ZVxuXHRcdCAqIGFueSBjcml0aWNhbCBmYXVsdHMsIGl0IGlzIGFkZGVkLiBPdGhlcndpc2UsIGl0J3MgbWFya2VkIGFzIGNydWZ0LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBiYXNlXG5cdFx0ICogd2FzIGFkZGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKi9cblx0XHR0cnlBZGRMaXRlcmFsQmFzZShiYXNlOiBTcGVjaWZpZWRQYXJhbGxlbCwgdmlhOiBIeXBlckVkZ2UpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2Jhc2VzLmhhcyh2aWEpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdC8vIEp1c3QgYXMgYSByZW1pbmRlciAtLSBwYXR0ZXJuLWNvbnRhaW5pbmcgcGFyYWxsZWxzIFxuXHRcdFx0Ly8gZG9uJ3QgY29tZSBpbnRvIHRoaXMgbWV0aG9kLiBCYXNlcyBhcmUgYXBwbGllZCB0b1xuXHRcdFx0Ly8gcGF0dGVybnMgaW4gdHJ5QXBwbHlQYXR0ZXJuQmFzZXMuXG5cdFx0XHRpZiAodGhpcy5wYXR0ZXJuKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG51bVNhdGlzZmllZCA9IHRoaXMuY29udHJhY3QudHJ5U2F0aXNmeUNvbmRpdGlvbihiYXNlKTtcblx0XHRcdGlmIChudW1TYXRpc2ZpZWQgPT09IDAgJiYgdGhpcy5jb250cmFjdC5oYXNDb25kaXRpb25zKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNhbml0aXplciA9IG5ldyBTYW5pdGl6ZXIodGhpcywgYmFzZSwgdmlhLCB0aGlzLmNydWZ0KTtcblx0XHRcdFxuXHRcdFx0Ly8gSW4gdGhpcyBjYXNlLCB3ZSBvbmx5IG5lZWQgdG8gZG8gYSBcblx0XHRcdC8vIHNoYWxsb3cgY2hlY2sgZm9yIGNpcmN1bGFyIGluaGVyaXRhbmNlLlxuXHRcdFx0aWYgKHNhbml0aXplci5kZXRlY3RDaXJjdWxhclJlZmVyZW5jZXMoKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2FuaXRpemVyLmRldGVjdExpc3RGcmFnbWVudENvbmZsaWN0cygpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmJhc2VDb3VudCA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChzYW5pdGl6ZXIuZGV0ZWN0TGlzdERpbWVuc2lvbmFsaXR5Q29uZmxpY3QoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuYWRkQmFzZUVudHJ5KGJhc2UsIHZpYSwgZmFsc2UpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIGluZGlyZWN0bHkgYXBwbHkgYSBiYXNlIHRvIHRoaXMgU3BlY2lmaWVkUGFyYWxsZWwgdmlhIGFuIGFsaWFzXG5cdFx0ICogYW5kIGVkZ2UuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHBhdHRlcm5QYXJhbGxlbENhbmRpZGF0ZXMgVGhlIHBhdHRlcm4tY29udGFpbmluZ1xuXHRcdCAqIFNwZWNpZmllZFBhcmFsbGVsIGluc3RhbmNlIHdob3NlIGJhc2VzIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoaXNcblx0XHQgKiBTcGVjaWZpZWRQYXJhbGxlbCwgaWYgdGhlIHByb3ZpZGVkIGFsaWFzIGlzIGEgbWF0Y2guXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHZpYUVkZ2UgVGhlIEh5cGVyRWRnZSBpbiB3aGljaCB0aGUgYWxpYXMgd2FzIGZvdW5kLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB2aWFBbGlhcyBUaGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdCB0aGUgcGFyYWxsZWwgZW1iZWRkZWRcblx0XHQgKiB3aXRoaW4gcGF0dGVyblBhcmFsbGVsQ2FuZGlkYXRlcy5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGJhc2Ugd2FzIGFkZGVkXG5cdFx0ICogc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqL1xuXHRcdHRyeUFkZEFsaWFzZWRCYXNlKFxuXHRcdFx0cGF0dGVyblBhcmFsbGVsQ2FuZGlkYXRlczogU3BlY2lmaWVkUGFyYWxsZWxbXSxcblx0XHRcdHZpYUVkZ2U6IEh5cGVyRWRnZSxcblx0XHRcdHZpYUFsaWFzOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2Jhc2VzLmhhcyh2aWFFZGdlKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjaG9zZW5QYXJhbGxlbHMgPSBwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzLnNsaWNlKCk7XG5cdFx0XHRjb25zdCBjb25kaXRpb25zID0gdGhpcy5jb250cmFjdC51bnNhdGlzZmllZENvbmRpdGlvbnM7XG5cdFx0XHRjb25zdCBiZWdhbldpdGhDb25kaXRpb25zID0gY29uZGl0aW9ucy5zaXplID4gMDtcblx0XHRcdFxuXHRcdFx0aWYgKGJlZ2FuV2l0aENvbmRpdGlvbnMpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBtYXhNYXRjaENvdW50ID0gMTtcblx0XHRcdFx0XG5cdFx0XHRcdG5leHRDYW5kaWRhdGU6IGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHBhdHRlcm5QYXJhbGxlbENhbmRpZGF0ZXMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbShjYW5kaWRhdGUuX2Jhc2VzLnZhbHVlcygpKTtcblx0XHRcdFx0XHRjb25zdCBjYW5kaWRhdGVCYXNlcyA9IGVudHJpZXNcblx0XHRcdFx0XHRcdC5tYXAoZSA9PiBlLnBhcmFsbGVscylcblx0XHRcdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNhbmRpZGF0ZUJhc2VzLmxlbmd0aCA8IG1heE1hdGNoQ291bnQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGNhbmRpZGF0ZUJhc2Ugb2YgY2FuZGlkYXRlQmFzZXMpXG5cdFx0XHRcdFx0XHRpZiAoIWNvbmRpdGlvbnMuaGFzKGNhbmRpZGF0ZUJhc2UpKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZSBuZXh0Q2FuZGlkYXRlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNob3NlblBhcmFsbGVscy5wdXNoKGNhbmRpZGF0ZSk7XG5cdFx0XHRcdFx0bWF4TWF0Y2hDb3VudCA9IGNhbmRpZGF0ZUJhc2VzLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNob3NlblBhcmFsbGVscy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRsZXQgd2FzQWRkZWQgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjaG9zZW5QYXJhbGxlbCBvZiBjaG9zZW5QYXJhbGxlbHMpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEp1c3QgYXMgYSByZW1pbmRlciAtLSBwYXR0ZXJuLWNvbnRhaW5pbmcgcGFyYWxsZWxzIGRvbid0IGNvbWVcblx0XHRcdFx0Ly8gaW50byB0aGlzIG1ldGhvZCAuLi4gb25seSB0aGUgYWxpYXNlcyB0aGF0IG1pZ2h0IG1hdGNoIHRoZW0uXG5cdFx0XHRcdGlmICh0aGlzLnBhdHRlcm4gfHwgIWNob3NlblBhcmFsbGVsLnBhdHRlcm4pXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldFBhdHRlcm4gaGFzIG5vIGluZml4ZXMsIHdlIGNhbiBnZXQgYXdheSB3aXRoIGEgc2ltcGxlXG5cdFx0XHRcdC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgYWxpYXMgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxuXHRcdFx0XHRpZiAoIWNob3NlblBhcmFsbGVsLnBhdHRlcm4uaGFzSW5maXhlcygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCFjaG9zZW5QYXJhbGxlbC5wYXR0ZXJuLnRlc3QodmlhQWxpYXMpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGJlZ2FuV2l0aENvbmRpdGlvbnMpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jb250cmFjdC50cnlTYXRpc2Z5Q29uZGl0aW9uKGNob3NlblBhcmFsbGVsKSA9PT0gMClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5hZGRCYXNlRW50cnkoY2hvc2VuUGFyYWxsZWwsIHZpYUVkZ2UsIHRydWUpO1xuXHRcdFx0XHRcdHdhc0FkZGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBOb3QgaW1wbGVtZW50ZWQsIGJ1dCB3ZSBzaG91bGRuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGhlcmUgeWV0LlxuXHRcdFx0cmV0dXJuIHdhc0FkZGVkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byBhcHBseSBhIHNldCBvZiBiYXNlcyB0byBhIHBhdHRlcm4tY29udGFpbmluZyBwYXJhbGxlbC5cblx0XHQgKiBcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC9wYXR0ZXJuIDogVGhpcywgRnVuY3Rpb24sIEFkZHMsIFRoZXNlXG5cdFx0ICovXG5cdFx0dHJ5QXBwbHlQYXR0ZXJuQmFzZXMoYmFzZVRhYmxlOiBUQmFzZVRhYmxlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGJhc2VzID0gQXJyYXkuZnJvbShiYXNlVGFibGUua2V5cygpKTtcblx0XHRcdFxuXHRcdFx0Ly8gTm9uLVBhdHRlcm4gbm9kZXMgc2hvdWxkIG5ldmVyIGNvbWUgdG8gdGhpcyBtZXRob2QuXG5cdFx0XHRpZiAoIXRoaXMucGF0dGVybilcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBiYXNlc0RlZXAgPSBiYXNlc1xuXHRcdFx0XHQubWFwKGIgPT4gQXJyYXkuZnJvbShiLmVhY2hCYXNlRGVlcCgpKSlcblx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuXHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpO1xuXHRcdFx0XG5cdFx0XHQvLyBSZW1pbmRlcjogdGhlIFNwZWNpZmllZFBhcmFsbGVscyBpbiB0aGUgYmFzZXNEZWVwIGFycmF5XG5cdFx0XHQvLyBhcmUgZXhwZWN0ZWQgdG8gYmUgZnVsbHkgcHJvY2Vzc2VkIGJ5IHRoZSB0aW1lIHdlIGdldCB0b1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QuIEl0IHNob3VsZCBiZSBzYWZlIHRvIHRvdWNoIHRoZW0uXG5cdFx0XHRcblx0XHRcdGlmIChiYXNlc0RlZXAubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYmFzZXNOb2RlcyA9IGJhc2VzLm1hcChiID0+IGIubm9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBGaW5kcyBhbGwgcGF0dGVybiBub2RlcyB0aGF0IGhhdmUgYW4gZWRnZSB0aGF0IHBvaW50c1xuXHRcdFx0XHQvLyB0byBhdCBsZWFzdCBvbmUgb2YgdGhlIGJhc2VzIGluIHRoZSBiYXNlc0RlZXAgYXJyYXkuXG5cdFx0XHRcdGNvbnN0IGJhc2VzRGVlcFNwcmF3bCA9IGJhc2VzRGVlcFxuXHRcdFx0XHRcdC5tYXAoYiA9PiBBcnJheS5mcm9tKGIubm9kZS5pbmJvdW5kcykpXG5cdFx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuXHRcdFx0XHRcdC5tYXAoaW5iID0+IGluYi5wcmVkZWNlc3Nvcilcblx0XHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpXG5cdFx0XHRcdFx0LmZpbHRlcihub2RlID0+IG5vZGUuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0LmZpbHRlcihub2RlID0+IG5vZGUub3V0Ym91bmRzXG5cdFx0XHRcdFx0XHQuZmlsdGVyKG9iID0+IG9iLnN1Y2Nlc3NvcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0Lm1hcChvYiA9PiBvYi5zdWNjZXNzb3JzWzBdLm5vZGUpXG5cdFx0XHRcdFx0XHQuZXZlcnkobm9kZSA9PiBiYXNlc05vZGVzLmluY2x1ZGVzKG5vZGUpKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBiYXNlc0RlZXBTcHJhd2xQYXR0ZXJucyA9IGJhc2VzRGVlcFNwcmF3bFxuXHRcdFx0XHRcdC5tYXAobiA9PiBuLnN1YmplY3QpXG5cdFx0XHRcdFx0LmZpbHRlcigocyk6IHMgaXMgUGF0dGVybiA9PiBzIGluc3RhbmNlb2YgUGF0dGVybik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB0ZXN0IGV2ZXJ5IHNpbmdsZSBvbmUgb2YgdGhlIFxuXHRcdFx0XHQgKiBwYXR0ZXJucyBpbiBiYXNlc0RlZXBTcHJhd2xQYXR0ZXJucyBhZ2FpbnN0IHRoaXNcblx0XHRcdFx0ICogdGhpcy5ub2RlLnN1YmplY3QgdG8gbWFrZSBzdXJlIHRoZSB0d28gcGF0dGVybnMgYXJlXG5cdFx0XHRcdCAqIGNvbXBsaWFudC5cblx0XHRcdFx0ICogXG5cdFx0XHRcdCAqIElmIHRoZXkncmUgbm90IGNvbXBsaWFudCwgd2UgbmVlZCB0byBzdGFydCBtYXJraW5nXG5cdFx0XHRcdCAqIGJhc2VzIGFzIGNydWZ0IHVudGlsIHRoZXkgYXJlLlxuXHRcdFx0XHQgKiBcblx0XHRcdFx0ICogVGhlcmUgaXMgYWxzbyBhIHJlY3Vyc2l2ZSBpbmZpeCBlbWJlZCBwcm9jZXNzIHRoYXRcblx0XHRcdFx0ICogbmVlZHMgdG8gaGFwcGVuIGhlcmUsIGJ1dCBtYXliZSB3ZSBzaG91bGQganVzdFxuXHRcdFx0XHQgKiBwdXQgdGhpcyBvZmYgdW50aWwgdGhlIGJhc2ljIHBhdHRlcm4gZnVuY3Rpb25hbGl0eVxuXHRcdFx0XHQgKiBpcyB3b3JraW5nP1xuXHRcdFx0XHQgKi9cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIGFsc28gbmVlZHMgdG8gdGFrZSBpbnRvIGFjY291bnQgYW55IG90aGVyIHBhdHRlcm5zXG5cdFx0XHQgKiB0aGF0IGFyZSBhcHBsaWVkIHRvIGFueSBvZiB0aGUgYmFzZXMgZGVmaW5lZCBkaXJlY3RseVxuXHRcdFx0ICogaW5saW5lLlxuXHRcdFx0ICovXG5cdFx0XHRcblx0XHRcdC8vIEhlcmUgd2UncmUganVzdCBhZGRpbmcgYWxsIHRoZSBiYXNlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXJcblx0XHRcdC8vIG9yIG5vdCBhbnkgb2YgdGhlIGFzc29jaWF0ZWQgZWRnZXMgd2VyZSBtYXJrZWQgYXMgY3J1ZnQuXG5cdFx0XHQvLyBUaGUgb3RoZXIgZW51bWVyYXRvcnMgc2tpcCBvdmVyIGNydWZ0IGVkZ2VzLCBzbyB0aGlzIGxpa2VseVxuXHRcdFx0Ly8gaXNuJ3QgYSBwcm9ibGVtLCBhbmQgaXQga2VlcHMgaXQgY29uc2lzdGVudCB3aXRoIHRoZSB3YXkgdGhlXG5cdFx0XHQvLyByZXN0IG9mIHRoZSBzeXN0ZW0gd29ya3MuXG5cdFx0XHRmb3IgKGNvbnN0IFtiYXNlLCB2aWFdIG9mIGJhc2VUYWJsZSlcblx0XHRcdFx0dGhpcy5hZGRCYXNlRW50cnkoYmFzZSwgdmlhLCBmYWxzZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIG51bWJlciBvZiBiYXNlcyB0aGF0IGhhdmUgXG5cdFx0ICogYmVlbiBleHBsaWNpdGx5IGFwcGxpZWQgdG8gdGhpcyBQYXJhbGxlbC5cblx0XHQgKi9cblx0XHRnZXQgYmFzZUNvdW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYmFzZXMuc2l6ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzTGlzdEludHJpbnNpYygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZS5pc0xpc3RJbnRyaW5zaWM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBpbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2U7XG5cdFx0fVxuXHRcdHByaXZhdGUgX2ludHJpbnNpY0V4dHJpbnNpY0JyaWRnZTogU3BlY2lmaWVkUGFyYWxsZWwgfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBFc3RhYmxpc2hlcyBhIGJyaWRnZSBiZXR3ZWVuIHRoaXMgU3BlY2lmaWVkUGFyYWxsZWwgYW5kIHRoZVxuXHRcdCAqIG9uZSBwcm92aWRlZC4gXG5cdFx0ICovXG5cdFx0Y3JlYXRlSW50cmluc2ljRXh0cmluc2ljQnJpZGdlKHBhcmFsbGVsOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5faW50cmluc2ljRXh0cmluc2ljQnJpZGdlICE9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbGxlbC5faW50cmluc2ljRXh0cmluc2ljQnJpZGdlICE9PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbGxlbC5ub2RlLmlzTGlzdEludHJpbnNpYyA9PT0gdGhpcy5ub2RlLmlzTGlzdEludHJpbnNpYylcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UgPSBwYXJhbGxlbDtcblx0XHRcdHBhcmFsbGVsLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UgPSB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXRMaXN0RGltZW5zaW9uYWxpdHkoKTogbnVtYmVyXG5cdFx0e1xuXHRcdFx0Ly8gTk9URTogVGhpcyBhY3R1YWxseSBuZWVkcyB0byBiZSBcImVhY2ggYmFzZSBpbmZlcnJlZFwiXG5cdFx0XHRcblx0XHRcdC8vIFRoaXMgaXMgcHVycG9zZWx5IG9ubHkgcmV0dXJuaW5nIHRoZSBkaW1lbnNpb25hbGl0eSBvZlxuXHRcdFx0Ly8gdGhlIGZpcnN0IGJhc2UuIFRoZXJlIGlzIGEgZ3VhcmFudGVlIHRoYXQgYWxsIGRpbWVuc2lvbmFsaXRpZXNcblx0XHRcdC8vIHdpbGwgYmUgdGhlIHNhbWUgaGVyZS5cblx0XHRcdGZvciAoY29uc3QgeyBiYXNlLCBlZGdlIH0gb2YgdGhpcy5lYWNoQmFzZSgpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBpbml0aWFsRGltID0gYmFzZS5nZXRMaXN0RGltZW5zaW9uYWxpdHkoKTtcblx0XHRcdFx0cmV0dXJuIGVkZ2UuaXNMaXN0ID8gaW5pdGlhbERpbSArIDEgOiBpbml0aWFsRGltO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBjb21wYXJlUGF0dGVyblRvKG90aGVyOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBtYXliZUNvbXBpbGVQYXR0ZXJuKClcblx0XHR7XG5cdFx0XHQvLy9pZiAoIXRoaXMucGF0dGVybilcblx0XHRcdC8vL1x0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHQvLy9pZiAoIXBhdHRlcm4uaGFzSW5maXhlcygpKVxuXHRcdFx0Ly8vXHR0aGlzLmNvbXBpbGVkRXhwcmVzc2lvbiA9IHBhdHRlcm4uXG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIFBhdHRlcm4gaW5zdGFuY2UgdGhhdCByZXNpZGVzIGluc2lkZSB0aGlzIFNwZWNpZmllZFBhcmFsbGVsLFxuXHRcdCAqIG9yIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiB0aGlzIFNwZWNpZmllZFBhcmFsbGVsIGRvZXMgbm90IGhhdmUgYW5cblx0XHQgKiBpbm5lciBQYXR0ZXJuLlxuXHRcdCAqL1xuXHRcdGdldCBwYXR0ZXJuKCk6IFBhdHRlcm4gfCBudWxsXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybiA/XG5cdFx0XHRcdHRoaXMubm9kZS5zdWJqZWN0IDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21waWxlZCByZWd1bGFyIGV4cHJlc3Npb25cblx0XHQgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZSwgaW4gdGhlIGNhc2Ugd2hlbiB0aGlzIGluc3RhbmNlIGlzXG5cdFx0ICogYSBwYXR0ZXJuIHBhcmFsbGVsLlxuXHRcdCAqIFxuXHRcdCAqIFRoaXMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHNob3VsZCBoYXZlIGFueSBpbmZpeGVzIGNvbXBpbGVkIGF3YXksXG5cdFx0ICogYW5kIHNob3VsZCBiZSBwYXNzYWJsZSB0byBhIEphdmFTY3JpcHQgUmVnRXhwLCBvciB0byB0aGUgRnNtIHN5c3RlbS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGNvbXBpbGVkRXhwcmVzc2lvbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQSB0eXBlIHRoYXQgZGVzY3JpYmVzIGFuIGVudHJ5IGluIHRoZSBiYXNlcyBtYXBcblx0ICogb2YgYSBTcGVjaWZpZWRQYXJhbGxlbC5cblx0ICovXG5cdGludGVyZmFjZSBJQmFzZUVudHJ5XG5cdHtcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHNldCBvZiBTcGVjaWZpZWRQYXJhbGxlbHMgdGhhdCBjYXVzZWQgdGhlIGJhc2UgdG8gYmUgY29uc3RydWN0ZWQuXG5cdFx0ICogTm90ZSB0aGF0IGEgYmFzZSBlbnRyeSBjYW4gaGF2ZSBtdWx0aXBsZSBwYXJhbGxlbHMgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgYmFzZVxuXHRcdCAqIGlzIGFjdHVhbGx5IGEgcGF0dGVybiB3aXRoIHR3byBlcXVhbGx5IHZpYWJsZSBtYXRjaGVzIGluIHNjb3BlLCBhbmQgbm8gY29udHJhY3Rcblx0XHQgKiBiZWluZyBpbXBvc2VkLCBmb3IgZXhhbXBsZTpcblx0XHQgKiBcblx0XHQgKiAvcGF0dGVybiA6IEFcblx0XHQgKiAvcGF0dGVybiA6IEJcblx0XHQgKiBcblx0XHQgKiBWYWx1ZSA6IHBhdHRlcm4gfiBBLCBCXG5cdFx0ICovXG5cdFx0cGFyYWxsZWxzOiBTcGVjaWZpZWRQYXJhbGxlbFtdO1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgd2hldGhlciB0aGUgaWRlbnRpZmllciBpcyBhbiBhbGlhcyAobWF0Y2hlZCBieSBhIHBhdHRlcm4pLiAqL1xuXHRcdGFsaWFzZWQ6IGJvb2xlYW47XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBVbnNwZWNpZmllZFBhcmFsbGVsIGV4dGVuZHMgUGFyYWxsZWxcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEludm9rZWQgYnkgUGFyYWxsZWxDYWNoZS4gRG8gbm90IGNhbGwuXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHR1cmk6IFVyaSxcblx0XHRcdGNvbnRhaW5lcjogUGFyYWxsZWwgfCBudWxsKVxuXHRcdHtcblx0XHRcdHN1cGVyKHVyaSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXZvaWRzIGVycm9uZW91cyBzdHJ1Y3R1cmFsIHR5cGUgY29tcGF0aWJpbGl0eSB3aXRoIFBhcmFsbGVsLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgdW5pcXVlOiB1bmRlZmluZWQ7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBjbGFzcyBmb3IgaGFuZGxpbmcgb2JqZWN0cyBtYXJrZWQgYXMgY3J1ZnQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQ3J1ZnRDYWNoZVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtKSB7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBZGRzIGEgZmF1bHQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIHRvIHRoZSBpbnRlcm5hbCBzZXQsXG5cdFx0ICogbWFya3MgYWxsIHJlbGV2YW50IG9iamVjdHMgYXMgY3J1ZnQsIGFuZCByZXBvcnRzIHRoZVxuXHRcdCAqIHJlbGV2YW50IGZhdWx0IHR5cGUuXG5cdFx0ICovXG5cdFx0YWRkKGNydWZ0OiBUQ3J1ZnQsIHJlbGV2YW50RmF1bHRUeXBlOiBGYXVsdFR5cGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZmF1bHRTb3VyY2VzOiByZWFkb25seSBURmF1bHRTb3VyY2VbXSA9XG5cdFx0XHRcdGNydWZ0IGluc3RhbmNlb2YgTm9kZSA/IGNydWZ0LnN0YXRlbWVudHMgOiBcblx0XHRcdFx0Y3J1ZnQgaW5zdGFuY2VvZiBIeXBlckVkZ2UgPyBjcnVmdC5mcmFnbWVudHMgOlxuXHRcdFx0XHRbY3J1ZnRdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0U3JjIG9mIGZhdWx0U291cmNlcylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZmF1bHQgPSBuZXcgRmF1bHQocmVsZXZhbnRGYXVsdFR5cGUsIGZhdWx0U3JjKTtcblx0XHRcdFx0dGhpcy5wcm9ncmFtLmZhdWx0cy5yZXBvcnQoZmF1bHQpO1xuXHRcdFx0XHR0aGlzLmNydWZ0LmFkZChmYXVsdFNyYyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuY3J1ZnQuYWRkKGNydWZ0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG5cdFx0ICogc3BlY2lmaWVkIG9iamVjdCBoYXMgYmVlbiBtYXJrZWQgYXMgY3J1ZnQuXG5cdFx0ICovXG5cdFx0aGFzKHNvdXJjZTogVENydWZ0KVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNydWZ0Lmhhcyhzb3VyY2UpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogU3RvcmVzIGEgc2V0IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGFzIGNydWZ0LiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgY3J1ZnQgPSBuZXcgU2V0PFRDcnVmdD4oKTtcblx0fVxuXG5cblx0LyoqICovXG5cdGV4cG9ydCB0eXBlIFRDcnVmdCA9IFRGYXVsdFNvdXJjZSB8IE5vZGUgfCBIeXBlckVkZ2U7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUGFyYWxsZWxDYWNoZVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIFBhcmFsbGVsIGluc3RhbmNlIGZyb20gdGhlIHNwZWNpZmllZCBOb2RlIG9yXG5cdFx0ICogVXJpIGluc3RhbmNlLiBcblx0XHQgKiBcblx0XHQgKiBAdGhyb3dzIEluIHRoZSBjYXNlIHdoZW4gYWxsIGNvbnRhaW5pbmcgUGFyYWxsZWxUeXBlcyB0byBoYXZlXG5cdFx0ICogbm90IGJlZW4gY3JlYXRlZCBiZWZvcmVoYW5kLlxuXHRcdCAqIFxuXHRcdCAqIEB0aHJvdyBJbiB0aGUgY2FzZSB3aGVuIGEgUGFyYWxsZWxUeXBlIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG5cdFx0ICogaW5wdXQgd2FzIGFscmVhZHkgY3JlYXRlZC5cblx0XHQgKi9cblx0XHRjcmVhdGUobm9kZTogTm9kZSwgY3J1ZnQ6IENydWZ0Q2FjaGUpOiBTcGVjaWZpZWRQYXJhbGxlbDtcblx0XHRjcmVhdGUodXJpOiBVcmkpOiBVbnNwZWNpZmllZFBhcmFsbGVsO1xuXHRcdGNyZWF0ZShrZXk6IE5vZGUgfCBVcmksIGNydWZ0PzogQ3J1ZnRDYWNoZSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXMoa2V5KSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzYXZlID0gKHBhcjogUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGtleVZhbCA9IHRoaXMuZ2V0S2V5VmFsKGtleSk7XG5cdFx0XHRcdHRoaXMucGFyYWxsZWxzLnNldChrZXlWYWwsIHBhcik7XG5cdFx0XHRcdHJldHVybiBwYXI7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb250YWluZXIgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE5vZGUpXG5cdFx0XHRcdFx0cmV0dXJuIGtleS5jb250YWluZXIgIT09IG51bGwgP1xuXHRcdFx0XHRcdFx0Tm90LnVuZGVmaW5lZCh0aGlzLmdldChrZXkuY29udGFpbmVyKSkgOlxuXHRcdFx0XHRcdFx0bnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBrZXkudHlwZXMubGVuZ3RoID4gMSA/XG5cdFx0XHRcdFx0Tm90LnVuZGVmaW5lZCh0aGlzLmdldChrZXkucmV0cmFjdFR5cGUoMSkpKSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGlmIChrZXkgaW5zdGFuY2VvZiBVcmkpXG5cdFx0XHRcdHJldHVybiBzYXZlKG5ldyBVbnNwZWNpZmllZFBhcmFsbGVsKGtleSwgY29udGFpbmVyKSk7XG5cdFx0XHRcblx0XHRcdGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKSAmJiBjb250YWluZXIgIT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGNydWZ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgb3V0UGFyID0gbmV3IFNwZWNpZmllZFBhcmFsbGVsKGtleSwgY29udGFpbmVyLCBjcnVmdCk7XG5cdFx0XHRpZiAoa2V5LmludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHNhdmUob3V0UGFyKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFzKGtleS5pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGJyaWRnZVBhciA9IG5ldyBTcGVjaWZpZWRQYXJhbGxlbChcblx0XHRcdFx0a2V5LmludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSxcblx0XHRcdFx0Y29udGFpbmVyLFxuXHRcdFx0XHRjcnVmdCk7XG5cdFx0XHRcblx0XHRcdG91dFBhci5jcmVhdGVJbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UoYnJpZGdlUGFyKTtcblx0XHRcdHJldHVybiBzYXZlKG91dFBhcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldChrZXk6IFVyaSk6IFBhcmFsbGVsIHwgdW5kZWZpbmVkO1xuXHRcdGdldChrZXk6IE5vZGUpOiBTcGVjaWZpZWRQYXJhbGxlbCB8IHVuZGVmaW5lZDtcblx0XHRnZXQoa2V5OiBOb2RlIHwgVXJpKVxuXHRcdHtcblx0XHRcdGNvbnN0IGtleVZhbCA9IHRoaXMuZ2V0S2V5VmFsKGtleSk7XG5cdFx0XHRjb25zdCBvdXQgPSB0aGlzLnBhcmFsbGVscy5nZXQoa2V5VmFsKTtcblx0XHRcdFxuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE5vZGUpXG5cdFx0XHRcdGlmIChvdXQgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRpZiAoIShvdXQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbCkpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGhhcyhrZXk6IE5vZGUgfCBVcmkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyYWxsZWxzLmhhcyh0aGlzLmdldEtleVZhbChrZXkpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBnZXRLZXlWYWwoa2V5OiBOb2RlIHwgVXJpKVxuXHRcdHtcblx0XHRcdGNvbnN0IHVyaSA9IGtleSBpbnN0YW5jZW9mIE5vZGUgPyBrZXkudXJpIDoga2V5O1xuXHRcdFx0cmV0dXJuIHVyaS50b1N0cmluZygpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBtYXAgb2YgYWxsIFBhcmFsbGVsIGluc3RhbmNlcyB0aGF0IGhhdmUgYmVlblxuXHRcdCAqIGNvbnN0cnVjdGVkIGJ5IHRoaXMgb2JqZWN0LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcGFyYWxsZWxzID0gbmV3IE1hcDxzdHJpbmcsIFBhcmFsbGVsPigpO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBkZWJ1ZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdGV4dDogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5wYXJhbGxlbHMpXG5cdFx0XHRcdHRleHQucHVzaCh2YWx1ZS5uYW1lKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRleHQuam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDb250cmFjdFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3Ioc291cmNlUGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJlY3Vyc2UgPSAoc3JjUGFyYWxsZWw6IFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoc3JjUGFyYWxsZWwgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBuZXN0ZWRQYXJhbGxlbCBvZiBzcmNQYXJhbGxlbC5nZXRQYXJhbGxlbHMoKSlcblx0XHRcdFx0XHRcdHJlY3Vyc2UobmVzdGVkUGFyYWxsZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHNyY1BhcmFsbGVsIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIHNyY1BhcmFsbGVsLmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0XHR0aGlzLl91bnNhdGlzZmllZENvbmRpdGlvbnMuYWRkKGJhc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGhpZ2hlclBhcmFsbGVsIG9mIHNvdXJjZVBhcmFsbGVsLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRyZWN1cnNlKGhpZ2hlclBhcmFsbGVsKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hbGxDb25kaXRpb25zID0gT2JqZWN0LmZyZWV6ZShBcnJheS5mcm9tKHRoaXMuX3Vuc2F0aXNmaWVkQ29uZGl0aW9ucykpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb21wdXRlcyB3aGV0aGVyIHRoZSBpbnB1dCBTcGVjaWZpZWRQYXJhbGxlbCBpcyBhIG1vcmUgZGVyaXZlZFxuXHRcdCAqIHR5cGUgb2YgdGhlIFNwZWNpZmllZFBhcmFsbGVsIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhpcyBDb250cmFjdC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIG51bWJlciB0aGF0IGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIGNvbmRpdGlvbnMgdGhhdFxuXHRcdCAqIHdlcmUgc2F0aXNmaWVkIGFzIGEgcmVzdWx0IG9mIGFkZGluZyB0aGUgcHJvdmlkZWQgU3BlY2lmaWVkUGFyYWxsZWxcblx0XHQgKiB0byB0aGUgQ29udHJhY3QuXG5cdFx0ICovXG5cdFx0dHJ5U2F0aXNmeUNvbmRpdGlvbihmb3JlaWduUGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmFsbENvbmRpdGlvbnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZm9yZWlnblBhcmFsbGVsQmFzZXMgPSBuZXcgU2V0PFNwZWNpZmllZFBhcmFsbGVsPigpO1xuXHRcdFx0Zm9yZWlnblBhcmFsbGVsQmFzZXMuYWRkKGZvcmVpZ25QYXJhbGxlbCk7XG5cdFx0XHRcblx0XHRcdGxldCBzYXRpc2ZpZWQgPSAwO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBhZGRGb3JlaWduUGFyYWxsZWxCYXNlcyA9IChzcmNQYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2Ygc3JjUGFyYWxsZWwuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHRhZGRGb3JlaWduUGFyYWxsZWxCYXNlcyhiYXNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvcmVpZ25QYXJhbGxlbEJhc2VzLmFkZChzcmNQYXJhbGxlbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIGZvcmVpZ25QYXJhbGxlbC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRhZGRGb3JlaWduUGFyYWxsZWxCYXNlcyhiYXNlKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBmb3JlaWduQmFzZSBvZiBmb3JlaWduUGFyYWxsZWxCYXNlcylcblx0XHRcdFx0Zm9yIChjb25zdCBjb25kaXRpb24gb2YgdGhpcy5hbGxDb25kaXRpb25zKVxuXHRcdFx0XHRcdGlmIChmb3JlaWduQmFzZSA9PT0gY29uZGl0aW9uKVxuXHRcdFx0XHRcdFx0c2F0aXNmaWVkICs9IHRoaXMuX3Vuc2F0aXNmaWVkQ29uZGl0aW9ucy5kZWxldGUoY29uZGl0aW9uKSA/IDEgOiAwO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2F0aXNmaWVkO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgaGFzQ29uZGl0aW9ucygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYWxsQ29uZGl0aW9ucy5sZW5ndGggPiAwO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgdW5zYXRpc2ZpZWRDb25kaXRpb25zKCk6IFJlYWRvbmx5U2V0PFNwZWNpZmllZFBhcmFsbGVsPlxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl91bnNhdGlzZmllZENvbmRpdGlvbnM7XG5cdFx0fVxuXHRcdHByaXZhdGUgcmVhZG9ubHkgX3Vuc2F0aXNmaWVkQ29uZGl0aW9ucyA9IG5ldyBTZXQ8U3BlY2lmaWVkUGFyYWxsZWw+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBhcmFsbGVscyB0aGF0IGFueSBzdXBwbGllZFxuXHRcdCAqIHBhcmFsbGVsIG11c3QgaGF2ZSBpbiBpdCdzIGJhc2UgZ3JhcGggaW4gb3JkZXIgdG8gYmUgZGVlbWVkXG5cdFx0ICogY29tcGxpYW50LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgYWxsQ29uZGl0aW9uczogcmVhZG9ubHkgU3BlY2lmaWVkUGFyYWxsZWxbXTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIGFjdHVhbCBmYXVsdCBkZXRlY3Rpb24gYmVoYXZpb3IsXG5cdCAqIHdpdGggZmFjaWxpdGllcyB0byBwZXJmb3JtIGFuYWx5c2lzIG9uIFBhcmFsbGVsIGluc3RhbmNlcywgYmVmb3JlXG5cdCAqIHRoZSBhY3R1YWwgYmFzZSBoYXMgYmVlbiBhcHBsaWVkIHRvIGl0LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFNhbml0aXplclxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRwcml2YXRlIHJlYWRvbmx5IHRhcmdldFBhcmFsbGVsOiBTcGVjaWZpZWRQYXJhbGxlbCxcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgcHJvcG9zZWRCYXNlOiBTcGVjaWZpZWRQYXJhbGxlbCxcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgcHJvcG9zZWRFZGdlOiBIeXBlckVkZ2UsXG5cdFx0XHRwcml2YXRlIHJlYWRvbmx5IGNydWZ0OiBDcnVmdENhY2hlKSB7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBEZXRlY3RzIGxpc3Qgb3BlcmFydG9yIGNvbmZsaWN0cyBiZXR3ZWVuIHRoZSBmcmFnbWVudHMgb2YgYW5cblx0XHQgKiBhbm5vdGF0aW9uLiBGb3IgZXhhbXBsZSwgY29uZmxpY3RzIG9mIHRoZSBmb2xsb3dpbmcgdHlwZSBhcmVcblx0XHQgKiBjYXVnaHQgaGVyZTpcblx0XHQgKiBcblx0XHQgKiBMaXN0IDogSXRlbVxuXHRcdCAqIExpc3QgOiBJdGVtLi4uXG5cdFx0ICovXG5cdFx0ZGV0ZWN0TGlzdEZyYWdtZW50Q29uZmxpY3RzKClcblx0XHR7XG5cdFx0XHRjb25zdCBzb3VyY2VzID0gdGhpcy5wcm9wb3NlZEVkZ2UuZnJhZ21lbnRzO1xuXHRcdFx0aWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNwYW5zID0gc291cmNlcy5maWx0ZXIoKHNyYyk6IHNyYyBpcyBTcGFuID0+IHNyYyBpbnN0YW5jZW9mIFNwYW4pO1xuXHRcdFx0Y29uc3QgaWRlbnRpZmllcnMgPSBzcGFuc1xuXHRcdFx0XHQubWFwKGYgPT4gZi5ib3VuZGFyeS5zdWJqZWN0KVxuXHRcdFx0XHQuZmlsdGVyKChzdWIpOiBzdWIgaXMgSWRlbnRpZmllciA9PiBzdWIgaW5zdGFuY2VvZiBJZGVudGlmaWVyKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWRlbnRpZmllcnNMaXN0ID0gaWRlbnRpZmllcnMuZmlsdGVyKGlkID0+IGlkLmlzTGlzdCk7XG5cdFx0XHRjb25zdCBpZGVudGlmaWVyc05vbkxpc3QgPSBpZGVudGlmaWVycy5maWx0ZXIoaWQgPT4gIWlkLmlzTGlzdCk7XG5cdFx0XHRcblx0XHRcdGlmIChpZGVudGlmaWVyc0xpc3QubGVuZ3RoID4gMCAmJiBpZGVudGlmaWVyc05vbkxpc3QubGVuZ3RoID4gMClcblx0XHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKVxuXHRcdFx0XHRcdHRoaXMuYWRkRmF1bHQoc3BhbiwgRmF1bHRzLkxpc3RBbm5vdGF0aW9uQ29uZmxpY3QpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mb3VuZENydWZ0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRkZXRlY3RDaXJjdWxhclJlZmVyZW5jZXMoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNpcmN1bGFyRWRnZVBhdGhzOiBIeXBlckVkZ2VbXVtdID0gW107XG5cdFx0XHRjb25zdCByZWN1cnNlID0gKFxuXHRcdFx0XHRzcmNCYXNlOiBTcGVjaWZpZWRQYXJhbGxlbCxcblx0XHRcdFx0cGF0aDogSHlwZXJFZGdlW10pID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlLCBlZGdlIH0gb2YgdGhpcy5iYXNlc09mKHNyY0Jhc2UpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHBhdGguaW5jbHVkZXMoZWRnZSkpXG5cdFx0XHRcdFx0XHRjaXJjdWxhckVkZ2VQYXRocy5wdXNoKHBhdGguc2xpY2UoKSk7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmVjdXJzZShiYXNlLCBwYXRoLmNvbmNhdChlZGdlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgeyBiYXNlLCBlZGdlIH0gb2YgdGhpcy5iYXNlc09mKHRoaXMudGFyZ2V0UGFyYWxsZWwpKVxuXHRcdFx0XHRyZWN1cnNlKGJhc2UsIFtdKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIGNpcmN1bGFyRWRnZVBhdGhzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGNpcmN1bGFyRWRnZSBvZiBpdGVtKVxuXHRcdFx0XHRcdHRoaXMuYWRkRmF1bHQoY2lyY3VsYXJFZGdlLCBGYXVsdHMuQ2lyY3VsYXJUeXBlUmVmZXJlbmNlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZm91bmRDcnVmdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZGV0ZWN0TGlzdERpbWVuc2lvbmFsaXR5Q29uZmxpY3QoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRhcmdldERpbSA9IHRoaXMudGFyZ2V0UGFyYWxsZWwuZ2V0TGlzdERpbWVuc2lvbmFsaXR5KCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHByb3Bvc2VkRGltID0gXG5cdFx0XHRcdHRoaXMucHJvcG9zZWRCYXNlLmdldExpc3REaW1lbnNpb25hbGl0eSgpICtcblx0XHRcdFx0KHRoaXMucHJvcG9zZWRFZGdlLmlzTGlzdCA/IDEgOiAwKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRhcmdldERpbSAhPT0gcHJvcG9zZWREaW0pXG5cdFx0XHRcdHRoaXMuYWRkRmF1bHQodGhpcy5wcm9wb3NlZEVkZ2UsIEZhdWx0cy5MaXN0RGltZW5zaW9uYWxEaXNjcmVwYW5jeUZhdWx0KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZm91bmRDcnVmdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIEdldHMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBmYXVsdCBoYXMgYmVlbiByZXBvcnRlZC4gKi9cblx0XHRnZXQgZm91bmRDcnVmdCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ZvdW5kQ3J1ZnQ7XG5cdFx0fVxuXHRcdHByaXZhdGUgX2ZvdW5kQ3J1ZnQgPSBmYWxzZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlICpiYXNlc09mKHBhcjogU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCB7IGJhc2UsIGVkZ2UgfSBvZiBwYXIuZWFjaEJhc2UoKSlcblx0XHRcdFx0eWllbGQgeyBiYXNlLCBlZGdlIH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnRhcmdldFBhcmFsbGVsID09PSBwYXIpXG5cdFx0XHRcdHlpZWxkIHsgYmFzZTogdGhpcy5wcm9wb3NlZEJhc2UsIGVkZ2U6IHRoaXMucHJvcG9zZWRFZGdlIH07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgYWRkRmF1bHQoc291cmNlOiBUQ3J1ZnQsIHJlbGV2YW50RmF1bHRUeXBlOiBGYXVsdFR5cGUpXG5cdFx0e1xuXHRcdFx0dGhpcy5fZm91bmRDcnVmdCA9IHRydWU7XG5cdFx0XHR0aGlzLmNydWZ0LmFkZChzb3VyY2UsIHJlbGV2YW50RmF1bHRUeXBlKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKiAqL1xuXHRpbnRlcmZhY2UgSVN0b3JlZENvbnRleHRcblx0e1xuXHRcdHZlcnNpb246IFZlcnNpb25TdGFtcDtcblx0XHR3b3JrZXI6IENvbnN0cnVjdGlvbldvcmtlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGZ1bGx5IGNvbnN0cnVjdGVkIHR5cGUgd2l0aGluIHRoZSBwcm9ncmFtLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFR5cGVcblx0e1xuXHRcdC8qKiBcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBDb25zdHJ1Y3RzIG9uZSBvciBtb3JlIFR5cGUgb2JqZWN0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG5cdFx0ICovXG5cdFx0c3RhdGljIGNvbnN0cnVjdCh1cmk6IFVyaSwgcHJvZ3JhbTogUHJvZ3JhbSk6IFR5cGUgfCBudWxsO1xuXHRcdHN0YXRpYyBjb25zdHJ1Y3Qoc3BpbmU6IFNwaW5lLCBwcm9ncmFtOiBQcm9ncmFtKTogVHlwZTtcblx0XHRzdGF0aWMgY29uc3RydWN0KHBhcmFtOiBVcmkgfCBTcGluZSwgcHJvZ3JhbTogUHJvZ3JhbSk6IFR5cGUgfCBudWxsXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpID0gVXJpLmNsb25lKHBhcmFtKTtcblx0XHRcdGlmICh1cmkudHlwZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKFR5cGVDYWNoZS5oYXModXJpLCBwcm9ncmFtKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2FjaGVkID0gVHlwZUNhY2hlLmdldCh1cmksIHByb2dyYW0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgdGhlIGNhY2hlZCB0eXBlIGV4aXN0cywgYnV0IGhhc24ndCBiZWVuIGNvbXBpbGVkIHlldCxcblx0XHRcdFx0Ly8gd2UgY2FuJ3QgcmV0dXJuIGl0LCB3ZSBuZWVkIHRvIGNvbXBpbGUgaXQgZmlyc3QuXG5cdFx0XHRcdGlmIChjYWNoZWQgPT09IG51bGwgfHwgY2FjaGVkIGluc3RhbmNlb2YgVHlwZSlcblx0XHRcdFx0XHRyZXR1cm4gY2FjaGVkIGFzIFR5cGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHdvcmtlciA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdG9yZWQgPSB0aGlzLnBhcmFsbGVsQ29udGV4dE1hcC5nZXQocHJvZ3JhbSk7XG5cdFx0XHRcdGlmIChzdG9yZWQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IG5ld1N0b3JlZDogSVN0b3JlZENvbnRleHQgPSB7XG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiBwcm9ncmFtLnZlcnNpb24sXG5cdFx0XHRcdFx0XHR3b3JrZXI6IG5ldyBDb25zdHJ1Y3Rpb25Xb3JrZXIocHJvZ3JhbSlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMucGFyYWxsZWxDb250ZXh0TWFwLnNldChwcm9ncmFtLCBuZXdTdG9yZWQpO1xuXHRcdFx0XHRcdHJldHVybiBuZXdTdG9yZWQud29ya2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHByb2dyYW0udmVyc2lvbi5uZXdlclRoYW4oc3RvcmVkLnZlcnNpb24pKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3RvcmVkLnZlcnNpb24gPSBwcm9ncmFtLnZlcnNpb247XG5cdFx0XHRcdFx0c3RvcmVkLndvcmtlciA9IG5ldyBDb25zdHJ1Y3Rpb25Xb3JrZXIocHJvZ3JhbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBzdG9yZWQud29ya2VyO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcGFyYWxsZWwgPSB3b3JrZXIuZHJpbGwodXJpKTtcblx0XHRcdGlmIChwYXJhbGxlbCA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0VHlwZUNhY2hlLnNldCh1cmksIHByb2dyYW0sIG51bGwpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgcGFyYWxsZWxMaW5lYWdlID0gW3BhcmFsbGVsXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgY3VycmVudFBhcmFsbGVsID0gcGFyYWxsZWwuY29udGFpbmVyOyBjdXJyZW50UGFyYWxsZWwgIT09IG51bGw7KVxuXHRcdFx0e1xuXHRcdFx0XHRwYXJhbGxlbExpbmVhZ2UudW5zaGlmdChjdXJyZW50UGFyYWxsZWwpO1xuXHRcdFx0XHRjdXJyZW50UGFyYWxsZWwgPSBjdXJyZW50UGFyYWxsZWwuY29udGFpbmVyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRsZXQgbGFzdFR5cGU6IFR5cGUgfCBudWxsID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjdXJyZW50UGFyYWxsZWwgb2YgcGFyYWxsZWxMaW5lYWdlKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoVHlwZUNhY2hlLmhhcyhjdXJyZW50UGFyYWxsZWwudXJpLCBwcm9ncmFtKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGV4aXN0aW5nVHlwZSA9IFR5cGVDYWNoZS5nZXQoY3VycmVudFBhcmFsbGVsLnVyaSwgcHJvZ3JhbSk7XG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nVHlwZSBpbnN0YW5jZW9mIFR5cGVQcm94eSlcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZXhpc3RpbmdUeXBlID09PSBudWxsKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGxhc3RUeXBlID0gZXhpc3RpbmdUeXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHR5cGU6IFR5cGUgPSBuZXcgVHlwZShjdXJyZW50UGFyYWxsZWwsIGxhc3RUeXBlLCBwcm9ncmFtKTtcblx0XHRcdFx0XHRUeXBlQ2FjaGUuc2V0KGN1cnJlbnRQYXJhbGxlbC51cmksIHByb2dyYW0sIHR5cGUpO1xuXHRcdFx0XHRcdGxhc3RUeXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGFzdFR5cGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIENvbnN0cnVjdHMgdGhlIGludmlzaWJsZSByb290LWxldmVsIFR5cGUgb2JqZWN0IHRoYXQgY29ycmVzcG9uZHNcblx0XHQgKiB0byB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBjb25zdHJ1Y3RSb290cyhkb2N1bWVudDogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcHJvZ3JhbSA9IGRvY3VtZW50LnByb2dyYW07XG5cdFx0XHRjb25zdCByb290czogVHlwZVtdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiBwcm9ncmFtLmdyYXBoLnJlYWRSb290cyhkb2N1bWVudCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmNvbnN0cnVjdChub2RlLnVyaSwgcHJvZ3JhbSk7XG5cdFx0XHRcdGlmICh0eXBlICE9PSBudWxsKVxuXHRcdFx0XHRcdHJvb3RzLnB1c2godHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHJvb3RzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgcGFyYWxsZWxDb250ZXh0TWFwID0gbmV3IFdlYWtNYXA8UHJvZ3JhbSwgSVN0b3JlZENvbnRleHQ+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3Rvcihcblx0XHRcdHNlZWQ6IFBhcmFsbGVsLFxuXHRcdFx0Y29udGFpbmVyOiBUeXBlIHwgbnVsbCxcblx0XHRcdHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0dGhpcy5wcml2YXRlID0gbmV3IFR5cGVQcml2YXRlKHByb2dyYW0sIHNlZWQpO1xuXHRcdFx0dGhpcy5uYW1lID0gc2VlZC51cmkudHlwZXNbc2VlZC51cmkudHlwZXMubGVuZ3RoIC0gMV0udmFsdWU7XG5cdFx0XHR0aGlzLnVyaSA9IHNlZWQudXJpO1xuXHRcdFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS5wYXJhbGxlbHMgPSBuZXcgVHlwZVByb3h5QXJyYXkoXG5cdFx0XHRcdHNlZWQuZ2V0UGFyYWxsZWxzKCkubWFwKGVkZ2UgPT5cblx0XHRcdFx0XHRuZXcgVHlwZVByb3h5KGVkZ2UudXJpLCBwcm9ncmFtKSkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBnZXRCYXNlcyA9IChzcDogU3BlY2lmaWVkUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGJhc2VzID0gQXJyYXkuZnJvbShzcC5lYWNoQmFzZSgpKTtcblx0XHRcdFx0cmV0dXJuIGJhc2VzLm1hcChlbnRyeSA9PiBcblx0XHRcdFx0XHRuZXcgVHlwZVByb3h5KGVudHJ5LmJhc2Uubm9kZS51cmksIHByb2dyYW0pKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWVkIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMucHJpdmF0ZS5iYXNlcyA9IG5ldyBUeXBlUHJveHlBcnJheShnZXRCYXNlcyhzZWVkKSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzZWVkIGluc3RhbmNlb2YgVW5zcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgcXVldWU6IFBhcmFsbGVsW10gPSBbc2VlZF07XG5cdFx0XHRcdGNvbnN0IHNwZWNpZmllZFBhcmFsbGVsczogU3BlY2lmaWVkUGFyYWxsZWxbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBxdWV1ZS5sZW5ndGg7KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudCA9IHF1ZXVlW2ldO1xuXHRcdFx0XHRcdGlmIChjdXJyZW50IGluc3RhbmNlb2YgVW5zcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goLi4uY3VycmVudC5nZXRQYXJhbGxlbHMoKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZWxzZSBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0c3BlY2lmaWVkUGFyYWxsZWxzLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJhc2VzID0gc3BlY2lmaWVkUGFyYWxsZWxzXG5cdFx0XHRcdFx0Lm1hcChwYXIgPT4gZ2V0QmFzZXMocGFyKSlcblx0XHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pXG5cdFx0XHRcdFx0LmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMucHJpdmF0ZS5iYXNlcyA9IG5ldyBUeXBlUHJveHlBcnJheShiYXNlcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuaXNMaXN0ID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChzZWVkIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN1YiA9IHNlZWQubm9kZS5zdWJqZWN0O1xuXHRcdFx0XHR0aGlzLmlzUGF0dGVybiA9IHN1YiBpbnN0YW5jZW9mIFBhdHRlcm47XG5cdFx0XHRcdHRoaXMuaXNVcmkgPSBzdWIgaW5zdGFuY2VvZiBVcmk7XG5cdFx0XHRcdHRoaXMuaXNBbm9ueW1vdXMgPSBzdWIgaW5zdGFuY2VvZiBBbm9uO1xuXHRcdFx0XHR0aGlzLmlzU3BlY2lmaWVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5pc0ZyZXNoID0gc2VlZC5nZXRQYXJhbGxlbHMoKS5sZW5ndGggPT09IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5hbWUgb2YgdGhlIHR5cGUsXG5cdFx0ICogb3IgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIHBhdHRlcm4gY29udGVudCBpbiB0aGVcblx0XHQgKiBjYXNlIHdoZW4gdGhlIHR5cGUgaXMgYWN0dWFsbHkgYSBwYXR0ZXJuLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIFVSSSB0aGF0IHNwZWNpZmllcyB3aGVyZSB0aGlzIFR5cGUgd2FzXG5cdFx0ICogZm91bmQgaW4gdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHVyaTogVXJpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHJlZmVyZW5jZSB0byB0aGUgdHlwZSwgYXMgaXQncyBkZWZpbmVkIGluIGl0J3Ncblx0XHQgKiBuZXh0IG1vc3QgYXBwbGljYWJsZSB0eXBlLlxuXHRcdCAqL1xuXHRcdGdldCBwYXJhbGxlbHMoKVxuXHRcdHtcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdHJldHVybiBOb3QubnVsbCh0aGlzLnByaXZhdGUucGFyYWxsZWxzKS5tYXliZUNvbXBpbGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJhbGxlbCByb290cyBvZiB0aGlzIHR5cGUuXG5cdFx0ICogVGhlIHBhcmFsbGVsIHJvb3RzIGFyZSB0aGUgZW5kcG9pbnRzIGZvdW5kIHdoZW5cblx0XHQgKiB0cmF2ZXJzaW5nIHVwd2FyZCB0aHJvdWdoIHRoZSBwYXJhbGxlbCBncmFwaC5cblx0XHQgKi9cblx0XHRnZXQgcGFyYWxsZWxSb290cygpXG5cdFx0e1xuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLnBhcmFsbGVsUm9vdHMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUucGFyYWxsZWxSb290cztcblx0XHRcdFxuXHRcdFx0Y29uc3Qgcm9vdHM6IFR5cGVbXSA9IFtdO1xuXHRcdFx0Zm9yIChjb25zdCB7IHR5cGUgfSBvZiB0aGlzLml0ZXJhdGUodCA9PiB0LnBhcmFsbGVscykpXG5cdFx0XHRcdGlmICh0eXBlICE9PSB0aGlzICYmIHR5cGUucGFyYWxsZWxzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyb290cy5wdXNoKHR5cGUpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnBhcmFsbGVsUm9vdHMgPSBPYmplY3QuZnJlZXplKHJvb3RzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBUeXBlIHRoYXQgY29udGFpbnMgdGhpcyBUeXBlLCBvciBudWxsIGluXG5cdFx0ICogdGhlIGNhc2Ugd2hlbiB0aGlzIFR5cGUgaXMgdG9wLWxldmVsLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGNvbnRhaW5lcjogVHlwZSB8IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IGFyZSBjb250YWluZWQgZGlyZWN0bHkgYnkgdGhpc1xuXHRcdCAqIG9uZS4gSW4gdGhlIGNhc2Ugd2hlbiB0aGlzIHR5cGUgaXMgYSBsaXN0IHR5cGUsIHRoaXMgYXJyYXkgZG9lc1xuXHRcdCAqIG5vdCBpbmNsdWRlIHRoZSBsaXN0J3MgaW50cmluc2ljIHR5cGVzLlxuXHRcdCAqL1xuXHRcdGdldCBjb250ZW50cygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5jb250ZW50cyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5jb250ZW50cztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0Y29uc3QgY29udGFpbmVkTmFtZXM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcblx0XHRcdC8vIERpZyB0aHJvdWdoIHRoZSBwYXJhbGxlbCBncmFwaCByZWN1cnNpdmVseSwgYW5kIGF0IGVhY2ggcGFyYWxsZWwsXG5cdFx0XHQvLyBkaWcgdGhyb3VnaCB0aGUgYmFzZSBncmFwaCByZWN1cnNpdmVseSwgYW5kIGNvbGxlY3QgYWxsIHRoZSBuYW1lc1xuXHRcdFx0Ly8gdGhhdCBhcmUgZm91bmQuXG5cdFx0XHRmb3IgKGNvbnN0IHsgdHlwZTogcGFyYWxsZWxUeXBlIH0gb2YgdGhpcy5pdGVyYXRlKHQgPT4gdC5wYXJhbGxlbHMsIHRydWUpKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHsgdHlwZTogYmFzZVR5cGUgfSBvZiBwYXJhbGxlbFR5cGUuaXRlcmF0ZSh0ID0+IHQuYmFzZXMsIHRydWUpKVxuXHRcdFx0XHRcdGlmIChiYXNlVHlwZS5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiBiYXNlVHlwZS5wcml2YXRlLnNlZWQubm9kZS5jb250ZW50cy5rZXlzKCkpXG5cdFx0XHRcdFx0XHRcdGlmICghY29udGFpbmVkTmFtZXMuaW5jbHVkZXMobmFtZSkpXG5cdFx0XHRcdFx0XHRcdFx0Y29udGFpbmVkTmFtZXMucHVzaChuYW1lKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29udGVudHMgPSBjb250YWluZWROYW1lc1xuXHRcdFx0XHQubWFwKGNvbnRhaW5lZE5hbWUgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IG1heWJlQ29udGFpbmVkVXJpID0gdGhpcy51cmkuZXh0ZW5kVHlwZShjb250YWluZWROYW1lKTtcblx0XHRcdFx0XHRyZXR1cm4gVHlwZS5jb25zdHJ1Y3QobWF5YmVDb250YWluZWRVcmksIHRoaXMucHJpdmF0ZS5wcm9ncmFtKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmZpbHRlcigodCk6IHQgaXMgVHlwZSA9PiB0ICE9PSBudWxsKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5jb250ZW50cyA9IE9iamVjdC5mcmVlemUoY29udGVudHMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgYXJlIGNvbnRhaW5lZCBkaXJlY3RseSBieSB0aGlzXG5cdFx0ICogb25lLiBJbiB0aGUgY2FzZSB3aGVuIHRoaXMgdHlwZSBpcyBub3QgYSBsaXN0IHR5cGUsIHRoaXMgYXJyYXlcblx0XHQgKiBpcyBlbXB0eS5cblx0XHQgKi9cblx0XHRnZXQgY29udGVudHNJbnRyaW5zaWMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuY29udGVudHNJbnRyaW5zaWMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuY29udGVudHNJbnRyaW5zaWM7XG5cdFx0XHRcblx0XHRcdGlmICghdGhpcy5pc0xpc3QpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuY29udGVudHNJbnRyaW5zaWMgPSBPYmplY3QuZnJlZXplKFtdKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBhcnJheSBvZiB0eXBlcyBmcm9tIHdoaWNoIHRoaXMgdHlwZSBleHRlbmRzLlxuXHRcdCAqIElmIHRoaXMgVHlwZSBleHRlbmRzIGZyb20gYSBwYXR0ZXJuLCBpdCBpcyBpbmNsdWRlZCBpbiB0aGlzXG5cdFx0ICogYXJyYXkuXG5cdFx0ICovXG5cdFx0Z2V0IGJhc2VzKCk6IHJlYWRvbmx5IFR5cGVbXVxuXHRcdHtcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5iYXNlcyA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmJhc2VzLm1heWJlQ29tcGlsZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBOb3QgaW1wbGVtZW50ZWQuXG5cdFx0ICovXG5cdFx0Z2V0IHN1cGVyb3JkaW5hdGVzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLnN1cGVyb3JkaW5hdGVzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnN1cGVyb3JkaW5hdGVzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnN1cGVyb3JkaW5hdGVzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXHRcdGdldCBzdWJvcmRpbmF0ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuc3Vib3JkaW5hdGVzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnN1Ym9yZGluYXRlcztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5zdWJvcmRpbmF0ZXMgPSBPYmplY3QuZnJlZXplKFtdKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB0eXBlcyB0aGF0IGRlcml2ZSBmcm9tIHRoZSBcblx0XHQgKiB0aGlzIFR5cGUgaW5zdGFuY2UuXG5cdFx0ICogXG5cdFx0ICogVGhlIHR5cGVzIHRoYXQgZGVyaXZlIGZyb20gdGhpcyBvbmUgYXMgYSByZXN1bHQgb2YgdGhlIHVzZSBvZlxuXHRcdCAqIGFuIGFsaWFzIGFyZSBleGNsdWRlZCBmcm9tIHRoaXMgYXJyYXkuXG5cdFx0ICovXG5cdFx0Z2V0IGRlcml2YXRpb25zKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmRlcml2YXRpb25zICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmRlcml2YXRpb25zO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdGlmICghKHRoaXMucHJpdmF0ZS5zZWVkIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmRlcml2YXRpb25zID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlcml2YXRpb25zID0gQXJyYXkuZnJvbSh0aGlzLnByaXZhdGUuc2VlZC5ub2RlLmluYm91bmRzKVxuXHRcdFx0XHQubWFwKGliID0+IGliLnByZWRlY2Vzc29yLnVyaSlcblx0XHRcdFx0Lm1hcCh1cmkgPT4gVHlwZS5jb25zdHJ1Y3QodXJpLCB0aGlzLnByaXZhdGUucHJvZ3JhbSkpXG5cdFx0XHRcdC5maWx0ZXIoKHQpOiB0IGlzIFR5cGUgPT4gdCBpbnN0YW5jZW9mIFR5cGUpXG5cdFx0XHRcdC5maWx0ZXIodHlwZSA9PiB0eXBlLmJhc2VzLmluY2x1ZGVzKHRoaXMpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5kZXJpdmF0aW9ucyA9IE9iamVjdC5mcmVlemUoZGVyaXZhdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHRoYXQgc2hhcmUgdGhlIHNhbWUgY29udGFpbmluZ1xuXHRcdCAqIHR5cGUgYXMgdGhpcyBvbmUuXG5cdFx0ICovXG5cdFx0Z2V0IGFkamFjZW50cygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5hZGphY2VudHMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWRqYWNlbnRzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmNvbnRhaW5lcilcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5hZGphY2VudHMgPSB0aGlzLmNvbnRhaW5lci5jb250ZW50cy5maWx0ZXIodCA9PiB0ICE9PSB0aGlzKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucHJpdmF0ZS5wcm9ncmFtO1xuXHRcdFx0Y29uc3QgZG9jdW1lbnQgPSBOb3QubnVsbChwcm9ncmFtLmRvY3VtZW50cy5nZXQodGhpcy51cmkpKTtcblx0XHRcdGNvbnN0IHJvb3RzID0gQXJyYXkuZnJvbSh0aGlzLnByaXZhdGUucHJvZ3JhbS5ncmFwaC5yZWFkUm9vdHMoZG9jdW1lbnQpKTtcblx0XHRcdGNvbnN0IGFkamFjZW50cyA9IHJvb3RzXG5cdFx0XHRcdC5tYXAobm9kZSA9PiBUeXBlLmNvbnN0cnVjdChub2RlLnVyaSwgcHJvZ3JhbSkpXG5cdFx0XHRcdC5maWx0ZXIoKHQpOiB0IGlzIFR5cGUgPT4gdCAhPT0gbnVsbCAmJiB0ICE9PSB0aGlzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5hZGphY2VudHMgPSBPYmplY3QuZnJlZXplKGFkamFjZW50cyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgcGF0dGVybnMgdGhhdCByZXNvbHZlIHRvIHRoaXMgdHlwZS5cblx0XHQgKi9cblx0XHRnZXQgcGF0dGVybnMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUucGF0dGVybnMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUucGF0dGVybnM7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIGEgbWFwIHdob3NlIGtleXMgYXJlIGEgY29uY2F0ZW5hdGlvbiBvZiB0aGUgVXJpcyBvZiBhbGxcblx0XHRcdC8vIHRoZSBiYXNlcyB0aGF0IGFyZSBtYXRjaGVkIGJ5IGEgcGFydGljdWxhciBwYXR0ZXJuLCBhbmQgd2hvc2Vcblx0XHRcdC8vIHZhbHVlcyBhcmUgdGhlIHR5cGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhhdCBwYXR0ZXJuLiBUaGlzIG1hcFxuXHRcdFx0Ly8gcHJvdmlkZXMgYW4gZWFzeSB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBwYXR0ZXJuXG5cdFx0XHQvLyB0aGF0IG1hdGNoZXMgYSBwYXJ0aWN1bGFyIHNldCBvZiB0eXBlcyBpbiB0aGUgdHlwZSBzY29wZS5cblx0XHRcdGNvbnN0IHBhdHRlcm5NYXAgPSBuZXcgTWFwPHN0cmluZywgVHlwZT4oKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB7IHR5cGUgfSBvZiB0aGlzLml0ZXJhdGUodCA9PiB0LmNvbnRhaW5lcikpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGFwcGxpY2FibGVQYXR0ZXJuVHlwZXMgPSB0eXBlLmFkamFjZW50c1xuXHRcdFx0XHRcdC5maWx0ZXIodCA9PiB0LmlzUGF0dGVybilcblx0XHRcdFx0XHQuZmlsdGVyKHQgPT4gdC5iYXNlcy5pbmNsdWRlcyh0eXBlKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhcHBsaWNhYmxlUGF0dGVybnNCYXNlc0xhYmVscyA9XG5cdFx0XHRcdFx0YXBwbGljYWJsZVBhdHRlcm5UeXBlcy5tYXAocCA9PiBwLmJhc2VzXG5cdFx0XHRcdFx0XHQubWFwKGIgPT4gYi51cmkudG9TdHJpbmcoKSlcblx0XHRcdFx0XHRcdC5qb2luKFN5bnRheC50ZXJtaW5hbCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBhcHBsaWNhYmxlUGF0dGVyblR5cGVzLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBiYXNlTGFiZWwgPSBhcHBsaWNhYmxlUGF0dGVybnNCYXNlc0xhYmVsc1tpXTtcblx0XHRcdFx0XHRpZiAoIXBhdHRlcm5NYXAuaGFzKGJhc2VMYWJlbCkpXG5cdFx0XHRcdFx0XHRwYXR0ZXJuTWFwLnNldChiYXNlTGFiZWwsIGFwcGxpY2FibGVQYXR0ZXJuVHlwZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dCA9IEFycmF5LmZyb20ocGF0dGVybk1hcC52YWx1ZXMoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnBhdHRlcm5zID0gT2JqZWN0LmZyZWV6ZShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJhdyBzdHJpbmcgdmFsdWVzIHJlcHJlc2VudGluZ1xuXHRcdCAqIHRoZSB0eXBlIGFsaWFzZXMgd2l0aCB3aGljaCB0aGlzIHR5cGUgaGFzIGJlZW4gYW5ub3RhdGVkLlxuXHRcdCAqIFxuXHRcdCAqIElmIHRoaXMgdHlwZSBpcyB1bnNwZWNpZmllZCwgdGhlIHBhcmFsbGVsIGdyYXBoIGlzIHNlYXJjaGVkLFxuXHRcdCAqIGFuZCBhbnkgYXBwbGljYWJsZSB0eXBlIGFsaWFzZXMgd2lsbCBiZSBwcmVzZW50IGluIHRoZSByZXR1cm5lZFxuXHRcdCAqIGFycmF5LlxuXHRcdCAqL1xuXHRcdGdldCBhbGlhc2VzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmFsaWFzZXMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWxpYXNlcztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0Y29uc3QgYWxpYXNlczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZXh0cmFjdEFsaWFzID0gKHNwOiBTcGVjaWZpZWRQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGVkZ2UsIGFsaWFzZWQgfSBvZiBzcC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdGlmIChhbGlhc2VkKVxuXHRcdFx0XHRcdFx0YWxpYXNlcy5wdXNoKGVkZ2UuaWRlbnRpZmllci50b1N0cmluZygpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuc2VlZCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRleHRyYWN0QWxpYXModGhpcy5wcml2YXRlLnNlZWQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBxdWV1ZTogVW5zcGVjaWZpZWRQYXJhbGxlbFtdID0gW3RoaXMucHJpdmF0ZS5zZWVkXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcXVldWUubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZVtpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhcmFsbGVsIG9mIGN1cnJlbnQuZ2V0UGFyYWxsZWxzKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFsbGVsIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRcdGV4dHJhY3RBbGlhcyhwYXJhbGxlbCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHBhcmFsbGVsIGluc3RhbmNlb2YgVW5zcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRcdFx0cXVldWUucHVzaChwYXJhbGxlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYWxpYXNlcyA9IGFsaWFzZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdGdldCB2YWx1ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUudmFsdWVzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnZhbHVlcztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0Y29uc3QgdmFsdWVzOiB7IHZhbHVlOiBzdHJpbmcsIGJhc2U6IFR5cGUgfCBudWxsIH1bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBleHRyYWN0VHlwZSA9IChzcDogU3BlY2lmaWVkUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBlZGdlIH0gb2Ygc3AuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCh7XG5cdFx0XHRcdFx0XHR2YWx1ZTogZWRnZS5pZGVudGlmaWVyLnRvU3RyaW5nKCksXG5cdFx0XHRcdFx0XHRiYXNlOiBUeXBlLmNvbnN0cnVjdChlZGdlLnByZWRlY2Vzc29yLnVyaSwgdGhpcy5wcml2YXRlLnByb2dyYW0pXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0ZXh0cmFjdFR5cGUodGhpcy5wcml2YXRlLnNlZWQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBxdWV1ZTogVW5zcGVjaWZpZWRQYXJhbGxlbFtdID0gW3RoaXMucHJpdmF0ZS5zZWVkXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcXVldWUubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZVtpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhcmFsbGVsIG9mIGN1cnJlbnQuZ2V0UGFyYWxsZWxzKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFsbGVsIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRcdGV4dHJhY3RUeXBlKHBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocGFyYWxsZWwgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmFsbGVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS52YWx1ZXMgPSB2YWx1ZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIGZpcnN0IGFsaWFzIHN0b3JlZCBpbiB0aGUgLnZhbHVlcyBhcnJheSwgb3IgbnVsbCBpZiB0aGVcblx0XHQgKiB2YWx1ZXMgYXJyYXkgaXMgZW1wdHkuXG5cdFx0ICovXG5cdFx0Z2V0IHZhbHVlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hbGlhc2VzLmxlbmd0aCA+IDAgPyB0aGlzLmFsaWFzZXNbMF0gOiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGlzIHR5cGUgcmVwcmVzZW50cyB0aGUgaW50cmluc2ljXG5cdFx0ICogc2lkZSBvZiBhIGxpc3QuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaXNMaXN0SW50cmluc2ljOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhpcyB0eXBlIHJlcHJlc2VudHMgdGhlIGV4dHJpbnNpY1xuXHRcdCAqIHNpZGUgb2YgYSBsaXN0LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlzTGlzdEV4dHJpbnNpYzogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoaXMgVHlwZSBpbnN0YW5jZSBoYXMgbm8gYW5ub3RhdGlvbnMgYXBwbGllZCB0byBpdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc0ZyZXNoOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzT3ZlcnJpZGUoKSB7IHJldHVybiB0aGlzLnBhcmFsbGVscy5sZW5ndGggPiAwOyB9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzSW50cm9kdWN0aW9uKCkgeyByZXR1cm4gdGhpcy5wYXJhbGxlbHMubGVuZ3RoID09PSAwOyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgaWYgdGhpcyBUeXBlIHdhcyBkaXJlY3RseSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgZG9jdW1lbnQsIG9yIGlmIGl0J3MgZXhpc3RlbmNlIHdhcyBpbmZlcnJlZC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc1NwZWNpZmllZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGlzQW5vbnltb3VzOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgaXNQYXR0ZXJuOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgaXNVcmk6IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBpc0xpc3Q6IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoaXMgVHlwZVxuXHRcdCAqIGluc3RhbmNlIHdhcyBjcmVhdGVkIGZyb20gYSBwcmV2aW91cyBlZGl0IGZyYW1lLCBhbmRcblx0XHQgKiBzaG91bGQgbm8gbG9uZ2VyIGJlIHVzZWQuXG5cdFx0ICovXG5cdFx0Z2V0IGlzRGlydHkoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUucHJvZ3JhbS52ZXJzaW9uLm5ld2VyVGhhbih0aGlzLnByaXZhdGUuc3RhbXApO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhbiBhcmJpdHJhcnkgcmVjdXJzaXZlLCBicmVhZHRoLWZpcnN0IHRyYXZlcnNhbFxuXHRcdCAqIHRoYXQgYmVnaW5zIGF0IHRoaXMgVHlwZSBpbnN0YW5jZS4gRW5zdXJlcyB0aGF0IG5vIHR5cGVzXG5cdFx0ICogdHlwZXMgYXJlIHlpZWxkZWQgbXVsdGlwbGUgdGltZXMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIG5leHRGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHR5cGUsIG9yIGFuXG5cdFx0ICogaXRlcmFibGUgb2YgdHlwZXMgdGhhdCBhcmUgdG8gYmUgdmlzaXRlZCBuZXh0LlxuXHRcdCAqIEBwYXJhbSByZXZlcnNlIEFuIG9wdGlvbmFsIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXNcblx0XHQgKiB3aGV0aGVyIHR5cGVzIGluIHRoZSByZXR1cm5lZCBhcnJheSBzaG91bGQgYmUgc29ydGVkXG5cdFx0ICogd2l0aCB0aGUgbW9zdCBkZWVwbHkgdmlzaXRlZCBub2RlcyBvY2N1cmluZyBmaXJzdC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSB0aGF0IHN0b3JlcyB0aGUgbGlzdCBvZiB0eXBlcyB0aGF0IHdlcmVcblx0XHQgKiB2aXNpdGVkLlxuXHRcdCAqL1xuXHRcdHZpc2l0KG5leHRGbjogKHR5cGU6IFR5cGUpID0+IEl0ZXJhYmxlPFR5cGUgfCBudWxsPiB8IFR5cGUgfCBudWxsLCByZXZlcnNlPzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLml0ZXJhdGUobmV4dEZuLCByZXZlcnNlKSkubWFwKGVudHJ5ID0+IGVudHJ5LnR5cGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhbiBhcmJpdHJhcnkgcmVjdXJzaXZlLCBicmVhZHRoLWZpcnN0IGl0ZXJhdGlvblxuXHRcdCAqIHRoYXQgYmVnaW5zIGF0IHRoaXMgVHlwZSBpbnN0YW5jZS4gRW5zdXJlcyB0aGF0IG5vIHR5cGVzXG5cdFx0ICogdHlwZXMgYXJlIHlpZWxkZWQgbXVsdGlwbGUgdGltZXMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIG5leHRGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHR5cGUsIG9yIGFuIGl0ZXJhYmxlXG5cdFx0ICogb2YgdHlwZXMgdGhhdCBhcmUgdG8gYmUgdmlzaXRlZCBuZXh0LlxuXHRcdCAqIEBwYXJhbSByZXZlcnNlIEFuIG9wdGlvbmFsIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXNcblx0XHQgKiB3aGV0aGVyIHRoZSBpdGVyYXRvciBzaG91bGQgeWllbGQgdHlwZXMgc3RhcnRpbmcgd2l0aCB0aGVcblx0XHQgKiBtb3N0IGRlZXBseSBuZXN0ZWQgdHlwZXMgZmlyc3QuXG5cdFx0ICogXG5cdFx0ICogQHlpZWxkcyBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhIGB0eXBlYCBwcm9wZXJ0eSB0aGF0IGlzIHRoZVxuXHRcdCAqIHRoZSBUeXBlIGJlaW5nIHZpc2l0ZWQsIGFuZCBhIGB2aWFgIHByb3BlcnR5IHRoYXQgaXMgdGhlIFR5cGVcblx0XHQgKiB0aGF0IHdhcyByZXR1cm5lZCBpbiB0aGUgcHJldmlvdXMgY2FsbCB0byBgbmV4dEZuYC5cblx0XHQgKi9cblx0XHQqaXRlcmF0ZShuZXh0Rm46ICh0eXBlOiBUeXBlKSA9PiBJdGVyYWJsZTxUeXBlIHwgbnVsbD4gfCBUeXBlIHwgbnVsbCwgcmV2ZXJzZT86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3QgeWllbGRlZDogVHlwZVtdID0gW107XG5cdFx0XHRcblx0XHRcdHR5cGUgUmVjdXJzZVR5cGUgPSBJdGVyYWJsZUl0ZXJhdG9yPHsgdHlwZTogVHlwZTsgdmlhOiBUeXBlIHwgbnVsbCB9Pjtcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlKHR5cGU6IFR5cGUsIHZpYTogVHlwZSB8IG51bGwpOiBSZWN1cnNlVHlwZVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoeWllbGRlZC5pbmNsdWRlcyh0eXBlKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXJldmVyc2UpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aWVsZGVkLnB1c2godHlwZSk7XG5cdFx0XHRcdFx0eWllbGQgeyB0eXBlLCB2aWEgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmVkdWNlZCA9IG5leHRGbih0eXBlKTtcblx0XHRcdFx0aWYgKHJlZHVjZWQgIT09IG51bGwgJiYgcmVkdWNlZCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHJlZHVjZWQgaW5zdGFuY2VvZiBUeXBlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHlpZWxkICpyZWN1cnNlKHJlZHVjZWQsIHR5cGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgbmV4dFR5cGUgb2YgcmVkdWNlZClcblx0XHRcdFx0XHRcdGlmIChuZXh0VHlwZSBpbnN0YW5jZW9mIFR5cGUpXG5cdFx0XHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlKG5leHRUeXBlLCB0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHJldmVyc2UpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aWVsZGVkLnB1c2godHlwZSk7XG5cdFx0XHRcdFx0eWllbGQgeyB0eXBlLCB2aWEgfTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR5aWVsZCAqcmVjdXJzZSh0aGlzLCBudWxsKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyBmb3IgYSBUeXBlIHRoYXQgaXMgbmVzdGVkIHVuZGVybmVhdGggdGhpcyBUeXBlLFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgdHlwZSBwYXRoLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KC4uLnR5cGVQYXRoOiBzdHJpbmdbXSlcblx0XHR7XG5cdFx0XHRsZXQgY3VycmVudFR5cGU6IFR5cGUgfCBudWxsID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB0eXBlTmFtZSBvZiB0eXBlUGF0aClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dFR5cGUgPSB0aGlzLmNvbnRlbnRzLmZpbmQodHlwZSA9PiB0eXBlLm5hbWUgPT09IHR5cGVOYW1lKTtcblx0XHRcdFx0aWYgKCFuZXh0VHlwZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGN1cnJlbnRUeXBlID0gbmV4dFR5cGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjdXJyZW50VHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBUeXBlIGhhcyB0aGUgc3BlY2lmaWVkIHR5cGVcblx0XHQgKiBzb21ld2hlcmUgaW4gaXQncyBiYXNlIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGlzKGJhc2VUeXBlOiBUeXBlKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgeyB0eXBlIH0gb2YgdGhpcy5pdGVyYXRlKHQgPT4gdC5iYXNlcykpXG5cdFx0XHRcdGlmICh0eXBlID09PSBiYXNlVHlwZSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgaW4gdGhpcyBUeXBlJ3Ncblx0XHQgKiBgLmNvbnRlbnRzYCBwcm9wZXJ0eSwgZWl0aGVyIGRpcmVjdGx5LCBvciBpbmRpcmVjdGx5IHZpYVxuXHRcdCAqIHRoZSBwYXJhbGxlbCBncmFwaHMgb2YgdGhlIGAuY29udGVudHNgIFR5cGVzLlxuXHRcdCAqL1xuXHRcdGhhcyh0eXBlOiBUeXBlKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbnRlbnRzLmluY2x1ZGVzKHR5cGUpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjb250YWluZWRUeXBlIG9mIHRoaXMuY29udGVudHMpXG5cdFx0XHRcdGlmICh0eXBlLm5hbWUgPT09IGNvbnRhaW5lZFR5cGUubmFtZSlcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhcmFsbGVsIG9mIGNvbnRhaW5lZFR5cGUuaXRlcmF0ZSh0ID0+IHQucGFyYWxsZWxzKSlcblx0XHRcdFx0XHRcdGlmIChwYXJhbGxlbC50eXBlID09PSB0eXBlKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBJbnRlcm5hbCBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIHByaXZhdGUgbWVtYmVyc1xuXHRcdCAqIG9mIHRoZSBUeXBlIG9iamVjdC4gRG8gbm90IHVzZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHByaXZhdGU6IFR5cGVQcml2YXRlO1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgaGlkZGVuIGNsYXNzIHRoYXQgc3RvcmVzIHRoZSBwcml2YXRlIGluZm9ybWF0aW9uIG9mXG5cdCAqIGEgVHlwZSBpbnN0YW5jZSwgdXNlZCB0byBtaXRpZ2F0ZSB0aGUgcmlzayBvZiBsb3ctcmFua1xuXHQgKiBkZXZlbG9wZXJzIGZyb20gZ2V0dGluZyB0aGVtc2VsdmVzIGludG8gdHJvdWJsZS5cblx0ICovXG5cdGNsYXNzIFR5cGVQcml2YXRlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0sXG5cdFx0XHRyZWFkb25seSBzZWVkOiBQYXJhbGxlbClcblx0XHR7XG5cdFx0XHR0aGlzLnN0YW1wID0gcHJvZ3JhbS52ZXJzaW9uO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBzdGFtcDogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGNvbnRlbnRzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRjb250ZW50c0ludHJpbnNpYzogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YmFzZXM6IFR5cGVQcm94eUFycmF5IHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cGFyYWxsZWxzOiBUeXBlUHJveHlBcnJheSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHBhcmFsbGVsUm9vdHM6IHJlYWRvbmx5IFR5cGVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHBhdHRlcm5zOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRhbGlhc2VzOiByZWFkb25seSBzdHJpbmdbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHZhbHVlczogcmVhZG9ubHkgeyB2YWx1ZTogc3RyaW5nOyBiYXNlOiBUeXBlIHwgbnVsbDsgfVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3VwZXJvcmRpbmF0ZXM6IHJlYWRvbmx5IFR5cGVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN1Ym9yZGluYXRlczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZGVyaXZhdGlvbnM6IHJlYWRvbmx5IFR5cGVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFkamFjZW50czogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dGhyb3dPbkRpcnR5KClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcm9ncmFtLnZlcnNpb24ubmV3ZXJUaGFuKHRoaXMuc3RhbXApKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ub2JqZWN0RGlydHkoKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUeXBlUHJveHlcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cHJpdmF0ZSByZWFkb25seSB1cmk6IFVyaSxcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7IH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRtYXliZUNvbXBpbGUoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbXBpbGVkVHlwZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZFR5cGU7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbXBpbGVkVHlwZSA9IFR5cGUuY29uc3RydWN0KHRoaXMudXJpLCB0aGlzLnByb2dyYW0pO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGNvbXBpbGVkVHlwZTogVHlwZSB8IG51bGwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUeXBlUHJveHlBcnJheVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhcnJheTogcmVhZG9ubHkgVHlwZVByb3h5W10pIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdG1heWJlQ29tcGlsZSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuY29tcGlsZWRBcnJheSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZEFycmF5O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBvdXQgPSB0aGlzLmFycmF5XG5cdFx0XHRcdC5tYXAobGF6eSA9PiBsYXp5Lm1heWJlQ29tcGlsZSgpKVxuXHRcdFx0XHQuZmlsdGVyKCh0eXBlKTogdHlwZSBpcyBUeXBlID0+IHR5cGUgIT09IG51bGwpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZEFycmF5ID0gT2JqZWN0LmZyZWV6ZShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHRwcml2YXRlIGNvbXBpbGVkQXJyYXk6IHJlYWRvbmx5IFR5cGVbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgVENhY2hlZFR5cGUgPSBUeXBlIHwgVHlwZVByb3h5IHwgbnVsbDtcblxuXG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUeXBlQ2FjaGVcblx0e1xuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBoYXModXJpOiBVcmksIHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmdldENhY2hlKHByb2dyYW0pO1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHVyaS50b1N0cmluZygpO1xuXHRcdFx0cmV0dXJuIGNhY2hlLm1hcC5oYXModXJpVGV4dCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBnZXQodXJpOiBVcmksIHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmdldENhY2hlKHByb2dyYW0pO1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHVyaS50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2FjaGUubWFwLmhhcyh1cmlUZXh0KSlcblx0XHRcdFx0cmV0dXJuIE5vdC51bmRlZmluZWQoY2FjaGUubWFwLmdldCh1cmlUZXh0KSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHByb3h5ID0gbmV3IFR5cGVQcm94eSh1cmksIHByb2dyYW0pO1xuXHRcdFx0dGhpcy5zZXQodXJpLCBwcm9ncmFtLCBwcm94eSk7XG5cdFx0XHRyZXR1cm4gcHJveHk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBzZXQodXJpOiBVcmksIHByb2dyYW06IFByb2dyYW0sIHR5cGU6IFRDYWNoZWRUeXBlKTogVENhY2hlZFR5cGVcblx0XHR7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUocHJvZ3JhbSk7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RyaW5nKCk7XG5cdFx0XHRjYWNoZS5tYXAuc2V0KHVyaVRleHQsIHR5cGUpO1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIGdldENhY2hlKHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmFsbENhY2hlcy5nZXQocHJvZ3JhbSkgfHwgKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGNhY2hlID0gbmV3IFR5cGVDYWNoZShwcm9ncmFtKTtcblx0XHRcdFx0dGhpcy5hbGxDYWNoZXMuc2V0KHByb2dyYW0sIGNhY2hlKTtcblx0XHRcdFx0cmV0dXJuIGNhY2hlO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Y2FjaGUubWF5YmVDbGVhcigpO1xuXHRcdFx0cmV0dXJuIGNhY2hlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBhbGxDYWNoZXMgPSBuZXcgV2Vha01hcDxQcm9ncmFtLCBUeXBlQ2FjaGU+KCk7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0dGhpcy52ZXJzaW9uID0gcHJvZ3JhbS52ZXJzaW9uO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIG1heWJlQ2xlYXIoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByb2dyYW0udmVyc2lvbi5uZXdlclRoYW4odGhpcy52ZXJzaW9uKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5tYXAuY2xlYXIoKTtcblx0XHRcdFx0dGhpcy52ZXJzaW9uID0gdGhpcy5wcm9ncmFtLnZlcnNpb247XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgdmVyc2lvbjogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgbWFwID0gbmV3IE1hcDxzdHJpbmcsIFRDYWNoZWRUeXBlPigpO1xuXHR9XG59XG4iLCJcbi8vIFV0aWxcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1V0aWwvSGVscGVycy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL011bHRpTWFwLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1V0aWwvRnMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9GZXRjaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL0hhc2gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9IaWdoZXJPcmRlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL05vdC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL1BhcnNlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9VdGlsL1VuaWNvZGVCbG9ja3MudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vVXRpbC9NaXNjLnRzXCIgLz5cblxuLy8gU3lzdGVtXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vUHJvZ3JhbS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vQWdlbnRDYWNoZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vQ2F1c2UudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL0V4Y2VwdGlvbi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vVXJpLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1N5c3RlbS9VcmlQcm90b2NvbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vVXJpUGFyc2VyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1N5c3RlbS9VcmlDb21wb25lbnQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL1VyaVJlYWRlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vU3ludGF4LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1N5c3RlbS9GYXVsdFNlcnZpY2UudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vU3lzdGVtL0ZhdWx0cy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9TeXN0ZW0vVmVyc2lvblN0YW1wLnRzXCIgLz5cblxuLy8gRmluaXRlIFN0YXRlIE1hY2hpbmVcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2ZzbS9BbHBoYWJldC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9mc20vVHJhbnNpdGlvbk1hcC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9mc20vVHJhbnNpdGlvblN0YXRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2ZzbS9HdWlkZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9mc20vRnNtLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2ZzbS9Gc21UcmFuc2xhdG9yLnRzXCIgLz5cblxuLy8gUGhhc2VzL0ZpbGVcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0RvY3VtZW50LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0RvY3VtZW50R3JhcGgudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvRG9jdW1lbnRIZWFkZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvTGluZVBhcnNlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9Bbm9uLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0xpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvQm91bmRzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL1N0YXRlbWVudC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9QYXR0ZXJuLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL1BhdHRlcm5QcmVjb21waWxlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9SZWdleFR5cGVzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0luZml4LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9GaWxlL0lkZW50aWZpZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0ZpbGUvU3Bhbi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9TcGluZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvRmlsZS9TdWJqZWN0LnRzXCIgLz5cblxuLy8gUGhhc2VzL0dyYXBoXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvR3JhcGgvSHlwZXJHcmFwaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvR3JhcGgvTm9kZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvR3JhcGgvTm9kZUluZGV4LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9HcmFwaC9IeXBlckVkZ2UudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL0dyYXBoL0luZml4U3Bhbi50c1wiIC8+XG5cbi8vIFBoYXNlcy9QYXJhbGxlbFxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL1BhcmFsbGVsL0NvbnN0cnVjdGlvbldvcmtlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvUGFyYWxsZWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL1BhcmFsbGVsL1NwZWNpZmllZFBhcmFsbGVsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9QYXJhbGxlbC9VbnNwZWNpZmllZFBhcmFsbGVsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9QYXJhbGxlbC9DcnVmdENhY2hlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9QYXJhbGxlbC9QYXJhbGxlbENhY2hlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9QYXJhbGxlbC9Db250cmFjdC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9QaGFzZXMvUGFyYWxsZWwvU2FuaXRpemVyLnRzXCIgLz5cblxuLy8gUGhhc2VzL1R5cGVcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9UeXBlL1R5cGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUGhhc2VzL1R5cGUvVHlwZVByb3h5LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9UeXBlL1R5cGVQcm94eUFycmF5LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL1BoYXNlcy9UeXBlL1R5cGVDYWNoZS50c1wiIC8+XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKiogXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiAoTm90IGltcGxlbWVudGVkKVxuXHQgKiBBIGNsYXNzIHRoYXQgc3BlY2lmaWVzIGJlaGF2aW9yIGFyb3VuZCB0aGUgcmVjb2duaXRpb24gXG5cdCAqIG9mIHBhdHRlcm5zIGZvdW5kIHdpdGhpbiBkb2N1bWVudHMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVjb2duaXRpb25cblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKCkgeyB9XG5cdFx0XG5cdFx0LyoqIFdoZXRoZXIgRmlsZSBVUklzIHNob3VsZCBiZSByZWNvZ25pemVkIGluIHN0YXRlbWVudHMuICovXG5cdFx0ZmlsZVVyaXMgPSBSZWNvZ25pdGlvblN0YXRlLm9uO1xuXHRcdFxuXHRcdC8qKiBXaGV0aGVyIEhUVFAgVVJJcyBzaG91bGQgYmUgcmVjb2duaXplZCBpbiBzdGF0ZW1lbnRzLiAqL1xuXHRcdGh0dHBVcmlzID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0XHRcblx0XHQvKiogV2hldGhlciByZWd1bGFyIGV4cHJlc3Npb25zIHNob3VsZCBiZSByZWNvZ25pemVkIGluIHN0YXRlbWVudHMuICovXG5cdFx0cmVndWxhckV4cHJlc3Npb25zID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0XHRcblx0XHQvKiogV2hldGhlciBjb21tZW50cyBzaG91bGQgYmUgcmVjb2duaXplZCBpbiBzdGF0ZW1lbnRzLiAqL1xuXHRcdGNvbW1lbnRzID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0fVxuXHRcblx0ZXhwb3J0IGNvbnN0IGVudW0gUmVjb2duaXRpb25TdGF0ZVxuXHR7XG5cdFx0LyoqIEluZGljYXRlcyB0aGF0IGEgcGF0dGVybiBpcyByZWNvZ25pemVkIGJ5IHRoZSBzeXN0ZW0uICovXG5cdFx0b24sXG5cdFx0XG5cdFx0LyoqIEluZGljYXRlcyB0aGF0IGEgcGF0dGVybiBpcyBub3QgcmVjb2duaXplZCBieSB0aGUgc3lzdGVtLiAqL1xuXHRcdG9mZixcblx0XHRcblx0XHQvKiogSW5kaWNhdGVzIHRoYXQgYSBwYXR0ZXJuIGlzIHJlY29nbml6ZWQgYnkgdGhlIHN5c3RlbSwgYW5kIG9taXR0ZWQuICovXG5cdFx0b21pdHRlZFxuXHR9XG59XG4iXX0=