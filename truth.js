"use strict";
var Truth;
(function (Truth) {
    /**
     * Asynchronously reads a truth document, and all documents
     * it references from the specified file system or HTTP(s) path.
     * File system paths are only supported if this code is running
     * within a Node.js-compatible environment.
     *
     * @returns A reference to the document read, or an Error.
     */
    async function read(truthFilePathOrUri) {
        const program = new Truth.Program();
        return await program.documents.read(truthFilePathOrUri);
    }
    Truth.read = read;
    /**
     * Parses the specified truth content into a new Truth program.
     *
     * @returns A reference to the parsed document.
     */
    async function parse(truthContent) {
        const program = new Truth.Program();
        return await program.documents.create(truthContent);
    }
    Truth.parse = parse;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A Map of the generic key and value types.
     * Supports keys that refer to multiple values.
     */
    class MultiMap {
        constructor() {
            /** */
            this.map = new Map();
        }
        /** */
        *[Symbol.iterator]() {
            for (const entry of this.map)
                yield entry;
        }
        /** */
        entries() {
            return this.map.entries();
        }
        /** */
        get(key) {
            return this.map.get(key);
        }
        /** */
        has(key, value) {
            const values = this.get(key);
            if (!values)
                return false;
            if (value !== undefined)
                return values.includes(value);
            return true;
        }
        /** */
        add(key, value) {
            if (value) {
                const values = this.get(key);
                if (values) {
                    if (!values.includes(value))
                        values.push(value);
                }
                else {
                    this.map.set(key, [value]);
                }
            }
            return this;
        }
        /** */
        delete(key, value) {
            if (value === undefined)
                return !!this.map.delete(key);
            const storedValues = this.map.get(key);
            if (storedValues === undefined)
                return false;
            if (storedValues.length === 1 && storedValues[0] === value) {
                this.map.delete(key);
                return true;
            }
            const valueIdx = storedValues.indexOf(value);
            if (valueIdx < 0)
                return false;
            storedValues.splice(valueIdx, 1);
            return true;
        }
        /** */
        values() {
            return this.map.values();
        }
    }
    Truth.MultiMap = MultiMap;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Exposes the "fs" module used by the compiler,
     * as well as the ability to change the module used
     * with a custom implementation.
     */
    class Fs {
        /**
         * Assigns a new implementation of the node "fs" module.
         */
        static override(module) {
            this._module = module;
        }
        /** */
        static get module() {
            if (this._module)
                return this._module;
            this._module = require("fs");
            return Truth.Not.null(this._module);
        }
    }
    /** */
    Fs._module = null;
    Truth.Fs = Fs;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A class that provides browser-style fetch functionality,
     * but with the ability to change this functions behavior
     * with a custom implementation.
     */
    class Fetch {
        /**
         *
         */
        static async exec(url) {
            const uri = Truth.Uri.tryParse(url);
            if (!uri)
                throw Truth.Exception.invalidUri(url);
            if (typeof fetch === "function") {
                try {
                    const response = await fetch(url);
                    if (response.status === 200)
                        return response.text();
                    return new FetchError(response.status, response.statusText);
                }
                catch (e) {
                    return new Error("Unknown error.");
                }
            }
            else if (typeof require === "function") {
                const getFn = uri.protocol === Truth.UriProtocol.https ? require("https").get :
                    uri.protocol === Truth.UriProtocol.http ? require("http").get :
                        null;
                if (getFn === null)
                    throw Truth.Exception.invalidUri(url);
                return await new Promise(resolve => {
                    getFn(url, response => {
                        const data = [];
                        response.on("data", chunk => {
                            data.push(typeof chunk === "string" ?
                                chunk :
                                chunk.toString("utf8"));
                        });
                        response.on("error", error => {
                            resolve(error);
                        });
                        response.on("end", () => {
                            resolve(data.join(""));
                        });
                    });
                    return "";
                });
            }
            throw Truth.Exception.unsupportedPlatform();
        }
    }
    Truth.Fetch = Fetch;
    /**
     *
     */
    class FetchError extends Error {
        constructor(statusCode, statusText) {
            super();
            this.statusCode = statusCode;
            this.statusText = statusText;
        }
    }
    Truth.FetchError = FetchError;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that encapsulates string hashing functionality.
     */
    Truth.Hash = new class Hash {
        constructor() {
            /** Stores the constant number of characters in a returned hash. */
            this.length = 8;
        }
        /**
         * Calculates a hash code from the specified string.
         */
        calculate(text) {
            if (text.length === 0)
                return "0".repeat(8);
            let hash = 0;
            for (let i = -1; ++i < text.length;) {
                const char = text.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash %= 2 ** 32;
            }
            return (hash + Math.pow(2, 31)).toString(16).toUpperCase();
        }
    }();
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that provides various higher-order functions
     * across data structures.
     */
    class HigherOrder {
        static copy(param) {
            if (param instanceof Array)
                return Object.freeze(param.slice());
            if (param instanceof Set) {
                const set = new Set();
                for (const value of param)
                    set.add(value);
                return Object.freeze(set);
            }
            if (param instanceof Map) {
                const map = new Map();
                for (const [key, value] of param)
                    map.set(key, value);
                return Object.freeze(map);
            }
            throw new TypeError();
        }
        constructor() { }
    }
    Truth.HigherOrder = HigherOrder;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Utility class for performing basic guarding.
     */
    class Not {
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's strictly equal to null.
         */
        static null(param) {
            if (param === null) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's strictly equal to undefined.
         */
        static undefined(param) {
            if (param === undefined) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
        /**
         * @returns The argument as specified, but throws an
         * exception in the case when it's null or undefined.
         */
        static nullable(param) {
            if (param === null || param === undefined) {
                debugger;
                throw new ReferenceError();
            }
            return param;
        }
    }
    Truth.Not = Not;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A general parsing utility class that provides consumption
     * methods that operate over a given input.
     */
    class Parser {
        /**
         * Constructs a new Parser object that operates over
         * the specified input string, optionally starting at the
         * specified position.
         */
        constructor(input) {
            this._position = 0;
            this.input = input.normalize();
            this._position = 0;
        }
        /**
         * Attempts to read the specified token immediately
         * following the cursor.
         *
         * @returns The content read. In the case when no
         * match could be found, an empty string is returned.
         */
        read(token) {
            if (!token)
                throw new TypeError();
            const pos = this._position;
            if (this.input.substr(pos, token.length) === token) {
                this._position += token.length;
                return token;
            }
            return "";
        }
        /**
         * Reads any whitespace characters and floating
         * escape characters.
         *
         * @returns The number of whitespace characters
         * read.
         */
        readWhitespace() {
            let count = 0;
            while (this.more()) {
                const c = count;
                if (this.read("\t" /* tab */))
                    count++;
                if (this.read(" " /* space */))
                    count++;
                if (this.read("\\" /* escapeChar */ + " " /* space */))
                    count++;
                if (this.read("\\" /* escapeChar */ + "\t" /* tab */))
                    count++;
                if (c === count)
                    break;
            }
            return count;
        }
        /**
         * Attempts to read a single stream-level grapheme from the
         * parse stream, using unicode-aware extraction method.
         * If the parse stream specifies a unicode escape sequence,
         * such as \uFFFF, these are seen as 6 individual graphemes.
         *
         * @returns The read grapheme, or an empty string in the case
         * when there is no more content in the parse stream.
         */
        readGrapheme() {
            if (this._position >= this.input.length)
                return "";
            const codeAtCursor = this.input.codePointAt(this._position) || -1;
            this._position += codeAtCursor > 0xFFFF ? 2 : 1;
            return String.fromCodePoint(codeAtCursor);
        }
        /**
         * Reads graphemes from the parse stream, until either
         * the cursor reaches one of the specified quit tokens,
         * or the parse stream terminates.
         */
        readUntil(...quitTokens) {
            let stream = "";
            while (this.more()) {
                if (quitTokens.some(t => this.peek(t)))
                    break;
                stream += this.readGrapheme();
            }
            return stream;
        }
        /**
         * Attempts to read the specified token from the parse stream,
         * if and only if it's at the end of the parse stream.
         */
        readThenTerminal(token) {
            if (this.peek(token) && this._position === this.input.length - token.length) {
                this._position += token.length;
                return token;
            }
            return "";
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified string exists immediately at the position of
         * the cursor.
         */
        peek(token) {
            return this.input.substr(this._position, token.length) === token;
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified string exists immediately at the position of
         * the cursor, and following this token is the end of the
         * parse stream.
         */
        peekThenTerminal(token) {
            return (this._position === this.input.length - token.length &&
                this.input.substr(this._position, token.length) === token);
        }
        /**
         * @returns A boolean value that indicates whether
         * there are more characters to read in the input.
         */
        more() {
            return this._position < this.input.length;
        }
        /**
         * Gets or sets the position of the cursor from where
         * reading takes place in the cursor.
         */
        get position() {
            return this._position;
        }
        set position(value) {
            if (value < 0)
                throw new RangeError();
            this._position = value;
        }
        //
        // DEAD
        //
        /**
         *
         */
        atRealBackslash() {
            const esc = "\\" /* escapeChar */;
            return this.input.substr(this._position, 2) === esc + esc;
        }
        /**
         * @deprecated
         * @returns A boolean value that indicates whether an
         * escape character exists behind the current character.
         * The algorithm used is respective of sequences of
         * multiple escape characters.
         */
        escaped() {
            let escaped = false;
            let backtrackPos = this._position;
            while (--backtrackPos >= 0)
                if (this.input[backtrackPos] === "\\" /* escapeChar */)
                    escaped = !escaped;
            return escaped;
        }
    }
    Truth.Parser = Parser;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Converts the names in the UnicodeBlocks object
     * to a map with lower case keys, for easy lookup.
     */
    function toMap(blocks) {
        const entries = Object.entries(blocks);
        const entriesFmt = entries.map(entry => [entry[0].toLowerCase(), entry[1]]);
        return Object.freeze(new Map(entriesFmt));
    }
    /**
     * Stores the maximum character code in the unicode set.
     */
    Truth.UnicodeMax = 65536;
    /**
     * Stores a map of the names of all unicode blocks,
     * and their character ranges.
     */
    Truth.UnicodeBlocks = toMap({
        "Control character": [0x0000, 0x001F],
        "Basic Latin": [0x0020, 0x007F],
        "Latin-1 Supplement": [0x0080, 0x00FF],
        "Latin Extended-A": [0x0100, 0x017F],
        "Latin Extended-B": [0x0180, 0x024F],
        "IPA Extensions": [0x0250, 0x02AF],
        "Spacing Modifier Letters": [0x02B0, 0x02FF],
        "Combining Diacritical Marks": [0x0300, 0x036F],
        "Greek and Coptic": [0x0370, 0x03FF],
        "Cyrillic": [0x0400, 0x04FF],
        "Cyrillic Supplement": [0x0500, 0x052F],
        "Armenian": [0x0530, 0x058F],
        "Hebrew": [0x0590, 0x05FF],
        "Arabic": [0x0600, 0x06FF],
        "Syriac": [0x0700, 0x074F],
        "Arabic Supplement": [0x0750, 0x077F],
        "Thaana": [0x0780, 0x07BF],
        "NKo": [0x07C0, 0x07FF],
        "Samaritan": [0x0800, 0x083F],
        "Mandaic": [0x0840, 0x085F],
        "Syriac Supplement": [0x0860, 0x086F],
        "Arabic Extended-A": [0x08A0, 0x08FF],
        "Devanagari": [0x0900, 0x097F],
        "Bengali": [0x0980, 0x09FF],
        "Gurmukhi": [0x0A00, 0x0A7F],
        "Gujarati": [0x0A80, 0x0AFF],
        "Oriya": [0x0B00, 0x0B7F],
        "Tamil": [0x0B80, 0x0BFF],
        "Telugu": [0x0C00, 0x0C7F],
        "Kannada": [0x0C80, 0x0CFF],
        "Malayalam": [0x0D00, 0x0D7F],
        "Sinhala": [0x0D80, 0x0DFF],
        "Thai": [0x0E00, 0x0E7F],
        "Lao": [0x0E80, 0x0EFF],
        "Tibetan": [0x0F00, 0x0FFF],
        "Myanmar": [0x1000, 0x109F],
        "Georgian": [0x10A0, 0x10FF],
        "Hangul Jamo": [0x1100, 0x11FF],
        "Ethiopic": [0x1200, 0x137F],
        "Ethiopic Supplement": [0x1380, 0x139F],
        "Cherokee": [0x13A0, 0x13FF],
        "Unified Canadian Aboriginal Syllabics": [0x1400, 0x167F],
        "Ogham": [0x1680, 0x169F],
        "Runic": [0x16A0, 0x16FF],
        "Tagalog": [0x1700, 0x171F],
        "Hanunoo": [0x1720, 0x173F],
        "Buhid": [0x1740, 0x175F],
        "Tagbanwa": [0x1760, 0x177F],
        "Khmer": [0x1780, 0x17FF],
        "Mongolian": [0x1800, 0x18AF],
        "Unified Canadian Aboriginal Syllabics Extended": [0x18B0, 0x18FF],
        "Limbu": [0x1900, 0x194F],
        "Tai Le": [0x1950, 0x197F],
        "New Tai Lue": [0x1980, 0x19DF],
        "Khmer Symbols": [0x19E0, 0x19FF],
        "Buginese": [0x1A00, 0x1A1F],
        "Tai Tham": [0x1A20, 0x1AAF],
        "Combining Diacritical Marks Extended": [0x1AB0, 0x1AFF],
        "Balinese": [0x1B00, 0x1B7F],
        "Sundanese": [0x1B80, 0x1BBF],
        "Batak": [0x1BC0, 0x1BFF],
        "Lepcha": [0x1C00, 0x1C4F],
        "Ol Chiki": [0x1C50, 0x1C7F],
        "Cyrillic Extended C": [0x1C80, 0x1C8F],
        "Sundanese Supplement": [0x1CC0, 0x1CCF],
        "Vedic Extensions": [0x1CD0, 0x1CFF],
        "Phonetic Extensions": [0x1D00, 0x1D7F],
        "Phonetic Extensions Supplement": [0x1D80, 0x1DBF],
        "Combining Diacritical Marks Supplement": [0x1DC0, 0x1DFF],
        "Latin Extended Additional": [0x1E00, 0x1EFF],
        "Greek Extended": [0x1F00, 0x1FFF],
        "General Punctuation": [0x2000, 0x206F],
        "Superscripts and Subscripts": [0x2070, 0x209F],
        "Currency Symbols": [0x20A0, 0x20CF],
        "Combining Diacritical Marks for Symbols": [0x20D0, 0x20FF],
        "Letterlike Symbols": [0x2100, 0x214F],
        "Number Forms": [0x2150, 0x218F],
        "Arrows": [0x2190, 0x21FF],
        "Mathematical Operators": [0x2200, 0x22FF],
        "Miscellaneous Technical": [0x2300, 0x23FF],
        "Control Pictures": [0x2400, 0x243F],
        "Optical Character Recognition": [0x2440, 0x245F],
        "Enclosed Alphanumerics": [0x2460, 0x24FF],
        "Box Drawing": [0x2500, 0x257F],
        "Block Elements": [0x2580, 0x259F],
        "Geometric Shapes": [0x25A0, 0x25FF],
        "Miscellaneous Symbols": [0x2600, 0x26FF],
        "Dingbats": [0x2700, 0x27BF],
        "Miscellaneous Mathematical Symbols-A": [0x27C0, 0x27EF],
        "Supplemental Arrows-A": [0x27F0, 0x27FF],
        "Braille Patterns": [0x2800, 0x28FF],
        "Supplemental Arrows-B": [0x2900, 0x297F],
        "Miscellaneous Mathematical Symbols-B": [0x2980, 0x29FF],
        "Supplemental Mathematical Operators": [0x2A00, 0x2AFF],
        "Miscellaneous Symbols and Arrows": [0x2B00, 0x2BFF],
        "Glagolitic": [0x2C00, 0x2C5F],
        "Latin Extended-C": [0x2C60, 0x2C7F],
        "Coptic": [0x2C80, 0x2CFF],
        "Georgian Supplement": [0x2D00, 0x2D2F],
        "Tifinagh": [0x2D30, 0x2D7F],
        "Ethiopic Extended": [0x2D80, 0x2DDF],
        "Cyrillic Extended-A": [0x2DE0, 0x2DFF],
        "Supplemental Punctuation": [0x2E00, 0x2E7F],
        "CJK Radicals Supplement": [0x2E80, 0x2EFF],
        "Kangxi Radicals": [0x2F00, 0x2FDF],
        "Ideographic Description Characters": [0x2FF0, 0x2FFF],
        "CJK Symbols and Punctuation": [0x3000, 0x303F],
        "Hiragana": [0x3040, 0x309F],
        "Katakana": [0x30A0, 0x30FF],
        "Bopomofo": [0x3100, 0x312F],
        "Hangul Compatibility Jamo": [0x3130, 0x318F],
        "Kanbun": [0x3190, 0x319F],
        "Bopomofo Extended": [0x31A0, 0x31BF],
        "CJK Strokes": [0x31C0, 0x31EF],
        "Katakana Phonetic Extensions": [0x31F0, 0x31FF],
        "Enclosed CJK Letters and Months": [0x3200, 0x32FF],
        "CJK Compatibility": [0x3300, 0x33FF],
        "CJK Unified Ideographs Extension A": [0x3400, 0x4DBF],
        "Yijing Hexagram Symbols": [0x4DC0, 0x4DFF],
        "CJK Unified Ideographs": [0x4E00, 0x9FFF],
        "Yi Syllables": [0xA000, 0xA48F],
        "Yi Radicals": [0xA490, 0xA4CF],
        "Lisu": [0xA4D0, 0xA4FF],
        "Vai": [0xA500, 0xA63F],
        "Cyrillic Extended-B": [0xA640, 0xA69F],
        "Bamum": [0xA6A0, 0xA6FF],
        "Modifier Tone Letters": [0xA700, 0xA71F],
        "Latin Extended-D": [0xA720, 0xA7FF],
        "Syloti Nagri": [0xA800, 0xA82F],
        "Common Indic Number Forms": [0xA830, 0xA83F],
        "Phags-pa": [0xA840, 0xA87F],
        "Saurashtra": [0xA880, 0xA8DF],
        "Devanagari Extended": [0xA8E0, 0xA8FF],
        "Kayah Li": [0xA900, 0xA92F],
        "Rejang": [0xA930, 0xA95F],
        "Hangul Jamo Extended-A": [0xA960, 0xA97F],
        "Javanese": [0xA980, 0xA9DF],
        "Myanmar Extended-B": [0xA9E0, 0xA9FF],
        "Cham": [0xAA00, 0xAA5F],
        "Myanmar Extended-A": [0xAA60, 0xAA7F],
        "Tai Viet": [0xAA80, 0xAADF],
        "Meetei Mayek Extensions": [0xAAE0, 0xAAFF],
        "Ethiopic Extended-A": [0xAB00, 0xAB2F],
        "Latin Extended-E": [0xAB30, 0xAB6F],
        "Cherokee Supplement": [0xAB70, 0xABBF],
        "Meetei Mayek": [0xABC0, 0xABFF],
        "Hangul Syllables": [0xAC00, 0xD7AF],
        "Hangul Jamo Extended-B": [0xD7B0, 0xD7FF],
        "High Surrogates": [0xD800, 0xDB7F],
        "High Private Use Surrogates": [0xDB80, 0xDBFF],
        "Low Surrogates": [0xDC00, 0xDFFF],
        "Private Use Area": [0xE000, 0xF8FF],
        "CJK Compatibility Ideographs": [0xF900, 0xFAFF],
        "Alphabetic Presentation Forms": [0xFB00, 0xFB4F],
        "Arabic Presentation Forms-A": [0xFB50, 0xFDFF],
        "Variation Selectors": [0xFE00, 0xFE0F],
        "Vertical Forms": [0xFE10, 0xFE1F],
        "Combining Half Marks": [0xFE20, 0xFE2F],
        "CJK Compatibility Forms": [0xFE30, 0xFE4F],
        "Small Form Variants": [0xFE50, 0xFE6F],
        "Arabic Presentation Forms-B": [0xFE70, 0xFEFF],
        "Halfwidth and Fullwidth Forms": [0xFF00, 0xFFEF],
        "Specials": [0xFFF0, 0xFFFF],
        "Linear B Syllabary": [0x10000, 0x1007F],
        "Linear B Ideograms": [0x10080, 0x100FF],
        "Aegean Numbers": [0x10100, 0x1013F],
        "Ancient Greek Numbers": [0x10140, 0x1018F],
        "Ancient Symbols": [0x10190, 0x101CF],
        "Phaistos Disc": [0x101D0, 0x101FF],
        "Lycian": [0x10280, 0x1029F],
        "Carian": [0x102A0, 0x102DF],
        "Coptic Epact Numbers": [0x102E0, 0x102FF],
        "Old Italic": [0x10300, 0x1032F],
        "Gothic": [0x10330, 0x1034F],
        "Old Permic": [0x10350, 0x1037F],
        "Ugaritic": [0x10380, 0x1039F],
        "Old Persian": [0x103A0, 0x103DF],
        "Deseret": [0x10400, 0x1044F],
        "Shavian": [0x10450, 0x1047F],
        "Osmanya": [0x10480, 0x104AF],
        "Osage": [0x104B0, 0x104FF],
        "Elbasan": [0x10500, 0x1052F],
        "Caucasian Albanian": [0x10530, 0x1056F],
        "Linear A": [0x10600, 0x1077F],
        "Cypriot Syllabary": [0x10800, 0x1083F],
        "Imperial Aramaic": [0x10840, 0x1085F],
        "Palmyrene": [0x10860, 0x1087F],
        "Nabataean": [0x10880, 0x108AF],
        "Hatran": [0x108E0, 0x108FF],
        "Phoenician": [0x10900, 0x1091F],
        "Lydian": [0x10920, 0x1093F],
        "Meroitic Hieroglyphs": [0x10980, 0x1099F],
        "Meroitic Cursive": [0x109A0, 0x109FF],
        "Kharoshthi": [0x10A00, 0x10A5F],
        "Old South Arabian": [0x10A60, 0x10A7F],
        "Old North Arabian": [0x10A80, 0x10A9F],
        "Manichaean": [0x10AC0, 0x10AFF],
        "Avestan": [0x10B00, 0x10B3F],
        "Inscriptional Parthian": [0x10B40, 0x10B5F],
        "Inscriptional Pahlavi": [0x10B60, 0x10B7F],
        "Psalter Pahlavi": [0x10B80, 0x10BAF],
        "Old Turkic": [0x10C00, 0x10C4F],
        "Old Hungarian": [0x10C80, 0x10CFF],
        "Rumi Numeral Symbols": [0x10E60, 0x10E7F],
        "Brahmi": [0x11000, 0x1107F],
        "Kaithi": [0x11080, 0x110CF],
        "Sora Sompeng": [0x110D0, 0x110FF],
        "Chakma": [0x11100, 0x1114F],
        "Mahajani": [0x11150, 0x1117F],
        "Sharada": [0x11180, 0x111DF],
        "Sinhala Archaic Numbers": [0x111E0, 0x111FF],
        "Khojki": [0x11200, 0x1124F],
        "Multani": [0x11280, 0x112AF],
        "Khudawadi": [0x112B0, 0x112FF],
        "Grantha": [0x11300, 0x1137F],
        "Newa": [0x11400, 0x1147F],
        "Tirhuta": [0x11480, 0x114DF],
        "Siddham": [0x11580, 0x115FF],
        "Modi": [0x11600, 0x1165F],
        "Mongolian Supplement": [0x11660, 0x1167F],
        "Takri": [0x11680, 0x116CF],
        "Ahom": [0x11700, 0x1173F],
        "Warang Citi": [0x118A0, 0x118FF],
        "Zanabazar Square": [0x11A00, 0x11A4F],
        "Soyombo": [0x11A50, 0x11AAF],
        "Pau Cin Hau": [0x11AC0, 0x11AFF],
        "Bhaiksuki": [0x11C00, 0x11C6F],
        "Marchen": [0x11C70, 0x11CBF],
        "Masaram Gondi": [0x11D00, 0x11D5F],
        "Cuneiform": [0x12000, 0x123FF],
        "Cuneiform Numbers and Punctuation": [0x12400, 0x1247F],
        "Early Dynastic Cuneiform": [0x12480, 0x1254F],
        "Egyptian Hieroglyphs": [0x13000, 0x1342F],
        "Anatolian Hieroglyphs": [0x14400, 0x1467F],
        "Bamum Supplement": [0x16800, 0x16A3F],
        "Mro": [0x16A40, 0x16A6F],
        "Bassa Vah": [0x16AD0, 0x16AFF],
        "Pahawh Hmong": [0x16B00, 0x16B8F],
        "Miao": [0x16F00, 0x16F9F],
        "Ideographic Symbols and Punctuation": [0x16FE0, 0x16FFF],
        "Tangut": [0x17000, 0x187FF],
        "Tangut Components": [0x18800, 0x18AFF],
        "Kana Supplement": [0x1B000, 0x1B0FF],
        "Kana Extended-A": [0x1B100, 0x1B12F],
        "Nushu": [0x1B170, 0x1B2FF],
        "Duployan": [0x1BC00, 0x1BC9F],
        "Shorthand Format Controls": [0x1BCA0, 0x1BCAF],
        "Byzantine Musical Symbols": [0x1D000, 0x1D0FF],
        "Musical Symbols": [0x1D100, 0x1D1FF],
        "Ancient Greek Musical Notation": [0x1D200, 0x1D24F],
        "Tai Xuan Jing Symbols": [0x1D300, 0x1D35F],
        "Counting Rod Numerals": [0x1D360, 0x1D37F],
        "Mathematical Alphanumeric Symbols": [0x1D400, 0x1D7FF],
        "Sutton SignWriting": [0x1D800, 0x1DAAF],
        "Glagolitic Supplement": [0x1E000, 0x1E02F],
        "Mende Kikakui": [0x1E800, 0x1E8DF],
        "Adlam": [0x1E900, 0x1E95F],
        "Arabic Mathematical Alphabetic Symbols": [0x1EE00, 0x1EEFF],
        "Mahjong Tiles": [0x1F000, 0x1F02F],
        "Domino Tiles": [0x1F030, 0x1F09F],
        "Playing Cards": [0x1F0A0, 0x1F0FF],
        "Enclosed Alphanumeric Supplement": [0x1F100, 0x1F1FF],
        "Enclosed Ideographic Supplement": [0x1F200, 0x1F2FF],
        "Miscellaneous Symbols and Pictographs": [0x1F300, 0x1F5FF],
        "Emoji": [0x1F600, 0x1F64F],
        "Ornamental Dingbats": [0x1F650, 0x1F67F],
        "Transport and Map Symbols": [0x1F680, 0x1F6FF],
        "Alchemical Symbols": [0x1F700, 0x1F77F],
        "Geometric Shapes Extended": [0x1F780, 0x1F7FF],
        "Supplemental Arrows-C": [0x1F800, 0x1F8FF],
        "Supplemental Symbols and Pictographs": [0x1F900, 0x1F9FF],
        "CJK Unified Ideographs Extension B": [0x20000, 0x2A6DF],
        "CJK Unified Ideographs Extension C": [0x2A700, 0x2B73F],
        "CJK Unified Ideographs Extension D": [0x2B740, 0x2B81F],
        "CJK Unified Ideographs Extension E": [0x2B820, 0x2CEAF],
        "CJK Unified Ideographs Extension F": [0x2CEB0, 0x2EBEF],
        "CJK Compatibility Ideographs Supplement": [0x2F800, 0x2FA1F],
        "Tags": [0xE0000, 0xE007F],
        "Variation Selectors Supplement": [0xE0100, 0xE01EF]
    });
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Stores unsorted general utility methods.
     */
    class Misc {
        /**
         * Counts incrementally through numbers, using the specified
         * radix sequence. For example, if the radixes [2, 2, 2] were to
         * be specified, this would result in binary counting starting at
         * [0, 0, 0] and ending at [1, 1, 1].
         */
        static *variableRadixCounter(radixes) {
            if (radixes.length === 0)
                return;
            if (radixes.length === 1) {
                for (let i = -1; ++i < radixes[0];)
                    yield [i];
                return;
            }
            const total = radixes.reduce((a, b) => a * b, 1);
            const digits = radixes.map(() => 0);
            const divideFactors = [1];
            for (let baseIdx = radixes.length - 1; --baseIdx >= 0;)
                divideFactors.unshift(radixes.slice(baseIdx + 1).reduce((a, b) => a * b, 1));
            for (let count = -1; ++count < total;) {
                const sequence = [];
                let remainder = count;
                for (let digitIdx = -1; ++digitIdx < digits.length;) {
                    const div = divideFactors[digitIdx];
                    sequence.push(remainder / div | 0);
                    remainder %= div;
                }
                yield sequence;
            }
        }
        /**
         *
         */
        static calculatePowerset(array) {
            const result = [[]];
            for (let i = 0; i < array.length; i++)
                for (let n = 0; n < result.length; n++)
                    result.push(result[n].concat(array[i]));
            return result;
        }
        /**
         * @returns Whether the items of the first set object form
         * a subset (not a proper subset) of the items of the second
         * set.
         */
        static isSubset(sourceSet, possibleSubset) {
            for (const item of possibleSubset)
                if (!sourceSet.has(item))
                    return false;
            return true;
        }
        /**
         * @returns Whether the items of the first set object form
         * a superset (not a proper superset) of the items of the
         * second set.
         */
        static isSuperset(sourceSet, possibleSuperset) {
            for (const item of sourceSet)
                if (!possibleSuperset.has(item))
                    return false;
            return true;
        }
        /**
         * @returns The number of items that are missing
         * from the second set that exist in the first set.
         */
        static computeSubsetFactor(a, b) {
            let count = 0;
            for (const item of a)
                count += b.includes(item) ? 0 : 1;
            return count;
        }
        /**
         * Performs a recursive reduction operation on an initial object
         * that represents some abstract node of a graph. The traversal
         * algorithm used ensures all provided nodes are only visited
         * once.
         */
        static reduceRecursive(initialObject, followFn, reduceFn) {
            const visited = new Set();
            const recurse = (object) => {
                visited.add(object);
                const reduceResult = [];
                for (const next of followFn(object))
                    if (!visited.has(next))
                        reduceResult.push(recurse(next));
                return reduceFn(object, Object.freeze(reduceResult));
            };
            return recurse(initialObject);
        }
        /**
         * @returns A proxy of the specified object, whose members
         * have been patched with the specified patch object.
         */
        static patch(source, patch) {
            const patchKeys = Object.freeze(Object.keys(patch));
            return new Proxy(source, {
                get(target, key) {
                    return patchKeys.includes(key) ?
                        patch[key] :
                        source[key];
                }
            });
        }
        /**
         * Safely parses a JSON object, silencing any thrown parse exceptions.
         */
        static tryParseJson(jsonText) {
            try {
                return JSON.parse(jsonText);
            }
            catch (e) {
                return null;
            }
        }
        constructor() { }
    }
    Truth.Misc = Misc;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * The top-level object that manages Truth documents.
     */
    class Program {
        /**
         * Creates a new Program, into which Documents may
         * be added, and verified.
         */
        constructor() {
            /** @internal */
            this.causes = new Truth.MultiMap();
            /** */
            this.unverifiedStatements = [];
            /** */
            this.unverifiedDocuments = [];
            this._version = Truth.VersionStamp.next();
            // The ordering of these instantations is relevant,
            // because it reflects the order in which each of
            // these services are going to process hooks.
            this.on(Truth.CauseDocumentCreate, data => {
                this.unverifiedDocuments.push(data.document);
            });
            this.on(Truth.CauseDocumentDelete, data => {
                const idx = this.unverifiedDocuments.indexOf(data.document);
                if (idx > -1)
                    this.unverifiedDocuments.splice(idx, 1);
            });
            this.on(Truth.CauseDocumentUriChange, () => {
                this._version = Truth.VersionStamp.next();
            });
            this.on(Truth.CauseAgentDetach, data => {
                for (const [cause, attachments] of this.causes)
                    for (const attachment of attachments)
                        if (attachment.uri && attachment.uri.equals(data.uri))
                            this.causes.delete(cause, attachment);
            });
            this.agentCache = new Truth.AgentCache(this);
            this.documents = new Truth.DocumentGraph(this);
            this.graph = new Truth.HyperGraph(this);
            this.on(Truth.CauseRevalidate, data => {
                for (let i = this.unverifiedStatements.length; i-- > 0;)
                    if (this.unverifiedStatements[i].isDisposed)
                        this.unverifiedStatements.splice(i, 1);
                for (const statement of data.parents)
                    if (!statement.isCruft)
                        this.unverifiedStatements.push(statement);
            });
            this.faults = new Truth.FaultService(this);
            this.on(Truth.CauseEditComplete, () => {
                this._version = Truth.VersionStamp.next();
            });
        }
        /** */
        get version() {
            return this._version;
        }
        /**
         * Probes the program and returns an array containing information
         * about the callbacks that will be triggered if a cause of the specified
         * type is broadcasted. Essentially, this method answers the question,
         * "Who is listening for Causes of type X?".
         *
         * If no agents have attached to the specified type, an empty array
         * is returned.
         */
        probe(causeType, scope = this) {
            if (scope instanceof Truth.Type)
                throw Truth.Exception.notImplemented();
            const results = [];
            const push = (ca) => results.push({ uri: ca.uri, scope: ca.scope });
            for (const [causeTypeKey, attachments] of this.causes)
                if (causeType === causeTypeKey)
                    for (const ca of attachments)
                        if (scope === ca.scope ||
                            scope instanceof Program && ca.scope instanceof Truth.Document)
                            push(ca);
            return results;
        }
        /**
         *
         */
        on(causeType, fn, scope) {
            const info = getHolderInfo(this);
            const usingScope = scope || info.scope || this;
            const ca = new CauseAttachment(info.uri, fn, usingScope);
            this.causes.add(causeType, ca);
        }
        /**
         * Progates the specified Cause object to all subscribers that
         * are listening for causes of object's type.
         *
         * @param cause A reference to the Cause instance to broadcast.
         *
         * @param filter An optional array of Uri instances that
         * specify the origin from where an agent that is attached
         * to the cause must loaded in order to be delivered the
         * cause instance.
         *
         * @returns An object that stores information about the
         * cause results that were returned, and the URI of the
         * agent that produced the result. In the case when the
         * agent was attached programmatically, the URI value
         * will be null.
         */
        cause(cause, ...filters) {
            const causeType = cause.constructor;
            const attachmentsAll = this.causes.get(causeType) || [];
            const attachments = attachmentsAll.filter(attachment => {
                if (filters.length === 0)
                    return true;
                const otherUri = attachment.uri;
                if (otherUri === null)
                    return true;
                return filters.find(uri => uri.equals(otherUri));
            });
            if (attachments.length === 0)
                return [];
            const result = [];
            for (const attachment of attachments) {
                const returned = attachment.callback(cause);
                if (returned !== null && returned !== undefined)
                    result.push({ from: attachment.uri, returned });
            }
            return result;
        }
        /**
         * Augments the global scope of the agents attached to this
         * program with a variable whose name and value are specified
         * in the arguments to this method. (Note that this only affects
         * agents that are attached *after* this call has been made.)
         */
        augment(name, value) {
            this.agentCache.augment(name, value);
        }
        /**
         *
         */
        attach(agentUri) {
            return new Promise(() => {
                throw Truth.Exception.notImplemented();
            });
        }
        /**
         *
         */
        detach(agentUri) {
            throw Truth.Exception.notImplemented();
        }
        query(root, ...typePath) {
            if (arguments.length > 1 && typePath.length === 0)
                throw Truth.Exception.passedArrayCannotBeEmpty("typePath");
            if (root instanceof Truth.Document) {
                if (typePath.length === 0)
                    return Truth.Type.constructRoots(root);
                const uri = root.sourceUri.extendType(typePath);
                return Truth.Type.construct(uri, this);
            }
            const docUri = Truth.Uri.maybeParse(root);
            if (docUri === null)
                throw Truth.Exception.absoluteUriExpected();
            const doc = this.documents.get(root);
            if (!doc)
                return null;
            const types = docUri.types.map(t => t.toString()).concat(typePath);
            if (types.length === 0)
                return Truth.Type.constructRoots(doc);
            const fullUri = docUri.extendType(typePath);
            const constructed = Truth.Type.construct(fullUri, this);
            if (typePath.length === 0)
                return constructed ?
                    Object.freeze([constructed]) :
                    [];
            return constructed;
        }
        /**
         * Begin inspecting a document loaded
         * into this program, a specific location.
         */
        inspect(document, line, offset) {
            const statement = document.read(line);
            const region = statement.getRegion(offset);
            switch (region) {
                case Truth.StatementRegion.void:
                    return new ProgramInspectionResult(null, statement);
                // Return all the types in the declaration side of the parent.
                case Truth.StatementRegion.whitespace:
                    {
                        const parent = document.getParentFromPosition(line, offset);
                        if (parent instanceof Truth.Document)
                            return new ProgramInspectionResult(parent, statement);
                        const types = parent.declarations
                            .map(decl => decl.factor())
                            .reduce((spines, s) => spines.concat(s), [])
                            .map(spine => Truth.Type.construct(spine, this));
                        return new ProgramInspectionResult(types, statement, null);
                    }
                //
                case Truth.StatementRegion.pattern:
                    {
                        // TODO: This should not be returning a PatternLiteral,
                        // but rather a fully constructed IPattern object. This
                        // code is only here as a shim.
                        const patternTypes = [];
                        return new ProgramInspectionResult(patternTypes, statement);
                    }
                // Return all the types related to the specified declaration.
                case Truth.StatementRegion.declaration:
                    {
                        const decl = statement.getDeclaration(offset);
                        if (!decl)
                            throw Truth.Exception.unknownState();
                        const types = decl
                            .factor()
                            .map(spine => Truth.Type.construct(spine, this));
                        return new ProgramInspectionResult(types, statement, decl);
                    }
                // 
                case Truth.StatementRegion.annotation:
                    {
                        const anno = statement.getAnnotation(offset);
                        if (!anno)
                            throw Truth.Exception.unknownState();
                        const spine = statement.declarations[0].factor()[0];
                        const type = Truth.Type.construct(spine, this);
                        const annoText = anno.boundary.subject.toString();
                        const base = type.bases.find(b => b.name === annoText);
                        const bases = base ? [base] : null;
                        return new ProgramInspectionResult(bases, statement, anno);
                    }
            }
            return new ProgramInspectionResult(null, statement, null);
        }
        /**
         * Performs a full verification of all documents loaded into the program.
         * This Program's .faults field is populated with any faults generated as
         * a result of the verification. If no documents loaded into this program
         * has been edited since the last verification, verification is not re-attempted.
         *
         * @returns An entrypoint into performing analysis of the Types that
         * have been defined in this program.
         */
        verify() {
            for (const doc of this.documents.each())
                for (const { statement } of doc.eachDescendant())
                    this.verifyAssociatedDeclarations(statement);
            return this.finalizeVerification();
        }
        /**
         * Performs verification on the parts of the document that have
         * not been verified since the last call to this method. Once this
         * method has completed, any detected faults will be available
         * by using the methods located in the `.faults` property of this
         * instance.
         *
         * @returns A boolean value that indicates whether verification
         * completed without detecting any faults in this Program.
         */
        reverify() {
            for (const doc of this.unverifiedDocuments)
                for (const { statement } of doc.eachDescendant())
                    this.verifyAssociatedDeclarations(statement);
            for (const smt of this.unverifiedStatements)
                this.verifyAssociatedDeclarations(smt);
            return this.finalizeVerification();
        }
        /** */
        verifyAssociatedDeclarations(statement) {
            if (!statement.isDisposed)
                for (const decl of statement.declarations)
                    decl.factor().map(spine => Truth.Type.construct(spine, this));
        }
        /** */
        finalizeVerification() {
            this.faults.refresh();
            this.unverifiedDocuments.length = 0;
            this.unverifiedStatements.length = 0;
            return this.faults.count === 0;
        }
    }
    Truth.Program = Program;
    /**
     * Gets information about the object that holds
     * the specified Program instance.
     */
    function getHolderInfo(program) {
        const ih = program.instanceHolder;
        return {
            uri: (ih ? ih.uri : null),
            scope: (ih ? ih.scope : program)
        };
    }
    /**
     * @internal
     * Stores information about the attachment
     * of a cause callback function.
     */
    class CauseAttachment {
        /** */
        constructor(uri, callback, scope) {
            this.uri = uri;
            this.callback = callback;
            this.scope = scope;
        }
    }
    /**
     * Stores the details about a precise location in a Document.
     */
    class ProgramInspectionResult {
        /** @internal */
        constructor(
        /**
         * Stores the compilation object that most closely represents
         * what was found at the specified location. Stores null in the
         * case when the specified location contains an object that
         * has been marked as cruft (the statement and span fields
         * are still populated in this case).
         */
        foundObject, 
        /**
         * Stores the Statement found at the specified location.
         */
        statement, 
        /**
         * Stores the Span found at the specified location, or
         * null in the case when no Span was found, such as if
         * the specified location is whitespace or a comment.
         */
        span = null) {
            this.foundObject = foundObject;
            this.statement = statement;
            this.span = span;
            if (Array.isArray(foundObject) && foundObject.length === 0)
                this.foundObject = null;
        }
    }
    Truth.ProgramInspectionResult = ProgramInspectionResult;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * A cache that stores agent build function loaded by a single program instance.
     */
    class AgentCache {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.agentFunctionParameters = new Map();
            /**
             * Stores the number of lines that are introduced by the script
             * engine when a code block is wrapped in a new Function()
             * block, which is then toString()'d. This is used in order to calculate
             * source map line offsets (which varies by engine).
             */
            this.sourceMapLineOffset = (() => {
                // eslint-disable-next-line no-new-func
                const testFn = new Function("a", "b", "c", ";");
                const lineCount = testFn.toString().split("\n").length;
                return lineCount - 2;
            })();
            /**
             * Stores a map whose keys are agent URIs, and whose values
             * are a set of Statement instances that reference the agent,
             * or, in the case when the agent is added to the program
             * through another means (such as programmatically),
             * a reference to the program is stored instead.
             *
             * Technically an agent should be attached in only one place
             * in the program, however, this may not always be the case,
             * and the system needs to be able to handle the case when
             * it isn't.
             *
             * This array is used to reference count / garbage collect
             * the attached agents.
             */
            this.cache = new Map();
            program.on(Truth.CauseUriReferenceAdd, data => {
                if (data.uri.ext === ".truth.js" /* js */)
                    this.attachAgent(data.uri, data.statement);
            });
            program.on(Truth.CauseUriReferenceRemove, data => {
                if (data.uri.ext === ".truth.js" /* js */)
                    this.detachAgent(data.uri, data.statement);
            });
        }
        /** */
        async attachAgent(uri, statement) {
            const uriText = uri.toStoreString();
            const existingCacheSet = this.cache.get(uriText);
            const reference = statement || this.program;
            if (existingCacheSet) {
                existingCacheSet.add(reference);
                return;
            }
            const scope = statement instanceof Truth.Statement ?
                statement.document :
                this.program;
            const sourceRaw = await Truth.UriReader.tryRead(uri);
            if (sourceRaw instanceof Error)
                return sourceRaw;
            const source = this.maybeAdjustSourceMap(uri, sourceRaw);
            const patchedProgram = Truth.Misc.patch(this.program, {
                instanceHolder: { uri, scope }
            });
            const params = [
                "program",
                "Truth",
                "require",
                ...this.agentFunctionParameters.keys(),
                source
            ];
            const args = [
                patchedProgram,
                Truth,
                AgentCache.hijackedRequireFn,
                ...this.agentFunctionParameters.values()
            ];
            try {
                const fn = Object.freeze(Function.apply(Function, params));
                await fn.apply(fn, args);
            }
            catch (e) {
                this.reportUserLandError(e);
                return;
            }
            this.program.cause(new Truth.CauseAgentAttach(uri, scope));
            const set = new Set([reference]);
            this.cache.set(uriText, set);
        }
        /** */
        detachAgent(uri, statement) {
            const uriText = uri.toStoreString();
            const existingCacheSet = this.cache.get(uriText);
            if (!existingCacheSet)
                return;
            existingCacheSet.delete(statement || this.program);
            if (existingCacheSet.size === 0) {
                this.cache.delete(uriText);
                this.program.cause(new Truth.CauseAgentDetach(uri));
            }
        }
        /**
         * @internal
         * (Called by Program)
         */
        augment(name, value) {
            if (this.agentFunctionParameters.has(name))
                throw Truth.Exception.causeParameterNameInUse(name);
            this.agentFunctionParameters.set(name, value);
        }
        /**
         * Adjusts the content of the sourcemap in the specified source code
         * file, to account for the discrepencies introduced by wrapping JavaScript
         * source code in a new Function() constructor.
         */
        maybeAdjustSourceMap(sourceUri, sourceCode) {
            // We can't do any of this source map mutation without Node.JS
            // access right now. Maybe this will change in the future.
            if (typeof require !== "function")
                return sourceCode;
            const lastLineStart = (() => {
                for (let i = sourceCode.length; i-- > 1;)
                    if (sourceCode[i - 1] === "\n")
                        return i;
                return -1;
            })();
            if (lastLineStart < 0)
                return sourceCode;
            const sourceMapUrl = ["//", "#", " source", "MappingURL="].join("");
            if (sourceCode.substr(lastLineStart, sourceMapUrl.length) !== sourceMapUrl)
                return sourceCode;
            const startPos = lastLineStart + sourceMapUrl.length;
            const ending = ";base64,";
            const endPos = sourceCode.indexOf(ending, startPos) + ending.length;
            // Unsupported source map format.
            if (endPos < ending.length)
                return sourceCode;
            const sourceMapRaw = this.fromBase64(sourceCode.slice(endPos));
            // There's probably some error in the source map
            if (!sourceMapRaw)
                return sourceCode;
            // The source map isn't parsing as a JSON object ... probably broken somehow
            const sourceMap = Truth.Misc.tryParseJson(sourceMapRaw);
            if (!sourceMap)
                return sourceCode;
            // Unsupported source map version
            if (typeof sourceMap.mappings !== "string")
                return sourceCode;
            // Placing a ; in the "mappings" property of the source map object
            // shifts the lines down by 1. It needs to be + 1, because we wrap
            // the code in our own setTimeout() block.
            const prefix = ";".repeat(this.sourceMapLineOffset + 1);
            const pathModule = require("path");
            const basePath = sourceUri.toStoreString(true);
            sourceMap.mappings = prefix + sourceMap.mappings;
            if (sourceMap.sources instanceof Array)
                sourceMap.sources = sourceMap.sources.map(s => pathModule.join(basePath, s));
            const newSourceMap = this.toBase64(JSON.stringify(sourceMap));
            const newSourceCode = sourceCode.slice(0, lastLineStart);
            // The source code is wrapped in a setTimeout in order
            // to give any attached debuggers a chance to connect.
            const varName = "$$__RESOLVE_FUNCTION__$$";
            const newSourceCodeDelayed = `return new Promise(${varName} => setTimeout(() => {\n` +
                newSourceCode +
                `; ${varName}(); }, 1))\n`;
            const newPrefix = sourceCode.slice(lastLineStart, endPos);
            return newSourceCodeDelayed + newPrefix + newSourceMap;
        }
        /** */
        reportUserLandError(e) {
            // NOTE: This should probably be reporting the error
            // somewhere where it's visible.
            debugger;
            throw e;
        }
        /** */
        toBase64(plain) {
            return typeof btoa === "function" ?
                btoa(plain) :
                Buffer.from(plain, "ascii").toString("base64");
        }
        /** */
        fromBase64(encoded) {
            return typeof atob === "function" ?
                atob(encoded) :
                Buffer.from(encoded, "base64").toString("ascii");
        }
    }
    /**
     * The require() function is not available within the context of an
     * agent for numerous (and non-obvious) reasons. This function
     * is fed into all agent functions to prevent any otherwise available
     * require() function from being accessed.
     */
    AgentCache.hijackedRequireFn = Object.freeze((specifier) => {
        throw new Error("The require() function is not available in this context. " +
            "Multi-file agents should be bundled with a bundler " +
            "such as RollupJS.");
    });
    Truth.AgentCache = AgentCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Abstract base class for all Causes defined both within
     * the compiler core, and in user code.
     */
    class Cause {
        constructor() {
            /**
             * Stores the return type of the Cause, if any. In a cause callback function,
             * this property exists as an array of objects that have been returned
             * from other cause aids.
             */
            this.returns = null;
        }
    }
    Truth.Cause = Cause;
    // 
    // Causes
    // 
    /** */
    class CauseAgentAttach extends Cause {
        constructor(
        /**
         * Stores the URI from where the agent was loaded.
         */
        uri, 
        /**
         * Stores an object that represents the scope of where the agent
         * applies.
         *
         * If the value is `instanceof Program`, this indicates that
         * the agent's causes are scoped to a particular program (which
         * is effectively "unscoped").
         *
         * If the value is `instanceof Document`, this indicates that
         * the agent's causes are scoped to the causes that can
         * originate from a single document.
         *
         * (Not implemented). If the value is `instanceof Type`, this
         * indicates that the agent's causes are scoped to the causes
         * that can originate from a single type.
         */
        scope) {
            super();
            this.uri = uri;
            this.scope = scope;
        }
    }
    Truth.CauseAgentAttach = CauseAgentAttach;
    /** */
    class CauseAgentDetach extends Cause {
        constructor(uri) {
            super();
            this.uri = uri;
        }
    }
    Truth.CauseAgentDetach = CauseAgentDetach;
    /** A cause that runs immediately after a document has been created. */
    class CauseDocumentCreate extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseDocumentCreate = CauseDocumentCreate;
    /** A cause that runs immediately before a document is removed from the program. */
    class CauseDocumentDelete extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseDocumentDelete = CauseDocumentDelete;
    /** A cause that runs when a document's file name changes. */
    class CauseDocumentUriChange extends Cause {
        constructor(document, newUri) {
            super();
            this.document = document;
            this.newUri = newUri;
        }
    }
    Truth.CauseDocumentUriChange = CauseDocumentUriChange;
    /** Abstract cause class for the resolution causes */
    class CauseResolve extends Cause {
        constructor(program, spine) {
            super();
            this.program = program;
            this.spine = spine;
        }
    }
    Truth.CauseResolve = CauseResolve;
    /** A cause that runs before the compiler is about to resolve a term. */
    class CauseBeforeResolve extends CauseResolve {
    }
    Truth.CauseBeforeResolve = CauseBeforeResolve;
    /** A cause that runs after the compiler has resolved a term. */
    class CauseAfterResolve extends CauseResolve {
    }
    Truth.CauseAfterResolve = CauseAfterResolve;
    /** A cause that runs when the compiler is unable to resolve a term. */
    class CauseNotResolved extends CauseResolve {
    }
    Truth.CauseNotResolved = CauseNotResolved;
    /** */
    class CauseInvalidate extends Cause {
        constructor(
        /**
         * A reference to the Document object in which the Invalidation occured.
         */
        document, 
        /**
         * An array of statements whose descendants should be invalidated.
         * If the array is empty, the entire document should be invalidated.
         */
        parents, 
        /**
         * An array of indexes whose length is the same as the parents field,
         * that represents the index of each parent within the document.
         */
        indexes) {
            super();
            this.document = document;
            this.parents = parents;
            this.indexes = indexes;
        }
    }
    Truth.CauseInvalidate = CauseInvalidate;
    /** */
    class CauseRevalidate extends Cause {
        constructor(
        /**
         * A reference to the Document object in which the Revalidation will occur.
         */
        document, 
        /**
         * An array of statements whose descendants should be revalidated.
         */
        parents, 
        /**
         * An array of indexes whose length is the same as the parents field,
         * that represents the index of each parent within the document.
         */
        indexes) {
            super();
            this.document = document;
            this.parents = parents;
            this.indexes = indexes;
        }
    }
    Truth.CauseRevalidate = CauseRevalidate;
    /** A cause that runs when a document edit transaction has completed. */
    class CauseEditComplete extends Cause {
        constructor(document) {
            super();
            this.document = document;
        }
    }
    Truth.CauseEditComplete = CauseEditComplete;
    /** */
    class CauseUriReference extends Cause {
        constructor(
        /**
         * A reference to the Statement instance that references
         * this URI, or null in the case when the program itself
         * references the URI by another means.
         */
        statement, uri) {
            super();
            this.statement = statement;
            this.uri = uri;
        }
    }
    Truth.CauseUriReference = CauseUriReference;
    /**
     * A hook that runs when a URI reference is added to a document,
     * but before it resolves to a resource.
     */
    class CauseUriReferenceAdd extends CauseUriReference {
    }
    Truth.CauseUriReferenceAdd = CauseUriReferenceAdd;
    /**
     * A hook that runs when a URI reference is removed from a document.
     */
    class CauseUriReferenceRemove extends CauseUriReference {
    }
    Truth.CauseUriReferenceRemove = CauseUriReferenceRemove;
    /**
     * A hook that runs when the set of faults that are detected
     * within the document have changed.
     */
    class CauseFaultChange extends Cause {
        constructor(faultsAdded, faultsRemoved) {
            super();
            this.faultsAdded = faultsAdded;
            this.faultsRemoved = faultsRemoved;
        }
    }
    Truth.CauseFaultChange = CauseFaultChange;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** @internal */
    class Exception {
        /** */
        static objectDirty() {
            return error(`
				Cannot call this method or access this property,
				because the document has changed since it
				was created.`);
        }
        /** */
        static invalidArgument() {
            return error("Invalid argument.");
        }
        /** */
        static passedArrayCannotBeEmpty(paramName) {
            return error("Array cannot be empty for parameter: " + paramName);
        }
        /** */
        static unknownState() {
            return error("An unknown state has been reached in the program.");
        }
        /** */
        static invalidCall() {
            return error("Cannot call this method given the current state of the program.");
        }
        /** */
        static notImplemented() {
            return error("Not implemented.");
        }
        /** */
        static agentNotRead() {
            return error(`
				Cannot instantiate an agent of this type,
				added. See agents.add.`);
        }
        /** */
        static agentMissing(rawUri) {
            return error(`Could not load an agent from the URI ${rawUri}`);
        }
        /** */
        static agentImportError(agentUri, errorText) {
            return error(`
				An error occured while trying to evaluate the agent at "${agentUri}".
				The error message returned was: ${errorText}`);
        }
        /** */
        static agentInvalid(rawUri) {
            return error(`
				The code file at ${rawUri} does not export a function. Consider looking
				at the documention and examples for the proper way to stucture an
				agent code file.`);
        }
        /** */
        static noRemoteAgents() {
            return error(`
				Agents cannot be loaded from remote URIs in this context.
				(Most likely, this code is running in Node.js where the loading
				of remote code is a security risk).`);
        }
        /** */
        static causeParameterNameInUse(paramName) {
            return error(`
				Cannot use the name "${paramName}" as a parameter
				name because it's already in use.`);
        }
        /** */
        static doubleTransaction() {
            return error("Cannot start a new transaction while another is executing.");
        }
        /** */
        static invalidUriRetraction() {
            return error("URI contains too few path segments to perform this retraction.");
        }
        /** */
        static invalidUri(rawUri) {
            return error("Invalid URI" + (typeof rawUri === "string" ? ": " + rawUri : ""));
        }
        /** */
        static uriNotSupported() {
            return error("URIs of this type are not supported.");
        }
        /** */
        static cannotMakeAbsolute() {
            return error(`
				Cannot make this URI absolute because no 
				process or window object could be found`);
        }
        /** */
        static absoluteUriExpected() {
            return error(`This method expects an absolute URI to be specified.`);
        }
        /** */
        static mustSpecifyVia() {
            return error(`
				Must specify the "via" argument because the parsed URI 
				was found to be relative`);
        }
        /** */
        static viaCannotBeRelative() {
            return error(`URI instances specified in the "via" argument must not be relative`);
        }
        /** */
        static invalidTypePath() {
            return error(`
				One or more of the types in the specified type path are invalid,
				because they contain either leading or trailing whitespace, or
				is an empty string.`);
        }
        /** */
        static invalidExtension(requiredExtension) {
            return error(`
				This method requires URIs that have the 
				".${requiredExtension}" extension.`);
        }
        /** */
        static invalidDocumentReference() {
            return error(`
				This document cannot be added as a dependency
				of the target document because it's storage location
				(memory or disk) differs from the that of the target.`);
        }
        /** */
        static nonEmptyDocument() {
            return error("Cannot call this method on a non-empty document.");
        }
        /** */
        static invalidWhileInEditTransaction() {
            return error(`Cannot call this method, or run this hook while an edit
				transaction is underway.`);
        }
        /** */
        static uncachableDocument() {
            return error(`
				Cannot cache this document because it was not loaded from a file.`);
        }
        /** */
        static documentAlreadyLoaded() {
            return error(`
				A document with this URI has already been created.
				Use Document.fromUri() instead.`);
        }
        /** */
        static documentNotLoaded() {
            return error("This document has not been loaded into the current program.");
        }
        /** */
        static cannotRefresh() {
            return error(`
				This resource cannot be reloaded because it only exists in memory.`);
        }
        /** */
        static offsetRequired() {
            return error(`
				Offset argument is required because the a whitespace-only
				statement was passed.`);
        }
        /** */
        static unsupportedPlatform() {
            return error("This code appears to be operating in an unsupported platform.");
        }
    }
    Truth.Exception = Exception;
    /**
     * Generates a proper error object from the specified message.
     */
    function error(msg) {
        return new Error(msg.trim().replace(/\s\s+/g, " "));
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Universal class for handling URIs that exist within a Truth document.
     */
    class Uri {
        /**
         * @internal
         */
        constructor(...uriLike) {
            /**
             *
             */
            this.protocol = Truth.UriProtocol.file;
            /**
             * Stores the name of the file referenced in the URI, including any extension.
             */
            this.file = "";
            /**
             * Stores the extension of the file referenced in the URI, if any.
             */
            this.ext = ".truth" /* truth */;
            /**
             * Stores the store-side components of this URI.
             * Excludes the file name.
             */
            this.stores = [];
            /**
             * Stores the type-side components of this URI.
             */
            this.types = [];
            /**
             * Stores the number of retractions that are defined in this
             * URI, in the case when the URI is relative.
             */
            this.retractionCount = 0;
            /**
             * Stores whether the URI is a relative path.
             */
            this.isRelative = false;
            for (const uriProps of uriLike)
                Object.assign(this, uriProps);
            Object.freeze(this.stores);
            Object.freeze(this.types);
            Object.freeze(this);
        }
        /**
         * Constructs a new Uri instance that points to a (possibly nested)
         * type defined in the specified document.
         */
        static from(document, ...types) {
            return document.sourceUri.extendType(types);
        }
        /**
         * Attempts to parse the specified string or Uri into
         * another Uri instance. If the parameter is already
         * a Uri, it is returned without further processing.
         */
        static maybeParse(value) {
            if (value instanceof Uri)
                return value;
            if (!value)
                return null;
            return this.tryParse(value);
        }
        /**
         * Attempts to parse the specified string into a Uri instance.
         * Returns null in the case when the Uri could not be parsed.
         */
        static tryParse(uri, via) {
            if (!uri)
                return null;
            const uriLike = typeof uri === "string" ?
                Truth.UriParser.parse(uri) :
                uri;
            if (uriLike === null)
                return null;
            const outUri = (() => {
                if (!(uriLike.isRelative && via))
                    return new Uri(uriLike);
                const viaParsed = typeof via === "string" ?
                    Truth.UriParser.parse(via) :
                    via;
                if (viaParsed === null)
                    throw Truth.Exception.invalidUri();
                if (viaParsed.isRelative)
                    throw Truth.Exception.viaCannotBeRelative();
                const uriStores = Truth.Not.undefined(uriLike.stores);
                const viaStores = Truth.Not.undefined(viaParsed.stores);
                const retract = uriLike.retractionCount || 0;
                if (viaStores.length < retract)
                    throw Truth.Exception.invalidUri();
                return new Uri(uriLike, {
                    protocol: viaParsed.protocol,
                    stores: retract > 0 ?
                        viaStores.slice(0, -retract).concat(uriStores) :
                        viaStores.concat(uriStores),
                    retractionCount: -1,
                    isRelative: false
                });
            })();
            // Return null when an extension was found that isn't
            // unknown (also when no extension was found). This
            // is in order to reduce the number of terms that have
            // a special meaning in a truth document.
            if (outUri.ext === "" /* unknown */)
                return null;
            // You can't have a type path that points to a 
            // non-truth file, so null is returned in this case.
            if (outUri.types.length > 0)
                if (outUri.ext !== ".truth" /* truth */)
                    return null;
            return outUri;
        }
        /**
         * Copies the specified URI or Spine into another URI instance.
         */
        static clone(value) {
            if (value instanceof Uri)
                return value;
            const srcUri = value.document.sourceUri;
            const typeSegments = value.vertebrae.map(vert => new Truth.UriComponent(vert.toString(true)));
            return new Uri(srcUri, { types: typeSegments });
        }
        /**
         * @internal
         * Creates an internal URI used to uniquely identify a
         * document that exists only in memory.
         */
        static createInternal() {
            const max = Number.MAX_SAFE_INTEGER;
            const ext = ".truth" /* truth */;
            return new Uri({
                protocol: Truth.UriProtocol.internal,
                file: Math.floor(Math.random() * max).toString(36) + ext,
                ext
            });
        }
        /**
         * @internal
         * Debugging utility. Do not use.
         */
        get value() { return this.toTypeString(); }
        /**
         * Creates a new Uri whose path of types is
         * retracted by the specified number of levels
         * of depth.
         */
        retractType(factor) {
            const types = this.types.slice(0, -factor);
            return new Uri(this, { types });
        }
        /**
         * Creates a new Uri, whose path of types is
         * retracted to the specified level of depth.
         */
        retractTypeTo(depth) {
            return depth < this.types.length ?
                this.retractType(this.types.length - depth) :
                this;
        }
        /**
         * Creates a new Uri whose path of stores is
         * retracted by the specified number of levels
         * of depth.
         */
        retractStore(factor) {
            const folders = this.stores.slice(0, -factor);
            return new Uri(this, { stores: folders });
        }
        /**
         * Creates a new Uri, whose path of folders is
         * retracted to the specified level of depth.
         */
        retractStoreTo(depth) {
            return depth < this.stores.length ?
                this.retractType(this.stores.length - depth) :
                this;
        }
        /**
         *
         */
        extendType(additionalTypeNames) {
            if (!additionalTypeNames)
                return new Uri(this);
            const components = typeof additionalTypeNames === "string" ?
                [new Truth.UriComponent(additionalTypeNames)] :
                additionalTypeNames.map(t => new Truth.UriComponent(t));
            return new Uri(this, { types: this.types.concat(components) });
        }
        /**
         *
         */
        extendStore(additionalStores) {
            if (!additionalStores)
                return new Uri(this);
            const stores = typeof additionalStores === "string" ?
                [new Truth.UriComponent(additionalStores)] :
                additionalStores.map(s => new Truth.UriComponent(s));
            return new Uri(this, { stores });
        }
        /**
         * @returns A boolean value that indicates whether this
         * Uri is structurally equivalent to the specified Uri.
         */
        equals(other, compareTypes) {
            if (this === other)
                return true;
            if (compareTypes) {
                if (this.types.length !== other.types.length)
                    return false;
                if (this.types.some((t, i) => t.value !== other.types[i].value))
                    return false;
            }
            if (this.protocol !== other.protocol)
                return false;
            if (this.stores.some((s, i) => s.value !== other.stores[i].value))
                return false;
            return true;
        }
        /**
         *
         */
        toAbsolute() {
            if (!this.isRelative)
                return this;
            const via = (() => {
                try {
                    if (typeof process === "object")
                        if (typeof process.cwd === "function")
                            return process.cwd() || null;
                    if (typeof window !== "undefined")
                        if (typeof window.location !== "undefined")
                            if (typeof window.location.href === "string")
                                return window.location.href || null;
                }
                catch (e) { }
                return null;
            })();
            if (via === null)
                throw Truth.Exception.cannotMakeAbsolute();
            return Uri.tryParse(this, via);
        }
        /**
         * @returns The path of types contained by this URI,
         * concatenated into a single string.
         */
        toTypeString() {
            return this.types.map(t => t.toStringEncoded())
                .join("/" /* componentSeparator */);
        }
        /**
         * @returns The path of stores contained by this URI,
         * concatenated into a single string.
         */
        toStoreString(omitFile = false) {
            const thisAbsolute = Truth.Not.null(this.isRelative ? this.toAbsolute() : this);
            // In the case when the specified protocol is "file",
            // the string should start with a / so that we get
            // and output that looks like /Users/person/....
            const proto = thisAbsolute.protocol === Truth.UriProtocol.file ?
                "/" :
                thisAbsolute.protocol + "//";
            const isWeb = thisAbsolute.protocol === Truth.UriProtocol.http ||
                thisAbsolute.protocol === Truth.UriProtocol.https;
            const components = thisAbsolute.stores
                .concat(omitFile ? [] : [new Truth.UriComponent(this.file)])
                .map((t, i) => {
                return i === 0 && isWeb ?
                    t.toStringHost() :
                    t.toStringEncoded();
            })
                .join("/" /* componentSeparator */);
            return proto + components;
        }
        /**
         *
         */
        toString() {
            let out = this.toStoreString();
            if (this.types.length > 0)
                out += "//" /* typeSeparator */ + this.toTypeString();
            return out;
        }
    }
    Truth.Uri = Uri;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * An enumeration that lists all availble protocols
     * supported by the system. The list can be enumerated
     * via Uri.eachProtocol()
     */
    let UriProtocol;
    (function (UriProtocol) {
        UriProtocol["none"] = "";
        UriProtocol["unknown"] = "?";
        UriProtocol["file"] = "file:";
        UriProtocol["https"] = "https:";
        UriProtocol["http"] = "http:";
        UriProtocol["internal"] = "internal:";
    })(UriProtocol = Truth.UriProtocol || (Truth.UriProtocol = {}));
    (function (UriProtocol) {
        /**
         * @returns A UriProtocol member from the specified string.
         */
        function resolve(value) {
            const vals = Object.values(UriProtocol);
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        UriProtocol.resolve = resolve;
    })(UriProtocol = Truth.UriProtocol || (Truth.UriProtocol = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class UriParser {
        /**
         *
         */
        static parse(raw) {
            let isRelative = false;
            let retractionCount = 0;
            let protocol = "";
            const parser = new Truth.Parser(raw);
            /**
             * Reads ./
             */
            function maybeReadCurrent() {
                const mark = parser.position;
                if (parser.read("." /* current */))
                    if (parser.read("/" /* componentSeparator */))
                        return true;
                parser.position = mark;
                return false;
            }
            /**
             * Reads ../../../
             * @returns True if at least one retraction was read, otherwise false.
             */
            function readRetractions() {
                const token = ".." /* retract */ + "/" /* componentSeparator */;
                while (parser.more()) {
                    if (!parser.read(token))
                        break;
                    retractionCount++;
                }
                return retractionCount > 0;
            }
            /**
             * Reads proto:
             * Assigns the local protocol variable if necessary.
             * @returns Trus if a protocol was found, otherwise false.
             */
            function maybeReadProtocol() {
                const mark = parser.position;
                let rawProto = "";
                if (parser.read("//" /* protocolRelative */)) {
                    protocol = Truth.UriProtocol.unknown;
                    return true;
                }
                const cancel = () => {
                    parser.position = mark;
                    return false;
                };
                while (parser.more()) {
                    const char = parser.readGrapheme();
                    if (isUpperAscii(char)) {
                        rawProto += String.fromCharCode(char.charCodeAt(0) + 32);
                        continue;
                    }
                    if (isLowerAscii(char)) {
                        rawProto += char;
                        continue;
                    }
                    if (char === ":") {
                        rawProto += ":";
                        break;
                    }
                    return cancel();
                }
                // Protocols need to have the // suffix after them ... for now.
                if (!parser.read("//"))
                    return cancel();
                return (protocol = rawProto) !== "";
            }
            /**
             * Reads the store side or the type side of a URI.
             */
            function readComponents(side) {
                const mark = parser.position;
                const out = [];
                const cancel = () => {
                    parser.position = mark;
                    return null;
                };
                while (parser.more()) {
                    const comp = readComponent();
                    if (comp === null)
                        break;
                    // URIs cannot have type-side-only components on their store side
                    if (side === "store")
                        if (comp.index >= 0 || comp.isPattern)
                            return cancel();
                    out.push(comp);
                    if (side === "store" && parser.read("//" /* typeSeparator */))
                        break;
                    if (parser.read("/" /* componentSeparator */))
                        continue;
                    break;
                }
                return out;
            }
            /**
             * Reads a single URI component.
             */
            function readComponent() {
                const mark = parser.position;
                const encChars = "._-~%".split("");
                const portChar = ":";
                let value = "";
                let port = "";
                let isParsingPort = false;
                const anonComp = maybeReadAnonymousComponent();
                if (anonComp)
                    return anonComp;
                const quit = () => {
                    parser.position = mark;
                    return null;
                };
                while (parser.more()) {
                    if (parser.peek("/" /* componentSeparator */))
                        break;
                    const g = parser.readGrapheme();
                    if (g === portChar) {
                        if (!isValidHostName(value) || !isValidIPv4Address(value))
                            return quit();
                        isParsingPort = true;
                        continue;
                    }
                    if (isParsingPort) {
                        if (!isDigit(g))
                            return quit();
                        port += g;
                        if (port.length > 5)
                            return quit();
                    }
                    else if (!encChars.includes(g) && !isUpperAscii(g) && !isLowerAscii(g) && !isDigit(g)) {
                        return quit();
                    }
                    else
                        value += g;
                }
                if (value === "")
                    return quit();
                return new Truth.UriComponent(port ? value + portChar + port : value);
            }
            /**
             *
             */
            function maybeReadAnonymousComponent() {
                const mark = parser.position;
                const cancel = () => {
                    parser.position = mark;
                    return null;
                };
                let anon = parser.read("[" /* indexerStart */);
                if (!anon)
                    return null;
                while (parser.more()) {
                    if (parser.read("]" /* indexerEnd */))
                        return anon.length > 0 ?
                            new Truth.UriComponent(anon + "]" /* indexerEnd */) :
                            cancel();
                    const g = parser.readGrapheme();
                    if (!isDigit(g))
                        break;
                    anon += g;
                }
                return cancel();
            }
            if (maybeReadCurrent() || readRetractions()) {
                isRelative = true;
            }
            else if (maybeReadProtocol()) {
                // Do nothing
            }
            else if (parser.read("/" /* componentSeparator */)) {
                protocol = Truth.UriProtocol.file;
            }
            else
                return null;
            const stores = readComponents("store");
            if (stores === null || stores.length === 0)
                return null;
            // URI ends with a /, this isn't a valid URI
            if (parser.readThenTerminal("/" /* componentSeparator */))
                return null;
            // URI ends with a //, this isn't a valid URI
            if (parser.readThenTerminal("//" /* typeSeparator */))
                return null;
            const types = readComponents("type");
            if (types === null)
                return null;
            if (types.length > 0) {
                // We should be done by now. 
                // If we're not, there's some garbage at the 
                // end of the URI, such as a forward slash.
                if (parser.more())
                    return null;
            }
            const file = stores[stores.length - 1].value;
            const ext = (() => {
                if (file.endsWith(".truth" /* truth */))
                    return ".truth" /* truth */;
                if (file.endsWith(".truth.js" /* js */))
                    return ".truth.js" /* js */;
                if (file.endsWith(".truth.wasm" /* wasm */))
                    return ".truth.wasm" /* wasm */;
                return "" /* unknown */;
            })();
            // If an extension was detected, the last component
            // from the end of the URI should be removed, because
            // "stores" does not include file names.
            if (ext !== "" /* unknown */)
                stores.pop();
            return {
                protocol: Truth.UriProtocol.resolve(protocol) || Truth.UriProtocol.unknown,
                file: ext ? file : "",
                ext,
                retractionCount,
                isRelative,
                stores: Object.freeze(stores),
                types: Object.freeze(types)
            };
        }
    }
    Truth.UriParser = UriParser;
    /** */
    function isUpperAscii(char) {
        const point = char.codePointAt(0) || 0;
        return point >= 65 && point <= 90;
    }
    /** */
    function isLowerAscii(char) {
        const point = char.codePointAt(0) || 0;
        return point >= 97 && point <= 122;
    }
    /** */
    function isDigit(char) {
        const point = char.codePointAt(0) || 0;
        return point >= 48 && point <= 57;
    }
    /** */
    function isValidIPv4Address(maybeIP) {
        if (!maybeIP)
            return false;
        const ipParts = maybeIP.split(".").filter(s => s);
        if (ipParts.length !== 4)
            return false;
        if (ipParts.some(s => !/^\d{1,3}$/.test(s)))
            return false;
        if (ipParts.some(s => parseInt(s, 10) > 255))
            return false;
        return true;
    }
    /** */
    function isValidHostName(maybeHostName) {
        if (!maybeHostName)
            return false;
        const hostParts = maybeHostName.split(".");
        if (hostParts.some(s => s.length === 0))
            return false;
        for (const hostPart of hostParts) {
            // NOTE: This is a make-shift host name validation
            // method. It should be replaced with something
            // that conforms to the relevant RFC specifications.
            const hostSegmentParts = hostPart.split(/-|--/);
            for (const hostSegmentPart of hostSegmentParts) {
                if (hostSegmentPart.length === 0)
                    return false;
                for (const cp of [...hostSegmentPart].map(s => s.codePointAt(0))) {
                    if (!cp || !(cp >= 48 && cp <= 57 ||
                        cp >= 65 && cp <= 90 ||
                        cp >= 97 && cp <= 122 ||
                        cp >= 128 && cp <= 165 ||
                        cp >= 255))
                        return false;
                }
            }
        }
        return true;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    const hashRegex = new RegExp("[a-f0-9]{" + Truth.Hash.length + "}", "i");
    /**
     * A class that represents a single component of a Uri.
     * Handled encoding and decoding of the underlying value.
     */
    class UriComponent {
        /** */
        constructor(raw) {
            /**
             * Stores a number that indicates a type index that this UriComponent,
             * refers to, used in the case when this UriComponent is referring to
             * an anonymous type.
             *
             * Stores -1 in the case when an index value is not relevant to this
             * UriComponent instance.
             */
            this.index = -1;
            /**
             * Stores the decoded text value of this UriComponent.
             * Stores a string version of the .index property in the case when
             * it is greater than -1.
             * This has the same value as the result of the .toString() method.
             */
            this.value = "";
            /**
             * Stores a pattern hash, in the case when this UriComponent
             * relates to a pattern. Stores an empty string in other cases.
             */
            this.hash = "";
            this.isRetract = raw === "..";
            this.isCurrent = raw === ".";
            this.hash = this.tryExtractHash(raw);
            if (raw.length > 2)
                if (raw[0] === "[" /* indexerStart */)
                    if (raw[raw.length - 1] === "]" /* indexerEnd */)
                        if (/\d+/.test(raw.slice(1, -1)))
                            this.index = +raw.slice(1, -1);
            this.value = this.index >= 0 ?
                this.index.toString() :
                unescape(raw);
            Object.freeze(this);
        }
        /** */
        tryExtractHash(text) {
            const delim = "/" /* main */;
            const delimEsc = escape(delim);
            const delimLen = text.startsWith(delim) ? delim.length :
                text.startsWith(delimEsc) ? delimEsc.length :
                    -1;
            const hashLen = Truth.Hash.length;
            if (delimLen < 0 || text.length < delimLen + hashLen + 1)
                return "";
            const hash = text.substr(delimLen, hashLen);
            if (hash.length !== hashLen || !hashRegex.test(hash))
                return "";
            return hash;
        }
        /** Stores whether this component represents a pattern. */
        get isPattern() { return this.hash !== ""; }
        /**
         * @returns The raw decoded text value of this UriComponent.
         */
        toString() {
            return this.value;
        }
        /**
         * @returns The URL encoded text value of this UriComponent.
         */
        toStringEncoded() {
            if (this.isPattern) {
                const de = "/" /* main */;
                return de + escape(this.value.slice(de.length));
            }
            if (this.index >= 0)
                return "[" /* indexerStart */ + this.index + "]" /* indexerEnd */;
            return escape(this.value);
        }
        /**
         * @returns The text value of this UriComponent, using an
         * encoding that is compatible with an RFC 3986 host name.
         */
        toStringHost() {
            return new URL("http://" + this.value).host;
        }
    }
    Truth.UriComponent = UriComponent;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    Truth.UriReader = new class UriReader {
        /**
         * Attempts to read the contents of the given URI.
         * If an error is generated while trying to read a file
         * at the specified location, the errors is returned.
         */
        async tryRead(uri) {
            if (uri.protocol === Truth.UriProtocol.file)
                return await readFile(uri.toStoreString());
            else if (uri.protocol === Truth.UriProtocol.http ||
                uri.protocol === Truth.UriProtocol.https)
                return await Truth.Fetch.exec(uri.toStoreString());
            throw Truth.Exception.notImplemented();
        }
    }();
    /** */
    const fileExists = (path) => new Promise((resolve, reject) => {
        Truth.Fs.module.exists(path, resolve);
    });
    /** */
    const readFile = (path, opts = "utf8") => new Promise(resolve => {
        Truth.Fs.module.readFile(path, opts, (error, data) => {
            resolve(error && error.errno ?
                error :
                data || "");
        });
    });
    /** */
    const writeFile = (path, data, opts = "utf8") => new Promise(resolve => {
        Truth.Fs.module.writeFile(path, data, opts, error => {
            resolve(error || null);
        });
    });
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * An enumeration that stores the escape sequences
     * that only match a single kind of character. "Sign" in
     * this case refers to the fact that these are escape
     * sequences that refer to another character.
     */
    let RegexSyntaxSign;
    (function (RegexSyntaxSign) {
        RegexSyntaxSign["tab"] = "\\t";
        RegexSyntaxSign["lineFeed"] = "\\n";
        RegexSyntaxSign["carriageReturn"] = "\\r";
        RegexSyntaxSign["escapedFinalizer"] = "\\/";
        RegexSyntaxSign["backslash"] = "\\\\";
    })(RegexSyntaxSign = Truth.RegexSyntaxSign || (Truth.RegexSyntaxSign = {}));
    (function (RegexSyntaxSign) {
        /**
         * @returns A RegexSyntaxSign member from the
         * specified sign literal (ex: "\t") or raw signable
         * character (ex: "	").
         */
        function resolve(value) {
            if (value.length < 1 || value.length > 2)
                return null;
            const vals = Object.values(RegexSyntaxSign);
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        RegexSyntaxSign.resolve = resolve;
        /** */
        function unescape(value) {
            switch (value) {
                case RegexSyntaxSign.tab: return String.fromCodePoint(9);
                case RegexSyntaxSign.lineFeed: return String.fromCodePoint(10);
                case RegexSyntaxSign.carriageReturn: return String.fromCodePoint(13);
                case RegexSyntaxSign.escapedFinalizer: return String.fromCodePoint(47);
                case RegexSyntaxSign.backslash: return String.fromCodePoint(92);
            }
            return "";
        }
        RegexSyntaxSign.unescape = unescape;
    })(RegexSyntaxSign = Truth.RegexSyntaxSign || (Truth.RegexSyntaxSign = {}));
    /**
     * An enumeration that stores the escape sequences
     * that can match more than one kind of character.
     */
    let RegexSyntaxKnownSet;
    (function (RegexSyntaxKnownSet) {
        RegexSyntaxKnownSet["digit"] = "\\d";
        RegexSyntaxKnownSet["digitNon"] = "\\D";
        RegexSyntaxKnownSet["alphanumeric"] = "\\w";
        RegexSyntaxKnownSet["alphanumericNon"] = "\\W";
        RegexSyntaxKnownSet["whitespace"] = "\\s";
        RegexSyntaxKnownSet["whitespaceNon"] = "\\S";
        RegexSyntaxKnownSet["wild"] = ".";
    })(RegexSyntaxKnownSet = Truth.RegexSyntaxKnownSet || (Truth.RegexSyntaxKnownSet = {}));
    (function (RegexSyntaxKnownSet) {
        const vals = Object.values(RegexSyntaxKnownSet);
        function resolve(value) {
            const idx = vals.indexOf(value);
            return idx < 0 ? null : vals[idx];
        }
        RegexSyntaxKnownSet.resolve = resolve;
    })(RegexSyntaxKnownSet = Truth.RegexSyntaxKnownSet || (Truth.RegexSyntaxKnownSet = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages the diagnostics that have been
     * reported for the current state of the program.
     */
    class FaultService {
        /** */
        constructor(program) {
            // Listen for invalidations and clear out any faults
            // that correspond to objects that don't exist in the
            // document anymore. 
            this.program = program;
            /** */
            this.inEditTransaction = false;
            /**
             * Stores the faults that are presented to external consumer
             * of the fault service when they use the accessor methods.
             */
            this.visibleFrame = new FaultFrame();
            /**
             * Stores the faults that have been built up during an edit transaction.
             * These faults are copied to the `visibleFrame` when the edit
             * transaction completes.
             */
            this.bufferFrame = new FaultFrame();
            /**
             * Stores the faults that were reported asynchronously, and therefore
             * are not bound to any edit transaction.
             */
            this.asyncFrame = new FaultFrame();
            program.on(Truth.CauseInvalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        for (const { statement } of smt.document.eachDescendant(smt, true))
                            this.removeStatementFaults(statement);
                }
                else
                    for (const { statement } of data.document.eachDescendant())
                        this.removeStatementFaults(statement);
                this.inEditTransaction = true;
            });
            program.on(Truth.CauseEditComplete, () => {
                this.inEditTransaction = false;
                this.refresh();
            });
        }
        /**
         * Removes all faults associated with the specified statement.
         */
        removeStatementFaults(statement) {
            this.bufferFrame.removeSource(statement);
            for (const span of statement.allSpans)
                this.bufferFrame.removeSource(span);
            for (const infixSpan of statement.infixSpans)
                this.bufferFrame.removeSource(infixSpan);
        }
        /**
         * Enumerates through the unrectified faults retained
         * by this FaultService.
         */
        *each() {
            const faultsSorted = Array.from(this.asyncFrame.faults.values())
                .concat(Array.from(this.visibleFrame.faults.values()))
                .map(faultMap => Array.from(faultMap.values()))
                .reduce((a, b) => a.concat(b), [])
                .sort((a, b) => a.line - b.line);
            for (const fault of faultsSorted)
                yield fault;
        }
        /**
         * Gets a number representing the number of
         * unrectified faults retained by this FaultService.
         */
        get count() {
            return this.visibleFrame.faults.size;
        }
        /**
         * Reports a fault. If a similar Fault on the same area
         * of the document hasn't been reported, the method
         * runs the FaultReported hook.
         */
        report(fault) {
            this.bufferFrame.addFault(fault);
        }
        /**
         * Reports a fault outside the context of an edit transaction.
         * This method is to be used for faults that are reported in
         * asynchronous callbacks, such as network errors.
         */
        reportAsync(fault) {
            this.bufferFrame.addFault(fault);
            if (!this.inEditTransaction)
                this.refresh();
        }
        /**
         * @returns A boolean value indicating whether this
         * FaultService retains a fault that is similar to the specified
         * fault (meaning that it has the same code and source).
         */
        has(similarFault) {
            for (const retainedFault of this.each())
                if (retainedFault.type.code === similarFault.type.code)
                    if (retainedFault.source === similarFault.source)
                        return true;
            return false;
        }
        /**
         * @returns An array of Fault objects that have been reported
         * at the specified source. If the source has no faults, an empty
         * array is returned.
         */
        check(source) {
            const out = [];
            for (const retainedFault of this.each())
                if (retainedFault.source === source)
                    out.push(retainedFault);
            return out;
        }
        /**
         * @internal
         * Used internally to inform the FaultService that type-level fault
         * analysis is being done on the provided Node. This is necessary
         * because type-level faults do not live beyond a single edit frame,
         * so the FaultService needs to know which Nodes were analyzed
         * so that newly rectified faults can be cleared out.
         *
         * When this method is called, any the faults corresponding to the
         * specified Node are cleared out, and are only added back in if
         * they were re-detected during this edit transaction.
         */
        inform(node) {
            const smts = node.statements.filter(smt => !smt.isDisposed);
            // Clear out any statement-level faults that touch the node
            for (const smt of smts)
                this.bufferFrame.removeSource(smt);
            // Clear out any span-level faults that touch the node
            const spans = smts
                .map(smt => smt.spans)
                .reduce((a, b) => a.concat(b), []);
            for (const span of spans)
                this.bufferFrame.removeSource(span);
            // Clear out any infix-level faults that touch the node
            const infixes = smts
                .map(smt => smt.infixSpans || [])
                .reduce((a, b) => a.concat(b), []);
            for (const infix of infixes)
                this.bufferFrame.removeSource(infix);
        }
        /**
         * @internal
         */
        refresh() {
            const faultsAdded = [];
            const faultsRemoved = [];
            for (const map of this.bufferFrame.faults.values())
                for (const fault of map.values())
                    if (!this.visibleFrame.hasFault(fault))
                        faultsAdded.push(fault);
            for (const map of this.visibleFrame.faults.values())
                for (const fault of map.values())
                    if (!this.bufferFrame.hasFault(fault))
                        faultsRemoved.push(fault);
            this.visibleFrame = this.bufferFrame;
            this.bufferFrame = this.bufferFrame.clone();
            if (faultsAdded.length + faultsRemoved.length > 0)
                this.program.cause(new Truth.CauseFaultChange(faultsAdded, faultsRemoved));
        }
    }
    Truth.FaultService = FaultService;
    /**
     *
     */
    class FaultFrame {
        constructor() {
            /**
             * A doubly-nested map of fault sources, fault codes, and the actual fault.
             */
            this.faults = new Map();
        }
        /** */
        clone() {
            const newFrame = new FaultFrame();
            for (const [faultSource, existingMap] of this.faults) {
                const newMap = new Map();
                for (const [code, fault] of existingMap)
                    newMap.set(code, fault);
                newFrame.faults.set(faultSource, newMap);
            }
            return newFrame;
        }
        /** */
        addFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            if (faultsForSource) {
                faultsForSource.set(fault.type.code, fault);
            }
            else {
                const map = new Map();
                map.set(fault.type.code, fault);
                this.faults.set(fault.source, map);
            }
        }
        /** */
        removeSource(source) {
            this.faults.delete(source);
            if (source instanceof Truth.Statement)
                for (const cruftObject of source.cruftObjects)
                    this.faults.delete(cruftObject);
        }
        /** */
        removeFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            if (faultsForSource)
                faultsForSource.delete(fault.type.code);
        }
        /** */
        hasFault(fault) {
            const faultsForSource = this.faults.get(fault.source);
            return faultsForSource ?
                faultsForSource.has(fault.type.code) :
                false;
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Fault {
        constructor(
        /** */
        type, 
        /** The document object that caused the fault to be reported. */
        source, 
        /**
         * A human-readable message that contains more in-depth detail
         * of the fault that occured, in addition to the standard message.
         */
        additionalDetail = "") {
            this.type = type;
            this.source = source;
            this.additionalDetail = additionalDetail;
            const src = this.source;
            // The +1's are necessary in order to deal with the fact that
            // most editors are 1-based whereas the internal representation
            // of statement strings are 0-based.
            if (src instanceof Truth.Statement) {
                // The TabsAndSpaces fault is the only fault that needs a
                // special case where it has a different reporting location.
                this.range = type.code === Truth.Faults.TabsAndSpaces.code ?
                    [1, src.indent + 1] :
                    [src.indent + 1, src.sourceText.length + 1];
            }
            else if (src instanceof Truth.Span || src instanceof Truth.InfixSpan) {
                this.range = [
                    src.boundary.offsetStart + 1,
                    src.boundary.offsetEnd + 1
                ];
            }
            else
                throw Truth.Exception.unknownState();
        }
        /**
         * Converts this fault into a string representation,
         * suitable for output as an error message.
         */
        toString() {
            const doc = this.document;
            const avoidProtocols = [
                Truth.UriProtocol.internal,
                Truth.UriProtocol.none,
                Truth.UriProtocol.unknown
            ];
            const uriText = avoidProtocols.includes(doc.sourceUri.protocol) ?
                "" : doc.sourceUri.toStoreString() + " ";
            const colNums = this.range.join("-");
            const colText = colNums ? ", Col " + colNums : "";
            return `${this.type.message} (${uriText}Line ${this.line}${colText})`;
        }
        /**
         * Gets a reference to the Document in which this Fault was detected.
         */
        get document() {
            return this.statement.document;
        }
        /**
         * Gets a reference to the Statement in which this Fault was detected.
         */
        get statement() {
            const src = this.source;
            return Truth.Not.null(src instanceof Truth.Statement ? src :
                src instanceof Truth.Span ? src.statement :
                    src instanceof Truth.InfixSpan ? src.statement :
                        null);
        }
        /**
         * Gets the line number of the Statement in which this Fault was detected.
         */
        get line() {
            const smt = this.statement;
            return smt.document.getLineNumber(smt) + 1;
        }
    }
    Truth.Fault = Fault;
    /**
     *
     */
    class FaultType {
        constructor(
        /**
         * An error code, useful for reference purposes, or display in a user interface.
         */
        code, 
        /**
         * A human-readable description of the fault.
         */
        message, 
        /**
         *
         */
        severity) {
            this.code = code;
            this.message = message;
            this.severity = severity;
            this.message = message.trim().replace(/\s\s+/g, " ");
        }
        /**
         * Creates a fault of this type.
         */
        create(source) {
            return new Fault(this, source);
        }
    }
    Truth.FaultType = FaultType;
    /**
     * Utility function for creating frozen fault instances.
     */
    function createFault(code, message, severity = 8 /* error */) {
        return Object.freeze(new FaultType(code, message, severity));
    }
    const quantifiers = `(${"*" /* star */}, 
		${"+" /* plus */},
		${"{" /* quantifierStart */}..${"}" /* quantifierEnd */})`;
    /**
     *
     */
    Truth.Faults = Object.freeze({
        /** */
        *each() {
            const values = Object.values(Truth.Faults);
            for (const faultType of values)
                if (faultType instanceof FaultType)
                    yield faultType;
        },
        /**
         * @returns An object containing the FaultType instance
         * associated with the fault with the specified code, as
         * well as the name of the instance. In the case when the
         * faultCode was not found, null is returned.
         */
        nameOf(faultCode) {
            const entries = Object.entries(Truth.Faults);
            for (const [name, type] of entries)
                if (type instanceof FaultType)
                    if (type.code === faultCode)
                        return name;
            return "";
        },
        //# Resource-related faults
        /** */
        UnresolvedResource: createFault(100, "URI points to a resource that could not be resolved."),
        /** */
        CircularResourceReference: createFault(102, "URI points to a resource that would cause a circular reference."),
        /** */
        InsecureResourceReference: createFault(104, `Documents loaded from remote locations
			cannot reference documents stored locally.`),
        //# Type verification faults
        /** */
        UnresolvedAnnotation: createFault(201, "Unresolved annotation."),
        /** */
        CircularTypeReference: createFault(203, "Circular type reference detected."),
        /** */
        ContractViolation: createFault(
        //! CHANGE THIS TO 204
        205, "Overridden types must explicitly expand the type as defined in the base."),
        /** */
        TypeCannotBeRefreshed: createFault(206, `This type cannot be refreshed, because one or more base
			types are imposing a specific type contract on it. Consider
			omitting the ${":" /* joint */} operator here.`, 4 /* warning */),
        /** */
        IgnoredAnnotation: createFault(207, `This annotation is ignored because another annotation
			in this statement resolves to the same type.`),
        /** */
        IgnoredAlias: createFault(209, `Aliases (meaning annotations that are matched by patterns)
			can't be added onto types that have a contract put in place
			by a base type.`),
        /** */
        TypeSelfReferential: createFault(211, "Types cannot be self-referential"),
        //# List-related faults
        /** */
        AnonymousInListIntrinsic: createFault(300, "Types contained directly by List-intrinsic types cannot be anonymous.", 4 /* warning */),
        /** */
        ListContractViolation: createFault(301, "The containing list cannot contain children of this type.", 4 /* warning */),
        /** */
        ListIntrinsicExtendingList: createFault(303, "List intrinsic types cannot extend from other lists."),
        /** (This is the same thing as a list dimensionality conflict) */
        ListExtrinsicExtendingNonList: createFault(305, "Lists cannot extend from non-lists."),
        /** */
        ListDimensionalDiscrepancyFault: createFault(307, `A union cannot be created between these two types
			because they are lists of different dimensions.`),
        /** */
        ListAnnotationConflict: createFault(309, `All fragments of this annotation need to have
			a list operator (${"..." /* list */})`),
        //# Pattern-related faults
        /** */
        PatternInvalid: createFault(400, "Invalid pattern."),
        /** */
        PatternWithoutAnnotation: createFault(402, "Pattern has no annotations.", 4 /* warning */),
        /** */
        PatternCanMatchEmpty: createFault(404, "Patterns must not be able to match an empty input."),
        /** */
        PatternMatchingTypesAlreadyExists: createFault(406, `A pattern matching these types has 
			already been defined in this scope.`),
        /** */
        PatternMatchingList: createFault(407, "A pattern cannot match a list type."),
        /** */
        PatternCanMatchWhitespaceOnly: createFault(420, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternAcceptsLeadingWhitespace: createFault(422, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternRequiresLeadingWhitespace: createFault(424, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternAcceptsTrailingWhitespace: createFault(426, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternRequiresTrailingWhitespace: createFault(428, "Patterns must not be able to match an input " +
            "containing only whitespace characters."),
        /** */
        PatternNonCovariant: createFault(440, "Pattern does not match it's base types."),
        /** */
        PatternPartialWithCombinator: createFault(442, "Partial patterns cannot explicitly match the comma character."),
        /** */
        PatternsFormDiscrepantUnion: createFault(499, "A union cannot be created between these types because their " +
            "associated patterns conflict with each other."),
        //# Infix related
        /** */
        InfixHasQuantifier: createFault(
        ///0,
        500, `Infixes cannot have quantifiers ${quantifiers} applied to them`),
        /** */
        InfixHasDuplicateIdentifier: createFault(
        ///0,
        501, "Infixes cannot have duplicate identifiers."),
        /** */
        InfixHasSelfReferentialType: createFault(
        ///410,
        503, "Infixes cannot be self-referential."),
        /** */
        InfixNonConvariant: createFault(
        ///412,
        505, "Infixes must be compatible with their bases."),
        /** */
        InfixCannotDefineNewTypes: createFault(
        ///422,
        507, `A type referenced in an infix must be contained
			by the pattern statement directly, or be contained
			by one of it's matched bases.`),
        /** */
        InfixReferencedTypeMustHavePattern: createFault(
        ///414,
        509, "Types applied to an infix must have at least one associated pattern."),
        /** */
        InfixReferencedTypeCannotBeRecursive: createFault(
        ///416,
        511, "Types applied to an infix must not create a recursive structure."),
        /** */
        InfixContractViolation: createFault(
        ///424,
        513, "Infix type annotations must explicitly expand the type as defined by the base."),
        /** */
        InfixPopulationChaining: createFault(
        ///426,
        515, "Population infixes cannot have multiple declarations."),
        /** */
        InfixUsingListOperator: createFault(
        ///0,
        517, `Infix identifiers cannot end with the list operator (${"..." /* list */}).`),
        /** */
        InfixReferencingList: createFault(
        ///428,
        519, "Infixes cannot reference list types."),
        /** */
        PortabilityInfixHasMultipleDefinitions: createFault(
        ///418,
        521, `Portability infixes with compatible types cannot
			be specified more than once.`),
        /** */
        PortabilityInfixHasUnion: createFault(
        ///418,
        523, "Portability infixes with unioned types are not supported at this time."),
        /** */
        PopulationInfixHasMultipleDefinitions: createFault(
        ///0,
        525, `Declarations in a population infix cannot be 
			defined twice in the same pattern`),
        /** */
        NominalInfixMustSubtype: createFault(
        ///430,
        527, "Patterns with nominal infixes require an input that is " +
            "a subtype of the type specified, not the type itself."),
        //# Parse errors
        /** */
        StatementBeginsWithComma: createFault(600, "Statements cannot begin with a comma."),
        /** */
        StatementBeginsWithEllipsis: createFault(602, "Statements cannot begin with an ellipsis (...)."),
        /** */
        StatementBeginsWithEscapedSpace: createFault(604, "Statements cannot begin with an escape character (\\) " +
            "that is followed by a tab or space."),
        /** */
        StatementContainsOnlyEscapeCharacter: createFault(606, "A statement cannot consist of a single escape character (\\)"),
        /** */
        StatementBeginsWithInvalidSequence: createFault(608, "A statement cannot begin with the sequences: /*, /+, or /?"),
        //# Parsing Faults
        /** */
        TabsAndSpaces: createFault(1000, "Statement indent contains a mixture of tabs and spaces.", 4 /* warning */),
        /** */
        DuplicateDeclaration: createFault(1001, "Duplicated declaration."),
        /** */
        UnterminatedCharacterSet: createFault(1002, `Unterminated character set. Pattern has an opening
			"${"[" /* setStart */}" character without a matching
			"${"]" /* setEnd */}" character.`),
        /** */
        UnterminatedGroup: createFault(1004, `Unterminated group. Pattern has an opening
			"${"(" /* groupStart */}" character without a matching
			"${")" /* groupEnd */}" character.`),
        /** */
        DuplicateQuantifier: createFault(1006, `Multiple consecutive quantifiers ${quantifiers} are not allowed.`),
        /** */
        UnterminatedInfix: createFault(1008, `Unterminated infix. Pattern has an opening ${"<" /* start */},
			${"<<" /* nominalStart */}, ${"</" /* patternStart */} delimiter without
			a matching closing delimiter.`),
        /** */
        EmptyPattern: createFault(1010, "Pattern has no matchable content.")
    });
    // Additional safety
    Array.from(Truth.Faults.each()).every(Object.freeze);
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Infinite incremental counter.
     */
    class VersionStamp {
        /** */
        constructor(stamp) {
            this.stamp = stamp;
        }
        /** */
        static next() {
            const createStamp = (stamp) => new VersionStamp(Object.freeze(stamp));
            if (typeof BigInt !== "undefined") {
                if (this.nextStamp === undefined)
                    return createStamp(this.nextStamp = BigInt(1));
                // See: https://github.com/eslint/eslint/issues/10574
                // eslint-disable-next-line valid-typeof
                if (typeof this.nextStamp === "bigint")
                    return createStamp(++this.nextStamp);
            }
            else {
                if (this.nextStamp === undefined) {
                    this.nextStamp = [1];
                    return createStamp(this.nextStamp.slice());
                }
                const ns = this.nextStamp;
                if (Array.isArray(ns)) {
                    // Polyfill infinite number counter for use in the 
                    // absence of a native BigInt implementation.
                    for (let i = ns.length; i-- > 0;) {
                        if (ns[i] === 999999999999) {
                            ns[i] = 0;
                            if (i === 0)
                                ns.unshift(1);
                        }
                        else {
                            ns[i]++;
                            break;
                        }
                    }
                    return createStamp(ns.slice());
                }
            }
            throw Truth.Exception.unknownState();
        }
        /** */
        newerThan(otherStamp) {
            return this.stamp > otherStamp.stamp;
        }
        /** */
        toString() {
            return Array.isArray(this.stamp) ?
                this.stamp.join("") :
                this.stamp.toString();
        }
    }
    Truth.VersionStamp = VersionStamp;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class AlphabetRange {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
    }
    Truth.AlphabetRange = AlphabetRange;
    /**
     * @internal
     */
    class Alphabet {
        /** */
        constructor(...ranges) {
            /** */
            this.ranges = [];
            this.ranges = ranges;
        }
        /**
         * Iterates through each character defined in the alphabet.
         */
        *[Symbol.iterator]() {
            for (const range of this.ranges)
                for (let i = range.from; i <= range.to; i++)
                    yield String.fromCodePoint(i);
        }
        /**
         * Iterates through all defined ranges in the alphabet,
         * excluding the wildcard range.
         */
        *eachRange() {
            if (this.hasWildcard()) {
                for (let rangeIdx = 0; rangeIdx < this.ranges.length - 1;)
                    yield this.ranges[rangeIdx++];
            }
            else
                for (const range of this.ranges)
                    yield range;
        }
        /** */
        has(symbol) {
            if (symbol === Alphabet.wildcard)
                return this.hasWildcard();
            const code = toCharCode(symbol);
            for (const range of this.ranges)
                if (range.from >= code && range.to <= code)
                    return true;
            return false;
        }
        /** */
        hasWildcard() {
            const rng = this.ranges;
            return rng.length > 0 && rng[rng.length - 1] === Alphabet.wildcardRange;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const symbols = [];
            for (const range of this.ranges)
                symbols.push(range.from === range.to ?
                    String.fromCodePoint(range.from) :
                    String.fromCodePoint(range.from) + " - " + String.fromCodePoint(range.to));
            if (this.hasWildcard())
                symbols.push(Alphabet.wildcard);
            return "[" + symbols.join(", ") + "]";
        }
    }
    /**
     * Stores a special token that the system understands to be the
     * wildcard character. The length of the token is longer than any
     * other token that could otherwise be found in the alphabet.
     */
    Alphabet.wildcard = "((wild))";
    /**
     * Stores a range that represents the wildcard character.
     * The range of the wildcard is positive infinity in both directions,
     * to ensure that it's always sorted last in the ranges array.
     */
    Alphabet.wildcardRange = Object.freeze(new AlphabetRange(Infinity, Infinity));
    Truth.Alphabet = Alphabet;
    /**
     * @internal
     * A disposable class for easily creating Alphabet instances
     * (This design avoids introducing mutability into the Alphabet class).
     */
    class AlphabetBuilder {
        /** */
        constructor(...others) {
            /** */
            this.ranges = [];
            for (const item of others) {
                if (item instanceof Alphabet) {
                    const theRanges = Array.from(item.eachRange());
                    for (const range of theRanges)
                        this.ranges.push(range);
                }
                else if (item instanceof AlphabetRange) {
                    this.ranges.push(item);
                }
                else {
                    const code = toCharCode(item);
                    this.ranges.push(new AlphabetRange(code, code));
                }
            }
        }
        /**
         * Adds an entry to the alphabet.
         * If the second parameter is omitted, the entry refers to a
         * single character, rather than a range of characters.
         */
        add(from, to) {
            const toAsNum = to === undefined ? from : to;
            this.ranges.push(new AlphabetRange(toCharCode(from), toCharCode(toAsNum)));
            return this;
        }
        /** */
        addWild() {
            this.ranges.push(Alphabet.wildcardRange);
            return this;
        }
        /**
         * @returns An optimized Alphabet instances composed
         * from the characters and ranges applied to this AlphabetBuilder.
         *
         * @param invert In true, causes the entries in the generated
         * Alphabet to be reversed, such that every character marked
         * as included is excluded, and vice versa.
         */
        toAlphabet(invert) {
            if (this.ranges.length === 0)
                return new Alphabet();
            const ranges = this.ranges
                .slice()
                .sort((a, b) => a.from - b.from);
            // Quick optimization of ranges
            for (let i = 0; i < ranges.length - 1; i++) {
                const thisRange = ranges[i];
                while (i < ranges.length - 1) {
                    const nextRange = ranges[i + 1];
                    // Omit
                    if (thisRange.to >= nextRange.to) {
                        ranges.splice(i + 1, 1);
                    }
                    // Concat
                    else if (thisRange.to + 1 >= nextRange.from) {
                        ranges.splice(i + 1, 1);
                        ranges[i] = new AlphabetRange(thisRange.from, nextRange.to);
                    }
                    // Next
                    else
                        break;
                }
            }
            if (invert) {
                //
                // This alphabet inversion algorithm has to deal with 4 cases,
                // depending on the pattern of the ranges and the spaces.
                // After the ranges are sorted and optimized, the ranges
                // array represents a layout that alternates between ranges
                // and spaces. There are 4 basic layouts (R = Range, S = Space):
                //
                // RSRS - Starts with a range, ends with a space
                // SRSR - Starts with a space, ends with a range
                // RSRSR - Starts with a range, ends with a range
                // SRSRS - Starts with a space, ends with a space
                // 
                // The algorithm deal with any leading or trailing space
                // separately, to make the looping less complicated. 
                // 
                const rangesInv = [];
                const lastRange = ranges[ranges.length - 1];
                const matchesZero = ranges[0].from === 0;
                const matchesMax = lastRange.to === Truth.UnicodeMax;
                if (matchesZero && matchesMax && ranges.length === 1)
                    return new Alphabet();
                if (!matchesZero)
                    rangesInv.push(new AlphabetRange(0, ranges[0].from));
                const endAt = matchesMax ?
                    lastRange.from :
                    Truth.UnicodeMax;
                for (let i = 0; i < ranges.length; i++) {
                    const prevRangeEnd = ranges[i].to;
                    const nextRangeStart = i < ranges.length - 1 ?
                        ranges[i + 1].from :
                        Truth.UnicodeMax + 1;
                    rangesInv.push(new AlphabetRange(prevRangeEnd + 1, nextRangeStart - 1));
                    if (nextRangeStart >= endAt)
                        break;
                }
                if (!matchesMax)
                    rangesInv.push(new AlphabetRange(lastRange.from, Truth.UnicodeMax));
            }
            return new Alphabet(...ranges);
        }
    }
    Truth.AlphabetBuilder = AlphabetBuilder;
    /** */
    function toCharCode(symbol) {
        return typeof symbol === "string" ?
            symbol.charCodeAt(0) :
            symbol;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TransitionMap {
        /** */
        constructor(transitionLiteral) {
            const transitions = new Map();
            if (transitionLiteral) {
                for (const [stateIdText, tslObject] of Object.entries(transitionLiteral)) {
                    const stateId = parseInt(stateIdText, 10);
                    if (stateId !== stateId)
                        throw new TypeError();
                    if (!tslObject || typeof tslObject !== "object")
                        throw new TypeError();
                    const tsl = tslObject;
                    transitions.set(stateId, new Truth.TransitionState(tsl));
                }
            }
            this.transitions = transitions;
        }
        /** */
        *[Symbol.iterator]() {
            for (const [stateId, transitionState] of this.transitions.entries())
                yield [stateId, transitionState];
        }
        /** */
        clone() {
            const out = new TransitionMap({});
            for (const [key, value] of this.transitions)
                out.transitions.set(key, value.clone());
            return out;
        }
        /** */
        has(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                return false;
            if (symbol === undefined)
                return !!transitionState;
            return transitionState.has(symbol);
        }
        get(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                return undefined;
            if (symbol === undefined)
                return transitionState;
            return transitionState.get(symbol);
        }
        acquire(stateId, symbol) {
            const transitionState = this.transitions.get(stateId);
            if (!transitionState)
                throw new Error();
            if (symbol === undefined)
                return transitionState;
            const subStateId = transitionState.get(symbol);
            if (subStateId === undefined)
                throw new Error();
            return subStateId;
        }
        /** */
        *eachStateId() {
            for (const stateId of this.transitions.keys())
                yield stateId;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const out = ["{"];
            for (const [stateId, tState] of this.transitions)
                out.push("\t" + stateId + ": " + tState.toString());
            out.push("}");
            return out.join("\n");
        }
    }
    Truth.TransitionMap = TransitionMap;
    /**
     * @internal
     */
    class MutableTransitionMap extends TransitionMap {
        /** */
        initialize(srcStateId) {
            this.transitions.set(srcStateId, new Truth.TransitionState());
        }
        /** */
        set(srcStateId, symbol, dstStateId) {
            const tState = this.transitions.get(srcStateId);
            if (!tState) {
                const tState = new Truth.TransitionState();
                tState.set(symbol, dstStateId);
                this.transitions.set(srcStateId, tState);
            }
            else {
                tState.set(symbol, dstStateId);
            }
        }
    }
    Truth.MutableTransitionMap = MutableTransitionMap;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TransitionState {
        /** */
        constructor(source) {
            this.stateMap = new Map();
            if (source)
                for (const [symbol, stateId] of Object.entries(source))
                    this.stateMap.set(symbol, stateId);
        }
        /** */
        clone() {
            const cloned = new TransitionState();
            for (const [symbol, stateId] of this.stateMap)
                cloned.stateMap.set(symbol, stateId);
            return cloned;
        }
        /** */
        has(symbol) {
            return this.stateMap.has(symbol);
        }
        /** */
        get(symbol) {
            return this.stateMap.get(symbol);
        }
        /** */
        set(symbol, stateId) {
            this.stateMap.set(symbol, stateId);
        }
        /** */
        *eachSymbol() {
            for (const symbol of this.stateMap.keys())
                yield symbol;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            const out = [];
            for (const [symbol, stateId] of this.stateMap)
                out.push("{ " + symbol + ": " + stateId + " }");
            return out.length ? out.join(", ") : "{}";
        }
    }
    Truth.TransitionState = TransitionState;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class Guide {
        /** */
        constructor(from) {
            /** */
            this.hasDst = null;
            /** */
            this.isFrozen = false;
            /** */
            this.arrows = new Map();
            if (from instanceof Guide) {
                this.hasDst = from.hasDst;
                for (const [stateIdSrc, stateIdDst] of from.arrows)
                    this.arrows.set(stateIdSrc, stateIdDst);
            }
            else if (typeof from === "number") {
                this.add(from);
            }
            else if (from) {
                for (const [stateIdSrc, stateIdDst] of from)
                    this.arrows.set(stateIdSrc, stateIdDst);
            }
        }
        /** */
        clone() {
            const cloned = new Guide();
            for (const [stateIdSrc, stateIdDst] of this.arrows)
                cloned.arrows.set(stateIdSrc, stateIdDst);
            return cloned;
        }
        /** */
        has(stateIdSrc) {
            return this.arrows.has(stateIdSrc);
        }
        /** */
        get(stateIdSrc) {
            return this.arrows.get(stateIdSrc);
        }
        /** */
        add(stateIdSrc, stateIdDst = null) {
            if (this.isFrozen)
                throw new TypeError();
            if (this.hasDst === null) {
                this.arrows.set(stateIdSrc, stateIdDst);
            }
            else {
                if (stateIdDst !== stateIdDst)
                    throw new TypeError();
                if (this.hasDst === true && typeof stateIdDst !== "number" ||
                    this.hasDst === false && typeof stateIdDst === "number")
                    throw new Error("Parameters need to be kept consistent across the instance.");
                this.arrows.set(stateIdSrc, stateIdDst);
            }
            this.hasDst = stateIdDst !== null;
        }
        /** */
        append(other) {
            if (this.isFrozen)
                throw new TypeError();
            if (this.hasDst === null) {
                for (const [src, dst] of other.arrows) {
                    this.hasDst = typeof dst === "number";
                    this.arrows.set(src, dst);
                }
            }
            else if (other.hasDst === null) {
                if (other.size !== 0)
                    throw Truth.Exception.unknownState();
            }
            else {
                for (const [src, dst] of other.arrows)
                    this.arrows.set(src, dst);
            }
        }
        /** */
        first() {
            const out = this.arrows.get(0);
            if (out === null || out === undefined)
                throw new Error();
            return out;
        }
        /** */
        *keys() {
            for (const src of this.arrows.keys())
                yield src;
        }
        /** */
        *values() {
            if (this.hasDst === true)
                for (const dst of this.arrows.values())
                    yield Truth.Not.null(dst);
        }
        /** */
        *entries() {
            if (this.hasDst === false)
                throw new Error("Cannot enumerate the full entries of this instance.");
            for (const [stateIdSrc, stateIdDst] of this.arrows)
                yield [stateIdSrc, Truth.Not.null(stateIdDst)];
        }
        /** */
        get size() { return this.arrows.size; }
        /**
         * @returns A boolean value that indicates whether the contents
         * of this guide match the contents of the guide specified in the
         * parameter.
         */
        equals(other) {
            if (this.size !== other.size)
                return false;
            for (const [src, dst] of this.arrows)
                if (other.arrows.get(src) !== dst)
                    return false;
            return true;
        }
        /** */
        freeze() {
            this.isFrozen = true;
            return this;
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            if (this.hasDst) {
                const literal = [];
                for (const [stateIdSrc, stateIdDst] of this.arrows)
                    literal.push(stateIdSrc + ": " + stateIdDst);
                return "{ " + literal.join(", ") + " }";
            }
            return "[" + Array.from(this.arrows.keys()).join(", ") + "]";
        }
    }
    Truth.Guide = Guide;
})(Truth || (Truth = {}));
/**
 * This code is a TypeScript conversion of a portion of the the Python
 * project "greenery", from GitHub user "qntm".
 *
 * The greenery project can be found here:
 * https://github.com/qntm/greenery
 *
 * Specifically, the code from where this code drew inspiration is:
 * https://github.com/qntm/greenery/blob/master/greenery/fsm.py
 *
 * Possibly relevant blog post:
 * https://qntm.org/algo
 *
 * The original MIT license from greenery is as follows:
 *
 * Copyright (C) 2012 to 2017 by qntm
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Truth;
/**
 * This code is a TypeScript conversion of a portion of the the Python
 * project "greenery", from GitHub user "qntm".
 *
 * The greenery project can be found here:
 * https://github.com/qntm/greenery
 *
 * Specifically, the code from where this code drew inspiration is:
 * https://github.com/qntm/greenery/blob/master/greenery/fsm.py
 *
 * Possibly relevant blog post:
 * https://qntm.org/algo
 *
 * The original MIT license from greenery is as follows:
 *
 * Copyright (C) 2012 to 2017 by qntm
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function (Truth) {
    /**
     * Oblivion is a Symbol object that is returned while calling crawl() if the Fsm
     * is transitioned to the oblivion state. For example while crawling two Fsms
     * in parallel we may transition to the oblivion state of both Fsms at once.
     * This warrants an out-of-bound signal which will reduce the complexity of
     * the new Fsm's map.
     */
    const Oblivion = Symbol();
    /**
     * @internal
     * A Finite State Machine or Fsm has an alphabet and a set of states. At any
     * given moment, the Fsm is in one state. When passed a symbol from the
     * alphabet, the Fsm jumps to another state (or possibly the same state).
     * A TransitionMap indicates where to jump. One state is nominated as the
     * initial state. Zero or more states are nominated as final states. If, after
     * consuming a string of symbols, the Fsm is in a final state, then it is said
     * to "accept" the string.
     */
    class Fsm {
        /** */
        constructor(
        /**
         * An iterable of symbols the Fsm can be fed.
         */
        alphabet, 
        /**
         * The set of possible states for the Fsm.
         */
        states, 
        /**
         * The initial state of the Fsm.
         */
        initial, 
        /**
         * The set of states that the Fsm accepts.
         */
        finals, 
        /**
         * May be sparse (i.e. it may omit transitions).
         * In the case of omitted transitions, a non-final
         * "oblivion" state is simulated.
         */
        transitions) {
            this.alphabet = alphabet;
            this.states = states;
            this.initial = initial;
            this.finals = finals;
            this.transitions = transitions;
        }
        /**
         * @returns A new Fsm instance that accept
         * no inputs, not even an empty string.
         */
        static empty(alphabet) {
            const tsl = {};
            for (const symbol of alphabet)
                tsl[symbol] = 0;
            return new Fsm(alphabet, new Set([0]), 0, new Set(), new Truth.TransitionMap({ 0: tsl }));
        }
        /**
         * @returns An Fsm that matches only an empty string.
         */
        static epsilon(alphabet) {
            return new Fsm(alphabet, new Set([0]), 0, new Set([0]), new Truth.TransitionMap());
        }
        /**
         * @returns A boolean value that indicates whether the present Fsm
         * accepts the supplied array of symbols. Equivalently, consider this
         * Fsm instance as a possibly-infinite set of strings and test whether
         * the input is a member of it.
         *
         * If the wildcard character is present in the specified alphabet, then
         * any symbol not in the specified alphabet will be assumed to be
         * wildcard.
         */
        accepts(input) {
            const thisHasWild = this.alphabet.hasWildcard();
            let stateId = this.initial;
            for (const char of input) {
                const symbol = thisHasWild && !this.alphabet.has(char) ?
                    Truth.Alphabet.wildcard :
                    char;
                // Missing transition = transition to dead state
                if (!this.transitions.has(stateId, symbol))
                    return false;
                const newStateId = this.transitions.get(stateId, symbol);
                if (newStateId === undefined)
                    throw new ReferenceError();
                stateId = newStateId;
            }
            return this.finals.has(stateId);
        }
        /**
         * @returns A reduced version of the Fsm, down to a minimal finite
         * state machine equivalent.
         *
         * (A result by Brzozowski (1963) shows that a minimal finite state
         * machine equivalent to the original can be obtained by reversing
         * the original twice.)
         */
        reduce() {
            return this.reverse().reverse();
        }
        /**
         * @returns A new Fsm instance that represents the concatenation
         * of the specified series of finite state machines.
         */
        concatenate(...fsms) {
            if (fsms.length === 0)
                throw new RangeError();
            if (fsms.length === 1)
                return fsms[0];
            /**
             * Take a state in the numbered Fsm and return a set containing it,
             * plus (if it's final) the first state from the next Fsm,
             * plus (if that's final) the first state from the next but one Fsm,
             * plus...
             */
            const connectAll = (idx, substateId) => {
                const result = new Truth.Guide();
                result.add(idx, substateId);
                let i = idx;
                let id = substateId;
                while (i < fsms.length - 1 && fsms[i].finals.has(id)) {
                    i++;
                    id = fsms[i].initial;
                    result.add(i, id);
                }
                return result;
            };
            /**
             * Use a superset containing states from all Fsms at once.
             * We start at the start of the first Fsm. If this state is final in the
             * first Fsm, then we are also at the start of the second Fsm. And so on.
             */
            const initial = new Truth.Guide();
            if (fsms.length > 0)
                initial.append(connectAll(0, fsms[0].initial));
            /**
             * If you're in a final state of the final Fsm, it's final.
             */
            const finalFn = (guide) => {
                for (const [i, substateId] of guide.entries())
                    if (i === fsms.length - 1 && fsms[i].finals.has(substateId))
                        return true;
                return false;
            };
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const [i, substateId] of guide.entries()) {
                    const fsm = fsms[i];
                    if (fsm.transitions.has(substateId, symbol)) {
                        const storedValue = fsm.transitions.acquire(substateId, symbol);
                        next.append(connectAll(i, storedValue));
                    }
                }
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            const alphabets = fsms.map(fsm => fsm.alphabet);
            const alphabet = new Truth.AlphabetBuilder(...alphabets).toAlphabet();
            return crawl(alphabet, initial, finalFn, followFn);
        }
        /**
         * Concatenate two finite state machines together.
         * For example, if this accepts "0*" and other accepts "1+(0|1)",
         * will return a finite state machine accepting "0*1+(0|1)".
         * Accomplished by effectively following non-deterministically.
         */
        add(other) {
            return this.concatenate(this, other);
        }
        /**
         * If the present Fsm accepts X, returns an Fsm accepting X*
         * (i.e. 0 or more instances of X). Note that this is not as simple
         * as naively connecting the final states back to the initial state:
         * see (b*ab)* for example.
         */
        star() {
            const initial = new Truth.Guide(this.initial);
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const substateId of guide.keys()) {
                    if (this.transitions.has(substateId, symbol))
                        next.add(this.transitions.acquire(substateId, symbol));
                    // If one of our substates is final, then we can also consider
                    // transitions from the initial state of the original Fsm.
                    if (this.finals.has(substateId) && this.transitions.has(this.initial, symbol))
                        next.add(this.transitions.acquire(this.initial, symbol));
                }
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            /** */
            const finalFn = (guide) => {
                for (const substateId of guide.keys())
                    if (this.finals.has(substateId))
                        return true;
                return false;
            };
            return crawl(this.alphabet, initial, finalFn, followFn).or(Fsm.epsilon(this.alphabet));
        }
        /**
         * Given an Fsm and a multiplication factor, return the multiplied Fsm.
         */
        multiply(factor) {
            if (factor < 0)
                throw new RangeError();
            const initial = new Truth.Guide([[this.initial, 0]]);
            /** */
            const finalFn = (guide) => {
                for (const [substateId, iteration] of guide.entries())
                    if (this.initial === substateId)
                        if (this.finals.has(this.initial) || iteration === factor)
                            return true;
                return false;
            };
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const [substateId, iteration] of guide.entries()) {
                    if (iteration < factor && this.transitions.has(substateId, symbol)) {
                        const num = this.transitions.acquire(substateId, symbol);
                        next.add(num, iteration);
                        if (this.finals.has(num))
                            next.add(this.initial, iteration + 1);
                    }
                }
                if (next.size === 0)
                    return Oblivion;
                return next;
            };
            return crawl(this.alphabet, initial, finalFn, followFn).reduce();
        }
        /**
         * @returns A new Fsm object that presents the union of
         * all supplied Fsm instances.
         */
        union(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.some(val => val));
        }
        /**
         * Performs logical alternation between this Fsm, and the Fsm
         * instance supplied in the argument.
         *
         * @returns A finite state machine which accepts any sequence of
         * symbols that is accepted by either self or other. Note that the set
         * of strings recognised by the two Fsms undergoes a set union.
         */
        or(other) {
            return this.union(other);
        }
        /**
         * @returns A new Fsm object that represents the
         * intersection of all supplied Fsm instances.
         */
        intersection(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.every(val => val));
        }
        /**
         * Treat the Fsms as sets of strings and return the
         * intersection of those sets in the form of a new Fsm.
         */
        and(other) {
            return this.intersection(other);
        }
        /**
         * @returns A new Fsm object that represents the computed
         * symmetric difference of all suppled Fsm instances.
         */
        symmetricDifference(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts.filter(val => val).length % 2 === 1);
        }
        /**
         * @returns A new Fsm instances that recognises only the strings
         * recognised by this Fsm, or the Fsm instance supplied in the
         * other argument, but not both.
         */
        xor(other) {
            return this.symmetricDifference(other);
        }
        /**
         * @returns A new Fsm instance that recogizes all inputs that
         * would not be accepted by this Fsm.
         */
        not() {
            const initial = new Truth.Guide([[0, this.initial]]);
            /** */
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                const first = guide.first();
                if (first !== undefined)
                    if (this.transitions.has(first, symbol))
                        next.add(0, this.transitions.get(first, symbol));
                return next;
            };
            /** */
            const finalFn = (guide) => {
                const first = guide.first();
                return !(first !== undefined && this.finals.has(first));
            };
            return crawl(this.alphabet, initial, finalFn, followFn);
        }
        /**
         * @returns A new Fsm such that for every input that the supplied
         * Fsm accepts, the new Fsm accepts the same input, but reversed.
         */
        reverse() {
            // Start from a composite "state-set" consisting of all final states.
            // If there are no final states, this set is empty and we'll find that
            // no other states get generated.
            const initial = new Truth.Guide();
            for (const stateId of this.finals)
                initial.add(stateId);
            // Find every possible way to reach the current state-set
            // using this symbol.
            const followFn = (guide, symbol) => {
                const next = new Truth.Guide();
                for (const prevStateId of this.transitions.eachStateId())
                    for (const stateId of guide.keys())
                        if (this.transitions.has(prevStateId, symbol))
                            if (this.transitions.get(prevStateId, symbol) === stateId)
                                next.add(prevStateId);
                return next.size === 0 ?
                    Oblivion :
                    next;
            };
            /** */
            const finalFn = (guide) => guide.has(this.initial);
            return crawl(this.alphabet, initial, finalFn, followFn);
        }
        /**
         * @returns A boolean value indicating whether this Fsm instance
         * accepts the same set of inputs as the Fsm instance specified
         * in the argument.
         */
        equivalent(other) {
            return this.xor(other).isEmpty();
        }
        /**
         * @returns A boolean value indicating whether this Fsm instance
         * does not accept the same set of inputs as the Fsm instance
         * specified in the argument.
         */
        unequivalent(other) {
            return !this.xor(other).isEmpty();
        }
        /**
         * @returns An Fsm instance which recognises only the inputs
         * recognised by the first Fsm instance in the list, but none of
         * the others.
         */
        difference(...fsms) {
            return crawlParallel(prependFsm(this, fsms), accepts => accepts[0] && accepts.slice(1).every(accepts => !accepts));
        }
        /**
         * @returns A boolean value that indicates whether a final state
         * can be reached from the specified state.
         */
        isStateLive(stateId) {
            const reachable = [stateId];
            for (let i = -1; ++i < reachable.length;) {
                const currentStateId = reachable[i];
                if (this.finals.has(currentStateId))
                    return true;
                if (this.transitions.has(currentStateId)) {
                    const transitionState = this.transitions.acquire(currentStateId);
                    for (const symbol of transitionState.eachSymbol()) {
                        const next = this.transitions.acquire(currentStateId, symbol);
                        if (!reachable.includes(next))
                            reachable.push(next);
                    }
                }
            }
            return false;
        }
        /**
         * An Fsm is empty if it recognises no strings. An Fsm may be arbitrarily
         * complicated and have arbitrarily many final states while still recognising
         * no strings because those final states may all be inaccessible from the
         * initial state. Equally, an Fsm may be non-empty despite having an empty
         * alphabet if the initial state is final.
         */
        isEmpty() {
            return !this.isStateLive(this.initial);
        }
        /**
         * Generate strings (lists of symbols) that this Fsm accepts. Since there may
         * be infinitely many of these we use a generator instead of constructing a
         * static list. Strings will be sorted in order of length and then lexically.
         * This procedure uses arbitrary amounts of memory but is very fast. There
         * may be more efficient ways to do this, that I haven't investigated yet.
         * You can use this in list comprehensions.
         */
        *eachString() {
            "Not implemented";
            debugger;
            yield "";
        }
        /**
         * @returns A boolean value that indicates whether the act of merging
         * this Fsm instance with the Fsm instance supplied in the argument
         * would result in an Fsm instance that accepts no inputs.
         */
        isDiscrepant(other) {
            return this.and(other).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a subset of the inputs accepted by
         * other Fsm instance specified.
         */
        isSubset(other) {
            return this.difference(other).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a proper subset of the inputs
         * accepted by other Fsm instance specified.
         */
        isProperSubset(other) {
            return this.difference(other).isEmpty() && this.unequivalent(other);
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a superset of the inputs accepted
         * by other Fsm instance specified.
         */
        isSuperset(other) {
            return other.difference(this).isEmpty();
        }
        /**
         * @returns A boolean value that indicates whether the set of inputs
         * accepted by this Fsm instance is a proper superset of the inputs
         * accepted by other Fsm instance specified.
         */
        isProperSuperset(other) {
            return other.difference(this).isEmpty() && other.unequivalent(this);
        }
        /**
         * Compute the Brzozowski derivative of this Fsm with respect to the input
         * string of symbols. <https://en.wikipedia.org/wiki/Brzozowski_derivative>
         * If any of the symbols are not members of the alphabet, that's a KeyError.
         * If you fall into oblivion, then the derivative is an Fsm accepting no
         * strings.
         *
         * @returns A new Fsm instance with the computed characteristics.
         */
        derive(input) {
            let stateId = this.initial;
            for (const char of input) {
                const symbol = (() => {
                    if (this.alphabet.has(char)) {
                        if (!this.alphabet.hasWildcard)
                            throw new Error(char);
                        return Truth.Alphabet.wildcard;
                    }
                    return char;
                })();
                if (!this.transitions.has(stateId, symbol))
                    return Oblivion;
                stateId = this.transitions.acquire(stateId, symbol);
            }
            return new Fsm(this.alphabet, this.states, stateId, this.finals, this.transitions.clone());
        }
        /**
         * @returns A string representation of this object,
         * for testing and debugging purposes.
         */
        toString() {
            return [
                "alphabet = " + this.alphabet.toString(),
                "states = " + Array.from(this.states).join(),
                "inital = " + this.initial,
                "finals = " + Array.from(this.finals).join(),
                "transitions = " + this.transitions.toString()
            ].join("\n");
        }
    }
    Truth.Fsm = Fsm;
    /**
     * Utility function to prepend an Fsm instance to an Fsm array.
     */
    function prependFsm(fsm, fsms) {
        return [fsm].concat(...fsms);
    }
    /**
     * Crawl several Fsms in parallel, mapping the states of a larger meta-Fsm.
     * To determine whether a state in the larger Fsm is final, pass all of the
     * finality statuses (e.g. [true, false, false] to testFn.
     */
    function crawlParallel(fsms, testFn) {
        const initial = new Truth.Guide();
        for (const [index, fsm] of fsms.entries())
            initial.add(index, fsm.initial);
        /**
         * Dedicated function accepts a "superset" and returns the next "superset"
         * obtained by following this transition in the new Fsm.
         */
        const followFn = (guide, symbol) => {
            const next = new Truth.Guide();
            for (const [index, fsm] of fsms.entries()) {
                const stateId = guide.get(index);
                if (stateId === null || stateId === undefined)
                    continue;
                const substateId = fsm.transitions.get(stateId);
                if (substateId === undefined)
                    continue;
                const alpha = fsm.alphabet;
                const actualSymbol = alpha.has(symbol) && alpha.hasWildcard() ?
                    Truth.Alphabet.wildcard :
                    symbol;
                if (substateId.has(actualSymbol))
                    next.add(index, fsm.transitions.get(stateId, actualSymbol));
            }
            if (next.size === 0)
                return Oblivion;
            return next;
        };
        /**
         * Determine the "is final?" condition of each substateId, then pass it to the
         * test to determine finality of the overall Fsm.
         */
        const finalFn = (guide) => {
            const accepts = [];
            for (const [idx, fsm] of fsms.entries()) {
                const substateId = guide.get(idx);
                if (substateId !== null && substateId !== undefined)
                    accepts.push(guide.has(idx) && fsm.finals.has(substateId));
            }
            return testFn(accepts);
        };
        const alphabets = fsms.map(fsm => fsm.alphabet);
        const alphabet = new Truth.AlphabetBuilder(...alphabets).toAlphabet();
        return crawl(alphabet, initial, finalFn, followFn).reduce();
    }
    /**
     * Given the above conditions and instructions, crawl a new unknown Fsm,
     * mapping its states, final states and transitions. Return the new Fsm.
     */
    function crawl(alphabet, initial, finalFn, followFn) {
        const debugLines = [];
        const guides = [initial];
        const finals = new Set();
        const transitions = new Truth.MutableTransitionMap();
        // Iterate over a growing list
        for (const [i, guide] of guides.entries()) {
            // Add to finals
            if (finalFn(guide))
                finals.add(i);
            // Compute transitions for this state
            transitions.initialize(i);
            for (const symbol of alphabet) {
                const next = followFn(guide, symbol);
                if (next !== Oblivion) {
                    let nextIdx = guides.findIndex(guide => guide.equals(next));
                    if (nextIdx < 0) {
                        nextIdx = guides.length;
                        guides.push(next);
                    }
                    transitions.set(i, symbol, nextIdx);
                    debugLines.push(next.toString());
                }
            }
        }
        return new Fsm(alphabet, new Set(Array(guides.length).keys()), 0, finals, transitions);
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Translates Pattern instances into a corresponding Fsm.
     */
    class FsmTranslator {
        /** */
        static exec(units) {
            for (const unit of units) {
                if (unit instanceof Truth.RegexSet) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexGroup) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexGrapheme) {
                    throw Truth.Exception.notImplemented();
                }
                else if (unit instanceof Truth.RegexSign) {
                    throw Truth.Exception.notImplemented();
                }
                else
                    throw Truth.Exception.unknownState();
            }
            return null;
        }
        /** */
        static translateSet(set, alpha = null) {
        }
        /** */
        static translateGroup(group, alpha = null) {
            const builder = alpha || new Truth.AlphabetBuilder().addWild();
        }
        /** */
        static createGroupAlphabet(group) {
            const builder = new Truth.AlphabetBuilder();
            builder.addWild();
            for (const element of group.cases) {
                throw Truth.Exception.notImplemented();
            }
        }
        /** */
        static translateGrapheme(grapheme, alpha = null) {
        }
        /** */
        static translateSign(sign, alpha = null) {
        }
    }
    Truth.FsmTranslator = FsmTranslator;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Document {
        /**
         * @internal
         * Internal constructor for Document objects.
         * Document objects are created via a Program
         * object.
         */
        constructor(program, sourceUri, sourceText) {
            this._types = null;
            /**
             * Stores the complete list of the Document's statements,
             * sorted in the order that they appear in the file.
             */
            this.statements = [];
            /**
             * A state variable that stores whether an
             * edit transaction is currently underway.
             */
            this.inEdit = false;
            this._version = Truth.VersionStamp.next();
            if (sourceUri.types.length)
                throw Truth.Exception.invalidArgument();
            this.program = program;
            this._sourceUri = sourceUri;
            if (this.inEdit)
                throw Truth.Exception.doubleTransaction();
            this.statements.length = 0;
            for (const statementText of readLines(sourceText))
                this.statements.push(new Truth.Statement(this, statementText));
            program.on(Truth.CauseDocumentUriChange, data => {
                if (data.document === this) {
                    if (this.inEdit)
                        throw Truth.Exception.invalidWhileInEditTransaction();
                    this._sourceUri = data.newUri;
                }
            });
        }
        /**
         * Queries this document for the root-level types.
         *
         * @param uri The URI of the document to query. If the URI contains
         * a type path, it is factored into the search.
         *
         * @param typePath The type path within the document to search.
         *
         * @returns A fully constructed Type instance that corresponds to
         * the type at the URI specified, or null in the case when no type
         * could be found.
         */
        query(...typePath) {
            return this.program.query(this, ...typePath);
        }
        /**
         * Gets the root-level types that are defined within this document.
         */
        get types() {
            if (this._types)
                return this._types;
            return this._types = Object.freeze(this.program.query(this));
        }
        /**
         * @returns An array of Statement objects that represent
         * ancestry of the specified statement. If the specified
         * statement is not in this document, the returned value
         * is null.
         */
        getAncestry(statement) {
            const smt = this.toStatement(statement);
            // If the statement is root-level, it can't have an ancestry.
            if (smt.indent === 0)
                return [];
            const startingIndex = this.toLineNumber(statement);
            if (startingIndex < 0)
                return null;
            if (startingIndex === 0)
                return [];
            const ancestry = [smt];
            let indentToBeat = smt.indent;
            for (let idx = startingIndex; --idx > -1;) {
                const currentStatement = this.statements[idx];
                if (currentStatement.isNoop)
                    continue;
                if (currentStatement.indent < indentToBeat) {
                    ancestry.unshift(currentStatement);
                    indentToBeat = currentStatement.indent;
                }
                if (currentStatement.indent === 0)
                    break;
            }
            return ancestry.slice(0, -1);
        }
        /**
         * @returns The parent Statement object of the specified
         * Statement. If the statement is top level, a reference to
         * this document object is returned. If the statement is
         * not found in the document, or the specified statement
         * is a no-op, the returned value is null.
         */
        getParent(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return null;
            // If the statement is root-level, it can't have a parent.
            if (smt.indent === 0)
                return this;
            const startingIndex = this.toLineNumber(statement);
            if (startingIndex < 0)
                return null;
            if (startingIndex === 0)
                return this;
            const currentIndent = smt.indent;
            for (let idx = startingIndex; --idx > -1;) {
                const currentStatement = this.statements[idx];
                if (currentStatement.isNoop)
                    continue;
                if (currentStatement.indent < currentIndent)
                    return currentStatement;
            }
            // If a parent statement wasn't found, then the
            // input statement is top-level, and a reference
            // to this Document object is returned.
            return this;
        }
        /**
         * @returns The Statement that would act as the parent
         * if a statement where to be inserted at the specified
         * virtual position in the document. If an inserted
         * statement would be top-level, a reference to this
         * document object is returned.
         */
        getParentFromPosition(virtualLine, virtualOffset) {
            if (virtualLine === 0 || virtualOffset < 1 || this.statements.length === 0)
                return this;
            const line = applyBounds(virtualLine, this.statements.length);
            for (let idx = line; idx--;) {
                const currentStatement = this.statements[idx];
                if (!currentStatement.isNoop && currentStatement.indent < virtualOffset)
                    return currentStatement;
            }
            return this;
        }
        /**
         * @returns The sibling Statement objects of the
         * specified Statement. If the specified statement
         * is not found in the document, or is a no-op, the
         * returned value is null.
         */
        getSiblings(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return null;
            if (smt.indent === 0)
                return this.getChildren(null);
            const parent = this.getParent(smt);
            if (parent === null)
                return null;
            if (parent === this)
                return parent.getChildren(null);
            return this.getChildren(parent);
        }
        /**
         * @returns The child Statement objects of the specified
         * Statement. If the argument is null or omitted, the document's
         * top-level statements are returned. If the specified statement
         * is not found in the document, the returned value is null.
         */
        getChildren(statement = null) {
            const children = [];
            // Stores the indent value that causes the loop
            // to terminate when reached.
            const breakIndent = statement ? statement.indent : -1;
            let childIndent = Number.MAX_SAFE_INTEGER;
            const startIdx = statement ?
                this.getLineNumber(statement) :
                -1;
            if (startIdx >= this.statements.length)
                return [];
            for (let idx = startIdx; ++idx < this.statements.length;) {
                const currentStatement = this.statements[idx];
                if (currentStatement.isNoop)
                    continue;
                // Check if we need to back up the indentation
                // of child statements, in order to deal with bizarre
                // (but unfortunately, valid) indentation.
                if (currentStatement.indent < childIndent)
                    childIndent = currentStatement.indent;
                // If we've reached the end of a series of a
                // statement locality.
                if (currentStatement.indent <= breakIndent)
                    break;
                if (currentStatement.indent <= childIndent)
                    children.push(currentStatement);
            }
            return children;
        }
        /**
         * @returns A boolean value that indicates whether the specified
         * statement, or the statement at the specified index has any
         * descendants. If the argument is null, the returned value is a
         * boolean indicating whether this document has any non-noop
         * statements.
         */
        hasDescendants(statement) {
            if (statement === null) {
                for (let idx = -1; ++idx < this.statements.length;)
                    if (!this.statements[idx].isNoop)
                        return true;
            }
            else {
                const smt = statement instanceof Truth.Statement ?
                    statement :
                    this.statements[statement];
                if (smt.isNoop)
                    return false;
                let idx = statement instanceof Truth.Statement ?
                    this.getLineNumber(statement) :
                    statement;
                while (++idx < this.statements.length) {
                    const currentStatement = this.statements[idx];
                    if (currentStatement.isNoop)
                        continue;
                    return currentStatement.indent > smt.indent;
                }
            }
            return false;
        }
        /**
         * @returns The index of the specified statement in
         * the document, relying on caching when available.
         * If the statement does not exist in the document,
         * the returned value is -1.
         */
        getLineNumber(statement) {
            return this.statements.indexOf(statement);
        }
        /**
         * @returns An array of strings containing the content
         * written in the comments directly above the specified
         * statement. Whitespace lines are ignored. If the specified
         * statement is a no-op, an empty array is returned.
         */
        getNotes(statement) {
            const smt = this.toStatement(statement);
            if (smt.isNoop)
                return [];
            const lineNum = this.getLineNumber(smt);
            if (lineNum < 1)
                return [];
            const commentLines = [];
            const requiredIndent = smt.indent;
            for (let num = lineNum; num--;) {
                const currentStatement = this.statements[num];
                if (currentStatement.isWhitespace)
                    continue;
                const commentText = currentStatement.getCommentText();
                if (commentText === null)
                    break;
                if (currentStatement.indent !== requiredIndent)
                    break;
                commentLines.push(commentText);
            }
            return commentLines;
        }
        /**
         * Enumerates through each statement that is a descendant of the
         * specified statement. If the parameters are null or omitted, all
         * statements in this Document are yielded.
         *
         * The method yields an object that contains the yielded statement,
         * as well as a numeric level value that specifies the difference in
         * the number of nesting levels between the specified initialStatement
         * and the yielded statement.
         *
         * @param initialStatement A reference to the statement object
         * from where the enumeration should begin.
         *
         * @param includeInitial A boolean value indicating whether or
         * not the specified initialStatement should also be returned
         * as an element in the enumeration. If true, initialStatement
         * must be non-null.
         */
        *eachDescendant(initialStatement = null, includeInitial) {
            if (includeInitial) {
                if (!initialStatement)
                    throw Truth.Exception.invalidArgument();
                yield { statement: initialStatement, level: 0 };
            }
            const initialChildren = this.getChildren(initialStatement);
            const self = this;
            // The initial level is 0 if the specified initialStatement is
            // null, because it indicates that the enumeration starts
            // at the root of the document.
            let level = initialStatement ? 1 : 0;
            function* recurse(statement) {
                yield { statement, level };
                level++;
                for (const childStatement of self.getChildren(statement))
                    yield* recurse(childStatement);
                level--;
            }
            for (const statement of initialChildren)
                yield* recurse(statement);
        }
        /**
         * @deprecated
         * Enumerates through each unique URI defined in this document,
         * that are referenced within the descendants of the specified
         * statement. If the parameters are null or omitted, all unique
         * URIs referenced in this document are yielded.
         *
         * @param initialStatement A reference to the statement object
         * from where the enumeration should begin.
         *
         * @param includeInitial A boolean value indicating whether or
         * not the specified initialStatement should also be returned
         * as an element in the enumeration. If true, initialStatement
         * must be non-null.
         */
        *eachUri(initialStatement = null, includeInitial) {
            //
            // NOTE: Although this method is deprecated, if it were
            // to be revived, it would need to support "cruft".
            //
            const yieldedUris = new Set();
            const iter = this.eachDescendant(initialStatement, includeInitial);
            for (const descendant of iter) {
                for (const span of descendant.statement.declarations) {
                    for (const spine of span.factor()) {
                        const uri = Truth.Uri.clone(spine);
                        const uriText = uri.toString();
                        if (!yieldedUris.has(uriText)) {
                            yieldedUris.add(uriText);
                            yield { uri, uriText };
                        }
                    }
                }
            }
        }
        /**
         * Enumerates through each statement in the document,
         * including comments and whitespace-only lines, starting
         * at the specified statement or numeric position.
         *
         * @yields The statements in the order that they appear
         * in the document, excluding whitespace-only statements.
         */
        *eachStatement(statement) {
            const startNum = (() => {
                if (!statement)
                    return 0;
                if (statement instanceof Truth.Statement)
                    return this.getLineNumber(statement);
                return statement;
            })();
            for (let i = startNum - 1; ++i < this.statements.length;)
                yield this.statements[i];
        }
        /**
         * Reads the Statement at the given position.
         * Negative numbers read Statement starting from the end of the document.
         */
        read(lineNumber) {
            const lineBounded = applyBounds(lineNumber, this.statements.length);
            return this.statements[lineBounded];
        }
        /**
         * Convenience method that converts a statement or it's index
         * within this document to a statement object.
         */
        toStatement(statementOrIndex) {
            return statementOrIndex instanceof Truth.Statement ?
                statementOrIndex :
                this.read(statementOrIndex);
        }
        /**
         * Convenience method to quickly turn a value that may be
         * a statement or a statement index, into a bounded statement
         * index.
         */
        toLineNumber(statementOrIndex) {
            return statementOrIndex instanceof Truth.Statement ?
                this.getLineNumber(statementOrIndex) :
                applyBounds(statementOrIndex, this.statements.length);
        }
        /**
         * Starts an edit transaction in the specified callback function.
         * Edit transactions are used to synchronize changes made in
         * an underlying file, typically done by a user in a text editing
         * environment. System-initiated changes such as automated
         * fixes, refactors, or renames do not go through this pathway.
         *
         * @param editFn The callback function in which to perform
         * document mutation operations.
         */
        edit(editFn) {
            if (this.inEdit)
                throw Truth.Exception.doubleTransaction();
            class InsertCall {
                constructor(smt, at) {
                    this.smt = smt;
                    this.at = at;
                }
            }
            class UpdateCall {
                constructor(smt, at) {
                    this.smt = smt;
                    this.at = at;
                }
            }
            class DeleteCall {
                constructor(at, count) {
                    this.at = at;
                    this.count = count;
                }
            }
            const calls = [];
            let hasDelete = false;
            let hasInsert = false;
            let hasUpdate = false;
            this.inEdit = true;
            editFn({
                delete: (at = -1, count = 1) => {
                    if (count > 0) {
                        calls.push(new DeleteCall(at, count));
                        hasDelete = true;
                    }
                },
                insert: (text, at = -1) => {
                    calls.push(new InsertCall(new Truth.Statement(this, text), at));
                    hasInsert = true;
                },
                update: (text, at = -1) => {
                    const boundAt = applyBounds(at, this.statements.length);
                    if (this.read(boundAt).sourceText !== text) {
                        calls.push(new UpdateCall(new Truth.Statement(this, text), at));
                        hasUpdate = true;
                    }
                }
            });
            if (calls.length === 0) {
                this.inEdit = false;
                return;
            }
            // Begin the algorithm that determines the changeset,
            // and runs the appropriate invalidation and revalidation
            // hooks. This is wrapped in an IIFE because we need to
            // perform finalization at the bottom (and there are early
            // return points throughout the algorithm.
            (() => {
                const hasMixed = hasInsert && hasUpdate ||
                    hasInsert && hasDelete ||
                    hasUpdate && hasDelete;
                const boundAt = (call) => applyBounds(call.at, this.statements.length);
                const doDelete = (call) => {
                    const at = boundAt(call);
                    const smts = this.statements.splice(at, call.count);
                    for (const smt of smts)
                        smt.dispose();
                    return smts;
                };
                const doInsert = (call) => {
                    if (call.at >= this.statements.length) {
                        this.statements.push(call.smt);
                    }
                    else {
                        const at = boundAt(call);
                        this.statements.splice(at, 0, call.smt);
                    }
                };
                const doUpdate = (call) => {
                    const at = boundAt(call);
                    this.statements[at].dispose();
                    this.statements[at] = call.smt;
                };
                if (!hasMixed) {
                    // This handles the first optimization, which is the case where
                    // the only kinds of mutations where updates, and no structural
                    // changes occured. This handles typical "user is typing" cases.
                    // Most edits will be caught here.
                    if (hasUpdate) {
                        // Sort the update calls by their index, and prune updates
                        // that would be overridden in a following call.
                        //! Remove this unnecessary variable once we can do that
                        //! without ESLint complaining (unnecessary brackets).
                        const updateCallsTyped = calls;
                        const updateCalls = updateCallsTyped
                            .sort((a, b) => a.at - b.at)
                            .filter((call, i) => i >= calls.length - 1 || call.at !== calls[i + 1].at);
                        const oldStatements = updateCalls.map(c => this.statements[c.at]);
                        const newStatements = updateCalls.map(c => c.smt);
                        const indexes = Object.freeze(updateCalls.map(c => c.at));
                        const noStructuralChanges = oldStatements.every((oldSmt, idx) => {
                            const newSmt = newStatements[idx];
                            return oldSmt.indent === newSmt.indent ||
                                oldSmt.isNoop && newSmt.isNoop;
                        });
                        if (noStructuralChanges) {
                            const hasOpStatements = oldStatements.some(smt => !smt.isNoop) ||
                                newStatements.some(smt => !smt.isNoop);
                            if (hasOpStatements) {
                                // Tell subscribers to blow away all the old statements.
                                this.program.cause(new Truth.CauseInvalidate(this, oldStatements, indexes));
                            }
                            // Run the actual mutations
                            for (const updateCall of updateCalls)
                                doUpdate(updateCall);
                            if (hasOpStatements) {
                                // Tell subscribers what changed
                                this.program.cause(new Truth.CauseRevalidate(this, newStatements, indexes));
                            }
                            return;
                        }
                    }
                    // This handles the second optimization, which is the case where
                    // only deletes occured, and none of the deleted statements have any
                    // descendants. This will handle the majority of "delete a line" cases.
                    if (hasDelete) {
                        const deleteCalls = calls;
                        const deadStatements = [];
                        const deadIndexes = [];
                        let hasOpStatements = false;
                        forCalls: for (const deleteCall of deleteCalls) {
                            for (let i = -1; ++i < deleteCall.count;) {
                                const deadSmt = this.statements[deleteCall.at + i];
                                if (this.hasDescendants(deadSmt)) {
                                    deadStatements.length = 0;
                                    break forCalls;
                                }
                                deadStatements.push(deadSmt);
                                deadIndexes.push(i);
                                if (!deadSmt.isNoop)
                                    hasOpStatements = true;
                            }
                        }
                        if (deadStatements.length > 0) {
                            // Tell subscribers to blow away all the old statements.
                            // An edit transaction can be avoided completely in the case
                            // when the only statements that were deleted were noops.
                            if (hasOpStatements)
                                this.program.cause(new Truth.CauseInvalidate(this, deadStatements, deadIndexes));
                            // Run the actual mutations
                            deleteCalls.forEach(doDelete);
                            // Run an empty revalidation hook, to comply with the
                            // rule that for every invalidation hook, there is always a
                            // corresponding revalidation hook.
                            if (hasOpStatements)
                                this.program.cause(new Truth.CauseRevalidate(this, [], []));
                            return;
                        }
                    }
                    // This handles the third optimization, which is the case
                    // where there are only noop statements being inserted
                    // into the document.
                    if (hasInsert) {
                        const insertCalls = calls;
                        if (insertCalls.every(call => call.smt.isNoop)) {
                            insertCalls.forEach(doInsert);
                            return;
                        }
                    }
                }
                // At this point, the checks to see if we can get away with
                // performing simplistic updates have failed. So we need
                // to resort to invalidating and revalidating larger swaths 
                // of statements.
                // Stores an array of statements whose descendant statements
                // should be invalidated. 
                //const invalidatedParents: { at: number; parent: Statement; }[] = [];
                const invalidatedParents = new Map();
                // Stores a value indicating whether the entire document
                // needs to be invalidated.
                let mustInvalidateDoc = false;
                // The first step is to go through all the statements, and compute the 
                // set of parent statements from where invalidation should originate.
                // In the majority of cases, this will only be one single statement object.
                for (const call of calls) {
                    const atBounded = applyBounds(call.at, this.statements.length);
                    if (call instanceof DeleteCall) {
                        const deletedStatement = this.statements[atBounded];
                        if (deletedStatement.isNoop)
                            continue;
                        const parent = this.getParent(atBounded);
                        if (parent instanceof Truth.Statement) {
                            invalidatedParents.set(call.at, parent);
                        }
                        else if (parent instanceof Document) {
                            mustInvalidateDoc = true;
                            break;
                        }
                        else
                            throw Truth.Exception.unknownState();
                    }
                    else {
                        if (call instanceof InsertCall) {
                            if (call.smt.isNoop)
                                continue;
                        }
                        else if (call instanceof UpdateCall) {
                            const oldStatement = this.statements[atBounded];
                            if (oldStatement.isNoop && call.smt.isNoop)
                                continue;
                        }
                        const parent = this.getParentFromPosition(call.at, call.smt.indent);
                        if (parent instanceof Truth.Statement) {
                            invalidatedParents.set(call.at, parent);
                        }
                        else if (parent === this) {
                            mustInvalidateDoc = true;
                            break;
                        }
                    }
                }
                // Although unclear how this could happen, if there
                // are no invalidated parents, we can safely return.
                if (!mustInvalidateDoc && invalidatedParents.size === 0)
                    return;
                // Prune any redundant parents. A parent is redundant
                // when it's a descendant of another parent in the 
                // invalidation array. The algorithm below compares the
                // statement ancestries of each possible pairs of invalidated
                // parents, and splices invalidated parents out of the 
                // array in the case when the parent is parented by some
                // other invalidated parent in the invalidatedParents array.
                const invalidatedAncestries = [];
                for (const at of invalidatedParents.keys()) {
                    const ancestry = this.getAncestry(at);
                    if (ancestry)
                        invalidatedAncestries.push(ancestry);
                }
                if (invalidatedAncestries.length > 1) {
                    for (let i = invalidatedAncestries.length; i--;) {
                        const ancestryA = invalidatedAncestries[i];
                        for (let n = i; n--;) {
                            const ancestryB = invalidatedAncestries[n];
                            if (ancestryA.length === ancestryB.length)
                                continue;
                            const aLessB = ancestryA.length < ancestryB.length;
                            const ancestryShort = aLessB ? ancestryA : ancestryB;
                            const ancestryLong = aLessB ? ancestryB : ancestryA;
                            if (ancestryShort.every((smt, idx) => smt === ancestryLong[idx]))
                                invalidatedAncestries.splice(aLessB ? n : i, 1);
                        }
                    }
                }
                const parents = mustInvalidateDoc ? [] : Array.from(invalidatedParents.values());
                const indexes = mustInvalidateDoc ? [] : Array.from(invalidatedParents.keys());
                // Notify observers of the Invalidate hook to invalidate the
                // descendants of the specified set of parent statements.
                this.program.cause(new Truth.CauseInvalidate(this, parents, indexes));
                const deletedStatements = [];
                // Perform the document mutations.
                for (const call of calls) {
                    if (call instanceof DeleteCall)
                        deletedStatements.push(...doDelete(call));
                    else if (call instanceof InsertCall)
                        doInsert(call);
                    else if (call instanceof UpdateCall)
                        doUpdate(call);
                }
                // Remove any deleted statements from the invalidatedParents map
                for (const deletedStatement of deletedStatements)
                    for (const [at, parentStatement] of invalidatedParents)
                        if (deletedStatement === parentStatement)
                            invalidatedParents.delete(at);
                // Notify observers of the Revalidate hook to update the
                // descendants of the specified set of parent statements.
                this.program.cause(new Truth.CauseRevalidate(this, Array.from(invalidatedParents.values()), Array.from(invalidatedParents.keys())));
            })();
            // Perform a debug-time check to be sure that there are
            // no disposed statements left hanging around in the document
            // after the edit transaction has completed.
            if ("DEBUG")
                for (const smt of this.statements)
                    if (smt.isDisposed)
                        throw Truth.Exception.unknownState();
            // Clean out any type cache
            this._types = null;
            // Tell subscribers that the edit transaction completed.
            this.program.cause(new Truth.CauseEditComplete(this));
            this._version = Truth.VersionStamp.next();
            this.inEdit = false;
        }
        /**
         * Executes a complete edit transaction, applying the series
         * of edits specified in the `edits` parameter.
         */
        editAtomic(edits) {
            this.edit(statements => {
                for (const editInfo of edits) {
                    if (!editInfo.range)
                        throw new TypeError("No range included.");
                    const startLine = editInfo.range.startLineNumber - 1;
                    const endLine = editInfo.range.endLineNumber - 1;
                    const startChar = editInfo.range.startColumn - 1;
                    const endChar = editInfo.range.endColumn - 1;
                    const startLineText = this.read(startLine).sourceText;
                    const endLineText = this.read(endLine).sourceText;
                    const prefixSegment = startLineText.slice(0, startChar);
                    const suffixSegment = endLineText.slice(endChar);
                    const segments = editInfo.text.split("\n");
                    const pastCount = endLine - startLine + 1;
                    const presentCount = segments.length;
                    const deltaCount = presentCount - pastCount;
                    // Detect the pure update cases
                    if (deltaCount === 0) {
                        if (pastCount === 1) {
                            statements.update(prefixSegment + editInfo.text + suffixSegment, startLine);
                        }
                        else {
                            statements.update(prefixSegment + segments[0], startLine);
                            for (let i = startLine; i <= endLine; i++) {
                                statements.update(prefixSegment + segments[i] + suffixSegment, startLine);
                            }
                            statements.update(segments.slice(-1)[0] + suffixSegment, endLine);
                        }
                        continue;
                    }
                    // Detect the pure delete cases
                    if (deltaCount < 0) {
                        const deleteCount = deltaCount * -1;
                        // Detect a delete ranging from the end of 
                        // one line, to the end of a successive line
                        if (startChar === startLineText.length)
                            if (endChar === endLineText.length) {
                                statements.delete(startLine + 1, deleteCount);
                                continue;
                            }
                        // Detect a delete ranging from the start of
                        // one line to the start of a successive line
                        if (startChar + endChar === 0) {
                            statements.delete(startLine, deleteCount);
                            continue;
                        }
                    }
                    // Detect the pure insert cases
                    if (deltaCount > 0) {
                        // Cursor is at the end of the line, and the first line of the 
                        // inserted content is empty (most likely, enter was pressed)						
                        if (startChar === startLineText.length && segments[0] === "") {
                            for (let i = 0; ++i < segments.length;)
                                statements.insert(segments[i], startLine + i);
                            continue;
                        }
                        // Cursor is at the beginning of the line, and the
                        // last line of the inserted content is empty.
                        if (startChar === 0 && segments.slice(-1)[0] === "") {
                            for (let i = -1; ++i < segments.length - 1;)
                                statements.insert(segments[i], startLine + i);
                            continue;
                        }
                    }
                    // This is the "fallback" behavior -- simply delete everything
                    // that is old, and insert everything that is new.
                    const deleteCount = endLine - startLine + 1;
                    statements.delete(startLine, deleteCount);
                    const insertLines = segments.slice();
                    insertLines[0] = prefixSegment + insertLines[0];
                    insertLines[insertLines.length - 1] += suffixSegment;
                    for (let i = -1; ++i < insertLines.length;)
                        statements.insert(insertLines[i], startLine + i);
                }
            });
        }
        /** Stores the URI from where this document was loaded. */
        get sourceUri() {
            return this._sourceUri;
        }
        /**
         * @internal
         * A rolling version stamp that increments after each edit transaction.
         */
        get version() {
            return this._version;
        }
        /**
         * Returns a formatted version of the Document.
         */
        toString(keepOriginalFormatting) {
            const lines = [];
            if (keepOriginalFormatting) {
                for (const statement of this.statements)
                    lines.push(statement.sourceText);
            }
            else
                for (const { statement, level } of this.eachDescendant()) {
                    const indent = "\t" /* tab */.repeat(level);
                    lines.push(indent + statement.toString());
                }
            return lines.join("\n");
        }
    }
    Truth.Document = Document;
    /**
     * Generator function that yields all statements (unparsed lines)
     * of the given source text.
     */
    function* readLines(source) {
        let cursor = -1;
        let statementStart = 0;
        const char = () => source[cursor];
        for (;;) {
            if (cursor >= source.length - 1)
                return yield source.slice(statementStart);
            cursor++;
            if (char() === "\n" /* terminal */) {
                yield source.slice(statementStart, cursor);
                statementStart = cursor + 1;
            }
        }
    }
    /**
     * Performs the integer bounding and wrapping formula that is
     * common on all positional arguments found in JavaScript array
     * and string methods (such as Array.slice).
     */
    function applyBounds(index, length) {
        if (index === 0 || length === 0)
            return 0;
        if (index > 0)
            return Math.min(index, length - 1);
        if (index < 0)
            return Math.max(length + index, 0);
        throw Truth.Exception.unknownState();
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that stores all the documents loaded into a
     * program, and the inter-dependencies between them.
     */
    class DocumentGraph {
        /** */
        constructor(program) {
            /**
             * An array of functions that should be executed when
             * all outstanding async operations have completed.
             */
            this.waitFns = [];
            /**
             * Counts the number of async operations in progress.
             */
            this.asyncCount = 0;
            /**
             * A map of documents loaded into the graph,
             * indexed by their URIs.
             */
            this.documents = new Map();
            /**
             * A map of each document's dependencies.
             */
            this.dependencies = new Map();
            /**
             * A map of the documents that depend on each document.
             */
            this.dependents = new Map();
            this.program = program;
            program.on(Truth.CauseDocumentUriChange, data => {
                for (const [oldUriText, docEntry] of this.documents) {
                    if (docEntry.document !== data.document)
                        continue;
                    const newUriText = data.newUri.toStoreString();
                    const entry = this.documents.get(oldUriText);
                    if (entry) {
                        this.documents.delete(oldUriText);
                        this.documents.set(newUriText, entry);
                    }
                    return;
                }
            });
            program.on(Truth.CauseRevalidate, data => {
                const docUri = data.document.sourceUri.toString();
                const entry = this.documents.get(docUri);
                const header = entry ? entry.header : null;
                // The header is being re-computed on every document
                // modification. There may be some optimizations here
                // to eliminate recompute in common cases, but it would
                // be a micro-optimization at the time of this writing.
                if (header)
                    header.recompute();
            });
            program.on(Truth.CauseUriReferenceAdd, data => {
                if (data.uri.ext !== ".truth" /* truth */)
                    return;
                const smt = data.statement;
                if (smt)
                    this.tryLink(smt.document, smt, data.uri);
            });
            program.on(Truth.CauseUriReferenceRemove, data => {
                if (data.uri.ext !== ".truth" /* truth */)
                    return;
                const entry = this.documents.get(data.uri.toStoreString());
                if (!entry)
                    return;
                const smt = data.statement;
                if (smt)
                    this.unlink(smt.document, entry.document);
            });
        }
        /**
         * Reads a Document from the specified URI.
         * The document is created and returned, asynchronously.
         */
        async read(uri) {
            const uriParsed = Truth.Uri.tryParse(uri);
            if (!uriParsed)
                throw Truth.Exception.invalidUri();
            const uriAbsolute = uriParsed.toAbsolute();
            if (!uriAbsolute)
                throw Truth.Exception.unknownState();
            const readResult = await Truth.UriReader.tryRead(uriAbsolute);
            if (readResult instanceof Error)
                return readResult;
            return this.create(uriAbsolute, readResult);
        }
        create(param1, param2) {
            const zeroArgs = arguments.length === 0;
            const oneArg = arguments.length === 1;
            const uri = (() => {
                if (zeroArgs || oneArg)
                    return Truth.Uri.createInternal();
                if (!param1)
                    return null;
                if (param1 instanceof Truth.Uri)
                    return param1;
                return Truth.Uri.tryParse(param1);
            })();
            if (!uri)
                throw Truth.Exception.invalidUri();
            const sourceText = zeroArgs ? "" :
                oneArg ? (param1 || "").toString() :
                    param2 || "";
            const document = new Truth.Document(this.program, uri, sourceText);
            const header = new Truth.DocumentHeader(document);
            const entry = { document, header };
            this.documents.set(uri.toStoreString(), entry);
            header.recompute();
            this.program.cause(new Truth.CauseDocumentCreate(document));
            return document;
        }
        /**
         * Blocks execution until all queued IO operations have completed.
         */
        await() {
            return new Promise(resolve => {
                if (this.asyncCount === 0)
                    resolve();
                else
                    this.waitFns.push(resolve);
            });
        }
        /**
         * @returns The document loaded into this graph
         * with the specified URI.
         */
        get(uri) {
            const uriText = typeof uri === "string" ? uri : uri.toStoreString();
            const entry = this.documents.get(uriText);
            return entry ? entry.document : null;
        }
        /**
         * @returns A boolean value that indicates whether
         * the specified Document has been loaded into
         * this DocumentGraph.
         */
        has(param) {
            if (param instanceof Truth.Document) {
                for (const entry of this.documents.values())
                    if (entry.document === param)
                        return true;
                return false;
            }
            return !!this.get(param);
        }
        /**
         * @returns An array containing all documents loaded into this
         * DocumentGraph. The array returned is sorted topologically
         * from left to right, so that forward traversals are guaranteed
         * to not cause dependency conflicts.
         */
        each() {
            // The topological sorting mechanism uses a variant of depth-first search.
            // Algorithm is described here: https://en.wikipedia.org/wiki/Topological_sorting
            const sortedResult = [];
            const docsFinalized = new Set();
            const docsInStack = new Set();
            const allDocs = Array.from(this.documents.values())
                .map(entry => entry.document);
            const recurse = (currentDoc) => {
                if (docsFinalized.has(currentDoc))
                    return;
                // Cycle detected. This condition should never pass because
                // DocumentGraph is supposed to prevent cycles.
                if (docsInStack.has(currentDoc))
                    throw Truth.Exception.unknownState();
                docsInStack.add(currentDoc);
                const deps = this.dependencies.get(currentDoc);
                if (deps)
                    for (const dep of deps)
                        recurse(dep.target);
                docsFinalized.add(currentDoc);
                sortedResult.unshift(currentDoc);
            };
            while (docsFinalized.size < allDocs.length) {
                const nextUnvisited = allDocs.find(d => !docsFinalized.has(d));
                if (!nextUnvisited)
                    throw Truth.Exception.unknownState();
                recurse(nextUnvisited);
            }
            return sortedResult;
        }
        /**
         * Deletes a document that was previously loaded into the compiler.
         * Intended to be called by the host environment when a file changes.
         */
        delete(target) {
            const doc = target instanceof Truth.Document ? target : (() => {
                const entry = this.documents.get(target.toString());
                return entry ? entry.document : null;
            })();
            if (!doc)
                return;
            this.program.cause(new Truth.CauseDocumentCreate(doc));
            // Go through the entire map of dependent documents, 
            // and find documents that have the deleted document 
            // listed as one of it's dependents. These documents are
            // then removed from the array of dependents.
            for (const [refDoc, dependents] of this.dependents) {
                const docIdx = dependents.indexOf(doc);
                if (docIdx > -1)
                    dependents.splice(docIdx, 1);
                if (dependents.length === 0)
                    this.dependents.delete(refDoc);
            }
            // Delete the dependencies of the document
            // after we're done clearing out the dependents.
            this.dependencies.delete(doc);
            // Delete the deleted document last
            this.documents.delete(doc.sourceUri.toString());
        }
        /**
         * Removes all documents from this graph.
         */
        clear() {
            this.documents.clear();
            this.dependencies.clear();
            this.dependents.clear();
        }
        /**
         * @returns An array containing the dependencies
         * associated with the specified document. The returned
         * array is sorted in the order in which the dependencies
         * are defined in the document.
         */
        getDependencies(doc) {
            const dependencies = this.dependencies.get(doc);
            if (!dependencies)
                return [];
            const urisSorted = [];
            const docDependencies = dependencies.map(d => d.target);
            const entry = this.documents.get(doc.sourceUri.toString());
            if (entry === undefined)
                throw Truth.Exception.unknownState();
            for (const statement of doc.eachStatement()) {
                if (statement.isNoop)
                    continue;
                // If a non-noop statement is reached that isn't a part
                // of the header, the end of the header has been reached.
                const refUri = entry.header.getHeaderUri(statement);
                if (!refUri)
                    break;
                urisSorted.push(refUri.toString());
            }
            const depsSorted = urisSorted.map(uriText => Truth.Not.undefined(docDependencies.find(docDep => docDep.sourceUri.toString() === uriText)));
            if (depsSorted.some(d => d === undefined))
                throw Truth.Exception.unknownState();
            return depsSorted;
        }
        /**
         * @returns An array containing the dependents
         * associated with the specified document.
         */
        getDependents(doc) {
            const dependents = this.dependents.get(doc);
            return dependents ?
                dependents.slice() :
                [];
        }
        /**
         * Attempts to add a link from one document to another,
         * via the specified URI. If there is some reason why the
         * link cannot be established, (circular references, bad
         * URIs), no link is added, and a fault is reported.
         */
        tryLink(containingDocument, containingStatement, uri) {
            this.asyncCount++;
            const uriText = uri.toString();
            setTimeout(() => (async () => {
                const refDocument = await (async () => {
                    // Is the document already loaded into the graph?
                    const existingEntry = this.documents.get(uriText);
                    if (existingEntry)
                        return existingEntry.document;
                    // Read the document if it wasn't loaded
                    const result = await this.read(uri);
                    if (result instanceof Error) {
                        const fault = Truth.Faults.UnresolvedResource.create(containingStatement);
                        this.program.faults.reportAsync(fault);
                        return null;
                    }
                    const newEntry = this.documents.get(uriText);
                    if (!newEntry)
                        throw Truth.Exception.unknownState();
                    return newEntry.document;
                })();
                if (!refDocument)
                    return;
                // Bail if a document loaded from HTTP is trying to reference
                // a document located on the file system.
                const srcProto = containingDocument.sourceUri.protocol;
                const dstProto = refDocument.sourceUri.protocol;
                if ((srcProto === Truth.UriProtocol.http || srcProto === Truth.UriProtocol.https) &&
                    dstProto === Truth.UriProtocol.file) {
                    const param = Truth.Faults.InsecureResourceReference.create(containingStatement);
                    this.program.faults.reportAsync(param);
                }
                // Bail if the addition of the reference is going to result in a circular reference.
                if (this.wouldCreateCycles(containingDocument, refDocument)) {
                    const param = Truth.Faults.CircularResourceReference.create(containingStatement);
                    this.program.faults.reportAsync(param);
                }
                else {
                    this.link(containingDocument, refDocument);
                }
                this.asyncCount--;
                if (this.asyncCount < 0)
                    throw Truth.Exception.unknownState();
                if (this.asyncCount === 0) {
                    const waitFns = this.waitFns.slice();
                    this.waitFns.length = 0;
                    waitFns.forEach(fn => fn());
                }
            })(), 0);
        }
        /**
         * Checks to see if the addition of a reference between the two
         * specified documents would result in a document graph with
         * circular relationships.
         *
         * The algorithm used performs a depth-first dependency search,
         * starting at the candidateTo. If the traversal pattern is able to
         * make its way to candidateFrom, it can be concluded that the
         * addition of the proposed reference would result in a cyclical
         * relationship.
         */
        wouldCreateCycles(proposedFrom, proposedTo) {
            const checkForCyclesRecursive = (current) => {
                if (current === proposedFrom)
                    return true;
                const dependencies = (this.dependencies.get(current) || []).map(d => d.target);
                if (dependencies.length === 0)
                    return false;
                if (current === proposedFrom)
                    dependencies.unshift(proposedTo);
                if (dependencies.some(d => checkForCyclesRecursive(d)))
                    return true;
                return false;
            };
            return checkForCyclesRecursive(proposedTo);
        }
        /**
         * Adds a dependency between two documents in the graph.
         * If a dependency between the two documents already exists,
         * the reference count of the dependency is incremented.
         * This method is executed only after other methods have
         * indicated that the addition of the link will not cause conflict.
         */
        link(from, to) {
            const dependencyArray = this.dependencies.get(from);
            if (dependencyArray) {
                const dependency = dependencyArray.find(d => d.target === to);
                if (dependency)
                    dependency.referenceCount++;
                else
                    dependencyArray.push(new Dependency(to));
            }
            else {
                this.dependencies.set(from, [new Dependency(to)]);
            }
            const dependentArray = this.dependents.get(to);
            if (dependentArray) {
                if (!dependentArray.includes(from))
                    dependentArray.push(from);
            }
            else {
                this.dependents.set(to, [from]);
            }
        }
        /**
         * Removes a dependency between two documents in the graph.
         * If the reference count of the dependency is greater than 1, the
         * the reference count is decremented instead of the dependency
         * being removed completely.
         */
        unlink(from, to) {
            const dependencyArray = this.dependencies.get(from);
            if (!dependencyArray)
                return;
            const dependencyIdx = dependencyArray.findIndex(d => d.target === to);
            if (dependencyIdx < 0)
                return;
            const dependency = dependencyArray[dependencyIdx];
            if (dependency.referenceCount > 1) {
                dependency.referenceCount--;
            }
            else {
                dependencyArray.splice(dependencyIdx);
                // Get rid of the entry in the dependencies map
                // completely if the dependency array is now empty.
                if (dependencyArray.length === 0)
                    this.dependencies.delete(from);
            }
            const dependentArray = this.dependents.get(to);
            if (dependentArray) {
                const depIdx = dependentArray.indexOf(from);
                if (depIdx > -1)
                    dependentArray.splice(depIdx, 1);
            }
        }
        /**
         * Converts the contents of this DocumentGraph to a
         * string representation, useful for testing purposes.
         */
        toString() {
            const lines = [];
            for (const [uriText, entry] of this.documents) {
                const uri = Truth.Uri.tryParse(uriText);
                const doc = entry.document;
                if (!uri)
                    throw Truth.Exception.unknownState();
                lines.push(uri.toString());
                lines.push("\tDependencies");
                const docDependencies = this.dependencies.get(doc);
                if (docDependencies) {
                    if (docDependencies.length) {
                        for (const dependency of docDependencies)
                            lines.push("\t\t" + dependency.target.sourceUri.toString());
                    }
                    else
                        lines.push("\t\t(none)");
                }
                else
                    lines.push("\t\t(undefined)");
                lines.push("\tDependents");
                const docDependents = this.dependents.get(doc);
                if (docDependents) {
                    if (docDependents.length) {
                        for (const docDependent of docDependents)
                            lines.push("\t\t" + docDependent.sourceUri.toString());
                    }
                    else
                        lines.push("\t\t(none)");
                }
                else
                    lines.push("\t\t(undefined)");
                lines.push("");
            }
            return lines.slice(0, -1).join("\n");
        }
    }
    Truth.DocumentGraph = DocumentGraph;
    /**
     * A class that stores information about a dependency
     * between documents.
     */
    class Dependency {
        constructor(target) {
            this.target = target;
            this.referenceCount = 0;
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     * Stores information about a document's header.
     */
    class DocumentHeader {
        /** */
        constructor(document) {
            /**
             * Stores a map of the URIs referenced in the header of this
             * document, which are indexed by the statement in which
             * the URI is found.
             */
            this.uriMap = new Map();
            this.document = document;
        }
        /**
         * Forces the header to be recomputed, by scanning
         * the statements in the underlying document.
         *
         * If the header has changed, the method runs the
         * necessary hooks to notify subscribers of hooks
         * any added or removed.
         */
        recompute() {
            const oldUriMap = this.uriMap;
            const newUriMap = new Map();
            for (const { statement } of this.document.eachDescendant()) {
                // Currently, any statement with an annotation is
                // considered to be a non-header statement. This
                // will change if scoped references become supported.
                // Also, only one URI reference statement per line is
                // accepted. Vaccuous statements break the header.
                if (statement.allAnnotations.length > 0 || statement.allDeclarations.length !== 1)
                    break;
                const decl = statement.allDeclarations[0];
                if (typeof decl.boundary.subject === "string")
                    throw Truth.Exception.unknownState();
                if (!(decl.boundary.subject instanceof Truth.Uri))
                    break;
                const refUri = decl.boundary.subject;
                const docUri = this.document.sourceUri;
                const uriAbsolute = Truth.Not.null(Truth.Uri.tryParse(refUri, docUri));
                newUriMap.set(statement, uriAbsolute);
            }
            if (oldUriMap.size + newUriMap.size === 0)
                return;
            const removedUriMap = new Map();
            const addedUriMap = new Map();
            for (const [statement, oldUri] of oldUriMap)
                if (!newUriMap.has(statement))
                    removedUriMap.set(oldUri, statement);
            for (const [statement, newUri] of newUriMap)
                if (!oldUriMap.has(statement))
                    addedUriMap.set(newUri, statement);
            const program = this.document.program;
            for (const [uri, statement] of removedUriMap)
                program.cause(new Truth.CauseUriReferenceRemove(statement, uri));
            for (const [uri, statement] of addedUriMap)
                program.cause(new Truth.CauseUriReferenceAdd(statement, uri));
            this.uriMap.clear();
            newUriMap.forEach((uri, statement) => this.uriMap.set(statement, uri));
        }
        /**
         * @returns The document reference URI that corresponds
         * to the specified statement. Returns null in the case when
         * the specified statement is not a part of the header.
         */
        getHeaderUri(statement) {
            return this.uriMap.get(statement) || null;
        }
    }
    Truth.DocumentHeader = DocumentHeader;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Parses a single line of Truth code, and returns
     * a Line object that contains information about
     * what was read.
     */
    class LineParser {
        /**
         * Generator function that yields all statements
         * (unparsed lines) of the given source text.
         */
        static *read(fullSource) {
            if (fullSource.length === 0)
                return;
            let cursor = 0;
            let statementStart = 0;
            for (; cursor < fullSource.length; cursor++) {
                if (fullSource[cursor] === "\n" /* terminal */) {
                    yield fullSource.slice(statementStart, cursor);
                    statementStart = cursor + 1;
                }
            }
            if (statementStart < cursor)
                yield fullSource.slice(statementStart);
        }
        /**
         * Main entry point for parsing a single line and producing a
         * RawStatement object.
         *
         * The parsing algorithm is some kind of quasi-recusive descent with
         * lookheads and backtracking in some places to make the logic easier
         * to follow. Technically, it's probably some mash-up of LL(k) & LALR.
         * Maybe if I blew 4 years of my life in some silly Comp Sci program
         * instead of dropping out of high school I could say for sure.
         */
        static parse(lineText, options) {
            const parserOptions = options || {
                readPatterns: true,
                readUris: true
            };
            const parser = new Truth.Parser(lineText);
            const sourceText = lineText;
            const indent = parser.readWhitespace();
            const declarationEntries = [];
            const annotationEntries = [];
            const esc = "\\" /* escapeChar */;
            let flags = Truth.LineFlags.none;
            let jointPosition = -1;
            let sum = "";
            /**
             * Universal function for quickly producing a RawStatement
             * instance using the values of the constructed local variables.
             */
            const ret = (fault = null) => new Truth.Line(sourceText, indent, new Truth.BoundaryGroup(declarationEntries), new Truth.BoundaryGroup(annotationEntries), sum, jointPosition, flags, fault);
            // In the case when the line contains only whitespace characters,
            // this condition will pass, bypassing the entire parsing process
            // and returning an (basically) fresh RawStatement object.
            if (!parser.more()) {
                flags |= Truth.LineFlags.isWhitespace;
                return ret();
            }
            {
                const mark = parser.position;
                if (parser.read("//" /* comment */)) {
                    if (!parser.more() || parser.read(" " /* space */) || parser.read("\t" /* tab */)) {
                        flags |= Truth.LineFlags.isComment;
                        return ret();
                    }
                    parser.position = mark;
                }
            }
            {
                const unparsableFaultType = (() => {
                    if (parser.read("," /* combinator */))
                        return Truth.Faults.StatementBeginsWithComma;
                    if (parser.read("..." /* list */))
                        return Truth.Faults.StatementBeginsWithEllipsis;
                    if (parser.read(esc + " " /* space */) || parser.read(esc + "\t" /* tab */))
                        return Truth.Faults.StatementBeginsWithEscapedSpace;
                    if (parser.readThenTerminal(esc))
                        return Truth.Faults.StatementContainsOnlyEscapeCharacter;
                    return null;
                })();
                if (unparsableFaultType) {
                    flags |= Truth.LineFlags.isCruft;
                    return ret(unparsableFaultType);
                }
            }
            {
                const markBeforeUri = parser.position;
                const uri = maybeReadUri();
                if (uri) {
                    flags |= Truth.LineFlags.hasUri;
                    declarationEntries.push(new Truth.Boundary(markBeforeUri, parser.position, uri));
                    return then();
                }
                const markBeforePattern = parser.position;
                const pattern = maybeReadPattern();
                if (isParseFault(pattern)) {
                    flags |= Truth.LineFlags.isCruft;
                    return ret(pattern);
                }
                if (pattern) {
                    flags |= Truth.LineFlags.hasPattern;
                    flags |= pattern.isTotal ?
                        Truth.LineFlags.hasTotalPattern :
                        Truth.LineFlags.hasPartialPattern;
                    declarationEntries.push(new Truth.Boundary(markBeforePattern, parser.position, pattern));
                    return then();
                }
                for (const boundsEntry of readDeclarations([]))
                    declarationEntries.push(boundsEntry);
                return then();
            }
            function then() {
                jointPosition = maybeReadJoint();
                const readResult = readAnnotations([]);
                sum = readResult.raw.trim();
                for (const boundsEntry of readResult.annotations)
                    annotationEntries.push(boundsEntry);
                if (jointPosition > -1) {
                    const dLen = declarationEntries.length;
                    const aLen = readResult.annotations.length;
                    if (dLen === 0) {
                        declarationEntries.unshift(new Truth.Boundary(jointPosition, jointPosition, new Truth.Anon()));
                        if (aLen === 0)
                            flags |= Truth.LineFlags.isVacuous;
                    }
                    else if (aLen === 0) {
                        flags |= Truth.LineFlags.isRefresh;
                    }
                }
                return ret();
            }
            /**
             * Reads the following series of declarations, which may be
             * either directly contained by a statement, or inside an infix.
             */
            function readDeclarations(quitTokens) {
                const entries = [];
                const until = quitTokens.concat(":" /* joint */);
                while (parser.more()) {
                    const readResult = maybeReadIdentifier(until);
                    if (readResult !== null)
                        entries.push(new Truth.Boundary(readResult.at, parser.position, readResult.identifier));
                    // The following combinator must be eaten before
                    // moving on to another declaration. If this fails,
                    // it's because the parse stream has ended.
                    if (!parser.read("," /* combinator */))
                        break;
                    if (peekJoint())
                        break;
                }
                return entries;
            }
            /**
             * Attempts to read the joint token from the parse stream.
             * Consumes all surrounding whitespace.
             * @returns A boolean value indicating whether the joint
             * token was read.
             */
            function maybeReadJoint() {
                const markBeforeWs = parser.position;
                parser.readWhitespace();
                const markAfterWs = parser.position;
                let foundJointPosition = -1;
                if (parser.read(":" /* joint */ + " " /* space */) ||
                    parser.read(":" /* joint */ + "\t" /* tab */) ||
                    parser.readThenTerminal(":" /* joint */)) {
                    foundJointPosition = markAfterWs;
                    parser.readWhitespace();
                }
                else {
                    parser.position = markBeforeWs;
                }
                return foundJointPosition;
            }
            /**
             * @returns A boolean value that indicates whether the joint
             * is the next logical token to be consumed. True is returned
             * in the case when whitespace characters sit between the
             * cursor and the joint operator.
             */
            function peekJoint() {
                const innerPeekJoint = () => {
                    return parser.peek(":" /* joint */ + " " /* space */) ||
                        parser.peek(":" /* joint */ + "\t" /* tab */) ||
                        parser.peekThenTerminal(":" /* joint */);
                };
                if (innerPeekJoint())
                    return true;
                if (!parser.peek(" " /* space */) && !parser.peek("\t" /* tab */))
                    return false;
                const mark = parser.position;
                parser.readWhitespace();
                const atJoint = innerPeekJoint();
                parser.position = mark;
                return atJoint;
            }
            /**
             *
             */
            function readAnnotations(quitTokens) {
                const annotations = [];
                let raw = "";
                while (parser.more()) {
                    const readResult = maybeReadIdentifier(quitTokens);
                    if (readResult !== null) {
                        annotations.push(new Truth.Boundary(readResult.at, parser.position, readResult.identifier));
                        raw += readResult.raw;
                    }
                    // If the next token is not a combinator, 
                    // the parse stream has ended.
                    if (!parser.read("," /* combinator */))
                        break;
                }
                return {
                    annotations,
                    raw
                };
            }
            /**
             * Attempts to read a raw annotation from the parse stream.
             * If found, the raw string found is returned.
             */
            function maybeReadIdentifier(quitTokens) {
                const until = quitTokens
                    .concat("," /* combinator */)
                    .filter(tok => tok !== ":" /* joint */);
                const shouldQuitOnJoint = quitTokens.includes(":" /* joint */);
                const at = parser.position + parser.readWhitespace();
                let token = "";
                while (parser.more()) {
                    if (until.some(tok => parser.peek(tok)))
                        break;
                    if (shouldQuitOnJoint && peekJoint())
                        break;
                    const g1 = parser.readGrapheme();
                    if (parser.more()) {
                        // The only operators that can be meaningfully escaped at
                        // the identifier level are the joint, the combinator, and the
                        // pattern delimiter. Other occurences of the escape character
                        // append this character to the identifier.
                        if (g1 === esc) {
                            const g2 = parser.readGrapheme();
                            token += g2;
                            continue;
                        }
                    }
                    token += g1;
                }
                const tokenTrimmed = token.trim();
                if (!tokenTrimmed.length)
                    return null;
                return {
                    at,
                    identifier: new Truth.Identifier(tokenTrimmed),
                    raw: token
                };
            }
            /**
             * Attempts to read a URI starting at the current position
             * of the cursor. The position of the cursor is not changed
             * in the case when a valid URI was not read.
             */
            function maybeReadUri() {
                if (!parserOptions.readUris)
                    return null;
                const mark = parser.position;
                const uri = Truth.Uri.tryParse(parser.readUntil());
                if (uri === null)
                    parser.position = mark;
                return uri;
            }
            /**
             * Attempts to read a pattern from the steam.
             */
            function maybeReadPattern(nested = false) {
                if (!nested && !parser.read("/" /* main */))
                    return null;
                if (!parserOptions.readPatterns)
                    return null;
                // These are reserved starting sequences. They're invalid
                // regex syntax, and we may use them in the future to pack
                // in other language features.
                if (parser.peek("+" /* plus */) ||
                    parser.peek("*" /* star */) ||
                    parser.peek("?" /* restrained */))
                    return Truth.Faults.StatementBeginsWithInvalidSequence;
                // TypeScript isn't perfect.
                const units = nested ?
                    readRegexUnits(true) :
                    readRegexUnits(false);
                if (isParseFault(units))
                    return units;
                // Right-trim any trailing whitespace
                while (units.length) {
                    const last = units[units.length - 1];
                    if (!(last instanceof Truth.RegexGrapheme))
                        break;
                    if (last.grapheme !== " " /* space */ && last.grapheme !== "\t" /* tab */)
                        break;
                    units.pop();
                }
                if (units.length === 0)
                    return Truth.Faults.EmptyPattern;
                const last = units[units.length - 1];
                const isTotal = last instanceof Truth.RegexGrapheme &&
                    last.quantifier === null &&
                    last.grapheme === "/" /* main */;
                // Need to pop off the 
                if (isTotal)
                    units.pop();
                // Now read the annotations, in order to compute the Pattern's hash
                const mark = parser.position;
                const foundJointPosition = maybeReadJoint();
                if (foundJointPosition < 0)
                    return new Truth.Pattern(Object.freeze(units), isTotal, "");
                const annos = readAnnotations([]).annotations;
                const annosArrayJoined = Array.from(annos.values())
                    .map(v => v.subject.toString())
                    .join("\n" /* terminal */);
                const hash = Truth.Hash.calculate(annosArrayJoined);
                parser.position = mark;
                return new Truth.Pattern(Object.freeze(units), isTotal, hash);
            }
            function readRegexUnits(nested) {
                const units = [];
                while (parser.more()) {
                    const setOrGroup = maybeReadRegexSet() || maybeReadRegexGroup();
                    if (isParseFault(setOrGroup))
                        return setOrGroup;
                    if (setOrGroup !== null) {
                        const quantifier = maybeReadRegexQuantifier();
                        if (isParseFault(quantifier))
                            return quantifier;
                        units.push(appendQuantifier(setOrGroup, quantifier));
                        continue;
                    }
                    if (nested) {
                        if (parser.peek("|" /* alternator */))
                            break;
                        if (parser.peek(")" /* groupEnd */))
                            break;
                    }
                    else {
                        // Infixes are not supported anywhere other 
                        // than at the top level of the pattern.
                        const infix = maybeReadInfix();
                        if (isParseFault(infix))
                            return infix;
                        if (infix !== null) {
                            const quantifier = maybeReadRegexQuantifier();
                            if (quantifier !== null)
                                return Truth.Faults.InfixHasQuantifier;
                            units.push(infix);
                            continue;
                        }
                        if (peekJoint())
                            break;
                    }
                    const grapheme = maybeReadRegexGrapheme();
                    if (!grapheme)
                        break;
                    // If the grapheme read is in the RegexSyntaxKnownSet
                    // enumeration, we need to convert the grapheme to a
                    // RegexSet instance, and push that on to the units array
                    // instead.
                    const regexKnownSet = (() => {
                        if (grapheme.character === Truth.RegexSyntaxKnownSet.wild && !grapheme.escaped)
                            return Truth.RegexSyntaxKnownSet.wild;
                        if (grapheme.escaped) {
                            const characterWithEscape = esc + grapheme.character;
                            const knownSet = Truth.RegexSyntaxKnownSet.resolve(characterWithEscape);
                            if (knownSet !== null)
                                return knownSet;
                        }
                        return null;
                    })();
                    const quantifier = maybeReadRegexQuantifier();
                    if (isParseFault(quantifier))
                        return quantifier;
                    if (regexKnownSet !== null) {
                        units.push(new Truth.RegexSet([regexKnownSet], [], [], [], false, quantifier));
                        continue;
                    }
                    if (grapheme.unicodeBlockName) {
                        const ubn = grapheme.unicodeBlockName;
                        units.push(new Truth.RegexSet([], [], [ubn], [], false, quantifier));
                        continue;
                    }
                    if (grapheme.escaped) {
                        const sign = Truth.RegexSyntaxSign.resolve(esc + grapheme.character);
                        if (sign !== null) {
                            units.push(new Truth.RegexSign(sign, quantifier));
                            continue;
                        }
                        // If this point is reached, it's because there was a unneccesarily
                        // escaped character found in the parse stream, such as "\a". In
                        // this case, the raw character can just be added as a regex unit.
                    }
                    units.push(new Truth.RegexGrapheme(grapheme.character, quantifier));
                }
                return units;
            }
            /**
             * Attempts to read a character set from the parse stream.
             * Example: [a-z0-9]
             */
            function maybeReadRegexSet() {
                if (!parser.read("[" /* setStart */))
                    return null;
                const rng = "-" /* range */;
                const knowns = [];
                const ranges = [];
                const blocks = [];
                const singles = [];
                const isNegated = !!parser.read("^" /* negate */);
                let closed = false;
                /**
                 * Stores all Graphemes read.
                 */
                const graphemes = [];
                /**
                 * Stores booleans that align with the items in "queue",
                 * that indicate whether or not the queued Grapheme
                 * can participate in a range.
                 */
                const rangableQueue = [];
                for (;;) {
                    const g = maybeReadRegexGrapheme();
                    if (g === null)
                        break;
                    if (!g.escaped && g.character === "]" /* setEnd */) {
                        closed = true;
                        break;
                    }
                    if (g.unicodeBlockName) {
                        blocks.push(g.unicodeBlockName);
                        rangableQueue.push(false);
                        graphemes.push(null);
                        continue;
                    }
                    const gFull = g.escaped ? esc + g.character : g.character;
                    const known = Truth.RegexSyntaxKnownSet.resolve(gFull);
                    if (known !== null) {
                        knowns.push(known);
                        rangableQueue.push(false);
                        graphemes.push(null);
                        continue;
                    }
                    graphemes.push(g);
                    rangableQueue.push(g.character.length > 0 &&
                        g.character !== "\\b" /* boundary */ &&
                        g.character !== "\\B" /* boundaryNon */);
                    if (g.unicodeBlockName)
                        continue;
                    const len = graphemes.length;
                    if (len < 3)
                        continue;
                    const maybeRng = graphemes[len - 2];
                    if (maybeRng !== null && maybeRng.character !== rng)
                        continue;
                    if (!rangableQueue[len - 3])
                        continue;
                    const maybeFrom = graphemes[len - 3];
                    if (maybeFrom === null)
                        throw Truth.Exception.unknownState();
                    // Peel back symbol queue, and add a range
                    // to the alphabet builder if the queue gets into
                    // a state where it's ending with something
                    // looking like: ?-?
                    const from = maybeFrom.character.codePointAt(0) || 0;
                    const to = g.character.codePointAt(0) || 0;
                    ranges.push(new Truth.RegexCharRange(from, to));
                    graphemes.length -= 3;
                    continue;
                }
                if (!closed)
                    return Truth.Faults.UnterminatedCharacterSet;
                for (const g of graphemes)
                    if (g !== null)
                        singles.push(g.character);
                const quantifier = maybeReadRegexQuantifier();
                if (isParseFault(quantifier))
                    return quantifier;
                return new Truth.RegexSet(knowns, ranges, blocks, singles, isNegated, quantifier);
            }
            /**
             * Attempts to read an alternation group from the parse stream.
             * Example: (A|B|C)
             */
            function maybeReadRegexGroup() {
                if (!parser.read("(" /* groupStart */))
                    return null;
                const cases = [];
                let closed = false;
                while (parser.more()) {
                    if (parser.read("|" /* alternator */))
                        continue;
                    if (parser.read(")" /* groupEnd */)) {
                        closed = true;
                        break;
                    }
                    const subUnits = readRegexUnits(true);
                    if (isParseFault(subUnits))
                        return subUnits;
                    // If the call to maybeReadPattern causes the cursor
                    // to reach the end of te parse stream, the expression
                    // is invalid because it would mean the input looks
                    // something like: /(aa|bb
                    if (!parser.more())
                        return Truth.Faults.UnterminatedGroup;
                    // A null subPattern could come back in the case when some
                    // bizarre syntax is found in the pattern such as: (a||b)
                    if (subUnits === null)
                        continue;
                    cases.push(Object.freeze(subUnits));
                }
                if (!closed)
                    return Truth.Faults.UnterminatedGroup;
                const quantifier = maybeReadRegexQuantifier();
                if (isParseFault(quantifier))
                    return quantifier;
                return new Truth.RegexGroup(Object.freeze(cases), quantifier);
            }
            /**
             * Attempts to read a pattern quantifier from the parse stream.
             * Checks for duplicates, which is necessary because the JavaScript
             * regular expression flavor (and others?) cannot parse an expression
             * with two consecutive quantifiers.
             */
            function maybeReadRegexQuantifier() {
                /** */
                function maybeReadQuantifier() {
                    const mark = parser.position;
                    if (parser.read("*" /* star */))
                        return new Truth.RegexQuantifier(0, Infinity, isRestrained());
                    if (parser.read("+" /* plus */))
                        return new Truth.RegexQuantifier(1, Infinity, isRestrained());
                    if (parser.read("?" /* restrained */))
                        return new Truth.RegexQuantifier(0, 1, false);
                    if (!parser.read("{" /* quantifierStart */))
                        return null;
                    const min = maybeReadInteger();
                    if (min !== null) {
                        const quantEnd = "}" /* quantifierEnd */;
                        // {2}
                        if (parser.read(quantEnd))
                            return new Truth.RegexQuantifier(min, min, isRestrained());
                        // {2,} or {2,3} or {2,???
                        if (parser.read("," /* quantifierSeparator */)) {
                            if (parser.read(quantEnd))
                                return new Truth.RegexQuantifier(min, Infinity, isRestrained());
                            const max = maybeReadInteger();
                            if (max !== null && parser.read(quantEnd))
                                return new Truth.RegexQuantifier(min, max, isRestrained());
                        }
                    }
                    parser.position = mark;
                    return null;
                }
                /** */
                function isRestrained() {
                    return !!parser.read("?" /* restrained */);
                }
                const quantifier = maybeReadQuantifier();
                if (quantifier)
                    if (maybeReadQuantifier())
                        return Truth.Faults.DuplicateQuantifier;
                return quantifier;
            }
            /**
             *
             */
            function maybeReadInteger() {
                let integerText = "";
                for (let i = 0; i < 16 && parser.more(); i++) {
                    const digit = (() => {
                        for (let digit = 0; digit <= 9; digit++)
                            if (parser.read(digit.toString()))
                                return digit.toString();
                        return "";
                    })();
                    if (!digit)
                        break;
                    integerText += digit;
                }
                return integerText.length > 0 ?
                    parseInt(integerText, 10) :
                    null;
            }
            /**
             *
             */
            function maybeReadInfix() {
                const mark = parser.position;
                const lhsEntries = [];
                const rhsEntries = [];
                const infixStart = parser.position;
                let infixFlags = Truth.InfixFlags.none;
                let quitToken = ">" /* end */;
                let hasJoint = false;
                if (parser.read("<<" /* nominalStart */)) {
                    infixFlags |= Truth.InfixFlags.nominal;
                    quitToken = ">>" /* nominalEnd */;
                }
                else if (parser.read("</" /* patternStart */)) {
                    infixFlags |= Truth.InfixFlags.pattern;
                    quitToken = "/>" /* patternEnd */;
                }
                else if (parser.read("<" /* start */)) {
                    infixFlags |= Truth.InfixFlags.population;
                    quitToken = ">" /* end */;
                }
                else
                    return null;
                parser.readWhitespace();
                if (parser.read(":" /* joint */)) {
                    infixFlags |= Truth.InfixFlags.portability;
                    parser.readWhitespace();
                    for (const boundsEntry of readAnnotations([quitToken]).annotations)
                        rhsEntries.push(new Truth.Boundary(boundsEntry.offsetStart, parser.position, boundsEntry.subject));
                }
                else {
                    for (const boundsEntry of readDeclarations([quitToken]))
                        lhsEntries.push(boundsEntry);
                    parser.readWhitespace();
                    if (maybeReadJoint() > -1) {
                        hasJoint = true;
                        parser.readWhitespace();
                        for (const boundsEntry of readAnnotations([quitToken]).annotations)
                            rhsEntries.push(new Truth.Boundary(boundsEntry.offsetStart, parser.position, boundsEntry.subject));
                    }
                }
                // Avoid producing an infix in weird cases such as:
                // < : >  </  />  <<:>>
                if (lhsEntries.length + rhsEntries.length === 0) {
                    parser.position = mark;
                    return null;
                }
                if (hasJoint)
                    infixFlags |= Truth.InfixFlags.hasJoint;
                parser.readWhitespace();
                if (!parser.read(quitToken))
                    return Truth.Faults.UnterminatedInfix;
                return new Truth.Infix(infixStart, parser.position, new Truth.BoundaryGroup(lhsEntries), new Truth.BoundaryGroup(rhsEntries), infixFlags);
            }
            /**
             * Attempts to read one single symbol from the parse stream,
             * while respecting unicode escape sequences, and escaped
             * characters.
             *
             * @returns The read string, or an empty string in the case when
             * there are no more characters in the parse stream.
             */
            function maybeReadRegexGrapheme() {
                if (!parser.more())
                    return null;
                const mark = parser.position;
                if (parser.read("\\u{" /* utf16GroupStart */)) {
                    const delim = "}" /* utf16GroupEnd */;
                    const unicodeRef = parser.readUntil(delim);
                    // Make sure the readUntil method stopped because it
                    // actually hit the delimiter, and not because it ran out
                    // of characters.
                    if (parser.more()) {
                        parser.read(delim);
                        if (Truth.UnicodeBlocks.has(unicodeRef.toLowerCase()))
                            return new Grapheme("", unicodeRef, true);
                        const len = unicodeRef.length;
                        if (len >= 1 && len <= 5) {
                            const num = parseInt(unicodeRef, 16);
                            if (num === num) {
                                const char = String.fromCodePoint(num);
                                return new Grapheme(char, "", true);
                            }
                        }
                    }
                    // Something came in that looked like a unicode escape
                    // sequence, but turned out not to be, like: \u
                    parser.position = mark;
                }
                if (parser.read(esc)) {
                    // If the parse stream ends with a backslash, we just
                    // return the actual backslash character as a character.
                    // This covers ridiculous but possible cases where a
                    // an unannotated type is named something like "Thing\".
                    if (!parser.more())
                        return new Grapheme(esc, "", false);
                    const g = parser.readGrapheme();
                    const decoded = Truth.RegexSyntaxSign.unescape(esc + g) || g;
                    return new Grapheme(decoded, "", true);
                }
                return new Grapheme(parser.readGrapheme(), "", false);
            }
            /** */
            function isParseFault(value) {
                return value instanceof Truth.FaultType;
            }
        }
        /** */
        constructor() { }
    }
    Truth.LineParser = LineParser;
    /** */
    class Grapheme {
        constructor(
        /**
         * Stores the character found in the parse stream in
         * their unescaped format. For example, in the case
         * when the field is referring to a unicode character,
         * the field would store "🐇" ... not "\u1F407".
         */
        character, 
        /**
         * Stores the name of the unicode block specified,
         * or an empty string if the grapheme does not refer
         * to a unicode block.
         */
        unicodeBlockName, 
        /**
         * Stores whether the discovered grapheme was
         * escaped in the parse stream. Note that if the
         * grapheme refers to a special character, such
         * as "\d" for all digits, this will be true.
         */
        escaped) {
            this.character = character;
            this.unicodeBlockName = unicodeBlockName;
            this.escaped = escaped;
        }
    }
    /**
     * Slightly awkward hack function to attach a PatternQuantifier
     * to an already existing PatternUnit (without resorting to making
     * quantifier a mutable property.
     */
    function appendQuantifier(unit, quantifier = null) {
        if (quantifier === null)
            return unit;
        if (unit instanceof Truth.RegexSet)
            return new Truth.RegexSet(unit.knowns, unit.ranges, unit.unicodeBlocks, unit.singles, unit.isNegated, quantifier);
        if (unit instanceof Truth.RegexGroup)
            return new Truth.RegexGroup(unit.cases, quantifier);
        if (unit instanceof Truth.RegexGrapheme)
            return new Truth.RegexGrapheme(unit.grapheme, quantifier);
        throw Truth.Exception.notImplemented();
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Placeholder object to mark the position of
     * an anonymous type within a statement.
     */
    class Anon {
        constructor() {
            /**
             * @internal
             * No-op property used for debugging
             * purposes, and also to dodge structural
             * type compatibility bugs in TypeScript.
             */
            this.id = ++nextId;
        }
        /** */
        toString() {
            return `__ANON${this.id}__`;
        }
    }
    Truth.Anon = Anon;
    let nextId = 0;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Stores information about a line, after being parsed.
     * A Line is different from a Statement in that it has no
     * relationship to a Document.
     */
    class Line {
        /*** */
        constructor(sourceText, indent, declarations, annotations, sum, jointPosition, flags, faultType) {
            this.sourceText = sourceText;
            this.indent = indent;
            this.declarations = declarations;
            this.annotations = annotations;
            this.sum = sum;
            this.jointPosition = jointPosition;
            this.flags = flags;
            this.faultType = faultType;
        }
    }
    Truth.Line = Line;
    /**
     * A bit field enumeration used to efficiently store
     * meta data about a Line (or a Statement) object.
     */
    let LineFlags;
    (function (LineFlags) {
        LineFlags[LineFlags["none"] = 0] = "none";
        LineFlags[LineFlags["isRefresh"] = 1] = "isRefresh";
        LineFlags[LineFlags["isVacuous"] = 2] = "isVacuous";
        LineFlags[LineFlags["isComment"] = 4] = "isComment";
        LineFlags[LineFlags["isWhitespace"] = 8] = "isWhitespace";
        LineFlags[LineFlags["isDisposed"] = 16] = "isDisposed";
        LineFlags[LineFlags["isCruft"] = 32] = "isCruft";
        LineFlags[LineFlags["hasUri"] = 64] = "hasUri";
        LineFlags[LineFlags["hasTotalPattern"] = 128] = "hasTotalPattern";
        LineFlags[LineFlags["hasPartialPattern"] = 256] = "hasPartialPattern";
        LineFlags[LineFlags["hasPattern"] = 512] = "hasPattern";
    })(LineFlags = Truth.LineFlags || (Truth.LineFlags = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Stakes out starting and ending character positions
     * of subjects within a given region.
     */
    class BoundaryGroup {
        /** */
        constructor(boundaries) {
            this.entries = Object.freeze(boundaries.slice().sort((entryA, entryB) => {
                return entryA.offsetStart - entryB.offsetStart;
            }));
        }
        /** */
        *[Symbol.iterator]() {
            for (const entry of this.entries)
                yield entry;
        }
        /** */
        *eachSubject() {
            for (const entry of this.entries)
                yield entry.subject;
        }
        /** */
        inspect(offset) {
            for (const entry of this.entries)
                if (offset >= entry.offsetStart && offset <= entry.offsetEnd)
                    return entry.subject;
            return null;
        }
        /** */
        first() {
            for (const entry of this)
                return entry;
            return null;
        }
        /** Gets the number of entries defined in the bounds. */
        get length() {
            return this.entries.length;
        }
    }
    Truth.BoundaryGroup = BoundaryGroup;
    /** */
    class Boundary {
        constructor(offsetStart, offsetEnd, subject) {
            this.offsetStart = offsetStart;
            this.offsetEnd = offsetEnd;
            this.subject = subject;
        }
    }
    Truth.Boundary = Boundary;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Statement {
        /**
         * @internal
         */
        constructor(document, text) {
            /**
             * @internal
             * Logical clock value used to make chronological
             * creation-time comparisons between Statements.
             */
            this.stamp = Truth.VersionStamp.next();
            /** @internal */
            this.flags = Truth.LineFlags.none;
            this._infixSpans = Object.freeze([]);
            const line = Truth.LineParser.parse(text);
            this.document = document;
            this.sourceText = line.sourceText;
            this.sum = line.sum;
            this.indent = line.indent;
            this.flags = line.flags;
            this.jointPosition = line.jointPosition;
            this.allDeclarations = Object.freeze(Array.from(line.declarations)
                .map(boundary => new Truth.Span(this, boundary)));
            this.allAnnotations = Object.freeze(Array.from(line.annotations)
                .map(boundary => new Truth.Span(this, boundary)));
            const faults = [];
            const cruftObjects = new Set();
            if (line.faultType !== null)
                faults.push(new Truth.Fault(line.faultType, this));
            for (const fault of this.eachParseFault()) {
                if (fault.type.severity === 8 /* error */)
                    cruftObjects.add(fault.source);
                faults.push(fault);
            }
            for (const fault of faults)
                // Check needed to support the unit tests, the feed
                // fake document objects into the statement constructor.
                if (document.program && document.program.faults)
                    document.program.faults.report(fault);
            this.cruftObjects = cruftObjects;
            this.faults = Object.freeze(faults);
            this.programStamp = document.program ?
                document.program.version :
                Truth.VersionStamp.next();
        }
        /**
         *
         */
        *eachParseFault() {
            // Check for tabs and spaces mixture
            if (this.indent > 0) {
                let hasTabs = false;
                let hasSpaces = false;
                for (let i = -1; ++i < this.indent;) {
                    const chr = this.sourceText[i];
                    if (chr === "\t" /* tab */)
                        hasTabs = true;
                    if (chr === " " /* space */)
                        hasSpaces = true;
                }
                if (hasTabs && hasSpaces)
                    yield new Truth.Fault(Truth.Faults.TabsAndSpaces, this);
            }
            if (this.allDeclarations.length > 1) {
                const subjects = [];
                for (const span of this.allDeclarations) {
                    const subText = span.toString();
                    if (subjects.includes(subText))
                        yield new Truth.Fault(Truth.Faults.DuplicateDeclaration, span);
                    else
                        subjects.push(subText);
                }
            }
            if (this.allAnnotations.length > 0) {
                // This performs an expedient check for "ListIntrinsicExtendingList",
                // however, full type analysis is required to cover all cases where
                // this fault may be reported.
                const getListSpans = (spans) => spans.filter(span => {
                    const sub = span.boundary.subject;
                    return sub instanceof Truth.Identifier && sub.isList;
                });
                const lhsListSpans = getListSpans(this.allDeclarations);
                const rhsListSpans = getListSpans(this.allAnnotations);
                if (lhsListSpans.length > 0 && rhsListSpans.length > 0)
                    for (const span of rhsListSpans)
                        yield new Truth.Fault(Truth.Faults.ListIntrinsicExtendingList, span);
            }
            const pattern = (() => {
                if (this.allDeclarations.length === 0)
                    return null;
                const hp = Truth.LineFlags.hasPattern;
                if ((this.flags & hp) !== hp)
                    return null;
                const subject = this.allDeclarations[0].boundary.subject;
                return subject instanceof Truth.Pattern ?
                    subject :
                    null;
            })();
            if (pattern === null)
                return;
            if (!pattern.isValid) {
                yield new Truth.Fault(Truth.Faults.PatternInvalid, this);
                return;
            }
            if (this.allAnnotations.length === 0)
                yield new Truth.Fault(Truth.Faults.PatternWithoutAnnotation, this);
            if (pattern.test(""))
                yield new Truth.Fault(Truth.Faults.PatternCanMatchEmpty, this);
            if (!pattern.isTotal)
                for (const unit of pattern.eachUnit())
                    if (unit instanceof Truth.RegexGrapheme)
                        if (unit.grapheme === "," /* combinator */) {
                            yield new Truth.Fault(Truth.Faults.PatternPartialWithCombinator, this);
                            break;
                        }
            const patternSpan = this.allDeclarations[0];
            if (patternSpan.infixes.length === 0)
                return;
            const infixSpans = [];
            for (const infix of patternSpan.infixes) {
                const lhs = Array.from(patternSpan.eachDeclarationForInfix(infix));
                const rhs = Array.from(patternSpan.eachAnnotationForInfix(infix));
                const all = lhs.concat(rhs);
                // This is a bit out of place ... but we need to populate the
                // infixSpans array and this is probably the most efficient
                // place to do that.
                infixSpans.push(...all);
                for (const infixSpan of all)
                    if (infixSpan.boundary.subject.isList)
                        yield new Truth.Fault(Truth.Faults.InfixUsingListOperator, infixSpan);
                yield* dedupInfixSubjects(lhs);
                yield* dedupInfixSubjects(rhs);
                const lhsIdentifiers = lhs.map(nfxSpan => nfxSpan.boundary.subject.toString());
                for (const infixSpan of rhs)
                    if (lhsIdentifiers.includes(infixSpan.boundary.subject.toString()))
                        yield new Truth.Fault(Truth.Faults.InfixHasSelfReferentialType, infixSpan);
                if (infix.isPopulation)
                    for (let idx = 1; idx < lhs.length; idx++)
                        yield new Truth.Fault(Truth.Faults.InfixPopulationChaining, lhs[idx]);
                yield* expedientListCheck(lhs);
                yield* expedientListCheck(rhs);
            }
            for (const infixSpan of dedupInfixesAcrossInfixes(patternSpan, infix => patternSpan.eachDeclarationForInfix(infix))) {
                if (infixSpan.containingInfix.isPopulation)
                    yield new Truth.Fault(Truth.Faults.PopulationInfixHasMultipleDefinitions, infixSpan);
            }
            for (const infixSpan of dedupInfixesAcrossInfixes(patternSpan, infix => patternSpan.eachAnnotationForInfix(infix))) {
                if (infixSpan.containingInfix.isPortability)
                    yield new Truth.Fault(Truth.Faults.PortabilityInfixHasMultipleDefinitions, infixSpan);
            }
            this._infixSpans = Object.freeze(infixSpans);
        }
        /**
         * Gets whether the joint operator exists at the
         * end of the statement, forcing the statement's
         * declarations to be "refresh types".
         */
        get isRefresh() {
            const f = Truth.LineFlags.isRefresh;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement contains nothing
         * other than a single joint operator.
         */
        get isVacuous() {
            const f = Truth.LineFlags.isVacuous;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement is a comment.
         */
        get isComment() {
            const f = Truth.LineFlags.isComment;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement contains
         * no non-whitespace characters.
         */
        get isWhitespace() {
            const f = Truth.LineFlags.isWhitespace;
            return (this.flags & f) === f;
        }
        /**
         * Gets whether the statement is a comment or whitespace.
         */
        get isNoop() {
            return this.isComment || this.isWhitespace;
        }
        /**
         * Gets whether the statement has been removed from it's
         * containing document. Removal occurs after the statement
         * has been invalidated. Therefore, this property will be false
         * before the invalidation phase has occured, even if it will be
         * disposed in the current edit transaction.
         */
        get isDisposed() {
            const f = Truth.LineFlags.isDisposed;
            return (this.flags & f) === f;
        }
        /**
         *
         */
        get isCruft() {
            const f = Truth.LineFlags.isCruft;
            return (this.flags & f) === f;
        }
        /**
         * Gets the line number of this statement in it's containing
         * document, or -1 if the statement is disposed and/or is not
         * in the document.
         */
        get index() {
            if (this.isDisposed)
                return -1;
            return this.document instanceof Truth.Document ?
                this.document.getLineNumber(this) :
                -1;
        }
        /**
         * Gets an array of spans in that represent the declarations
         * of this statement, excluding those that have been marked
         * as object-level cruft.
         */
        get declarations() {
            if (this.cruftObjects.size === 0)
                return this.allDeclarations;
            const out = [];
            for (const span of this.allDeclarations)
                if (!this.cruftObjects.has(span))
                    out.push(span);
            return Object.freeze(out);
        }
        /**
         * Gets a list of all infixes defined in the pattern of this statement.
         */
        get infixSpans() {
            return this._infixSpans;
        }
        /**
         * Gets an array of spans in that represent the annotations
         * of this statement, from left to right, excluding those that
         * have been marked as object-level cruft.
         */
        get annotations() {
            if (this.cruftObjects.size === 0)
                return this.allAnnotations;
            const out = [];
            for (const span of this.allAnnotations)
                if (!this.cruftObjects.has(span))
                    out.push(span);
            return Object.freeze(out);
        }
        /**
         * Gets an array of spans in that represent both the declarations
         * and the annotations of this statement, excluding those that have
         * been marked as object-level cruft.
         */
        get spans() {
            return this.isCruft ?
                [] :
                this.declarations.concat(this.annotations);
        }
        /**
         *
         */
        get allSpans() {
            return this.declarations.concat(this.annotations);
        }
        /**
         * Gets a boolean value indicating whether or not the
         * statement contains a declaration of a pattern.
         */
        get hasPattern() {
            const d = this.allDeclarations;
            return d.length === 1 && d[0].boundary.subject instanceof Truth.Pattern;
        }
        /**
         * @internal
         * Marks the statement as being removed from it's containing document.
         */
        dispose() {
            this.flags = this.flags | Truth.LineFlags.isDisposed;
        }
        /**
         * @returns The kind of StatementRegion that exists
         * at the given character offset within the Statement.
         */
        getRegion(offset) {
            if (this.isComment || offset < this.indent || this.isCruft)
                return StatementRegion.void;
            if (this.isWhitespace)
                return StatementRegion.whitespace;
            if (this.hasPattern) {
                const bnd = this.allDeclarations[0].boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return StatementRegion.pattern;
            }
            if (offset <= this.jointPosition || this.jointPosition < 0) {
                for (const span of this.allDeclarations) {
                    const bnd = span.boundary;
                    if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                        return StatementRegion.declaration;
                }
                return StatementRegion.declarationVoid;
            }
            for (const span of this.allAnnotations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return StatementRegion.annotation;
            }
            return StatementRegion.annotationVoid;
        }
        /**
         *
         */
        getSubject(offset) {
            return this.getDeclaration(offset) || this.getAnnotation(offset);
        }
        /**
         * @returns A span to the declaration subject at the
         * specified offset, or null if there is none was found.
         */
        getDeclaration(offset) {
            for (const span of this.declarations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return span;
            }
            return null;
        }
        /**
         * @returns A span to the annotation subject at the
         * specified offset, or null if there is none was found.
         */
        getAnnotation(offset) {
            for (const span of this.annotations) {
                const bnd = span.boundary;
                if (offset >= bnd.offsetStart && offset <= bnd.offsetEnd)
                    return span;
            }
            return null;
        }
        /**
         * @returns A string containing the inner comment text of
         * this statement, excluding the comment syntax token.
         * If the statement isn't a comment, an empty string is returned.
         */
        getCommentText() {
            return this.isComment ?
                this.sourceText.slice(this.indent + "//" /* comment */.length).trim() :
                "";
        }
        /**
         * Converts the statement to a formatted string representation.
         */
        toString(includeIndent = false) {
            const serializeSpans = (spans, escStyle) => {
                return spans
                    .filter(sp => !(sp.boundary.subject instanceof Truth.Anon))
                    .map(sp => Truth.SubjectSerializer.forExternal(sp, escStyle))
                    .join("," /* combinator */ + " " /* space */);
            };
            const indent = includeIndent ? "\t" /* tab */.repeat(this.indent) : "";
            if (this.isCruft)
                return indent + "(cruft)";
            if (this.isWhitespace)
                return indent;
            if (this.isVacuous)
                return indent + ":" /* joint */;
            const decls = serializeSpans(this.allDeclarations, 1 /* declaration */);
            const annos = serializeSpans(this.allAnnotations, 2 /* annotation */);
            const joint = annos.length > 0 || this.isRefresh ? ":" /* joint */ : "";
            const jointL = decls.length > 0 && joint !== "" ? " " /* space */ : "";
            const jointR = annos.length > 0 ? " " /* space */ : "";
            return indent + decls + jointL + joint + jointR + annos;
        }
    }
    Truth.Statement = Statement;
    /**
     * Defines the areas of a statement that are significantly
     * different when performing inspection.
     */
    let StatementRegion;
    (function (StatementRegion) {
        /**
         * Refers to the area within a comment statement,
         * or the whitespace preceeding a non-no-op.
         */
        StatementRegion[StatementRegion["void"] = 0] = "void";
        /**
         * Refers to the area in the indentation area.
         */
        StatementRegion[StatementRegion["whitespace"] = 1] = "whitespace";
        /**
         * Refers to the
         */
        StatementRegion[StatementRegion["pattern"] = 2] = "pattern";
        /** */
        StatementRegion[StatementRegion["declaration"] = 3] = "declaration";
        /** */
        StatementRegion[StatementRegion["annotation"] = 4] = "annotation";
        /** */
        StatementRegion[StatementRegion["declarationVoid"] = 5] = "declarationVoid";
        /** */
        StatementRegion[StatementRegion["annotationVoid"] = 6] = "annotationVoid";
    })(StatementRegion = Truth.StatementRegion || (Truth.StatementRegion = {}));
    /**
     * Yields faults on infix spans in the case when an identifier
     * has been re-declared multiple times within the same infix.
     */
    function* dedupInfixSubjects(side) {
        if (side.length === 0)
            return;
        const subjects = [];
        for (const nfxSpan of side) {
            const subText = nfxSpan.boundary.subject.toString();
            if (subjects.includes(subText)) {
                yield new Truth.Fault(Truth.Faults.InfixHasDuplicateIdentifier, nfxSpan);
            }
            else
                subjects.push(subText);
        }
    }
    /**
     * Yields faults on infix spans in the case when an identifier
     * has been re-declared multiple times across the infixes.
     */
    function* dedupInfixesAcrossInfixes(span, infixFn) {
        const identifiers = [];
        for (const infix of span.infixes) {
            const infixSpans = Array.from(infixFn(infix));
            for (const infixSpan of infixSpans) {
                const text = infixSpan.boundary.subject.toString();
                if (identifiers.includes(text)) {
                    yield infixSpan;
                }
                else
                    identifiers.push(text);
            }
        }
    }
    /**
     * Yields when successive equivalent instances are discovered
     * in the specified iterator.
     */
    function* dedup(iterator, equalityFn) {
        const yielded = [];
        for (const item of iterator) {
            if (yielded.includes(item))
                yield item;
            else
                yielded.push(item);
        }
    }
    /**
     * Performs a quick and dirty check to see if the infix is referencing
     * a list, by looking to see if it has the list operator. A full check needs
     * to perform type inspection to see if any of the types that correspond
     * to the identifiers specified are actually lists.
     */
    function* expedientListCheck(side) {
        if (side.length === 0)
            return;
        for (const nfxSpan of side)
            if (nfxSpan.boundary.subject.isList)
                yield new Truth.Fault(Truth.Faults.InfixUsingListOperator, nfxSpan);
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Pattern {
        /** @internal */
        constructor(
        /**
         *
         */
        units, 
        /**
         * Stores whether the pattern is considered to be "Total"
         * or "Partial". Total patterns must match an entire annotation
         * set (the entire strip of content to the right of a joint, after
         * being trimmed). Partial patterns match individually
         * specified subjects (separated by commas).
         */
        isTotal, 
        /**
         * Stores a hash which is computed from the set of
         * annotations specified to the right of the pattern.
         */
        hash) {
            this.units = units;
            this.isTotal = isTotal;
            this.hash = hash;
            /** */
            this.compiledRegExp = null;
            this.compiledRegExp = Truth.PatternPrecompiler.exec(this);
            this.isValid = this.compiledRegExp instanceof RegExp;
        }
        /**
         * Recursively enumerates through this Pattern's unit structure.
         */
        *eachUnit() {
            function* recurse(units) {
                for (const unit of units) {
                    yield unit;
                    if (unit instanceof Truth.RegexGroup)
                        for (const unitCase of unit.cases)
                            recurse(unitCase);
                }
            }
            yield* recurse(this.units);
        }
        /**
         * @returns A boolean value that indicates whether
         * this Pattern has at least one infix, of any type.
         */
        hasInfixes() {
            return this.units.some(u => u instanceof Truth.Infix);
        }
        /**
         * @returns An array containing the infixes of the
         * specified type that are defined in this Pattern.
         * If the argument is omitted, all infixes of any type
         * defined on this Pattern are returned.
         */
        getInfixes(type = Truth.InfixFlags.none) {
            return this.units
                .filter((u) => u instanceof Truth.Infix)
                .filter(nfx => (nfx.flags & type) === type);
        }
        /**
         * Performs an "expedient" test that determines whether the
         * specified input has a chance of being matched by this pattern.
         * The check is considered expedient, rather than thorough,
         * because any infixes that exist in this pattern are replaced
         * with "catch all" regular expression sequence, rather than
         * embedding the pattern associated with the type specified
         * in the infix.
         */
        test(input) {
            const regExp = this.compiledRegExp;
            if (regExp === null)
                return false;
            const inputTrimmed = input.trim();
            if (inputTrimmed === "")
                return false;
            return regExp.test(input);
        }
        /**
         * Executes the pattern (like a function) using the specified
         * string as the input.
         *
         * @returns A ReadonlyMap whose keys align with the infixes
         * contained in this Pattern, and whose values are strings that
         * are the extracted "inputs", found in the place of each infix.
         * If this Pattern has no infixes, an empty map is returned.
         */
        exec(patternParameter) {
            const regExp = this.compiledRegExp;
            if (regExp === null)
                return new Map();
            const result = new Map();
            const infixes = this.getInfixes();
            if (this.getInfixes().length === 0)
                return result;
            const infixCaptureGroupIndexes = (() => {
                const idxArray = [];
                let idx = 0;
                for (const unit of this.eachUnit()) {
                    if (unit instanceof Truth.Infix)
                        idxArray.push(++idx);
                    if (unit instanceof Truth.RegexGroup)
                        idx++;
                }
                ///Make sure the above produces the same behavior before deleting
                ///const recurseUnits = (units: readonly (RegexUnit | Infix>)[]) =>
                ///{
                ///	for (const unit of units)
                ///	{
                ///		if (unit instanceof Infix)
                ///		{
                ///			idxArray.push(++idx);
                ///		}
                ///		else if (unit instanceof RegexGroup)
                ///		{
                ///			++idx;
                ///			for (const unitCase of unit.cases)
                ///				recurseUnits(unitCase);
                ///		}
                ///	}
                ///}
                ///recurseUnits(this.units);
                return idxArray;
            })();
            const reg = new RegExp(regExp.source, regExp.flags);
            const matches = reg.exec(patternParameter);
            if (matches === null)
                return result;
            for (const [idx, infix] of infixes.entries())
                result.set(infix, matches[infixCaptureGroupIndexes[idx]]);
            return result;
        }
        /**
         * Converts this Pattern to a string representation.
         * (Note that the serialized pattern cannot be used
         * as a parameter to a JavaScript RegExp object.)
         *
         * @param includeHashPrefix If true, the Pattern's hash
         * prefix will be prepended to the serialized result.
         */
        toString(includeHashPrefix) {
            const prefix = includeHashPrefix ? escape(this.hash) : "";
            const delim = "/" /* main */.toString();
            return delim + prefix +
                this.units.map(u => u.toString()).join("") +
                (this.isTotal ? delim : "");
        }
    }
    Truth.Pattern = Pattern;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    class PatternPrecompiler {
        /**
         * Compiles the specified pattern into a JS-native
         * RegExp object that can be used to execute regular
         * expression pre-matching (i.e. checks that essentially
         * ignore any infixes that the pattern may have).
         */
        static exec(pattern) {
            const result = [];
            for (const unit of pattern.units) {
                if (unit instanceof Truth.RegexGrapheme) {
                    if (MustEscapeChars.includes(unit.grapheme))
                        result.push("\\" /* escapeChar */ + unit.grapheme);
                    else
                        result.push(unit.grapheme);
                    if (unit.quantifier)
                        result.push(unit.quantifier.toString());
                }
                else if (unit instanceof Truth.Infix) {
                    result.push(ExpedientInfixPattern);
                }
                else {
                    result.push(unit.toString());
                }
            }
            result.unshift("^");
            result.push("$");
            const regText = result.join("");
            try {
                return new RegExp(regText, "u");
            }
            catch (e) {
                return null;
            }
        }
    }
    Truth.PatternPrecompiler = PatternPrecompiler;
    /**
     * Stores the list of characters that must be escaped
     * in order for the Truth regular expression flavor to
     * be compatible with the engine build into JavaScript.
     */
    const MustEscapeChars = ["$", "^", "{", "}"];
    /**
     * Stores the pattern that is fed into a pattern in
     * place of where infixes are, in order to be able to
     * do early tests on the regular expression without
     * doing a full resolution of the types that the infixes
     * reference. The pattern essentially means:
     *
     * "Match one non-whitespace character, or a series
     * of characters, provided that the string of characters
     * don't begin or end with whitespace."
     */
    const ExpedientInfixPattern = "(\\S+(\\s+\\S+)*)";
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * Ambient unifier for all PatternUnit instances
     */
    class RegexUnit {
        constructor(quantifier) {
            this.quantifier = quantifier;
        }
    }
    Truth.RegexUnit = RegexUnit;
    /**
     *
     */
    class RegexSet extends RegexUnit {
        /** */
        constructor(knowns, ranges, unicodeBlocks, singles, isNegated, quantifier) {
            super(quantifier);
            this.knowns = knowns;
            this.ranges = ranges;
            this.unicodeBlocks = unicodeBlocks;
            this.singles = singles;
            this.isNegated = isNegated;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const kLen = this.knowns.length;
            const rLen = this.ranges.length;
            const uLen = this.unicodeBlocks.length;
            const cLen = this.singles.length;
            const setText = (() => {
                if (kLen === 1 && rLen + uLen + cLen === 0)
                    return this.knowns[0].toString();
                if (uLen === 1 && kLen + rLen + cLen === 0)
                    return [
                        "[" /* setStart */ +
                            serializeUnicodeBlock(this.unicodeBlocks[0]) +
                            "]" /* setEnd */
                    ].join("");
                if (cLen === 1 && kLen + rLen + uLen === 0)
                    return this.singles[0];
                return [
                    "[" /* setStart */,
                    ...this.knowns,
                    ...this.ranges.map(r => esc(r.from) + "-" + esc(r.to)),
                    ...this.unicodeBlocks.map(serializeUnicodeBlock),
                    ...escMany(this.singles),
                    "]" /* setEnd */
                ].join("");
            })();
            return setText + (this.quantifier ? this.quantifier.toString() : "");
        }
        /**
         * @internal
         */
        toAlphabet() {
            const alphabetBuilder = new Truth.AlphabetBuilder();
            const gt = (char) => char.charCodeAt(0) + 1;
            const lt = (char) => char.charCodeAt(0) - 1;
            for (const known of this.knowns) {
                switch (known) {
                    case Truth.RegexSyntaxKnownSet.digit:
                        alphabetBuilder.add("0", "9");
                        break;
                    case Truth.RegexSyntaxKnownSet.digitNon:
                        alphabetBuilder.add(0, lt("0"));
                        alphabetBuilder.add(gt("9"), Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.alphanumeric:
                        alphabetBuilder.add("0", "9");
                        alphabetBuilder.add("A", "Z");
                        alphabetBuilder.add("a", "z");
                        break;
                    case Truth.RegexSyntaxKnownSet.alphanumericNon:
                        alphabetBuilder.add(0, lt("0"));
                        alphabetBuilder.add(gt("9"), lt("A"));
                        alphabetBuilder.add(gt("Z"), lt("a"));
                        alphabetBuilder.add(gt("z"), Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.whitespace:
                        alphabetBuilder.add(9, 13);
                        alphabetBuilder.add(160);
                        alphabetBuilder.add(5760);
                        alphabetBuilder.add(8192, 8202);
                        alphabetBuilder.add(8232);
                        alphabetBuilder.add(8233);
                        alphabetBuilder.add(8239);
                        alphabetBuilder.add(8287);
                        alphabetBuilder.add(12288);
                        alphabetBuilder.add(65279);
                        break;
                    case Truth.RegexSyntaxKnownSet.whitespaceNon:
                        alphabetBuilder.add(0, 8);
                        alphabetBuilder.add(14, 159);
                        alphabetBuilder.add(161, 5759);
                        alphabetBuilder.add(5761, 8191);
                        alphabetBuilder.add(8203, 8231);
                        alphabetBuilder.add(8232);
                        alphabetBuilder.add(8233);
                        alphabetBuilder.add(8234, 8238);
                        alphabetBuilder.add(8240, 8286);
                        alphabetBuilder.add(8288, 12287);
                        alphabetBuilder.add(12289, 65278);
                        alphabetBuilder.add(65280, Truth.UnicodeMax);
                        break;
                    case Truth.RegexSyntaxKnownSet.wild:
                        alphabetBuilder.addWild();
                        break;
                }
            }
            for (const range of this.ranges)
                alphabetBuilder.add(range.from, range.to);
            for (const single of this.singles)
                alphabetBuilder.add(single);
            return alphabetBuilder.toAlphabet(this.isNegated);
        }
    }
    Truth.RegexSet = RegexSet;
    /**
     *
     */
    class RegexCharRange {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
    }
    Truth.RegexCharRange = RegexCharRange;
    /**
     *
     */
    class RegexGroup extends RegexUnit {
        constructor(
        /**
         *
         */
        cases, quantifier) {
            super(quantifier);
            this.cases = cases;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            if (this.cases.length === 0)
                return "";
            const start = "(" /* groupStart */;
            const mid = this.cases
                .map(ca => ca.map(unit => esc(unit.toString())).join(""))
                .join("|" /* alternator */);
            const end = ")" /* groupEnd */;
            const quant = this.quantifier ? this.quantifier.toString() : "";
            return start + mid + end + quant;
        }
    }
    Truth.RegexGroup = RegexGroup;
    /**
     * A pattern "grapheme" is a pattern unit class that
     * represents:
     *
     * a) A "Literal", which is a single unicode-aware character,
     * with possible representations being an ascii character,
     * a unicode character, or an ascii or unicode escape
     * sequence.
     *
     * or b) A "Special", which is a sequence that matches
     * something other than the character specified,
     * such as . \b \s
     */
    class RegexGrapheme extends RegexUnit {
        constructor(grapheme, quantifier) {
            super(quantifier);
            this.grapheme = grapheme;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const q = this.quantifier;
            const qEsc = q === null ? "" : esc(q.toString());
            const g = this.grapheme.toString();
            return escapableGraphemes.includes(g) ?
                "\\" + g + qEsc :
                g + qEsc;
        }
    }
    Truth.RegexGrapheme = RegexGrapheme;
    /** */
    const escapableGraphemes = [
        "*" /* star */,
        "+" /* plus */,
        "^" /* negate */,
        "?" /* restrained */,
        "(" /* groupStart */,
        ")" /* groupEnd */,
        "|" /* alternator */,
        "[" /* setStart */,
        "]" /* setEnd */,
        "{" /* quantifierStart */,
        "}" /* quantifierEnd */
    ];
    /**
     * A Regex "Sign" refers to an escape sequence that refers
     * to one other character, as opposed to that character
     * being written directly in the parse stream.
     */
    class RegexSign extends RegexUnit {
        constructor(sign, quantifier) {
            super(quantifier);
            this.sign = sign;
            this.quantifier = quantifier;
        }
        /** */
        toString() {
            const q = this.quantifier;
            return this.sign.toString() + (q === null ? "" : esc(q.toString()));
        }
    }
    Truth.RegexSign = RegexSign;
    /**
     * A pattern unit class that represents +, *,
     * and explicit quantifiers such as {1,2}.
     */
    class RegexQuantifier {
        constructor(
        /**
         * Stores the lower bound of the quantifier,
         * or the fewest number of graphemes to be matched.
         */
        min = 0, 
        /**
         * Stores the upper bound of the quantifier,
         * or the most number of graphemes to be matched.
         */
        max = Infinity, 
        /**
         * Stores whether the the quantifier is restrained,
         * in that it matches the fewest possible number
         * of characters.
         *
         * (Some regular expression flavours awkwardly
         * refer to this as "non-greedy".)
         */
        restrained) {
            this.min = min;
            this.max = max;
            this.restrained = restrained;
        }
        /**
         * Converts the regex quantifier to an optimized string.
         */
        toString() {
            const rst = this.restrained ? "?" /* restrained */ : "";
            if (this.min === 0 && this.max === Infinity)
                return "*" /* star */ + rst;
            if (this.min === 1 && this.max === Infinity)
                return "+" /* plus */ + rst;
            if (this.min === 0 && this.max === 1)
                return "?" /* restrained */;
            const qs = "{" /* quantifierStart */;
            const qp = "," /* quantifierSeparator */;
            const qe = "}" /* quantifierEnd */;
            return this.min === this.max ?
                qs + this.min + qe :
                qs + this.min + qp + (this.max === Infinity ? "" : this.max.toString()) + qe;
        }
    }
    Truth.RegexQuantifier = RegexQuantifier;
    /**
     * Utility function that returns a double escape
     * if the passed value is a backslash.
     */
    function esc(maybeBackslash) {
        if (maybeBackslash === 92 || maybeBackslash === "\\")
            return "\\\\";
        if (typeof maybeBackslash === "number")
            return String.fromCodePoint(maybeBackslash);
        return maybeBackslash;
    }
    /**
     *
     */
    function escMany(array) {
        return array.map(esc).join("");
    }
    /**
     *
     */
    function serializeUnicodeBlock(blockName) {
        const block = Truth.UnicodeBlocks.get(blockName.toLowerCase());
        if (block === undefined)
            throw Truth.Exception.unknownState();
        const rng = "-" /* range */;
        const from = block[0].toString(16);
        const to = block[1].toString(16);
        return `\\u{${from}}${rng}\\u{${to}}`;
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a portion of the content
     * within an Infix that spans a type reference.
     */
    class Infix {
        constructor(
        /**
         * Stores the left-most character position of the Infix
         * (before the delimiter), relative to the containing statement.
         */
        offsetStart, 
        /**
         * Stores the left-most character position of the Infix
         * (after the delimiter), relative to the containing statement.
         */
        offsetEnd, 
        /**
         * Stores the Bounds object that marks out the positions
         * of the identifiers in the Infix that are located before
         * any Joint operator.
         */
        lhs, 
        /**
         * Stores the Bounds object that marks out the positions
         * of the identifiers in the Infix that are located after
         * any Joint operator.
         */
        rhs, 
        /** */
        flags) {
            this.offsetStart = offsetStart;
            this.offsetEnd = offsetEnd;
            this.lhs = lhs;
            this.rhs = rhs;
            this.flags = flags;
        }
        /**
         * Gets whether this Infix is of the "pattern" variety.
         */
        get isPattern() {
            return (this.flags & InfixFlags.pattern) === InfixFlags.pattern;
        }
        /**
         * Gets whether this Infix is of the "portability" variety.
         */
        get isPortability() {
            return (this.flags & InfixFlags.portability) === InfixFlags.portability;
        }
        /**
         * Gets whether this Infix is of the "population" variety.
         */
        get isPopulation() {
            return (this.flags & InfixFlags.population) === InfixFlags.population;
        }
        /**
         * Gets whether this Infix has the "nominal" option set.
         */
        get isNominal() {
            return (this.flags & InfixFlags.nominal) === InfixFlags.nominal;
        }
        /** */
        toString() {
            const delimL = this.isPattern ? "</" /* patternStart */ :
                this.isNominal ? "<<" /* nominalStart */ :
                    this.isPortability ? "<" /* start */ + " " /* space */ + ":" /* joint */ + " " /* space */ :
                        "<" /* start */;
            const delimR = this.isPattern ? "/>" /* patternEnd */ :
                this.isNominal ? ">>" /* nominalEnd */ :
                    ">" /* end */;
            const join = (spans) => Array.from(spans)
                .map(entry => entry.subject)
                .join("," /* combinator */ + " " /* space */);
            if (this.isPortability)
                return join(this.rhs);
            if (this.isPattern)
                return join(this.lhs);
            const joint = this.rhs.length > 0 ?
                " " /* space */ + ":" /* joint */ + " " /* space */ :
                "";
            return delimL + join(this.lhs) + joint + join(this.rhs) + delimR;
        }
    }
    Truth.Infix = Infix;
    /**
     *
     */
    let InfixFlags;
    (function (InfixFlags) {
        InfixFlags[InfixFlags["none"] = 0] = "none";
        /**
         * Indicates that the joint was specified within
         * the infix. Can be used to determine if the infix
         * contains some (erroneous) syntax resembing
         * a refresh type, eg - /<Type : >/
         */
        InfixFlags[InfixFlags["hasJoint"] = 1] = "hasJoint";
        /**
         * Indicates that the </Pattern/> syntax was
         * used to embed the patterns associated
         * with a specified type.
         */
        InfixFlags[InfixFlags["pattern"] = 2] = "pattern";
        /**
         * Indicates that the infix is of the "portabiity"
         * variety, using the syntax < : Type>
         */
        InfixFlags[InfixFlags["portability"] = 4] = "portability";
        /**
         * Indicates that the infix is of the "popuation"
         * variety, using the syntax <Declaration : Annotation>
         * or <Declaration>
         */
        InfixFlags[InfixFlags["population"] = 8] = "population";
        /**
         * Indicates that the <<Double>> angle bracket
         * syntax was used to only match named types,
         * rather than aliases.
         */
        InfixFlags[InfixFlags["nominal"] = 16] = "nominal";
    })(InfixFlags = Truth.InfixFlags || (Truth.InfixFlags = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a single subject in a Statement.
     * Consumers of this class should not expect Subject objects
     * to be long-lived, as they are discarded regularly after edit
     * transactions complete.
     */
    class Identifier {
        /** */
        constructor(text) {
            const listTok = "..." /* list */;
            const tokLen = listTok.length;
            this.isList = text.length > tokLen + 1 && text.slice(-tokLen) === listTok;
            this.fullName = text;
            this.typeName = this.isList ? text.slice(0, -tokLen) : text;
        }
        /**
         * Converts this Subject to it's string representation.
         * @param escape If true, preserves any necessary
         * escaping required to ensure the identifier string
         * is in a parsable format.
         */
        toString(escape = 0 /* none */) {
            const val = (() => {
                switch (escape) {
                    case 0 /* none */:
                        return this.typeName;
                    case 1 /* declaration */:
                        {
                            // Regex delimiters are escaped if and only if 
                            // they're the first character in an Identifier.
                            const dlmReg = new RegExp("^" + "/" /* main */);
                            const jntRegS = new RegExp(":" /* joint */ + " " /* space */);
                            const jntRegT = new RegExp(":" /* joint */ + "\t" /* tab */);
                            const cmbReg = new RegExp("," /* combinator */);
                            return this.typeName
                                .replace(dlmReg, "\\" /* escapeChar */ + "/" /* main */)
                                .replace(jntRegS, "\\" /* escapeChar */ + ":" /* joint */ + " " /* space */)
                                .replace(jntRegT, "\\" /* escapeChar */ + ":" /* joint */ + "\t" /* tab */)
                                .replace(cmbReg, "\\" /* escapeChar */ + "," /* combinator */);
                        }
                    case 2 /* annotation */:
                        {
                            const reg = new RegExp("," /* combinator */);
                            const rep = "\\" /* escapeChar */ + "," /* combinator */;
                            return this.typeName.replace(reg, rep);
                        }
                }
            })();
            return val + (this.isList ? "..." /* list */ : "");
        }
    }
    Truth.Identifier = Identifier;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a position in a statement.
     */
    class Span {
        /**
         * @internal
         */
        constructor(
        /**
         * Stores a reference to the Statement that contains this Span.
         */
        statement, 
        /**
         * Stores the subject, and the location of it in the document.
         */
        boundary) {
            this.statement = statement;
            this.boundary = boundary;
            /**
             * @internal
             * Logical clock value used to make chronological
             * creation-time comparisons between Spans.
             */
            this.stamp = Truth.VersionStamp.next();
            this._infixes = null;
            /** */
            this.infixSpanTable = new Map();
            this._ancestry = null;
            /**  */
            this.factoredSpines = null;
            this.name =
                Truth.SubjectSerializer.forInternal(boundary) +
                    ` (${boundary.offsetStart}, ${boundary.offsetEnd})`;
        }
        /**
         * Gets the Infixes stored within this Span, in the case when
         * the Span corresponds to a Pattern. In other cases, and
         * empty array is returned.
         */
        get infixes() {
            return this._infixes || (this._infixes = Object.freeze((() => {
                return this.boundary.subject instanceof Truth.Pattern ?
                    Array.from(this.boundary.subject.getInfixes()) :
                    [];
            })()));
        }
        /** */
        *eachDeclarationForInfix(infix) {
            if (!this.infixes.includes(infix))
                throw Truth.Exception.invalidCall();
            const { lhs } = this.queryInfixSpanTable(infix);
            for (const infixSpan of lhs)
                yield infixSpan;
        }
        /** */
        *eachAnnotationForInfix(infix) {
            if (!this.infixes.includes(infix))
                throw Truth.Exception.invalidCall();
            const { rhs } = this.queryInfixSpanTable(infix);
            for (const infixSpan of rhs)
                yield infixSpan;
        }
        /** */
        queryInfixSpanTable(infix) {
            return this.infixSpanTable.get(infix) || (() => {
                const lhs = [];
                const rhs = [];
                for (const boundary of infix.lhs)
                    lhs.push(new Truth.InfixSpan(this, infix, boundary));
                for (const boundary of infix.rhs)
                    rhs.push(new Truth.InfixSpan(this, infix, boundary));
                return { lhs, rhs };
            })();
        }
        /**
         * Gets an array of statements that represent the statement
         * containment progression, all the way back to the containing
         * document.
         */
        get ancestry() {
            if (this._ancestry)
                if (this._ancestry.every(smt => !smt.isDisposed))
                    return this._ancestry;
            // If the ancestry has no yet been computed, or it has, but at least of
            // it's statements have been disposed, then it must be recomputed.
            this._ancestry = this.statement.document.getAncestry(this.statement);
            if (!this._ancestry)
                throw Truth.Exception.unknownState();
            return this._ancestry;
        }
        /**
         * Splits apart the groups subjects specified in the containing
         * statement's ancestry, and generates a series of spines,
         * each indicating a separate pathway of declarations through
         * the ancestry that reach the location in the document
         * referenced by this global span object.
         *
         * The generated spines are referentially opaque. Running this
         * method on the same Span object always returns the same
         * Spine instance.
         */
        factor() {
            if (this.factoredSpines)
                return this.factoredSpines;
            if (this.isCruft || this.statement.isCruft)
                return this.factoredSpines = Object.freeze([]);
            if (this.ancestry.length === 0)
                return this.factoredSpines = Object.freeze([new Truth.Spine([this])]);
            // We need to factor the ancestry. This means we're taking the
            // specified ancestry path, and splitting where any has-a side unions
            // exist, in effect creating all possible paths to the specified tip.
            // It's possible to have statements in the span path in the case
            // when the statement has been deemed as cruft, and therefore,
            // is impossible to extract any spans from it.
            const factoredSpanPaths = [];
            // An array of arrays. The first dimension corresponds to a statement. 
            // The second dimension stores the declaration spans themselves.
            const ancestryMatrix = this.ancestry.map(smt => Array.from(smt.declarations));
            // An array that stores the number of declaration spans in each statement.
            const ancestryLengths = ancestryMatrix.map(span => span.length);
            // Multiplying together the number of spans in each statement will
            // give the total number of unique spines that will be produced.
            const numSpines = ancestryLengths.reduce((a, b) => a * b, 1);
            // Start with an array of 0's, whose length matches the number
            // of statements in the ancestry. Each number in this array will be 
            // incremented by 1, from right to left, each number maxing out at
            // the number of declarations in the ancestor. After each incrementation,
            // the progression of numbers will run through all indexes required to
            // perform a full factorization of the terms in the ancestry. This array
            // tells the algorithm which indexes in ancestryMatrix to pull when
            // constructing a spine.
            const cherryPickIndexes = ancestryLengths.map(() => 0);
            // Stores the position in cherryPickIndexes that we're currently
            // incrementing. Moves backward when the number at 
            // the target position is >= the number of terms at that position.
            let targetIncLevel = 0;
            for (let i = -1; ++i < numSpines;) {
                // Do an insertion at the indexes specified by insertionIndexes
                const spanPath = [];
                // Cherry pick a series of terms from the ancestry terms,
                // according to the index set we're currently on.
                for (let level = -1; ++level < this.ancestry.length;) {
                    const statement = this.ancestry[level];
                    if (statement.isCruft) {
                        spanPath.push(statement);
                        continue;
                    }
                    const spansForStatement = ancestryMatrix[level];
                    const spanIndex = cherryPickIndexes[level];
                    const span = spansForStatement[spanIndex];
                    if (!span)
                        throw Truth.Exception.unknownState();
                    spanPath.push(span);
                }
                // The tip span specified in the method arguments
                // is added at the end of all generated span paths.
                spanPath.push(this);
                factoredSpanPaths.push(spanPath);
                // Bump up the current cherry pick index, 
                // or if we hit the roof, move to the next level,
                // and keep doing this until we find a number
                // to increment.
                while (cherryPickIndexes[targetIncLevel] >= ancestryLengths[targetIncLevel] - 1)
                    targetIncLevel++;
                cherryPickIndexes[targetIncLevel]++;
            }
            return this.factoredSpines =
                Object.freeze(factoredSpanPaths.map(spanPath => new Truth.Spine(spanPath)));
        }
        /**
         * Gets a boolean value that indicates whether this Span is considered
         * object-level cruft, and should therefore be ignored during type analysis.
         */
        get isCruft() {
            return this.statement.cruftObjects.has(this);
        }
        /**
         * Converts this Span to a string representation.
         *
         * @param includeHashPrefix If the subject inside this Span is a
         * Pattern, and this argument is true, the Pattern's hash prefix
         * will be prepended to the serialized result.
         */
        toString(includeHashPrefix) {
            const sub = this.boundary.subject;
            return sub instanceof Truth.Pattern ?
                sub.toString(!!includeHashPrefix) :
                sub.toString();
        }
    }
    Truth.Span = Span;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that manages an array of Span objects that
     * represent a specific spine of declarations, starting at
     * a document, passing through a series of spans,
     * and ending at a tip span.
     */
    class Spine {
        /** */
        constructor(vertebrae) {
            /** Stores an array of the Spans that compose the Spine. */
            this.vertebrae = [];
            if (vertebrae.length === 0)
                throw Truth.Exception.invalidCall();
            this.vertebrae = vertebrae.map(v => {
                if (v instanceof Truth.Span)
                    return v;
                const existCruftMarker = CruftMarkers.get(v);
                if (existCruftMarker !== undefined)
                    return existCruftMarker;
                const newCruftMarker = new CruftMarker(v);
                CruftMarkers.set(v, newCruftMarker);
                return newCruftMarker;
            });
            const tip = this.vertebrae[vertebrae.length - 1];
            if (tip instanceof CruftMarker)
                throw Truth.Exception.invalidCall();
            this.tip = tip;
        }
        /** */
        get statement() { return this.tip.statement; }
        /** Gets a reference to the document that sits at the top of the spine. */
        get document() { return this.statement.document; }
    }
    Truth.Spine = Spine;
    /**
     * A class that acts as a stand-in for a statement that has been
     * marked as cruft, suitable for usage in a Spine.
     */
    class CruftMarker {
        /** @internal */
        constructor(statement) {
            this.statement = statement;
        }
        /**
         * Converts this cruft marker to a string representation,
         * which is derived from a hash calculated from this
         * marker's underlying statement.
         */
        toString() {
            return "≈" + Truth.Hash.calculate(this.statement.sourceText);
        }
    }
    Truth.CruftMarker = CruftMarker;
    const CruftMarkers = new WeakMap();
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /** */
    class SubjectSerializer {
        /**
         * Universal method for serializing a subject to a string,
         * useful for debugging and supporting tests.
         */
        static forExternal(target, escapeStyle = 0 /* none */) {
            const subject = this.resolveSubject(target);
            return this.serialize(subject, escapeStyle, false);
        }
        /**
         * Serializes a subject, or a known subject containing object for internal use.
         */
        static forInternal(target) {
            const subject = this.resolveSubject(target);
            return this.serialize(subject, 0 /* none */, true);
        }
        /** */
        static resolveSubject(target) {
            return target instanceof Truth.Boundary ? target.subject :
                target instanceof Truth.Span ? target.boundary.subject :
                    target instanceof Truth.InfixSpan ? target.boundary.subject :
                        target;
        }
        /** */
        static serialize(subject, escapeStyle, includeHash) {
            if (subject instanceof Truth.Identifier)
                return subject.toString(escapeStyle);
            else if (subject instanceof Truth.Pattern)
                return subject.toString(includeHash);
            else if (subject instanceof Truth.Uri)
                return subject.toString();
            else if (subject instanceof Truth.Anon)
                return subject.toString();
            throw Truth.Exception.unknownState();
        }
    }
    Truth.SubjectSerializer = SubjectSerializer;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class HyperGraph {
        /** @internal */
        constructor(program) {
            this.program = program;
            /**
             * Stores a GraphTransaction instance in the case
             * when an edit transaction is underway.
             */
            this.activeTransactions = new Map();
            this.nodeIndex = new Truth.NodeIndex(this.program);
            if (HyperGraph.disabled)
                return;
            program.documents.each()
                .forEach(this.include.bind(this));
            program.on(Truth.CauseDocumentCreate, data => {
                this.include(data.document);
            });
            program.on(Truth.CauseDocumentDelete, data => {
                this.exclude(data.document);
            });
            program.on(Truth.CauseInvalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        this.exclude(smt);
                }
                else
                    this.exclude(data.document);
            });
            program.on(Truth.CauseRevalidate, data => {
                if (data.parents.length > 0) {
                    for (const smt of data.parents)
                        this.include(smt);
                }
                else
                    this.include(data.document);
            });
        }
        /**
         * Reads a root Node with the specified
         * name out of the specified document.
         */
        read(document, name) {
            const uriText = document.sourceUri
                .extendType(name)
                .toString();
            return this.nodeIndex.getNodeByUri(uriText) || null;
        }
        /**
         * @returns An array containing the node objects
         * that are defined at the root level of the specified
         * document.
         */
        *readRoots(document) {
            for (const node of this.nodeIndex.eachNode())
                if (node.container === null)
                    if (node.document === document)
                        yield node;
        }
        /**
         * Handles a document-level exclusion, which is the removal
         * of a section of Spans within a document, or possibly the
         * entire document itself.
         */
        exclude(root) {
            const { document, iterator } = this.methodSetup(root);
            const txn = new GraphTransaction();
            ///const maybeDestabilizedEdges: HyperEdge[] = [];
            for (const { statement } of iterator) {
                for (const declaration of statement.declarations) {
                    const associatedNodes = new Set(declaration
                        .factor()
                        .map(spine => Truth.Uri.clone(spine))
                        .map(uri => this.nodeIndex.getNodeByUri(uri))
                        .filter((n) => n instanceof Truth.Node));
                    for (const associatedNode of associatedNodes) {
                        associatedNode.removeDeclaration(declaration);
                        if (associatedNode.declarations.size === 0)
                            txn.destabilizedNodes.push(associatedNode);
                        for (const ob of associatedNode.outbounds)
                            if (ob.fragments.length === 0)
                                txn.destablizedEdges.push(ob);
                        ///for (const ib of associatedNode.inbounds)
                        ///	maybeDestabilizedEdges.push(ib);
                    }
                }
            }
            ///for (const edge of maybeDestabilizedEdges)
            ///	if (edge.successors.every(scsr => txn.destabilizedNodes.includes(scsr.node)))
            ///		txn.destablizedEdges.push(edge);
            this.activeTransactions.set(document, txn);
        }
        /**
         * Performs a revalidation of the Nodes that correspond to the
         * input argument.
         *
         * @param root The root object under which which revalidation
         * should occur. In the case when a Document instance is passed,
         * all Nodes present within the document are revalidated. In the
         * case when a Statement instance is passed, the Nodes that
         * correspond to the Statement, and all of it's contents are
         * revalidated.
         */
        include(root) {
            const { document, iterator } = this.methodSetup(root);
            const txn = this.activeTransactions.get(document);
            // Stores all the nodes that have been affected by a new
            // fragment either being added or removed from it.
            const affectedNodes = [];
            // Stores a subset of the affectedNodes array. Contains
            // only the nodes that are at the highest level of depth
            // within the node set (not necessarily the document root).
            const affectedNodesApexes = [];
            /**
             * @returns The containing node that
             * corresponds to the specified URI.
             */
            const findNode = (uri) => {
                if (uri.types.length === 0)
                    throw Truth.Exception.invalidArgument();
                const existingNode = affectedNodes.find(node => node.uri.equals(uri, true));
                if (existingNode)
                    return existingNode;
                const cachedNode = this.nodeIndex.getNodeByUri(uri);
                if (cachedNode)
                    return cachedNode;
                return null;
            };
            const breadthFirstOrganizer = [];
            for (const { level, statement } of iterator) {
                // Possibly append a bunch of empty multi-maps
                // at the end of the organizer, so that we don't
                // access an uninitialized index down below.
                while (breadthFirstOrganizer.length < level + 1)
                    breadthFirstOrganizer.push(new Truth.MultiMap());
                // In the case when the current statement has been deemed
                // as cruft, it's OK to just continue, because the breadth-first
                // organizer will end up with an empty multi-map in the case
                // when the portion of the hierarchy being traversed looks 
                // like:
                // 
                // Foo
                // 	[Cruft]    <=== Will correspond to an empty multi-map
                // 		Bar
                //
                // Or, it will end up with a populated multi-map in the case
                // when there is another statement at [Cruft]'s level of depth.
                // Either way, there are no spans that need to be added from
                // statements marked as cruft. The traversal will still reach
                // the crufty statement's contents, causing the spines to still
                // be computed.
                if (statement.isCruft)
                    continue;
                const multiMap = breadthFirstOrganizer[level];
                for (const decl of statement.declarations) {
                    for (const spine of decl.factor()) {
                        const uri = Truth.Uri.clone(spine);
                        const typeNames = spine.vertebrae.map(v => v.toString(true));
                        multiMap.add(typeNames.join("\n" /* terminal */), { uri, declaration: decl });
                        // If the declaration has population infixes, these
                        // need to be added to the map as though they
                        // were regular declarations.
                        const popInfixes = decl.infixes.filter(nfx => nfx.isPopulation);
                        if (popInfixes.length === 0)
                            continue;
                        for (const infix of popInfixes) {
                            for (const infixSpan of decl.eachDeclarationForInfix(infix)) {
                                const nfxText = Truth.SubjectSerializer.forInternal(infixSpan);
                                const infixSpineParts = typeNames.concat(nfxText);
                                multiMap.add(infixSpineParts.join("\n" /* terminal */), {
                                    uri: uri.extendType(nfxText),
                                    declaration: infixSpan
                                });
                            }
                        }
                    }
                }
            }
            // The following block populates the appropriate Nodes
            // in the graph with the new Span objects that were sent
            // in through the "root" parameter. New Node objects
            // are created if necessary.
            for (const multiMap of breadthFirstOrganizer)
                for (const entry of multiMap.values())
                    for (const { uri, declaration } of entry) {
                        const nodeAtUri = findNode(uri);
                        if (nodeAtUri) {
                            affectedNodes.push(nodeAtUri);
                            nodeAtUri.addDeclaration(declaration);
                            continue;
                        }
                        const container = uri.types.length > 1 ?
                            findNode(uri.retractType(1)) :
                            null;
                        if (uri.types.length > 1 && container === null)
                            throw Truth.Exception.unknownState();
                        // Note that when creating a Node, it's
                        // automatically bound to it's container.
                        const newNode = new Truth.Node(container, declaration);
                        affectedNodes.push(newNode);
                        // Populate the topMostAffectedNodes array, 
                        // which is needed to find the nodes that are
                        // affected by the change, but are not located
                        // directly within the patch.
                        if (affectedNodesApexes.length === 0) {
                            affectedNodesApexes.push(newNode);
                        }
                        else {
                            // If we've encountered a node that is higher
                            // than the level of depth defined in the nodes currently
                            // in the affectedNodesApexes array.
                            const highestDepth = affectedNodes[0].uri.types.length;
                            const nodeDepth = newNode.uri.types.length;
                            if (nodeDepth < highestDepth)
                                affectedNodesApexes.length = 0;
                            if (nodeDepth <= highestDepth)
                                affectedNodesApexes.push(newNode);
                        }
                    }
            // Add or update all new HyperEdges by feeding in all
            // annotation spans for each declaration span.
            // This needs to happen in a second pass because
            // all new nodes need to be created and positioned
            // in the graph before new "HyperEdge spans" can be added,
            // because doing this causes resolution to occur.
            for (const node of affectedNodes)
                for (const declaration of node.declarations) {
                    if (declaration instanceof Truth.Span) {
                        for (const annotation of declaration.statement.annotations)
                            node.addEdgeFragment(annotation);
                    }
                    else {
                        const nfx = declaration.containingInfix;
                        for (const boundary of nfx.rhs) {
                            node.addEdgeFragment(new Truth.InfixSpan(declaration.containingSpan, nfx, boundary));
                        }
                    }
                }
            // This is doing the reverse of what the above affectedNodes
            // loop is doing ... this is connecting other nodes to the affected
            // nodes, whereas the loop above is connecting affectedNodes
            // to others.
            if (affectedNodesApexes.length > 0) {
                // Stores the series of containers that any of the newly discovered
                // possibly affected nodes must have in their containment list
                // in order to be included in the "affectedNodes" array.
                const apexContainers = affectedNodesApexes
                    .map(node => node.container)
                    .filter((node) => node !== null)
                    .filter((v, i, a) => a.indexOf(v) === i);
                const checkRoot = apexContainers.length === 0;
                const isBelowAnApexContainer = (node) => node.containment.some(n => apexContainers.includes(n));
                for (const scsrNode of affectedNodesApexes) {
                    // Pattern and URI resolution doesn't occur in the
                    // Node graph, so when the node's subject isn't 
                    // an identifier, we don't add any edges to it.
                    if (!(scsrNode.subject instanceof Truth.Identifier))
                        continue;
                    const idents = this.nodeIndex.getAssociatedIdentifiers(scsrNode);
                    for (const ident of idents) {
                        const predecessors = this.nodeIndex.getNodesByIdentifier(ident);
                        for (const predecessor of predecessors)
                            if (checkRoot || isBelowAnApexContainer(predecessor))
                                predecessor.addEdgeSuccessor(scsrNode);
                    }
                }
            }
            // If there's no active transaction the corresponds to the input
            // document, the most likely reason is that an entire document
            // is being included for the first time.
            if (txn) {
                for (const maybeDeadEdge of txn.destablizedEdges)
                    if (maybeDeadEdge.fragments.length > 0)
                        maybeDeadEdge.predecessor.disposeEdge(maybeDeadEdge);
                for (const maybeDeadNode of txn.destabilizedNodes)
                    if (maybeDeadNode.declarations.size === 0) {
                        maybeDeadNode.dispose();
                        this.nodeIndex.delete(maybeDeadNode);
                    }
            }
            // Populate nodeCache with any newly created nodes.
            for (const affectedNode of affectedNodes) {
                affectedNode.sortOutbounds();
                const affectedUri = affectedNode.uri.toString();
                const cachedNode = this.nodeIndex.getNodeByUri(affectedUri);
                if (cachedNode) {
                    if (cachedNode !== affectedNode)
                        throw Truth.Exception.unknownState();
                    this.nodeIndex.update(affectedNode);
                }
                else {
                    this.nodeIndex.set(affectedUri, affectedNode);
                }
                this.sanitize(affectedNode);
            }
        }
        /** */
        log() {
            console.log("---- INTERNAL GRAPH REPRESENTATION ----");
            for (const node of this.nodeIndex.eachNode())
                console.log(node.toString(true));
        }
        /**
         * Performs setup for the invalidate and revalidate methods.
         */
        methodSetup(root) {
            const document = root instanceof Truth.Document ?
                root :
                root.document;
            const iterator = root instanceof Truth.Document ?
                document.eachDescendant() :
                document.eachDescendant(root, true);
            return { document, iterator };
        }
        /**
         * Reports any Node-level faults detected.
         */
        sanitize(node) {
            // Check for faulty refresh types
            // This can only happen on non-infix spans
            if (!(node.declarations.values().next().value instanceof Truth.Span))
                return;
            const smts = node.statements;
            const smtsRefresh = smts.filter(smt => smt.isRefresh);
            const smtsAnnotated = smts.filter(smt => smt.allAnnotations.length > 0);
            if (smtsRefresh.length > 0 && smtsAnnotated.length > 0)
                for (const smt of smtsRefresh)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.TypeCannotBeRefreshed, smt));
        }
        /**
         * Serializes the Graph into a format suitable
         * for debugging and comparing against baselines.
         */
        toString() {
            return this.nodeIndex.toString();
        }
    }
    Truth.HyperGraph = HyperGraph;
    /**
     *
     */
    class GraphTransaction {
        constructor() {
            /**
             * Stores an array of Nodes that no longer have any
             * underlying Span objects, due to their removal in
             * the invalidation phase.
             */
            this.destabilizedNodes = [];
            /**
             * Stores an array of Fans that no longer have any
             * underlying Span objects, due to their removal in
             * the invalidation phase.
             */
            this.destablizedEdges = [];
        }
    }
    /**
     * @internal
     * Debug utility.
     */
    function serializeNodes(nodes) {
        return "\n" + nodes.map(node => node.toString(true)).join("\n");
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a single Node contained within
     * the Program's Graph. Nodes are long-lived, referentially
     * significant objects that persist between edit frames.
     *
     * Nodes are connected in a graph not by edges, but by
     * HyperEdges. A HyperEdge (from graph theory) is similar
     * to a directed edge in that it has a single predecessor,
     * but differs in that it has multiple successors.
     *
     * It is necessary for Nodes to be connected to each other
     * in this way, in order for further phases in the pipeline
     * to execute the various kinds of polymorphic type
     * resolution.
     */
    class Node {
        /** @internal */
        constructor(container, declaration) {
            this.lastUri = null;
            this._contents = new Map();
            this._portabilityTargets = null;
            this._inbounds = new Set();
            this._outbounds = [];
            this._containment = null;
            const span = declaration instanceof Truth.Span ?
                declaration :
                declaration.containingSpan;
            this.container = container;
            this.document = span.statement.document;
            this.stamp = this.document.version;
            this._declarations = new Set([declaration]);
            this.subject = declaration.boundary.subject;
            this.name = Truth.SubjectSerializer.forInternal(this.subject);
            this.isListIntrinsic =
                this.subject instanceof Truth.Identifier &&
                    this.subject.isList;
            const containerTypePath = container !== null ?
                this.containment.slice().reverse().map(n => n.name) :
                [];
            this.typePath = containerTypePath.concat(this.name);
            if (this.declarations.size === 0)
                throw Truth.Exception.unknownState();
            if (!this.container) {
                this.addRootNode(this);
                return this;
            }
            this.container._contents.set(this.name, this);
            ///if (!(declaration instanceof Span))
            ///	return this;
            ///
            ///const identifier = declaration.boundary.subject;
            ///
            ///if (!(identifier instanceof Identifier))
            ///	return this;
            ///
            ///const containerPattern = (() =>
            ///{
            ///	for (const decl of this.container.declarations)
            ///		if (decl.boundary.subject instanceof Pattern)
            ///			return decl.boundary.subject;
            ///})();
            ///
            ///if (!containerPattern)
            ///	return this;
            ///
            ///for (const nfx of containerPattern.getInfixes(InfixFlags.population))
            ///	for (const ident of nfx.lhs.eachSubject())
            ///		if (ident.fullName === identifier.fullName)
            ///			//return (this.containerInfix = nfx), this;
            ///			return this;
        }
        /**
         * Removes this Node, and all its contents from the graph.
         */
        dispose() {
            if (this.container === null) {
                const map = Node.rootNodes.get(this.document);
                if (map)
                    map.delete(this.name);
            }
            else
                this.container._contents.delete(this.name);
            for (const ib of this._inbounds)
                ib.removeSuccessor(this);
            function recurse(node) {
                for (const edge of node._outbounds)
                    node.disposeEdge(edge);
                for (const containedNode of node._contents.values())
                    recurse(containedNode);
                // Manual memory management going on here.
                // Clearing out the Sets is probably unnecessary
                // because the GC would catch it anyways, but
                // these calls are here just to be safe.
                // It's still required that we clear out the inbounds
                // from the nodes to which this one is connected.
                node._declarations.clear();
                node._inbounds.clear();
            }
            recurse(this);
        }
        /**
         * Removes the specified HyperEdge from this Node's
         * set of outbounds.
         *
         * @throws In the case when the specified HyperEdge is
         * not owned by this Node.
         */
        disposeEdge(edge) {
            if (edge.predecessor !== this)
                throw Truth.Exception.invalidArgument();
            const idx = this._outbounds.indexOf(edge);
            this._outbounds.splice(idx, 1);
            for (const scsr of edge.successors)
                scsr.node._inbounds.delete(edge);
            edge.clearFragments();
        }
        /**
         * In the case when this node is a direct descendent of a
         * pattern node, and that pattern has population infixes,
         * and this node directly corresponds to one of those infixes,
         * this property gets a reference to said corresponding infix.
         */
        get containerInfix() {
            const flag = Truth.InfixFlags.population;
            if (this.container !== null)
                if (this.container.subject instanceof Truth.Pattern)
                    for (const nfx of this.container.subject.getInfixes(flag))
                        for (const ident of nfx.lhs.eachSubject())
                            return nfx;
            return null;
        }
        /** */
        get uri() {
            // Because the URI of the document can change, we need to 
            // make sure it's not hard coded into the node instance.
            const outUri = this.document.sourceUri.extendType(this.typePath);
            if (this.lastUri !== null)
                if (outUri.equals(this.lastUri))
                    return this.lastUri;
            return this.lastUri = outUri;
        }
        /**
         * Gets whether this Node has been explicitly defined as a list
         * extrinsic. It is worth noting that this property in and of itself is
         * not sufficient to determine whether any corresponding type is
         * actually a list (full type analysis is required to make this conclusion).
         */
        get isListExtrinsic() {
            for (const ob of this.outbounds)
                for (const source of ob.fragments)
                    if (source.boundary.subject instanceof Truth.Identifier)
                        if (source.boundary.subject.isList)
                            return true;
            return false;
        }
        /**
         * Gets a reference to the "opposite side of the list".
         *
         * If this Node represents a list intrinsic type, this property gets
         * a reference to the Node that represents the corresponding
         * extrinsic side.
         *
         * If this Node represents anything that *isn't* a list intrinsic type,
         * the property gets a reference to the Node that represents the
         * corresponding intrinsic side (whether the node is a list or not).
         *
         * Gets null in the case when there is no corresponding list intrinsic
         * or extrinsic Node to connect.
         */
        get intrinsicExtrinsicBridge() {
            if (this.subject instanceof Truth.Identifier)
                for (const adjacent of this.adjacents.values())
                    if (adjacent.subject instanceof Truth.Identifier)
                        if (adjacent.subject.typeName === this.subject.typeName)
                            if (adjacent.subject.isList !== this.isListIntrinsic)
                                return adjacent;
            return null;
        }
        /**
         * Stores the set of declaration-side Span instances that
         * compose this Node. If this the size of this set were to
         * reach zero, the Node would be marked for deletion.
         * (Node cleanup uses a reference counted collection
         * mechanism that uses the size of this set as it's guide).
         *
         * Note that although the type of this field is defined as
         * "Set<Span | InfixSpan>", in practice, it is either a set
         * of Span instances, or a set containing one single
         * InfixSpan instance. This is because it's possible to have
         * fragments of a type declared in multiple places in
         * a document, however, InfixSpans can only exist in one
         * place.
         */
        get declarations() {
            return this._declarations;
        }
        /** */
        addDeclaration(span) {
            this._declarations.add(span);
        }
        /** */
        removeDeclaration(span) {
            const wasDeleted = this._declarations.delete(span);
            if (wasDeleted) {
                // Remove all of the annotations that exist on the same
                // statement as the one that contains the declaration that
                // was removed. Note that this won't mess up fragmented
                // types. For example, consider the situation when the first
                // statement is removed from the following document:
                // 
                // A, B : X, Y
                // A, C : X, Y
                // 
                // Statements are removed atomically, so when the statement
                // is removed, this will result in 2 calls to this method: one for
                // the first "A", and one for the "B". When the second call is made,
                // the associated annotations will already have been removed.
                for (let i = this._outbounds.length; i-- > 0;) {
                    const ob = this._outbounds[i];
                    for (const anno of span.statement.allAnnotations)
                        ob.removeFragment(anno);
                    if (ob.fragments.length === 0)
                        this._outbounds.splice(i, 1);
                }
            }
        }
        /**
         * Gets an array containing the statements that
         * contain this Node.
         */
        get statements() {
            return Object.freeze(Array.from(this.declarations)
                .map(decl => decl.statement)
                .filter((v, i, a) => a.indexOf(v) === i));
        }
        /**
         * Gets a readonly map of Nodes that are contained
         * by this node in the containment hierarchy.
         */
        get contents() {
            return this._contents;
        }
        /**
         * Gets a readonly name of Nodes that are adjacent
         * to this Node in the containment hierarchy.
         */
        get adjacents() {
            const adjacentNodes = this.container ?
                this.container.contents :
                this.getRootNodes();
            // Filter this node out of the result set, because
            // Nodes cannot be adjacent to themselves.
            const out = new Map();
            for (const [name, node] of adjacentNodes)
                if (node !== this)
                    out.set(name, node);
            return out;
        }
        /**
         * Gets a 2-dimensional array containing the names of
         * the portability infixes that have been defined within
         * this node, with the first dimension corresponding to
         * a unique portability infix, and the second dimension
         * corresponding to the names defined within that infix.
         *
         * For example, given the following pattern:
         * /< : A, B, C>< : D, E, F> : ???
         *
         * The following result would be produced:
         * [["A", "B", "C"], ["D", "E", "F"]]
         */
        get portabilityTargets() {
            if (this._portabilityTargets !== null)
                return this._portabilityTargets;
            if (!(this.subject instanceof Truth.Pattern))
                return this._portabilityTargets = [];
            const identifierArrays = this.subject
                .getInfixes(Truth.InfixFlags.portability)
                .map(nfx => Object.freeze(Array.from(nfx.rhs.eachSubject())
                .map(ident => ident.typeName)));
            return this._portabilityTargets = Object.freeze(identifierArrays);
        }
        /**
         * @returns A set of nodes that are matched by
         * patterns of adjacent nodes.
         *
         * (Note that this is possible because annotations
         * that have been applied to a pattern cannot be
         * polymorphic)
         */
        getPatternNodesMatching(nodes) {
            const outNodes = [];
            //
            // This doesn't work because we don't know if
            // a node has been marked as cruft at this point.
            // This method may return junk results in the
            // case when one of the required nodes has
            // been marked as cruft (but then, wouldn't the
            // incoming node also be cruft?)
            //
            for (const node of this.adjacents.values()) {
                if (node.subject instanceof Truth.Pattern) {
                    const unorphaned = node.outbounds
                        .filter(ob => ob.successors.length > 0)
                        .map(ob => ob.successors[0].node);
                    if (unorphaned.length === 0)
                        continue;
                    if (unorphaned.length === nodes.length)
                        if (unorphaned.every(node => nodes.includes(node)))
                            outNodes.push(...unorphaned);
                }
            }
            return outNodes;
        }
        /**
         * Gets an immutable set of HyperEdges from adjacent
         * or contained Nodes that reference this Node.
         *
         * (The ordering of inbounds isn't important, as
         * they have no physical representation in the
         * document, which is why they're stored in a Set
         * rather than an array.)
         */
        get inbounds() {
            return this._inbounds;
        }
        /**
         * Gets an array of HyperEdges that connect this Node to
         * others, being either adjacents, or Nodes that
         * exists somewhere in the containment hierarchy.
         */
        get outbounds() {
            return this._outbounds;
        }
        /**
         * @internal
         * Sorts the outbound HyperEdges, so that they're ordering
         * is consistent with the way their corresponding
         * annotations appear in the underlying document.
         */
        sortOutbounds() {
            if (this._outbounds.length === 0)
                return;
            if (this._outbounds.length === 1) {
                const edge = this._outbounds[0];
                if (edge.fragments.length === 1)
                    return;
            }
            const edgeLookup = new Map();
            for (const edge of this._outbounds) {
                for (const src of edge.fragments.values()) {
                    const smt = src.statement;
                    const lineNum = smt.document.getLineNumber(smt);
                    const existingTuple = edgeLookup.get(edge);
                    if (existingTuple !== undefined) {
                        const existingStmt = existingTuple[0];
                        const existingStmtIdx = existingTuple[1];
                        if (lineNum < existingStmtIdx) {
                            existingTuple[0] = existingStmt;
                            existingTuple[1] = existingStmtIdx;
                        }
                    }
                    else {
                        edgeLookup.set(edge, [smt, lineNum]);
                    }
                }
            }
            // Sort the output edges in the array, so that the sorting of
            // the array aligns with the appearance of the underlying
            // spans in the document.
            this._outbounds.sort((edgeA, edgeB) => {
                const tupleA = edgeLookup.get(edgeA);
                const tupleB = edgeLookup.get(edgeB);
                const obs = this._outbounds;
                if (tupleA === undefined || tupleB === undefined)
                    throw Truth.Exception.unknownState();
                const [smtA, smtIdxA] = tupleA;
                const [smtB, smtIdxB] = tupleB;
                // If the top-most span of the predecessors of
                // the edges are located in different statements,
                // a simple comparison of the statement indexes
                // is possible.
                if (smtIdxA < smtIdxB)
                    return -1;
                if (smtIdxB < smtIdxA)
                    return 1;
                // At this point, statement A and statement B 
                // are actually equal.
                if (smtA !== smtB) {
                    throw Truth.Exception.unknownState();
                }
                const annos = smtA.annotations;
                const findMinIndex = (edge) => {
                    let minIdx = Infinity;
                    for (const src of edge.fragments) {
                        if (src instanceof Truth.InfixSpan)
                            throw Truth.Exception.unknownState();
                        const idx = annos.indexOf(src);
                        if (idx < minIdx)
                            minIdx = idx;
                    }
                    if (minIdx === Infinity)
                        throw Truth.Exception.unknownState();
                    return minIdx;
                };
                const edgeAIdx = findMinIndex(edgeA);
                const edgeBIdx = findMinIndex(edgeB);
                return edgeAIdx - edgeBIdx;
            });
        }
        /**
         * @internal
         * Adds a new edge to the node, or updates an existing one with
         * a new fragment.
         *
         * If no edge exists for the new fragment, a new one is created.
         */
        addEdgeFragment(fragment) {
            const identifier = fragment.boundary.subject;
            if (!(identifier instanceof Truth.Identifier))
                throw Truth.Exception.unknownState();
            // If the input source is "alone", it means that it refers to
            // a statement-level annotation that has no other annotations
            // beside it (e.g. in an annotation structure looking like "D: A1, A2")
            // This is relevant, because if the source is alone, it also needs
            // to be compared against any visible total patterns.
            const sourceIsAlone = fragment instanceof Truth.Span &&
                fragment.statement.annotations.length === 1;
            /**
             * Adds a edge to it's two applicable successor nodes.
             */
            const append = (edge) => {
                this._outbounds.push(edge);
                for (const suc of edge.successors)
                    suc.node._inbounds.add(edge);
            };
            // If there is already an existing outbound HyperEdge, we can
            // add the new Span to the edge's list of Spans, and quit.
            // This works whether the edge is for a type or pattern.
            const existingEdge = this._outbounds.find(edge => {
                return edge.identifier.typeName === identifier.typeName;
            });
            if (existingEdge) {
                existingEdge.addFragment(fragment);
            }
            else {
                const successors = [];
                for (const level of this.enumerateContainment()) {
                    const successorNode = level.container !== null &&
                        level.container !== this &&
                        level.container.name === identifier.typeName ?
                        level.container :
                        level.adjacents.get(identifier.typeName);
                    if (successorNode !== undefined) {
                        successors.push(new Truth.Successor(successorNode, level.longitudeDelta));
                        // There should only ever be a single successor in the case when
                        // the node is a pattern node, because the annotations (which
                        // are eventually become bases) of these nodes do not have
                        // polymorphic behavior.
                        if (this.subject instanceof Truth.Pattern)
                            break;
                    }
                }
                append(new Truth.HyperEdge(this, fragment, successors));
            }
            // 
            // Refresh the sums before quitting.
            // 
            ///const sumEdgeForInputSpanIdx = this._outbounds.findIndex(edge => 
            ///{
            ///	if (edge.kind === HyperEdgeKind.summation)
            ///		for (const src of edge.sources)
            ///			return src.statement === smt;
            ///	
            ///	return false;
            ///});
            ///
            ///if (sumEdgeForInputSpanIdx > -1)
            ///	this._outbounds.splice(sumEdgeForInputSpanIdx, 1);
            ///
            ///if (!sourceIsAlone)
            ///	for (const { longitudeDelta, adjacents } of this.enumerateContainment())
            ///		for (const adjacentNode of adjacents.values())
            ///			if (adjacentNode.subject instanceof Pattern)
            ///				if (adjacentNode.subject.isTotal)
            ///					if (adjacentNode.subject.test(smt.sum))
            ///						append(new HyperEdge(
            ///							this,
            ///							smt.sum,
            ///							[new Successor(
            ///								adjacentNode,
            ///								longitudeDelta)],
            ///							HyperEdgeKind.summation));
        }
        /**
         *
         */
        addEdgeSuccessor(successorNode) {
            const identifier = successorNode.subject;
            if (!(identifier instanceof Truth.Identifier))
                throw Truth.Exception.unknownState();
            for (const ob of this.outbounds) {
                if (ob.identifier.typeName !== successorNode.name)
                    continue;
                const scsrLong = successorNode.uri.types.length;
                const predLong = ob.predecessor.uri.types.length;
                ob.addSuccessor(successorNode, predLong - scsrLong);
                successorNode._inbounds.add(ob);
            }
        }
        /**
         *
         */
        enumerateOutbounds() {
            ///const recurse = (node: Node) =>
            ///{
            ///	for (const edge of node.outbounds)
            ///		for (const successor of edge.successors)
            ///			//yield { node: 
            ///}
            ///
            ///yield *recurse(this);
        }
        /**
         * Enumerates upwards through the containment
         * hierarchy of the Nodes present in this Node's
         * containing document, yielding the adjacents at
         * every level, and then continues through to the
         * root level adjacents of each of the document's
         * dependencies.
         */
        *enumerateContainment() {
            const doc = this.document;
            const program = doc.program;
            const deps = program.documents.getDependencies(doc);
            let currentLevel = this;
            let longitudeCount = 0;
            do {
                yield {
                    sourceDocument: doc,
                    container: currentLevel,
                    adjacents: currentLevel.adjacents,
                    longitudeDelta: longitudeCount++
                };
            } while ((currentLevel = currentLevel.container) !== null);
            // NOTE: This is broken. It needs to be recursive.
            for (let i = deps.length; --i > 0;) {
                const sourceDocument = deps[i];
                yield {
                    sourceDocument,
                    container: null,
                    adjacents: this.getRootNodes(sourceDocument),
                    longitudeDelta: longitudeCount
                };
            }
        }
        /**
         * @returns An array that stores the containment hierarchy
         * of the Nodes present in this Node's containing document,
         * yielding each containerof this Node.
         */
        get containment() {
            if (this._containment !== null)
                return this._containment;
            const nodes = [];
            let currentLevel = this;
            while ((currentLevel = currentLevel.container) !== null)
                nodes.push(currentLevel);
            return this._containment = Object.freeze(nodes);
        }
        /** */
        removeEdgeSource(src) {
            for (let i = this._outbounds.length; --i > 0;)
                this._outbounds[i].removeFragment(src);
        }
        /** */
        toString(includePath = true) {
            const decls = Array.from(this.declarations);
            const spans = decls.filter((s) => s instanceof Truth.Span);
            const anchors = decls.filter((a) => a instanceof Truth.InfixSpan);
            const spansText = spans.map(s => Truth.SubjectSerializer.forInternal(s)).join(", ");
            const anchorText = anchors.map(a => Truth.SubjectSerializer.forInternal(a)).join(", ");
            const ob = this.outbounds.length;
            const ib = this.inbounds.size;
            const path = includePath ? this.uri.types.join("/") + " " : "";
            const simple = [
                path,
                spansText.length ? "spans=" + spansText : "",
                anchorText.length ? "anchor=" + anchorText : "",
                "out=" + ob,
                "in=" + ib
            ].filter(s => s.trim()).join(", ");
            const fmt = (str) => str.split("\n").map(s => "\t\t" + s).join("\n");
            const obsVerbose = this.outbounds
                .map(ob => fmt(ob.toString()));
            const ibsVerbose = Array.from(this.inbounds.values())
                .map(ib => fmt(ib.toString()));
            const verbose = "\n\tOuts:\n" + obsVerbose.join("\n\n") +
                "\n\tIns:\n" + ibsVerbose.join("\n\n");
            return simple + verbose;
        }
        /** */
        addRootNode(node) {
            const existingSet = Node.rootNodes.get(node.document);
            if (existingSet) {
                existingSet.set(node.name, node);
            }
            else {
                const map = new Map();
                map.set(node.name, node);
                Node.rootNodes.set(node.document, map);
            }
        }
        /** */
        removeRootNode(node) {
            const existingSet = Node.rootNodes.get(node.document);
            if (existingSet) {
                existingSet.delete(node.name);
                // This is somewhat redundant as the set
                // is likely going to be GC'd away anyway in
                // this case. It's here for completeness sake.
                if (existingSet.size === 0)
                    Node.rootNodes.delete(node.document);
            }
        }
        /** */
        getRootNodes(fromDocument) {
            const fromDoc = fromDocument || this.document;
            const out = Node.rootNodes.get(fromDoc) || new Map();
            return Truth.HigherOrder.copy(out);
        }
    }
    /** */
    Node.rootNodes = new WeakMap();
    Truth.Node = Node;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class NodeIndex {
        /** */
        constructor(program) {
            /**
             * Stores a map of all nodes that have been loaded into the program,
             * indexed by a string representation of it's URI.
             */
            this.uriToNodeMap = new Map();
            /**
             * Stores a map which is indexed by a unique identifier, and which as
             * values that are the nodes that use that identifier, either as a declaration
             * or an annotation.
             *
             * The purpose of this cache is to get a quick answer to the question:
             * "We added a new identifier at position X ... what nodes might possibly
             * have been affected by this?"
             */
            this.identifierToNodesMap = new Map();
            /**
             * Stores a map which is essentially a reverse of identifierToNodesMap.
             * This is so that when nodes need to be deleted or updated, we can
             * quickly find the place in identifierToNodesMap where the node has
             * been referenced.
             */
            this.nodesToIdentifiersMap = new WeakMap();
            program.on(Truth.CauseDocumentUriChange, data => {
                // Update the entire cache when the URI of any document changes.
                const newUriStore = data.newUri.retractTypeTo(0);
                const entries = Array.from(this.uriToNodeMap.entries());
                for (const [oldUriText, node] of entries) {
                    if (node.document !== data.document)
                        continue;
                    const oldUri = Truth.Not.null(Truth.Uri.tryParse(oldUriText));
                    const newUriText = newUriStore
                        .extendType(oldUri.types.map(t => t.value))
                        .toString();
                    this.uriToNodeMap.delete(oldUriText);
                    this.uriToNodeMap.set(newUriText, node);
                }
            });
        }
        /**
         * Enumerates through all Node instances stored
         * in the index.
         */
        *eachNode() {
            for (const node of this.uriToNodeMap.values())
                yield node;
        }
        /**
         * Gets the number of nodes stored in the index.
         */
        get count() {
            return this.uriToNodeMap.size;
        }
        /**
         * Updates the index, establishing a cached relationship
         * between the specified uri and the specified node.
         */
        set(uri, node) {
            const uriText = typeof uri === "string" ? uri : uri.toString();
            this.uriToNodeMap.set(uriText, node);
            this.update(node);
        }
        /**
         * Updates the index by refreshing in the set of identifiers
         * that are associated with the specified node.
         */
        update(node) {
            const pastIdentifiers = this.nodesToIdentifiersMap.get(node);
            const presentIdentifiers = this.getAssociatedIdentifiers(node);
            if (pastIdentifiers !== undefined) {
                for (const [idx, ident] of pastIdentifiers.entries()) {
                    if (presentIdentifiers.includes(ident))
                        continue;
                    pastIdentifiers.splice(idx, 1);
                    const map = this.identifierToNodesMap.get(ident);
                    if (map === undefined)
                        continue;
                    map.delete(node);
                    if (map.size === 0)
                        this.identifierToNodesMap.delete(ident);
                }
            }
            for (const identifier of presentIdentifiers) {
                const nodesForIdent = this.identifierToNodesMap.get(identifier) || (() => {
                    const out = new Set();
                    this.identifierToNodesMap.set(identifier, out);
                    return out;
                })();
                nodesForIdent.add(node);
            }
            this.nodesToIdentifiersMap.set(node, presentIdentifiers);
        }
        /** */
        getNodeByUri(uri) {
            const uriText = typeof uri === "string" ? uri : uri.toString();
            return this.uriToNodeMap.get(uriText);
        }
        /**
         * @returns An array that contains the nodes that are associated
         * with the specified identifier that exist at or below the specified
         * depth. "Associated" means that the identifier is either equivalent
         * to the Node's main subject, or it is referenced in one of it's edges.
         */
        getNodesByIdentifier(identifer) {
            const out = this.identifierToNodesMap.get(identifer);
            return out ? Array.from(out) : [];
        }
        /**
         * Removes the specified node from the index, if it exists.
         */
        delete(deadNode) {
            for (const [uri, node] of this.uriToNodeMap)
                if (node === deadNode)
                    this.uriToNodeMap.delete(uri);
            const existingIdentifiers = this.nodesToIdentifiersMap.get(deadNode);
            if (existingIdentifiers === undefined)
                return;
            for (const identifier of existingIdentifiers) {
                const nodes = this.identifierToNodesMap.get(identifier);
                if (nodes === undefined)
                    continue;
                nodes.delete(deadNode);
                if (nodes.size === 0)
                    this.identifierToNodesMap.delete(identifier);
            }
            this.nodesToIdentifiersMap.delete(deadNode);
        }
        /**
         * @returns An array that contains the identifiers associated with
         * the specified Node.
         */
        getAssociatedIdentifiers(node) {
            const identifiers = [];
            if (node.subject instanceof Truth.Identifier)
                identifiers.push(node.subject.typeName);
            for (const smt of node.statements)
                for (const anno of smt.allAnnotations)
                    if (anno.boundary.subject instanceof Truth.Identifier)
                        identifiers.push(anno.boundary.subject.typeName);
            return identifiers;
        }
        /**
         * Serializes the index into a format suitable
         * for debugging and comparing against baselines.
         */
        toString() {
            if (this.uriToNodeMap.size === 0)
                return "(empty)";
            const out = [];
            const keys = Array.from(this.uriToNodeMap.keys()).map(s => {
                const uri = Truth.Uri.tryParse(s);
                return uri ? uri.toString() : s;
            });
            const values = Array.from(this.uriToNodeMap.values());
            for (let i = -1; ++i < keys.length;) {
                const key = keys[i];
                const value = values[i].toString(false);
                out.push(`${key}\n\t${value}\n`);
            }
            out.push("(Identifier Cache)");
            for (const [identifier, nodes] of this.identifierToNodesMap) {
                out.push("\t" + identifier);
                out.push("\t\t: " + Array.from(nodes)
                    .map(node => node.uri.toTypeString())
                    .join(", "));
            }
            return out.join("\n").trim();
        }
    }
    Truth.NodeIndex = NodeIndex;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A HyperEdge connects an origin predecessor Node to a series of
     * successor Nodes. From graph theory, a "hyper edge" is different
     * from an "edge" in that it can have many successors:
     * https://en.wikipedia.org/wiki/Hypergraph
     */
    class HyperEdge {
        constructor(
        /**
         * The Node from where the HyperEdge connection begins.
         * For example, given the following document:
         *
         * Foo
         * 	Bar : Foo
         *
         * Two Node objects would be created, one for the first instance
         * of "Foo", and another for the instance of "Bar". A HyperEdge
         * would be created between "Bar" and "Foo", and it's
         * precedessor would refer to the Node representing the
         * occurence of "Bar".
         */
        predecessor, source, successors) {
            this.predecessor = predecessor;
            if (!(source.boundary.subject instanceof Truth.Identifier))
                throw Truth.Exception.unknownState();
            const successorNodes = successors
                .map(scsr => scsr.node)
                .filter((v, i, a) => a.indexOf(v) === i);
            if (successorNodes.length !== successors.length)
                throw Truth.Exception.unknownState();
            this.identifier = source.boundary.subject;
            this.fragmentsMutable = [source];
            this.successorsMutable = successors.slice();
        }
        /**
         * Attempts to add another fragment to the HyperEdge.
         * Reports a fault instead in the case when there is a
         * list conflict between the source provided and the
         * existing sources. (I.e. one of the sources is defined
         * as a list, and another is not).
         */
        addFragment(fragment) {
            ///const isPattern = this.predecessor.subject instanceof Pattern;
            ///const isInfix = source instanceof InfixSpan;
            ///if (isPattern !== isInfix)
            ///	throw Exception.invalidCall();
            if (this.fragmentsMutable.includes(fragment))
                return;
            //! The ordering of the sources is not being handled here.
            this.fragmentsMutable.push(fragment);
        }
        /**
         * Removes the specified annotation-side Span or InfixSpan
         * from this edge.
         */
        removeFragment(fragment) {
            const fragPos = this.fragmentsMutable.indexOf(fragment);
            if (fragPos >= 0)
                this.fragmentsMutable.splice(fragPos, 1);
        }
        /** */
        clearFragments() {
            this.fragmentsMutable.length = 0;
        }
        /**
         * Gets the set of annotation-side Spans or annotation-side
         * InfixSpans that are responsible for the conception of this
         * HyperEdge.
         *
         * The array contains either Span instances or InfixSpan instances,
         * but never both. In the case when the array stores Span instances,
         * the location of those Spans are potentially scattered across many
         * statements.
         */
        get fragments() {
            return this.fragmentsMutable;
        }
        /**
         *
         */
        addSuccessor(node, longitude) {
            if (!this.successorsMutable.find(scsr => scsr.node === node))
                this.successorsMutable.push(new Successor(node, longitude));
        }
        /**
         *
         */
        removeSuccessor(node) {
            for (let i = this.successorsMutable.length; i-- > 0;)
                if (this.successorsMutable[i].node === node)
                    this.successorsMutable.splice(i, 1);
        }
        /**
         * Stores all possible success Nodes to which the predecessor
         * Node is preemptively connected via this HyperEdge. The
         * connection is said to be preemptive, because the connection
         * might be ignored during polymorphic name resolution.
         */
        get successors() {
            return this.successorsMutable;
        }
        /**
         * Gets whether this HyperEdge has no immediately resolvable
         * successors. This means that the subject being referred to by
         * this HyperEdge is either a type alias which will be matched by
         * a pattern, or just a plain old fault.
         */
        get isDangling() {
            return this.successors.length === 0;
        }
        /**
         * Gets a value that indicates whether the sources of the edge
         * causes incrementation of the list dimensionality of the type
         * that corresponnds to this HyperEdge's predecessor Node.
         *
         * (Note that all sources need to agree on this value, and the
         * necessary faults are generated to ensure that this is always
         * the case.)
         */
        get isList() {
            for (const source of this.fragments) {
                const sub = source.boundary.subject;
                return sub instanceof Truth.Identifier && sub.isList;
            }
            return false;
        }
        /**
         * Gets a value that indicates the specific part of the
         * predecessor where this HyperEdge begins.
         */
        get predecessorOrigin() {
            //! Is this still necessary?
            if (this.fragmentsMutable.length === 0)
                throw Truth.Exception.unknownState();
            const src = this.fragmentsMutable[0];
            if (src instanceof Truth.Span)
                return HyperEdgeOrigin.statement;
            if (src.containingInfix.isPortability)
                return HyperEdgeOrigin.portabilityInfix;
            if (src.containingInfix.isPopulation)
                return HyperEdgeOrigin.populationInfix;
            if (src.containingInfix.isPattern)
                return HyperEdgeOrigin.patternInfix;
            throw Truth.Exception.unknownState();
        }
        /**
         * @returns A string representation of this HyperEdge,
         * suitable for debugging and testing purposes.
         */
        toString() {
            return [
                "Value=" + this.identifier,
                "Predecessors=" + this.predecessor.name,
                "Successors=" + this.successors
                    .map(n => n.node.name + " << " + n.longitude)
                    .join(", "),
                "Sources=" + Array.from(this.fragments)
                    .map(src => src.boundary.subject).join(", "),
                "---"
            ].join("\n");
        }
    }
    Truth.HyperEdge = HyperEdge;
    /**
     *
     */
    class Successor {
        constructor(node, 
        /**
         * The the number of levels of depth in the containment
         * hierarchy that need to be crossed in order for the containing
         * HyperEdge to be established between the predecessor and
         * this successor.
         */
        longitude) {
            this.node = node;
            this.longitude = longitude;
            this.stamp = Truth.VersionStamp.next();
        }
    }
    Truth.Successor = Successor;
    /**
     * Indicates the place in a statement where a HyperEdge starts.
     * (HyperEdges can start either at the statement level, or within
     * various kinds of infixes.)
     */
    let HyperEdgeOrigin;
    (function (HyperEdgeOrigin) {
        HyperEdgeOrigin[HyperEdgeOrigin["statement"] = 0] = "statement";
        HyperEdgeOrigin[HyperEdgeOrigin["populationInfix"] = 1] = "populationInfix";
        HyperEdgeOrigin[HyperEdgeOrigin["portabilityInfix"] = 2] = "portabilityInfix";
        HyperEdgeOrigin[HyperEdgeOrigin["patternInfix"] = 3] = "patternInfix";
    })(HyperEdgeOrigin = Truth.HyperEdgeOrigin || (Truth.HyperEdgeOrigin = {}));
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that marks out the location of an infix Identifer within
     * it's containing Infix, it's containing Span, and then it's containing
     * Statement, Document, and Program.
     */
    class InfixSpan {
        constructor(containingSpan, containingInfix, boundary) {
            this.containingSpan = containingSpan;
            this.containingInfix = containingInfix;
            this.boundary = boundary;
        }
        /**
         * Gets the Statement that contains this Anchor.
         */
        get statement() {
            return this.containingSpan.statement;
        }
        /**
         * Gets a boolean value that indicates whether this InfixSpan
         * is considered object-level cruft, and should therefore be
         * ignored during type analysis.
         */
        get isCruft() {
            return this.containingSpan.statement.cruftObjects.has(this);
        }
    }
    Truth.InfixSpan = InfixSpan;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A worker class that handles the construction of networks
     * of Parallel instances, which are eventually transformed
     * into type objects.
     */
    class ConstructionWorker {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.excavated = new WeakSet();
            /** A call queue used to prevent circular drilling. */
            this.drillQueue = [];
            /**
             * Used for safety purposes to catch unexpected behavior.
             */
            this.handledHyperEdges = new WeakSet();
            /** */
            this.parallels = new Truth.ParallelCache();
            /**
             * Stores the set of Parallel instances that have been "raked",
             * which means that that have gone through the process of
             * having their requested bases applied.
             *
             * This set may include both pattern and non-patterns Parallels,
             * (even though their raking processes are completely different).
             */
            this.rakedParallels = new WeakSet();
            this.cruft = new Truth.CruftCache(this.program);
        }
        /**
         * Constructs the corresponding Parallel instances for
         * all specified types that exist within the provided Document,
         * or below the provided SpecifiedParallel.
         */
        excavate(from) {
            if (this.excavated.has(from))
                return;
            this.excavated.add(from);
            const queue = [];
            const processNodes = (iterator) => {
                for (const node of iterator) {
                    const drilledParallel = this.drillFromNode(node);
                    if (drilledParallel !== null)
                        queue.push(drilledParallel);
                }
            };
            if (from instanceof Truth.Document)
                processNodes(this.program.graph.readRoots(from));
            else
                queue.push(from);
            for (const currentParallel of queue)
                processNodes(currentParallel.node.contents.values());
        }
        /**
         * Constructs the fewest possible Parallel instances
         * to arrive at the type specified by the directive.
         */
        drill(directive) {
            const result = this.drillFromUri(directive);
            this.drillQueue.length = 0;
            return result;
        }
        /** */
        drillFromUri(directive) {
            if (this.parallels.has(directive))
                return Truth.Not.undefined(this.parallels.get(directive));
            const typePath = directive.types.slice().map(t => t.value);
            if (typePath.length === 0)
                throw Truth.Exception.invalidArgument();
            const sourceDoc = this.program.documents.get(directive);
            if (sourceDoc === null)
                throw Truth.Exception.documentNotLoaded();
            const surfaceNode = this.program.graph.read(sourceDoc, typePath[0]);
            if (surfaceNode === null)
                return null;
            let typeIdx = 0;
            let lastSeed = this.parallels.get(directive.retractTypeTo(1)) ||
                this.rake(this.parallels.create(surfaceNode, this.cruft));
            // We can pass by any Parallel instances that have already
            // been constructed. The real work begins when we get to
            // the first point in the URI where there is no constructed
            // Parallel instance.
            for (;;) {
                const uri = directive.retractTypeTo(typeIdx + 1);
                if (!this.parallels.has(uri))
                    break;
                lastSeed = Truth.Not.undefined(this.parallels.get(uri));
                if (++typeIdx >= typePath.length)
                    return lastSeed;
            }
            do {
                const typeName = typePath[typeIdx];
                const descended = this.descend(lastSeed, typeName);
                if (descended === null)
                    return null;
                lastSeed = this.rake(descended);
            } while (++typeIdx < typePath.length);
            return lastSeed;
        }
        /**
         * An entrypoint into the drill function that operates
         * on a Node instead of a Uri. Essentially, this method
         * calls "drillFromUri()" safely (meaning that it detects
         * circular invokations, and returns null in these cases).
         */
        drillFromNode(node) {
            // Circular drilling is only a problem if we're
            // drilling on the same level.
            const q = this.drillQueue;
            if (q.length === 0) {
                q.push(node);
            }
            else if (q[0].container === node.container) {
                if (q.includes(node))
                    return null;
            }
            else {
                q.length = 0;
                q.push(node);
            }
            const drillResult = this.drillFromUri(node.uri);
            if (drillResult === null)
                throw Truth.Exception.unknownState();
            if (!(drillResult instanceof Truth.SpecifiedParallel))
                throw Truth.Exception.unknownState();
            return drillResult;
        }
        /**
         * "Raking" a Parallel is the process of deeply traversing it's
         * Parallel Graph (depth first), and for each visited Parallel,
         * deeply traversing it's Base Graph as well (also depth first).
         * Through this double-traversal process, the Parallel's edges
         * are constructed into a traversable graph.
         */
        rake(seed) {
            // If the seed's container is null, this means that the seed
            // is root-level, and so it cannot have any Parallel types.
            // It may however have Base types, and these need to be
            // handled.
            if (seed.container === null) {
                if (!(seed instanceof Truth.SpecifiedParallel))
                    throw Truth.Exception.unknownState();
                this.rakeSpecifiedParallel(seed);
            }
            else
                this.rakeParallelGraph(seed);
            return seed;
        }
        /**
         * Recursive function that digs through the parallel graph,
         * and rakes all SpecifiedParallels that are discovered.
         */
        rakeParallelGraph(par) {
            for (const edgePar of par.getParallels())
                this.rakeParallelGraph(edgePar);
            if (par instanceof Truth.SpecifiedParallel)
                this.rakeSpecifiedParallel(par);
        }
        /**
         * Splitter method that rakes both a pattern and a non-pattern
         * containing SpecifiedParallel.
         */
        rakeSpecifiedParallel(par) {
            if (this.rakedParallels.has(par))
                return par;
            this.rakedParallels.add(par);
            if (par.pattern)
                this.rakePatternBases(par);
            else
                this.rakeBaseGraph(par);
        }
        /**
         * Recursively follows the bases of the specified source Node.
         * Parallel instances are created for any visited Node instance
         * that does not have one already created.
         * Although the algorithm is careful to avoid circular bases, it's
         * too early in the processing pipeline to report these circular
         * bases as faults. This is because polymorphic name resolution
         * needs to take place before the system can be sure that a
         * seemingly-circular base structure is in fact what it seems.
         * True circular base detection is therefore handled at a future
         * point in the pipeline.
         */
        rakeBaseGraph(srcParallel) {
            if (srcParallel.pattern)
                throw Truth.Exception.unknownState();
            for (const hyperEdge of srcParallel.node.outbounds) {
                if (this.cruft.has(hyperEdge))
                    continue;
                const possibilities = hyperEdge.successors
                    .filter(scsr => !this.cruft.has(scsr.node))
                    .sort((a, b) => a.longitude - b.longitude);
                if (possibilities.length > 0) {
                    // This is where the polymorphic name resolution algorithm
                    // takes place. The algorithm operates by working it's way
                    // up the list of nodes (aka the scope chain), looking for
                    // a possible resolution target where the act of applying the
                    // associated Parallel as a base, causes at least one of the 
                    // conditions on the contract to be satisfied. Or, in the case
                    // when there are no conditions on the contract, the node
                    // that is the closest ancestor is used.
                    for (const possibleScsr of possibilities) {
                        const possibleNode = possibleScsr.node;
                        const baseParallel = this.drillFromNode(possibleNode);
                        // baseParallel will be null in the case when a circular
                        // relationship has been detected (and quitting is
                        // required here in order to avoid a stack overflow).
                        if (baseParallel === null)
                            continue;
                        this.rakeSpecifiedParallel(baseParallel);
                        // There are cases when an entire parallel needs to be
                        // "excavated", meaning that the Parallel's entire subtree
                        // of contents needs to be analyzed and converted into
                        // parallels. This is necessary because a fully defined set
                        // of parallels is required in order to detect discrepant
                        // unions (and therefore, report the attempt at a type
                        // union as faulty).
                        if (srcParallel.baseCount > 0) {
                            if (srcParallel.baseCount === 1)
                                this.excavate(srcParallel.firstBase);
                            this.excavate(baseParallel);
                        }
                        if (!srcParallel.tryAddLiteralBase(baseParallel, hyperEdge))
                            continue;
                        if (this.handledHyperEdges.has(hyperEdge))
                            throw Truth.Exception.unknownState();
                        this.handledHyperEdges.add(hyperEdge);
                        continue;
                    }
                }
                else {
                    // At this point, we've discovered an annotation that we're
                    // going to try to resolve as an alias. If this doesn't work,
                    // the edge will be marked as cruft. Possibly a future version
                    // of this compiler will allow other agents to hook into this
                    // process and augment the resolution strategy.
                    const candidatePatternPars = [];
                    for (const { patternParallel } of this.ascend(srcParallel)) {
                        this.rakePatternBases(patternParallel);
                        candidatePatternPars.push(patternParallel);
                    }
                    if (candidatePatternPars.length > 0) {
                        const identifiers = hyperEdge.fragments
                            .map(src => src.boundary.subject)
                            .filter((s) => s instanceof Truth.Identifier);
                        if (identifiers.length === 0)
                            continue;
                        const alias = identifiers[0].fullName;
                        if (srcParallel.tryAddAliasedBase(candidatePatternPars, hyperEdge, alias)) {
                            this.handledHyperEdges.add(hyperEdge);
                            continue;
                        }
                    }
                    if (!this.handledHyperEdges.has(hyperEdge))
                        this.cruft.add(hyperEdge, Truth.Faults.UnresolvedAnnotation);
                }
            }
            if (!srcParallel.isContractSatisfied)
                for (const smt of srcParallel.node.statements)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.ContractViolation, smt));
            return srcParallel;
        }
        /**
         * Finds the set of bases that should be applied to the provided
         * pattern-containing SpecifiedParallel instance, and attempts
         * to have them applied.
         */
        rakePatternBases(patternParallel) {
            if (!patternParallel.pattern)
                throw Truth.Exception.unknownState();
            const bases = new Map();
            const obs = patternParallel.node.outbounds;
            const nameOf = (edge) => Truth.SubjectSerializer.forInternal(edge.fragments[0]);
            for (let i = -1; ++i < obs.length;) {
                const hyperEdge = obs[i];
                if (this.cruft.has(hyperEdge))
                    continue;
                const len = hyperEdge.successors.length;
                // Because resolving pattern bases has non-polymorphic behavior, 
                // we can get away with checking for these faults here without going
                // through the whole drilling process.
                if (len === 0) {
                    this.cruft.add(hyperEdge, Truth.Faults.UnresolvedAnnotation);
                    continue;
                }
                if (obs.findIndex(e => nameOf(e) === nameOf(hyperEdge)) !== i) {
                    this.cruft.add(hyperEdge, Truth.Faults.IgnoredAnnotation);
                    continue;
                }
                if (len > 1)
                    throw Truth.Exception.unknownState();
                const baseNode = hyperEdge.successors[0].node;
                const baseParallel = this.drillFromNode(baseNode);
                if (baseParallel !== null)
                    bases.set(baseParallel, hyperEdge);
            }
            // Circular bases still need to be checked. It's unclear how and
            // where to actually do this, while factoring in the constraint
            // that these can be caused through the use of aliases.
            // Anything that is a list (with any dimensionality) needs to be
            // cut off, because these bases can't be applied to patterns.
            for (const [base, via] of bases)
                if (base.getListDimensionality() > 0)
                    this.cruft.add(via, Truth.Faults.PatternMatchingList);
            // Now we need to determine if any of these bases are redundant.
            // This is done by checking to see if any of the bases are specified
            // somewhere in the base graph of all others.
            for (const [baseA] of bases)
                for (const [baseB, via] of bases)
                    if (baseA !== baseB)
                        if (baseA.hasBase(baseB))
                            this.cruft.add(via, Truth.Faults.IgnoredAnnotation);
            const pattern = patternParallel.node.subject;
            const span = patternParallel.node.declarations.values().next().value;
            const portInfixes = pattern.getInfixes(Truth.InfixFlags.portability);
            if (portInfixes.length > 0) {
                const validPortabilityInfixes = [];
                for (const portInfix of portInfixes) {
                    const nfxAnnosIter = span.eachAnnotationForInfix(portInfix);
                    const nfxAnnos = Array.from(nfxAnnosIter);
                    if (nfxAnnos.length === 0)
                        throw Truth.Exception.unknownState();
                    // At this time, we're currently generating a fault in the case when
                    // a portability infix has multiple definitions. Although the parser
                    // and the Graph-level infrastructure supports this, more study is
                    // required in order to determine if this is a characteristic of Truth.
                    if (nfxAnnos.length > 1) {
                        for (const nfx of nfxAnnos.slice(1))
                            this.cruft.add(nfx, Truth.Faults.PortabilityInfixHasUnion);
                    }
                    else
                        validPortabilityInfixes.push(portInfix);
                }
                // This code checks for overlapping types. The algorithm used here is
                // similar to the redundant bases check used above. However, in the case
                // of infixes, these aren't just redundant, they would be problematic if
                // left in. To explain why, try to figure out how a String type would draw
                // it's data out of an alias matching the following pattern:
                // 	/< : Email>< : String> : Type
                // (hint: it doesn't work)
                //! Not implemented
            }
            // TODO: Check for use of lists within any kind of infix.
            // It's possible for no collected bases to be returned
            // in the case when there were actually annotations
            // specified within the file, but they were all found to
            // be cruft.
            if (bases.size === 0)
                return;
            patternParallel.tryApplyPatternBases(bases);
        }
        /**
         * A generator function that works its way upwards, starting at the
         * provided SpecifiedParallel. The function yields the series of
         * Parallels that contain Patterns that are visible to the provided
         * srcParallel. The bases of these parallels have not necessarily
         * been applied.
         *
         * The ordering of the Parallels yielded is relevant. The instances
         * that were yielded closer to the beginning take prescedence over
         * the ones yielded at the end.
         */
        *ascend(srcParallel) {
            const discoveredPatternNodes = new Set();
            const yieldable = (patternNode) => {
                discoveredPatternNodes.add(patternNode);
                return Truth.Not.null(this.parallels.get(patternNode) ||
                    this.parallels.create(patternNode, this.cruft));
            };
            function* recurse(current) {
                for (const { base } of current.eachBase())
                    yield* recurse(base);
                if (current instanceof Truth.SpecifiedParallel)
                    for (const node of current.node.contents.values())
                        if (node.subject instanceof Truth.Pattern)
                            if (!discoveredPatternNodes.has(node))
                                yield {
                                    pattern: node.subject,
                                    patternParallel: yieldable(node)
                                };
            }
            // The process starts at the container of the current parallel,
            // even though this function needs to yield other parallels that
            // are adjacent to srcParallel, because we reach back into the
            // adjacents from the container.
            for (let current = srcParallel.container; current instanceof Truth.SpecifiedParallel;) {
                yield* recurse(current);
                current = current.container;
            }
            for (const root of this.program.graph.readRoots(srcParallel.node.document))
                if (root.subject instanceof Truth.Pattern)
                    if (!discoveredPatternNodes.has(root))
                        yield {
                            pattern: root.subject,
                            patternParallel: yieldable(root)
                        };
        }
        /**
         * Constructs and returns a new seed Parallel from the specified
         * zenith Parallel, navigating downwards to the specified type name.
         */
        descend(zenith, typeName) {
            /**
             * @returns A new Parallel (either being a SpecifiedParallel
             * or an UnspecifiedParallel instance), that corresponds to
             * the specified zenith parallel.
             */
            const descendOne = (zenith) => {
                if (zenith instanceof Truth.SpecifiedParallel) {
                    const nextNode = zenith.node.contents.get(typeName);
                    if (nextNode) {
                        const out = this.parallels.get(nextNode) ||
                            this.parallels.create(nextNode, this.cruft);
                        this.verifyDescend(zenith, out);
                        return out;
                    }
                }
                const nextUri = zenith.uri.extendType(typeName);
                return (this.parallels.get(nextUri) ||
                    this.parallels.create(nextUri));
            };
            /**
             * @returns A boolean value that indicates whether the act
             * of descending from the specified Parallel to the typeName
             * passed to the containing method is going to result in a
             * SpecifiedParallel instance.
             */
            function canDescendToSpecified(parallel) {
                return (parallel instanceof Truth.SpecifiedParallel &&
                    parallel.node.contents.has(typeName));
            }
            //
            // TODO: These functions can probably be replaced with
            // a call to Misc.reduceRecursive()
            //
            function* recurseParallels(par) {
                for (const parEdge of par.getParallels())
                    yield* recurseParallels(parEdge);
                yield par;
            }
            function* recurseBases(par) {
                for (const { base } of par.eachBase())
                    yield* recurseBases(base);
                yield par;
            }
            function* recurse(par) {
                for (const parallelEdge of recurseParallels(par)) {
                    if (parallelEdge instanceof Truth.SpecifiedParallel)
                        for (const baseEdge of recurseBases(parallelEdge))
                            yield baseEdge;
                    yield parallelEdge;
                }
            }
            // The following algorithm performs a recursive reduction on
            // the zenith, and produces a set of Parallels to prune from the
            // descension process. The Parallels that end up getting pruned
            // are the ones that, if unpruned, would result in a layer that
            // has UnspecifiedParallels that shouldn't actually exist. For
            // example, consider the following document:
            //
            // Class
            // 
            // SubClass : Class
            // 	Child
            // 
            // "Class" should not have an UnspecifiedParallel called "Child",
            // because that was introduced in the derived "SubClass" type.
            // And so this algorithm stakes out cut off points so that we don't
            // blindly just descend all Parallels in the layer.
            const prunedParallels = new Set();
            const pruneParallelsFollowFn = (par) => {
                const upperParallels = par.getParallels().slice();
                if (par instanceof Truth.SpecifiedParallel)
                    for (const { base } of par.eachBase())
                        upperParallels.push(base);
                return upperParallels;
            };
            const hasSpecifiedContents = Truth.Misc.reduceRecursive(zenith, pruneParallelsFollowFn, (current, results) => {
                const prune = results.every(result => !result) &&
                    !canDescendToSpecified(current);
                if (prune)
                    prunedParallels.add(current);
                return !prune;
            });
            // In the case when the method is attempting to descend
            // to a level where there are no nodes whose name match
            // the type name specified (i.e. the whole layer would be 
            // unspecified parallels), null is returned because a descend
            // wouldn't make sense.
            if (!hasSpecifiedContents)
                return null;
            const descendParallelsFollowFn = (par) => {
                if (!(par instanceof Truth.SpecifiedParallel))
                    return [];
                const bases = Array.from(par.eachBase())
                    .map(entry => entry.base)
                    .slice();
                const result = bases
                    .concat(par.getParallels())
                    .filter(par => !prunedParallels.has(par));
                return result;
            };
            const seed = Truth.Misc.reduceRecursive(zenith, descendParallelsFollowFn, (current, nested) => {
                const nextPar = descendOne(current);
                for (const edge of nested)
                    nextPar.addParallel(edge);
                return nextPar;
            });
            return seed;
        }
        /**
         * Performs verification on the descend operation.
         * Reports any faults that can occur during this process.
         */
        verifyDescend(zenithParallel, descendParallel) {
            if (descendParallel.node.subject instanceof Truth.Anon)
                if (zenithParallel.isListIntrinsic)
                    this.program.faults.report(new Truth.Fault(Truth.Faults.AnonymousInListIntrinsic, descendParallel.node.statements[0]));
        }
    }
    Truth.ConstructionWorker = ConstructionWorker;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(uri, container) {
            this.uri = uri;
            this.container = container;
            /**
             * Stores a version number for this instance,
             * useful for debugging purposes.
             */
            this.version = Truth.VersionStamp.next();
            this._contents = new Map();
            this._parallels = [];
            this.name = uri.toTypeString();
            if (this.name.startsWith("/"))
                this.name = unescape(this.name);
            if (container !== null)
                container._contents.set(uri.types.slice(-1)[0].value, this);
        }
        /**
         *
         */
        get contents() {
            return this._contents;
        }
        /** */
        getParallels() {
            return Object.freeze(this._parallels.slice());
        }
        /** */
        get hasParallels() {
            return this._parallels.length > 0;
        }
        /** */
        addParallel(parallel) {
            if (!this._parallels.includes(parallel))
                this._parallels.push(parallel);
        }
    }
    Truth.Parallel = Parallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class SpecifiedParallel extends Truth.Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(node, container, cruft) {
            super(node.uri, container);
            this._contract = null;
            this._bases = new Map();
            this._intrinsicExtrinsicBridge = null;
            /**
             * Stores a string representation of the compiled regular expression
             * associated with this instance, in the case when this instance is
             * a pattern parallel.
             *
             * This string representation should have any infixes compiled away,
             * and should be passable to a JavaScript RegExp, or to the Fsm system.
             */
            this.compiledExpression = null;
            this.node = node;
            this.cruft = cruft;
            node.document.program.faults.inform(node);
        }
        /** */
        get isContractSatisfied() {
            return this.contract.unsatisfiedConditions.size === 0;
        }
        /** */
        get contract() {
            // It's important that this contract is computed lazily, because
            // if you try to compute it in the constructor, the Parallel graph
            // won't be constructed, and you'll end up with an empty contract.
            if (this._contract === null)
                this._contract = new Truth.Contract(this);
            return this._contract;
        }
        /**
         * Gets the first base contained by this instance.
         * @throws In the case when this instance contains no bases.
         */
        get firstBase() {
            for (const baseEntry of this._bases.values())
                return baseEntry.parallels[0];
            throw Truth.Exception.unknownState();
        }
        /**
         * Performs a shallow traversal on the non-cruft bases
         * defined directly on this Parallel.
         */
        *eachBase() {
            for (const [edge, baseEntry] of this._bases)
                if (!this.cruft.has(edge))
                    for (const base of baseEntry.parallels)
                        yield { base, edge, aliased: baseEntry.aliased };
        }
        /**
         *
         */
        addBaseEntry(base, edge, aliased) {
            const existing = this._bases.get(edge);
            if (existing)
                existing.parallels.push(base);
            else
                this._bases.set(edge, { parallels: [base], aliased });
        }
        /**
         * Performs a deep traversal on the non-cruft bases
         * defined on this Parallel.
         */
        *eachBaseDeep() {
            const queue = Array.from(this.eachBase()).map(e => e.base);
            for (let i = -1; ++i < queue.length;) {
                const current = queue[i];
                yield current;
                for (const { base } of current.eachBase())
                    if (!queue.includes(base))
                        queue.push(base);
            }
        }
        /**
         * @returns A boolean value that indicates whether the provided
         * SpecifiedParallel instance exists somewhere, possibly nested,
         * in the base graph of this instance.
         */
        hasBase(testBase) {
            const queue = Array.from(this.eachBase()).map(e => e.base);
            for (let i = -1; ++i < queue.length;) {
                const current = queue[i];
                if (current === testBase)
                    return true;
                for (const { base } of current.eachBase())
                    if (!queue.includes(base))
                        queue.push(base);
            }
            return false;
        }
        /**
         * Attempts to add the provided SpecifiedParallel as a base of
         * this instance. If the addition of the new base would not generate
         * any critical faults, it is added. Otherwise, it's marked as cruft.
         *
         * @returns A boolean value that indicates whether the base
         * was added successfully.
         */
        tryAddLiteralBase(base, via) {
            if (this._bases.has(via))
                throw Truth.Exception.unknownState();
            // Just as a reminder -- pattern-containing parallels 
            // don't come into this method. Bases are applied to
            // patterns in tryApplyPatternBases.
            if (this.pattern)
                throw Truth.Exception.unknownState();
            const numSatisfied = this.contract.trySatisfyCondition(base);
            if (numSatisfied === 0 && this.contract.hasConditions)
                return false;
            const sanitizer = new Truth.Sanitizer(this, base, via, this.cruft);
            // In this case, we only need to do a 
            // shallow check for circular inheritance.
            if (sanitizer.detectCircularReferences())
                return false;
            if (sanitizer.detectListFragmentConflicts())
                return false;
            if (this.baseCount > 0) {
                if (sanitizer.detectListDimensionalityConflict())
                    return false;
            }
            this.addBaseEntry(base, via, false);
            return true;
        }
        /**
         * Attempts to indirectly apply a base to this SpecifiedParallel via an alias
         * and edge.
         *
         * @param patternParallelCandidates The pattern-containing
         * SpecifiedParallel instance whose bases should be applied to this
         * SpecifiedParallel, if the provided alias is a match.
         *
         * @param viaEdge The HyperEdge in which the alias was found.
         *
         * @param viaAlias The string to test against the parallel embedded
         * within patternParallelCandidates.
         *
         * @returns A boolean value that indicates whether a base was added
         * successfully.
         */
        tryAddAliasedBase(patternParallelCandidates, viaEdge, viaAlias) {
            if (this._bases.has(viaEdge))
                throw Truth.Exception.unknownState();
            const chosenParallels = patternParallelCandidates.slice();
            const conditions = this.contract.unsatisfiedConditions;
            const beganWithConditions = conditions.size > 0;
            if (beganWithConditions) {
                let maxMatchCount = 1;
                nextCandidate: for (const candidate of patternParallelCandidates) {
                    const entries = Array.from(candidate._bases.values());
                    const candidateBases = entries
                        .map(e => e.parallels)
                        .reduce((a, b) => a.concat(b), []);
                    if (candidateBases.length < maxMatchCount)
                        continue;
                    for (const candidateBase of candidateBases)
                        if (!conditions.has(candidateBase))
                            continue nextCandidate;
                    chosenParallels.push(candidate);
                    maxMatchCount = candidateBases.length;
                }
                if (chosenParallels.length === 0)
                    return false;
            }
            let wasAdded = false;
            for (const chosenParallel of chosenParallels) {
                // Just as a reminder -- pattern-containing parallels don't come
                // into this method ... only the aliases that might match them.
                if (this.pattern || !chosenParallel.pattern)
                    throw Truth.Exception.unknownState();
                // If the targetPattern has no infixes, we can get away with a simple
                // check to see if the alias matches the regular expression.
                if (!chosenParallel.pattern.hasInfixes()) {
                    if (!chosenParallel.pattern.test(viaAlias))
                        continue;
                    if (beganWithConditions)
                        if (this.contract.trySatisfyCondition(chosenParallel) === 0)
                            continue;
                    this.addBaseEntry(chosenParallel, viaEdge, true);
                    wasAdded = true;
                }
            }
            // Not implemented, but we shouldn't throw an exception here yet.
            return wasAdded;
        }
        /**
         * Attempts to apply a set of bases to a pattern-containing parallel.
         *
         * @example
         * /pattern : This, Function, Adds, These
         */
        tryApplyPatternBases(baseTable) {
            const bases = Array.from(baseTable.keys());
            // Non-Pattern nodes should never come to this method.
            if (!this.pattern)
                throw Truth.Exception.unknownState();
            const basesDeep = bases
                .map(b => Array.from(b.eachBaseDeep()))
                .reduce((a, b) => a.concat(b), [])
                .filter((v, i, a) => a.indexOf(v) === i);
            // Reminder: the SpecifiedParallels in the basesDeep array
            // are expected to be fully processed by the time we get to
            // this method. It should be safe to touch them.
            if (basesDeep.length > 0) {
                const basesNodes = bases.map(b => b.node);
                // Finds all pattern nodes that have an edge that points
                // to at least one of the bases in the basesDeep array.
                const basesDeepSprawl = basesDeep
                    .map(b => Array.from(b.node.inbounds))
                    .reduce((a, b) => a.concat(b), [])
                    .map(inb => inb.predecessor)
                    .filter((v, i, a) => a.indexOf(v) === i)
                    .filter(node => node.subject instanceof Truth.Pattern)
                    .filter(node => node.outbounds
                    .filter(ob => ob.successors.length === 0)
                    .map(ob => ob.successors[0].node)
                    .every(node => basesNodes.includes(node)));
                const basesDeepSprawlPatterns = basesDeepSprawl
                    .map(n => n.subject)
                    .filter((s) => s instanceof Truth.Pattern);
                /**
                 * At this point, we need to test every single one of the
                 * patterns in basesDeepSprawlPatterns against this
                 * this.node.subject to make sure the two patterns are
                 * compliant.
                 *
                 * If they're not compliant, we need to start marking
                 * bases as cruft until they are.
                 *
                 * There is also a recursive infix embed process that
                 * needs to happen here, but maybe we should just
                 * put this off until the basic pattern functionality
                 * is working?
                 */
            }
            /**
             * This also needs to take into account any other patterns
             * that are applied to any of the bases defined directly
             * inline.
             */
            // Here we're just adding all the bases regardless of whether
            // or not any of the associated edges were marked as cruft.
            // The other enumerators skip over cruft edges, so this likely
            // isn't a problem, and it keeps it consistent with the way the
            // rest of the system works.
            for (const [base, via] of baseTable)
                this.addBaseEntry(base, via, false);
        }
        /**
         * Gets the number of bases that have
         * been explicitly applied to this Parallel.
         */
        get baseCount() {
            return this._bases.size;
        }
        /** */
        get isListIntrinsic() {
            return this.node.isListIntrinsic;
        }
        /** */
        get intrinsicExtrinsicBridge() {
            return this._intrinsicExtrinsicBridge;
        }
        /**
         * Establishes a bridge between this SpecifiedParallel and the
         * one provided.
         */
        createIntrinsicExtrinsicBridge(parallel) {
            if (this._intrinsicExtrinsicBridge !== null)
                throw Truth.Exception.unknownState();
            if (parallel._intrinsicExtrinsicBridge !== null)
                throw Truth.Exception.unknownState();
            if (parallel.node.isListIntrinsic === this.node.isListIntrinsic)
                throw Truth.Exception.unknownState();
            this._intrinsicExtrinsicBridge = parallel;
            parallel._intrinsicExtrinsicBridge = this;
        }
        /** */
        getListDimensionality() {
            // NOTE: This actually needs to be "each base inferred"
            // This is purposely only returning the dimensionality of
            // the first base. There is a guarantee that all dimensionalities
            // will be the same here.
            for (const { base, edge } of this.eachBase()) {
                const initialDim = base.getListDimensionality();
                return edge.isList ? initialDim + 1 : initialDim;
            }
            return 0;
        }
        /**
         *
         */
        comparePatternTo(other) {
        }
        /**
         *
         */
        maybeCompilePattern() {
            ///if (!this.pattern)
            ///	return;
            ///if (!pattern.hasInfixes())
            ///	this.compiledExpression = pattern.
        }
        /**
         * Gets the Pattern instance that resides inside this SpecifiedParallel,
         * or null in the case when this SpecifiedParallel does not have an
         * inner Pattern.
         */
        get pattern() {
            return this.node.subject instanceof Truth.Pattern ?
                this.node.subject :
                null;
        }
    }
    Truth.SpecifiedParallel = SpecifiedParallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class UnspecifiedParallel extends Truth.Parallel {
        /**
         * @internal
         * Invoked by ParallelCache. Do not call.
         */
        constructor(uri, container) {
            super(uri, container);
        }
    }
    Truth.UnspecifiedParallel = UnspecifiedParallel;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A simple class for handling objects marked as cruft.
     */
    class CruftCache {
        /** */
        constructor(program) {
            this.program = program;
            /** Stores a set of objects that have been marked as cruft. */
            this.cruft = new Set();
        }
        /**
         * Adds a fault of the specified type to the internal set,
         * marks all relevant objects as cruft, and reports the
         * relevant fault type.
         */
        add(cruft, relevantFaultType) {
            const faultSources = cruft instanceof Truth.Node ? cruft.statements :
                cruft instanceof Truth.HyperEdge ? cruft.fragments :
                    [cruft];
            for (const faultSrc of faultSources) {
                const fault = new Truth.Fault(relevantFaultType, faultSrc);
                this.program.faults.report(fault);
                this.cruft.add(faultSrc);
            }
            this.cruft.add(cruft);
        }
        /**
         * @returns A boolean value that indicates whether the
         * specified object has been marked as cruft.
         */
        has(source) {
            return this.cruft.has(source);
        }
    }
    Truth.CruftCache = CruftCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class ParallelCache {
        constructor() {
            /**
             * Stores a map of all Parallel instances that have been
             * constructed by this object.
             */
            this.parallels = new Map();
        }
        create(key, cruft) {
            if (this.has(key))
                throw Truth.Exception.unknownState();
            const save = (par) => {
                const keyVal = this.getKeyVal(key);
                this.parallels.set(keyVal, par);
                return par;
            };
            const container = (() => {
                if (key instanceof Truth.Node)
                    return key.container !== null ?
                        Truth.Not.undefined(this.get(key.container)) :
                        null;
                return key.types.length > 1 ?
                    Truth.Not.undefined(this.get(key.retractType(1))) :
                    null;
            })();
            if (key instanceof Truth.Uri)
                return save(new Truth.UnspecifiedParallel(key, container));
            if (!(container instanceof Truth.SpecifiedParallel) && container !== null)
                throw Truth.Exception.unknownState();
            if (cruft === undefined)
                throw Truth.Exception.unknownState();
            const outPar = new Truth.SpecifiedParallel(key, container, cruft);
            if (key.intrinsicExtrinsicBridge === null)
                return save(outPar);
            if (this.has(key.intrinsicExtrinsicBridge))
                throw Truth.Exception.unknownState();
            const bridgePar = new Truth.SpecifiedParallel(key.intrinsicExtrinsicBridge, container, cruft);
            outPar.createIntrinsicExtrinsicBridge(bridgePar);
            return save(outPar);
        }
        get(key) {
            const keyVal = this.getKeyVal(key);
            const out = this.parallels.get(keyVal);
            if (key instanceof Truth.Node)
                if (out !== undefined)
                    if (!(out instanceof Truth.SpecifiedParallel))
                        throw Truth.Exception.unknownState();
            return out;
        }
        /** */
        has(key) {
            return this.parallels.has(this.getKeyVal(key));
        }
        /** */
        getKeyVal(key) {
            const uri = key instanceof Truth.Node ? key.uri : key;
            return uri.toString();
        }
        /** */
        get debug() {
            const text = [];
            for (const [key, value] of this.parallels)
                text.push(value.name);
            return text.join("\n");
        }
    }
    Truth.ParallelCache = ParallelCache;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     *
     */
    class Contract {
        /** */
        constructor(sourceParallel) {
            this._unsatisfiedConditions = new Set();
            const recurse = (srcParallel) => {
                if (srcParallel instanceof Truth.UnspecifiedParallel) {
                    for (const nestedParallel of srcParallel.getParallels())
                        recurse(nestedParallel);
                }
                else if (srcParallel instanceof Truth.SpecifiedParallel) {
                    for (const { base } of srcParallel.eachBase())
                        this._unsatisfiedConditions.add(base);
                }
            };
            for (const higherParallel of sourceParallel.getParallels())
                recurse(higherParallel);
            this.allConditions = Object.freeze(Array.from(this._unsatisfiedConditions));
        }
        /**
         * Computes whether the input SpecifiedParallel is a more derived
         * type of the SpecifiedParallel that corresponds to this Contract.
         *
         * @returns A number that indicates the number of conditions that
         * were satisfied as a result of adding the provided SpecifiedParallel
         * to the Contract.
         */
        trySatisfyCondition(foreignParallel) {
            if (this.allConditions.length === 0)
                return 0;
            const foreignParallelBases = new Set();
            foreignParallelBases.add(foreignParallel);
            let satisfied = 0;
            const addForeignParallelBases = (srcParallel) => {
                for (const { base } of srcParallel.eachBase())
                    addForeignParallelBases(base);
                foreignParallelBases.add(srcParallel);
            };
            for (const { base } of foreignParallel.eachBase())
                addForeignParallelBases(base);
            for (const foreignBase of foreignParallelBases)
                for (const condition of this.allConditions)
                    if (foreignBase === condition)
                        satisfied += this._unsatisfiedConditions.delete(condition) ? 1 : 0;
            return satisfied;
        }
        /** */
        get hasConditions() {
            return this.allConditions.length > 0;
        }
        /** */
        get unsatisfiedConditions() {
            return this._unsatisfiedConditions;
        }
    }
    Truth.Contract = Contract;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that encapsulates the actual fault detection behavior,
     * with facilities to perform analysis on Parallel instances, before
     * the actual base has been applied to it.
     */
    class Sanitizer {
        /** */
        constructor(targetParallel, proposedBase, proposedEdge, cruft) {
            this.targetParallel = targetParallel;
            this.proposedBase = proposedBase;
            this.proposedEdge = proposedEdge;
            this.cruft = cruft;
            this._foundCruft = false;
        }
        /**
         * Detects list operartor conflicts between the fragments of an
         * annotation. For example, conflicts of the following type are
         * caught here:
         *
         * List : Item
         * List : Item...
         */
        detectListFragmentConflicts() {
            const sources = this.proposedEdge.fragments;
            if (sources.length === 0)
                return false;
            const spans = sources.filter((src) => src instanceof Truth.Span);
            const identifiers = spans
                .map(f => f.boundary.subject)
                .filter((sub) => sub instanceof Truth.Identifier);
            const identifiersList = identifiers.filter(id => id.isList);
            const identifiersNonList = identifiers.filter(id => !id.isList);
            if (identifiersList.length > 0 && identifiersNonList.length > 0)
                for (const span of spans)
                    this.addFault(span, Truth.Faults.ListAnnotationConflict);
            return this.foundCruft;
        }
        /** */
        detectCircularReferences() {
            const circularEdgePaths = [];
            const recurse = (srcBase, path) => {
                for (const { base, edge } of this.basesOf(srcBase)) {
                    if (path.includes(edge))
                        circularEdgePaths.push(path.slice());
                    else
                        recurse(base, path.concat(edge));
                }
            };
            for (const { base, edge } of this.basesOf(this.targetParallel))
                recurse(base, []);
            for (const item of circularEdgePaths)
                for (const circularEdge of item)
                    this.addFault(circularEdge, Truth.Faults.CircularTypeReference);
            return this.foundCruft;
        }
        /** */
        detectListDimensionalityConflict() {
            const targetDim = this.targetParallel.getListDimensionality();
            const proposedDim = this.proposedBase.getListDimensionality() +
                (this.proposedEdge.isList ? 1 : 0);
            if (targetDim !== proposedDim)
                this.addFault(this.proposedEdge, Truth.Faults.ListDimensionalDiscrepancyFault);
            return this.foundCruft;
        }
        /** Gets a boolean value that indicates whether a fault has been reported. */
        get foundCruft() {
            return this._foundCruft;
        }
        /** */
        *basesOf(par) {
            for (const { base, edge } of par.eachBase())
                yield { base, edge };
            if (this.targetParallel === par)
                yield { base: this.proposedBase, edge: this.proposedEdge };
        }
        /** */
        addFault(source, relevantFaultType) {
            this._foundCruft = true;
            this.cruft.add(source, relevantFaultType);
        }
    }
    Truth.Sanitizer = Sanitizer;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * A class that represents a fully constructed type within the program.
     */
    class Type {
        /**
         *
         */
        constructor(seed, container, program) {
            /**
             * Stores whether this type represents the intrinsic
             * side of a list.
             */
            this.isListIntrinsic = false;
            /**
             * Stores whether this type represents the extrinsic
             * side of a list.
             */
            this.isListExtrinsic = false;
            /**
             * Stores whether this Type instance has no annotations applied to it.
             */
            this.isFresh = false;
            /**
             * Stores a value that indicates if this Type was directly specified
             * in the document, or if it's existence was inferred.
             */
            this.isSpecified = false;
            /** */
            this.isAnonymous = false;
            /** */
            this.isPattern = false;
            /** */
            this.isUri = false;
            /** */
            this.isList = false;
            this.private = new TypePrivate(program, seed);
            this.name = seed.uri.types[seed.uri.types.length - 1].value;
            this.uri = seed.uri;
            this.container = container;
            this.private.parallels = new Truth.TypeProxyArray(seed.getParallels().map(edge => new Truth.TypeProxy(edge.uri, program)));
            const getBases = (sp) => {
                const bases = Array.from(sp.eachBase());
                return bases.map(entry => new Truth.TypeProxy(entry.base.node.uri, program));
            };
            if (seed instanceof Truth.SpecifiedParallel) {
                this.private.bases = new Truth.TypeProxyArray(getBases(seed));
            }
            else if (seed instanceof Truth.UnspecifiedParallel) {
                const queue = [seed];
                const specifiedParallels = [];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    if (current instanceof Truth.UnspecifiedParallel)
                        queue.push(...current.getParallels());
                    else if (current instanceof Truth.SpecifiedParallel)
                        specifiedParallels.push(current);
                }
                const bases = specifiedParallels
                    .map(par => getBases(par))
                    .reduce((a, b) => a.concat(b), [])
                    .filter((v, i, a) => a.indexOf(v) === i);
                this.private.bases = new Truth.TypeProxyArray(bases);
            }
            this.isList = false;
            if (seed instanceof Truth.SpecifiedParallel) {
                const sub = seed.node.subject;
                this.isPattern = sub instanceof Truth.Pattern;
                this.isUri = sub instanceof Truth.Uri;
                this.isAnonymous = sub instanceof Truth.Anon;
                this.isSpecified = true;
                this.isFresh = seed.getParallels().length === 0;
            }
        }
        static construct(param, program) {
            const uri = Truth.Uri.clone(param);
            if (uri.types.length === 0)
                return null;
            if (Truth.TypeCache.has(uri, program)) {
                const cached = Truth.TypeCache.get(uri, program);
                // If the cached type exists, but hasn't been compiled yet,
                // we can't return it, we need to compile it first.
                if (cached === null || cached instanceof Type)
                    return cached;
            }
            const worker = (() => {
                const stored = this.parallelContextMap.get(program);
                if (stored === undefined) {
                    const newStored = {
                        version: program.version,
                        worker: new Truth.ConstructionWorker(program)
                    };
                    this.parallelContextMap.set(program, newStored);
                    return newStored.worker;
                }
                else if (program.version.newerThan(stored.version)) {
                    stored.version = program.version;
                    stored.worker = new Truth.ConstructionWorker(program);
                }
                return stored.worker;
            })();
            const parallel = worker.drill(uri);
            if (parallel === null) {
                Truth.TypeCache.set(uri, program, null);
                return null;
            }
            const parallelLineage = [parallel];
            for (let currentParallel = parallel.container; currentParallel !== null;) {
                parallelLineage.unshift(currentParallel);
                currentParallel = currentParallel.container;
            }
            let lastType = null;
            for (const currentParallel of parallelLineage) {
                if (Truth.TypeCache.has(currentParallel.uri, program)) {
                    const existingType = Truth.TypeCache.get(currentParallel.uri, program);
                    if (existingType instanceof Truth.TypeProxy)
                        throw Truth.Exception.unknownState();
                    if (existingType === null)
                        throw Truth.Exception.unknownState();
                    lastType = existingType;
                }
                else {
                    const type = new Type(currentParallel, lastType, program);
                    Truth.TypeCache.set(currentParallel.uri, program, type);
                    lastType = type;
                }
            }
            return lastType;
        }
        /**
         * @internal
         * Constructs the invisible root-level Type object that corresponds
         * to the specified document.
         */
        static constructRoots(document) {
            const program = document.program;
            const roots = [];
            for (const node of program.graph.readRoots(document)) {
                const type = this.construct(node.uri, program);
                if (type !== null)
                    roots.push(type);
            }
            return Object.freeze(roots);
        }
        /**
         * Stores a reference to the type, as it's defined in it's
         * next most applicable type.
         */
        get parallels() {
            this.private.throwOnDirty();
            return Truth.Not.null(this.private.parallels).maybeCompile();
        }
        /**
         * Stores a reference to the parallel roots of this type.
         * The parallel roots are the endpoints found when
         * traversing upward through the parallel graph.
         */
        get parallelRoots() {
            this.private.throwOnDirty();
            if (this.private.parallelRoots !== null)
                return this.private.parallelRoots;
            const roots = [];
            for (const { type } of this.iterate(t => t.parallels))
                if (type !== this && type.parallels.length === 0)
                    roots.push(type);
            return this.private.parallelRoots = Object.freeze(roots);
        }
        /**
         * Stores the array of types that are contained directly by this
         * one. In the case when this type is a list type, this array does
         * not include the list's intrinsic types.
         */
        get contents() {
            if (this.private.contents !== null)
                return this.private.contents;
            this.private.throwOnDirty();
            const containedNames = [];
            // Dig through the parallel graph recursively, and at each parallel,
            // dig through the base graph recursively, and collect all the names
            // that are found.
            for (const { type: parallelType } of this.iterate(t => t.parallels, true))
                for (const { type: baseType } of parallelType.iterate(t => t.bases, true))
                    if (baseType.private.seed instanceof Truth.SpecifiedParallel)
                        for (const name of baseType.private.seed.node.contents.keys())
                            if (!containedNames.includes(name))
                                containedNames.push(name);
            const contents = containedNames
                .map(containedName => {
                const maybeContainedUri = this.uri.extendType(containedName);
                return Type.construct(maybeContainedUri, this.private.program);
            })
                .filter((t) => t !== null);
            return this.private.contents = Object.freeze(contents);
        }
        /**
         * @internal
         * Stores the array of types that are contained directly by this
         * one. In the case when this type is not a list type, this array
         * is empty.
         */
        get contentsIntrinsic() {
            if (this.private.contentsIntrinsic !== null)
                return this.private.contentsIntrinsic;
            if (!this.isList)
                return this.private.contentsIntrinsic = Object.freeze([]);
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
        }
        /**
         * Stores the array of types from which this type extends.
         * If this Type extends from a pattern, it is included in this
         * array.
         */
        get bases() {
            this.private.throwOnDirty();
            if (this.private.bases === null)
                throw Truth.Exception.unknownState();
            return this.private.bases.maybeCompile();
        }
        /**
         * @internal
         * Not implemented.
         */
        get superordinates() {
            if (this.private.superordinates !== null)
                return this.private.superordinates;
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
            // eslint-disable-next-line no-unreachable
            return this.private.superordinates = Object.freeze([]);
        }
        /**
         * @internal
         */
        get subordinates() {
            if (this.private.subordinates !== null)
                return this.private.subordinates;
            this.private.throwOnDirty();
            throw Truth.Exception.notImplemented();
            // eslint-disable-next-line no-unreachable
            return this.private.subordinates = Object.freeze([]);
        }
        /**
         * Gets an array that contains the types that derive from the
         * this Type instance.
         *
         * The types that derive from this one as a result of the use of
         * an alias are excluded from this array.
         */
        get derivations() {
            if (this.private.derivations !== null)
                return this.private.derivations;
            this.private.throwOnDirty();
            if (!(this.private.seed instanceof Truth.SpecifiedParallel))
                return this.private.derivations = Object.freeze([]);
            const derivations = Array.from(this.private.seed.node.inbounds)
                .map(ib => ib.predecessor.uri)
                .map(uri => Type.construct(uri, this.private.program))
                .filter((t) => t instanceof Type)
                .filter(type => type.bases.includes(this));
            return this.private.derivations = Object.freeze(derivations);
        }
        /**
         * Gets an array that contains the that share the same containing
         * type as this one.
         */
        get adjacents() {
            if (this.private.adjacents !== null)
                return this.private.adjacents;
            this.private.throwOnDirty();
            if (this.container)
                return this.private.adjacents = this.container.contents.filter(t => t !== this);
            const program = this.private.program;
            const document = Truth.Not.null(program.documents.get(this.uri));
            const roots = Array.from(this.private.program.graph.readRoots(document));
            const adjacents = roots
                .map(node => Type.construct(node.uri, program))
                .filter((t) => t !== null && t !== this);
            return this.private.adjacents = Object.freeze(adjacents);
        }
        /**
         * Gets an array that contains the patterns that resolve to this type.
         */
        get patterns() {
            if (this.private.patterns !== null)
                return this.private.patterns;
            this.private.throwOnDirty();
            // Stores a map whose keys are a concatenation of the Uris of all
            // the bases that are matched by a particular pattern, and whose
            // values are the type object containing that pattern. This map
            // provides an easy way to determine if there is already a pattern
            // that matches a particular set of types in the type scope.
            const patternMap = new Map();
            for (const { type } of this.iterate(t => t.container)) {
                const applicablePatternTypes = type.adjacents
                    .filter(t => t.isPattern)
                    .filter(t => t.bases.includes(type));
                const applicablePatternsBasesLabels = applicablePatternTypes.map(p => p.bases
                    .map(b => b.uri.toString())
                    .join("\n" /* terminal */));
                for (let i = -1; ++i < applicablePatternTypes.length;) {
                    const baseLabel = applicablePatternsBasesLabels[i];
                    if (!patternMap.has(baseLabel))
                        patternMap.set(baseLabel, applicablePatternTypes[i]);
                }
            }
            const out = Array.from(patternMap.values());
            return this.private.patterns = Object.freeze(out);
        }
        /**
         * Gets an array that contains the raw string values representing
         * the type aliases with which this type has been annotated.
         *
         * If this type is unspecified, the parallel graph is searched,
         * and any applicable type aliases will be present in the returned
         * array.
         */
        get aliases() {
            if (this.private.aliases !== null)
                return this.private.aliases;
            this.private.throwOnDirty();
            const aliases = [];
            const extractAlias = (sp) => {
                for (const { edge, aliased } of sp.eachBase())
                    if (aliased)
                        aliases.push(edge.identifier.toString());
            };
            if (this.private.seed instanceof Truth.SpecifiedParallel) {
                extractAlias(this.private.seed);
            }
            else if (this.private.seed instanceof Truth.UnspecifiedParallel) {
                const queue = [this.private.seed];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    for (const parallel of current.getParallels()) {
                        if (parallel instanceof Truth.SpecifiedParallel)
                            extractAlias(parallel);
                        else if (parallel instanceof Truth.UnspecifiedParallel)
                            queue.push(parallel);
                    }
                }
            }
            return this.private.aliases = aliases;
        }
        /**
         *
         */
        get values() {
            if (this.private.values !== null)
                return this.private.values;
            this.private.throwOnDirty();
            const values = [];
            const extractType = (sp) => {
                for (const { edge, aliased } of sp.eachBase())
                    values.push({
                        aliased,
                        value: edge.identifier.toString(),
                        base: Type.construct(edge.predecessor.uri, this.private.program)
                    });
            };
            if (this.private.seed instanceof Truth.SpecifiedParallel) {
                extractType(this.private.seed);
            }
            else if (this.private.seed instanceof Truth.UnspecifiedParallel) {
                const queue = [this.private.seed];
                for (let i = -1; ++i < queue.length;) {
                    const current = queue[i];
                    for (const parallel of current.getParallels()) {
                        if (parallel instanceof Truth.SpecifiedParallel)
                            extractType(parallel);
                        else if (parallel instanceof Truth.UnspecifiedParallel)
                            queue.push(parallel);
                    }
                }
            }
            return this.private.values = values;
        }
        /**
         * Gets the first alias stored in the .values array, or null if the
         * values array is empty.
         */
        get value() {
            return this.aliases.length > 0 ? this.aliases[0] : null;
        }
        /** */
        get isOverride() { return this.parallels.length > 0; }
        /** */
        get isIntroduction() { return this.parallels.length === 0; }
        /**
         * Gets a boolean value that indicates whether this Type
         * instance was created from a previous edit frame, and
         * should no longer be used.
         */
        get isDirty() {
            return this.private.program.version.newerThan(this.private.stamp);
        }
        /**
         * Performs an arbitrary recursive, breadth-first traversal
         * that begins at this Type instance. Ensures that no types
         * types are yielded multiple times.
         *
         * @param nextFn A function that returns a type, or an
         * iterable of types that are to be visited next.
         * @param reverse An optional boolean value that indicates
         * whether types in the returned array should be sorted
         * with the most deeply visited nodes occuring first.
         *
         * @returns An array that stores the list of types that were
         * visited.
         */
        visit(nextFn, reverse) {
            return Array.from(this.iterate(nextFn, reverse)).map(entry => entry.type);
        }
        /**
         * Performs an arbitrary recursive, breadth-first iteration
         * that begins at this Type instance. Ensures that no types
         * types are yielded multiple times.
         *
         * @param nextFn A function that returns a type, or an iterable
         * of types that are to be visited next.
         * @param reverse An optional boolean value that indicates
         * whether the iterator should yield types starting with the
         * most deeply nested types first.
         *
         * @yields An object that contains a `type` property that is the
         * the Type being visited, and a `via` property that is the Type
         * that was returned in the previous call to `nextFn`.
         */
        *iterate(nextFn, reverse) {
            const yielded = [];
            function* recurse(type, via) {
                if (yielded.includes(type))
                    return;
                if (!reverse) {
                    yielded.push(type);
                    yield { type, via };
                }
                const reduced = nextFn(type);
                if (reduced !== null && reduced !== undefined) {
                    if (reduced instanceof Type)
                        return yield* recurse(reduced, type);
                    for (const nextType of reduced)
                        if (nextType instanceof Type)
                            yield* recurse(nextType, type);
                }
                if (reverse) {
                    yielded.push(type);
                    yield { type, via };
                }
            }
            yield* recurse(this, null);
        }
        /**
         * Queries for a Type that is nested underneath this Type,
         * at the specified type path.
         */
        query(...typePath) {
            let currentType = null;
            for (const typeName of typePath) {
                const nextType = this.contents.find(type => type.name === typeName);
                if (!nextType)
                    break;
                currentType = nextType;
            }
            return currentType;
        }
        /**
         * Checks whether this Type has the specified type
         * somewhere in it's base graph.
         */
        is(baseType) {
            for (const { type } of this.iterate(t => t.bases))
                if (type === baseType)
                    return true;
            return false;
        }
        /**
         * Checks whether the specified type is in this Type's
         * `.contents` property, either directly, or indirectly via
         * the parallel graphs of the `.contents` Types.
         */
        has(type) {
            if (this.contents.includes(type))
                return true;
            for (const containedType of this.contents)
                if (type.name === containedType.name)
                    for (const parallel of containedType.iterate(t => t.parallels))
                        if (parallel.type === type)
                            return true;
            return false;
        }
    }
    /** */
    Type.parallelContextMap = new WeakMap();
    Truth.Type = Type;
    /**
     * @internal
     * A hidden class that stores the private information of
     * a Type instance, used to mitigate the risk of low-rank
     * developers from getting themselves into trouble.
     */
    class TypePrivate {
        constructor(program, seed) {
            this.program = program;
            this.seed = seed;
            /** */
            this.contents = null;
            /** */
            this.contentsIntrinsic = null;
            /** */
            this.bases = null;
            /** */
            this.parallels = null;
            /** */
            this.parallelRoots = null;
            /** */
            this.patterns = null;
            /** */
            this.aliases = null;
            /** */
            this.values = null;
            /** */
            this.superordinates = null;
            /** */
            this.subordinates = null;
            /** */
            this.derivations = null;
            /** */
            this.adjacents = null;
            this.stamp = program.version;
        }
        /** */
        throwOnDirty() {
            if (this.program.version.newerThan(this.stamp))
                throw Truth.Exception.objectDirty();
        }
    }
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeProxy {
        /** */
        constructor(uri, program) {
            this.uri = uri;
            this.program = program;
            /** */
            this.compiledType = undefined;
        }
        /** */
        maybeCompile() {
            if (this.compiledType !== undefined)
                return this.compiledType;
            return this.compiledType = Truth.Type.construct(this.uri, this.program);
        }
    }
    Truth.TypeProxy = TypeProxy;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeProxyArray {
        /**
         *
         */
        constructor(array) {
            this.array = array;
            this.compiledArray = undefined;
        }
        /**
         *
         */
        maybeCompile() {
            if (this.compiledArray !== undefined)
                return this.compiledArray;
            const out = this.array
                .map(lazy => lazy.maybeCompile())
                .filter((type) => type !== null);
            return this.compiledArray = Object.freeze(out);
        }
    }
    Truth.TypeProxyArray = TypeProxyArray;
})(Truth || (Truth = {}));
var Truth;
(function (Truth) {
    /**
     * @internal
     */
    class TypeCache {
        /** */
        constructor(program) {
            this.program = program;
            /** */
            this.map = new Map();
            this.version = program.version;
        }
        /** */
        static has(uri, program) {
            const cache = this.getCache(program);
            const uriText = uri.toString();
            return cache.map.has(uriText);
        }
        /** */
        static get(uri, program) {
            const cache = this.getCache(program);
            const uriText = uri.toString();
            if (cache.map.has(uriText))
                return Truth.Not.undefined(cache.map.get(uriText));
            const proxy = new Truth.TypeProxy(uri, program);
            this.set(uri, program, proxy);
            return proxy;
        }
        /** */
        static set(uri, program, type) {
            const cache = this.getCache(program);
            const uriText = uri.toString();
            cache.map.set(uriText, type);
            return type;
        }
        /** */
        static getCache(program) {
            const cache = this.allCaches.get(program) || (() => {
                const cache = new TypeCache(program);
                this.allCaches.set(program, cache);
                return cache;
            })();
            cache.maybeClear();
            return cache;
        }
        /** */
        maybeClear() {
            if (this.program.version.newerThan(this.version)) {
                this.map.clear();
                this.version = this.program.version;
            }
        }
    }
    /**
     *
     */
    TypeCache.allCaches = new WeakMap();
    Truth.TypeCache = TypeCache;
})(Truth || (Truth = {}));
// Util
/// <reference path="./util/Helpers.ts" />
/// <reference path="./util/MultiMap.ts" />
/// <reference path="./util/Fs.ts" />
/// <reference path="./util/Fetch.ts" />
/// <reference path="./util/Hash.ts" />
/// <reference path="./util/HigherOrder.ts" />
/// <reference path="./util/Not.ts" />
/// <reference path="./util/Parser.ts" />
/// <reference path="./util/UnicodeBlocks.ts" />
/// <reference path="./util/Misc.ts" />
// System
/// <reference path="./system/Program.ts" />
/// <reference path="./system/AgentCache.ts" />
/// <reference path="./system/Cause.ts" />
/// <reference path="./system/Exception.ts" />
/// <reference path="./system/Uri.ts" />
/// <reference path="./system/UriProtocol.ts" />
/// <reference path="./system/UriParser.ts" />
/// <reference path="./system/UriComponent.ts" />
/// <reference path="./system/UriReader.ts" />
/// <reference path="./system/Syntax.ts" />
/// <reference path="./system/FaultService.ts" />
/// <reference path="./system/Faults.ts" />
/// <reference path="./system/VersionStamp.ts" />
// Finite State Machine
/// <reference path="./fsm/Alphabet.ts" />
/// <reference path="./fsm/TransitionMap.ts" />
/// <reference path="./fsm/TransitionState.ts" />
/// <reference path="./fsm/Guide.ts" />
/// <reference path="./fsm/Fsm.ts" />
/// <reference path="./fsm/FsmTranslator.ts" />
// Phases / File Representation
/// <reference path="./phases/file/Document.ts" />
/// <reference path="./phases/file/DocumentGraph.ts" />
/// <reference path="./phases/file/DocumentHeader.ts" />
/// <reference path="./phases/file/LineParser.ts" />
/// <reference path="./phases/file/Anon.ts" />
/// <reference path="./phases/file/Line.ts" />
/// <reference path="./phases/file/Bounds.ts" />
/// <reference path="./phases/file/Statement.ts" />
/// <reference path="./phases/file/Pattern.ts" />
/// <reference path="./phases/file/PatternPrecompiler.ts" />
/// <reference path="./phases/file/RegexTypes.ts" />
/// <reference path="./phases/file/Infix.ts" />
/// <reference path="./phases/file/Identifier.ts" />
/// <reference path="./phases/file/Span.ts" />
/// <reference path="./phases/file/Spine.ts" />
/// <reference path="./phases/file/Subject.ts" />
// Phases / Graph Representation
/// <reference path="./phases/graph/HyperGraph.ts" />
/// <reference path="./phases/graph/Node.ts" />
/// <reference path="./phases/graph/NodeIndex.ts" />
/// <reference path="./phases/graph/HyperEdge.ts" />
/// <reference path="./phases/graph/InfixSpan.ts" />
// Phases / Parallel Representation
/// <reference path="./phases/parallel/ConstructionWorker.ts" />
/// <reference path="./phases/parallel/Parallel.ts" />
/// <reference path="./phases/parallel/SpecifiedParallel.ts" />
/// <reference path="./phases/parallel/UnspecifiedParallel.ts" />
/// <reference path="./phases/parallel/CruftCache.ts" />
/// <reference path="./phases/parallel/ParallelCache.ts" />
/// <reference path="./phases/parallel/Contract.ts" />
/// <reference path="./phases/parallel/Sanitizer.ts" />
// Phases / Type Representation
/// <reference path="./phases/type/Type.ts" />
/// <reference path="./phases/type/TypeProxy.ts" />
/// <reference path="./phases/type/TypeProxyArray.ts" />
/// <reference path="./phases/type/TypeCache.ts" />
var Truth;
(function (Truth) {
    /**
     * @internal
     * (Not implemented)
     * A class that specifies behavior around the recognition
     * of patterns found within documents.
     */
    class Recognition {
        /** */
        constructor() {
            /** Whether File URIs should be recognized in statements. */
            this.fileUris = 0 /* on */;
            /** Whether HTTP URIs should be recognized in statements. */
            this.httpUris = 0 /* on */;
            /** Whether regular expressions should be recognized in statements. */
            this.regularExpressions = 0 /* on */;
            /** Whether comments should be recognized in statements. */
            this.comments = 0 /* on */;
        }
    }
    Truth.Recognition = Recognition;
})(Truth || (Truth = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1dGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS91dGlsL0hlbHBlcnMudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS91dGlsL011bHRpTWFwLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvdXRpbC9Gcy50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3V0aWwvRmV0Y2gudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS91dGlsL0hhc2gudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS91dGlsL0hpZ2hlck9yZGVyLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvdXRpbC9Ob3QudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS91dGlsL1BhcnNlci50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3V0aWwvVW5pY29kZUJsb2Nrcy50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3V0aWwvTWlzYy50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3N5c3RlbS9Qcm9ncmFtLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2Uvc3lzdGVtL0FnZW50Q2FjaGUudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9zeXN0ZW0vQ2F1c2UudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9zeXN0ZW0vRXhjZXB0aW9uLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2Uvc3lzdGVtL1VyaS50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3N5c3RlbS9VcmlQcm90b2NvbC50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3N5c3RlbS9VcmlQYXJzZXIudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9zeXN0ZW0vVXJpQ29tcG9uZW50LnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2Uvc3lzdGVtL1VyaVJlYWRlci50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3N5c3RlbS9TeW50YXgudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9zeXN0ZW0vRmF1bHRTZXJ2aWNlLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2Uvc3lzdGVtL0ZhdWx0cy50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3N5c3RlbS9WZXJzaW9uU3RhbXAudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9mc20vQWxwaGFiZXQudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9mc20vVHJhbnNpdGlvbk1hcC50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL2ZzbS9UcmFuc2l0aW9uU3RhdGUudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9mc20vR3VpZGUudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9mc20vRnNtLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvZnNtL0ZzbVRyYW5zbGF0b3IudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZmlsZS9Eb2N1bWVudC50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9maWxlL0RvY3VtZW50R3JhcGgudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZmlsZS9Eb2N1bWVudEhlYWRlci50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9maWxlL0xpbmVQYXJzZXIudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZmlsZS9Bbm9uLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL2ZpbGUvTGluZS50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9maWxlL0JvdW5kcy50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9maWxlL1N0YXRlbWVudC50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9maWxlL1BhdHRlcm4udHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZmlsZS9QYXR0ZXJuUHJlY29tcGlsZXIudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZmlsZS9SZWdleFR5cGVzLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL2ZpbGUvSW5maXgudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZmlsZS9JZGVudGlmaWVyLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL2ZpbGUvU3Bhbi50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9maWxlL1NwaW5lLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL2ZpbGUvU3ViamVjdC50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9ncmFwaC9IeXBlckdyYXBoLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL2dyYXBoL05vZGUudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvZ3JhcGgvTm9kZUluZGV4LnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL2dyYXBoL0h5cGVyRWRnZS50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9ncmFwaC9JbmZpeFNwYW4udHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvcGFyYWxsZWwvQ29uc3RydWN0aW9uV29ya2VyLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL3BhcmFsbGVsL1BhcmFsbGVsLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL3BhcmFsbGVsL1NwZWNpZmllZFBhcmFsbGVsLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL3BhcmFsbGVsL1Vuc3BlY2lmaWVkUGFyYWxsZWwudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvcGFyYWxsZWwvQ3J1ZnRDYWNoZS50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy9wYXJhbGxlbC9QYXJhbGxlbENhY2hlLnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL3BhcmFsbGVsL0NvbnRyYWN0LnRzIiwiLi4vVHJ1dGhTdGFjay9UcnV0aC9zb3VyY2UvcGhhc2VzL3BhcmFsbGVsL1Nhbml0aXplci50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy90eXBlL1R5cGUudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvdHlwZS9UeXBlUHJveHkudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9waGFzZXMvdHlwZS9UeXBlUHJveHlBcnJheS50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlL3BoYXNlcy90eXBlL1R5cGVDYWNoZS50cyIsIi4uL1RydXRoU3RhY2svVHJ1dGgvc291cmNlLyEudHMiLCIuLi9UcnV0aFN0YWNrL1RydXRoL3NvdXJjZS9zeXN0ZW0vUmVjb2duaXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLElBQVUsS0FBSyxDQTBCZDtBQTFCRCxXQUFVLEtBQUs7SUFFZDs7Ozs7OztPQU9HO0lBQ0ksS0FBSyxVQUFVLElBQUksQ0FBQyxrQkFBMEI7UUFFcEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxNQUFBLE9BQU8sRUFBRSxDQUFDO1FBQzlCLE9BQU8sTUFBTSxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFKcUIsVUFBSSxPQUl6QixDQUFBO0lBRUQ7Ozs7T0FJRztJQUNJ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O1lBRS9CLDREQUE0RDtZQUM1RCxhQUFRLGNBQXVCO1lBRS9CLHNFQUFzRTtZQUN0RSx1QkFBa0IsY0FBdUI7WUFFekMsMkRBQTJEO1lBQzNELGFBQVEsY0FBdUI7UUFaZixDQUFDO0tBYWpCO0lBaEJZLGlCQUFXLGNBZ0J2QixDQUFBO0FBYUYsQ0FBQyxFQXJDUyxLQUFLLEtBQUwsS0FBSyxRQXFDZCIsInNvdXJjZXNDb250ZW50IjpbIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSByZWFkcyBhIHRydXRoIGRvY3VtZW50LCBhbmQgYWxsIGRvY3VtZW50c1xuXHQgKiBpdCByZWZlcmVuY2VzIGZyb20gdGhlIHNwZWNpZmllZCBmaWxlIHN5c3RlbSBvciBIVFRQKHMpIHBhdGguXG5cdCAqIEZpbGUgc3lzdGVtIHBhdGhzIGFyZSBvbmx5IHN1cHBvcnRlZCBpZiB0aGlzIGNvZGUgaXMgcnVubmluZ1xuXHQgKiB3aXRoaW4gYSBOb2RlLmpzLWNvbXBhdGlibGUgZW52aXJvbm1lbnQuXG5cdCAqIFxuXHQgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgcmVhZCwgb3IgYW4gRXJyb3IuXG5cdCAqL1xuXHRleHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZCh0cnV0aEZpbGVQYXRoT3JVcmk6IHN0cmluZylcblx0e1xuXHRcdGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbSgpO1xuXHRcdHJldHVybiBhd2FpdCBwcm9ncmFtLmRvY3VtZW50cy5yZWFkKHRydXRoRmlsZVBhdGhPclVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBzcGVjaWZpZWQgdHJ1dGggY29udGVudCBpbnRvIGEgbmV3IFRydXRoIHByb2dyYW0uXG5cdCAqIFxuXHQgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgcGFyc2VkIGRvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlKHRydXRoQ29udGVudDogc3RyaW5nKVxuXHR7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKCk7XG5cdFx0cmV0dXJuIGF3YWl0IHByb2dyYW0uZG9jdW1lbnRzLmNyZWF0ZSh0cnV0aENvbnRlbnQpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgTWFwIG9mIHRoZSBnZW5lcmljIGtleSBhbmQgdmFsdWUgdHlwZXMuXG5cdCAqIFN1cHBvcnRzIGtleXMgdGhhdCByZWZlciB0byBtdWx0aXBsZSB2YWx1ZXMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTXVsdGlNYXA8VEtleSwgVFZhbD5cblx0e1xuXHRcdC8qKiAqL1xuXHRcdCpbU3ltYm9sLml0ZXJhdG9yXSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcClcblx0XHRcdFx0eWllbGQgZW50cnk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGVudHJpZXMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLm1hcC5lbnRyaWVzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldChrZXk6IFRLZXkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoa2V5OiBUS2V5LCB2YWx1ZT86IFRWYWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXQoa2V5KTtcblx0XHRcdGlmICghdmFsdWVzKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHZhbHVlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFkZChrZXk6IFRLZXksIHZhbHVlOiBUVmFsKVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXQoa2V5KTtcblx0XHRcdFx0aWYgKHZhbHVlcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLm1hcC5zZXQoa2V5LCBbdmFsdWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZGVsZXRlKGtleTogVEtleSwgdmFsdWU/OiBUVmFsKVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gISF0aGlzLm1hcC5kZWxldGUoa2V5KTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3RvcmVkVmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG5cdFx0XHRpZiAoc3RvcmVkVmFsdWVzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHN0b3JlZFZhbHVlcy5sZW5ndGggPT09IDEgJiYgc3RvcmVkVmFsdWVzWzBdID09PSB2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5tYXAuZGVsZXRlKGtleSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCB2YWx1ZUlkeCA9IHN0b3JlZFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdGlmICh2YWx1ZUlkeCA8IDApXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0c3RvcmVkVmFsdWVzLnNwbGljZSh2YWx1ZUlkeCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dmFsdWVzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAudmFsdWVzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgbWFwID0gbmV3IE1hcDxUS2V5LCBUVmFsW10+KCk7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdGRlY2xhcmUgY29uc3QgTm9kZUZzOiB0eXBlb2YgaW1wb3J0KFwiZnNcIik7XG5cdFxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEV4cG9zZXMgdGhlIFwiZnNcIiBtb2R1bGUgdXNlZCBieSB0aGUgY29tcGlsZXIsIFxuXHQgKiBhcyB3ZWxsIGFzIHRoZSBhYmlsaXR5IHRvIGNoYW5nZSB0aGUgbW9kdWxlIHVzZWRcblx0ICogd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGc1xuXHR7XG5cdFx0LyoqXG5cdFx0ICogQXNzaWducyBhIG5ldyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbm9kZSBcImZzXCIgbW9kdWxlLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBvdmVycmlkZShtb2R1bGU6IHR5cGVvZiBOb2RlRnMpXG5cdFx0e1xuXHRcdFx0dGhpcy5fbW9kdWxlID0gbW9kdWxlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgZ2V0IG1vZHVsZSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX21vZHVsZSlcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21vZHVsZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5fbW9kdWxlID0gcmVxdWlyZShcImZzXCIpO1xuXHRcdFx0cmV0dXJuIE5vdC5udWxsKHRoaXMuX21vZHVsZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIF9tb2R1bGU6IHR5cGVvZiBOb2RlRnMgfCBudWxsID0gbnVsbDtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIGNsYXNzIHRoYXQgcHJvdmlkZXMgYnJvd3Nlci1zdHlsZSBmZXRjaCBmdW5jdGlvbmFsaXR5LFxuXHQgKiBidXQgd2l0aCB0aGUgYWJpbGl0eSB0byBjaGFuZ2UgdGhpcyBmdW5jdGlvbnMgYmVoYXZpb3Jcblx0ICogd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGZXRjaFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0c3RhdGljIGFzeW5jIGV4ZWModXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IEVycm9yPlxuXHRcdHtcblx0XHRcdGNvbnN0IHVyaSA9IFVyaS50cnlQYXJzZSh1cmwpO1xuXHRcdFx0aWYgKCF1cmkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkVXJpKHVybCk7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlb2YgZmV0Y2ggPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdHtcblx0XHRcdFx0dHJ5XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZldGNoRXJyb3IoXG5cdFx0XHRcdFx0XHRyZXNwb25zZS5zdGF0dXMsXG5cdFx0XHRcdFx0XHRyZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdHtcblx0XHRcdFx0dHlwZSBIdHRwR2V0ID0gdHlwZW9mIGltcG9ydChcImh0dHBcIikuZ2V0O1xuXHRcdFx0XHR0eXBlIEh0dHBzR2V0ID0gdHlwZW9mIGltcG9ydChcImh0dHBzXCIpLmdldDtcblx0XHRcdFx0dHlwZSBHZXRGbiA9IEh0dHBHZXQgfCBIdHRwc0dldDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGdldEZuOiBHZXRGbiA9IFxuXHRcdFx0XHRcdHVyaS5wcm90b2NvbCA9PT0gVXJpUHJvdG9jb2wuaHR0cHMgPyByZXF1aXJlKFwiaHR0cHNcIikuZ2V0IDpcblx0XHRcdFx0XHR1cmkucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmh0dHAgPyByZXF1aXJlKFwiaHR0cFwiKS5nZXQgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZ2V0Rm4gPT09IG51bGwpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRVcmkodXJsKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZTxzdHJpbmcgfCBFcnJvcj4ocmVzb2x2ZSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Z2V0Rm4odXJsLCByZXNwb25zZSA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGE6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJlc3BvbnNlLm9uKFwiZGF0YVwiLCBjaHVuayA9PlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRkYXRhLnB1c2godHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRjaHVuayA6XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsudG9TdHJpbmcoXCJ1dGY4XCIpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5vbihcImVycm9yXCIsIGVycm9yID0+XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoZXJyb3IpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoZGF0YS5qb2luKFwiXCIpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVuc3VwcG9ydGVkUGxhdGZvcm0oKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Jcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgc3RhdHVzQ29kZTogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgc3RhdHVzVGV4dDogc3RyaW5nKVxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0ZGVjbGFyZSBmdW5jdGlvbiBmZXRjaCguLi5hcmdzOiB1bmtub3duW10pOiBhbnk7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyBzdHJpbmcgaGFzaGluZyBmdW5jdGlvbmFsaXR5LlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IEhhc2ggPSBuZXcgY2xhc3MgSGFzaFxuXHR7XG5cdFx0LyoqIFN0b3JlcyB0aGUgY29uc3RhbnQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gYSByZXR1cm5lZCBoYXNoLiAqL1xuXHRcdHJlYWRvbmx5IGxlbmd0aCA9IDg7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlcyBhIGhhc2ggY29kZSBmcm9tIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdGNhbGN1bGF0ZSh0ZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKHRleHQubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gXCIwXCIucmVwZWF0KDgpO1xuXHRcdFx0XG5cdFx0XHRsZXQgaGFzaCA9IDA7XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHRleHQubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2hhciA9IHRleHQuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNoYXI7XG5cdFx0XHRcdGhhc2ggJT0gMiAqKiAzMjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIChoYXNoICsgTWF0aC5wb3coMiwgMzEpKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0XHR9XG5cdH0oKTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcHJvdmlkZXMgdmFyaW91cyBoaWdoZXItb3JkZXIgZnVuY3Rpb25zXG5cdCAqIGFjcm9zcyBkYXRhIHN0cnVjdHVyZXMuXG5cdCAqL1xuXHRleHBvcnQgYWJzdHJhY3QgY2xhc3MgSGlnaGVyT3JkZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgcmVhZG9ubHkgY29weSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5LCBzZXQsIG9yIGxpc3QuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNvcHk8VD4oYXJyYXk6IHJlYWRvbmx5IFRbXSk6IHJlYWRvbmx5IFRbXTtcblx0XHRzdGF0aWMgY29weTxUPihzZXQ6IFJlYWRvbmx5U2V0PFQ+KTogUmVhZG9ubHlTZXQ8VD47XG5cdFx0c3RhdGljIGNvcHk8SywgVj4obWFwOiBSZWFkb25seU1hcDxLLCBWPik6IFJlYWRvbmx5TWFwPEssIFY+O1xuXHRcdHN0YXRpYyBjb3B5KHBhcmFtOiBvYmplY3QpOiBvYmplY3Rcblx0XHR7XG5cdFx0XHRpZiAocGFyYW0gaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUocGFyYW0uc2xpY2UoKSk7XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbSBpbnN0YW5jZW9mIFNldClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiBwYXJhbSlcblx0XHRcdFx0XHRzZXQuYWRkKHZhbHVlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHNldCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwYXJhbSBpbnN0YW5jZW9mIE1hcClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyYW0pXG5cdFx0XHRcdFx0bWFwLnNldChrZXksIHZhbHVlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKG1hcCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHR9XG5cdFx0XG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgfVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogVXRpbGl0eSBjbGFzcyBmb3IgcGVyZm9ybWluZyBiYXNpYyBndWFyZGluZy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBOb3Rcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBhcmd1bWVudCBhcyBzcGVjaWZpZWQsIGJ1dCB0aHJvd3MgYW5cblx0XHQgKiBleGNlcHRpb24gaW4gdGhlIGNhc2Ugd2hlbiBpdCdzIHN0cmljdGx5IGVxdWFsIHRvIG51bGwuXG5cdFx0ICovXG5cdFx0c3RhdGljIG51bGw8VD4ocGFyYW06IFQpOiBOb3ROdWxsPFQ+XG5cdFx0e1xuXHRcdFx0aWYgKHBhcmFtID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRkZWJ1Z2dlcjtcblx0XHRcdFx0dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiA8Tm90TnVsbDxUPj5wYXJhbTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGFyZ3VtZW50IGFzIHNwZWNpZmllZCwgYnV0IHRocm93cyBhblxuXHRcdCAqIGV4Y2VwdGlvbiBpbiB0aGUgY2FzZSB3aGVuIGl0J3Mgc3RyaWN0bHkgZXF1YWwgdG8gdW5kZWZpbmVkLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyB1bmRlZmluZWQ8VD4ocGFyYW06IFQpOiBOb3RVbmRlZmluZWQ8VD5cblx0XHR7XG5cdFx0XHRpZiAocGFyYW0gPT09IHVuZGVmaW5lZClcblx0XHRcdHtcblx0XHRcdFx0ZGVidWdnZXI7XG5cdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gPE5vdFVuZGVmaW5lZDxUPj5wYXJhbTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGFyZ3VtZW50IGFzIHNwZWNpZmllZCwgYnV0IHRocm93cyBhblxuXHRcdCAqIGV4Y2VwdGlvbiBpbiB0aGUgY2FzZSB3aGVuIGl0J3MgbnVsbCBvciB1bmRlZmluZWQuXG5cdFx0ICovXG5cdFx0c3RhdGljIG51bGxhYmxlPFQ+KHBhcmFtOiBUKTogTm90TnVsbDxUPiB8IE5vdFVuZGVmaW5lZDxUPlxuXHRcdHtcblx0XHRcdGlmIChwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHRkZWJ1Z2dlcjtcblx0XHRcdFx0dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiA8Tm90TnVsbDxUPiB8IE5vdFVuZGVmaW5lZDxUPj5wYXJhbTtcblx0XHR9XG5cdH1cblxuXHR0eXBlIE5vdE51bGw8VD4gPSBUIGV4dGVuZHMgbnVsbCA/IG5ldmVyIDogVDtcblx0dHlwZSBOb3RVbmRlZmluZWQ8VD4gPSBUIGV4dGVuZHMgdW5kZWZpbmVkID8gbmV2ZXIgOiBUO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgZ2VuZXJhbCBwYXJzaW5nIHV0aWxpdHkgY2xhc3MgdGhhdCBwcm92aWRlcyBjb25zdW1wdGlvblxuXHQgKiBtZXRob2RzIHRoYXQgb3BlcmF0ZSBvdmVyIGEgZ2l2ZW4gaW5wdXQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUGFyc2VyXG5cdHtcblx0XHQvKipcblx0XHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFBhcnNlciBvYmplY3QgdGhhdCBvcGVyYXRlcyBvdmVyXG5cdFx0ICogdGhlIHNwZWNpZmllZCBpbnB1dCBzdHJpbmcsIG9wdGlvbmFsbHkgc3RhcnRpbmcgYXQgdGhlXG5cdFx0ICogc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0dGhpcy5pbnB1dCA9IGlucHV0Lm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSAwO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byByZWFkIHRoZSBzcGVjaWZpZWQgdG9rZW4gaW1tZWRpYXRlbHkgXG5cdFx0ICogZm9sbG93aW5nIHRoZSBjdXJzb3IuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgVGhlIGNvbnRlbnQgcmVhZC4gSW4gdGhlIGNhc2Ugd2hlbiBub1xuXHRcdCAqIG1hdGNoIGNvdWxkIGJlIGZvdW5kLCBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0cmVhZCh0b2tlbj86IHN0cmluZylcblx0XHR7XG5cdFx0XHRpZiAoIXRva2VuKVxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBvcyA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pbnB1dC5zdWJzdHIocG9zLCB0b2tlbi5sZW5ndGgpID09PSB0b2tlbilcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gKz0gdG9rZW4ubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWFkcyBhbnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGFuZCBmbG9hdGluZ1xuXHRcdCAqIGVzY2FwZSBjaGFyYWN0ZXJzLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0ICogcmVhZC5cblx0XHQgKi9cblx0XHRyZWFkV2hpdGVzcGFjZSgpXG5cdFx0e1xuXHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKHRoaXMubW9yZSgpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjID0gY291bnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5yZWFkKFN5bnRheC50YWIpKVxuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5yZWFkKFN5bnRheC5zcGFjZSkpXG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnJlYWQoU3ludGF4LmVzY2FwZUNoYXIgKyBTeW50YXguc3BhY2UpKVxuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5yZWFkKFN5bnRheC5lc2NhcGVDaGFyICsgU3ludGF4LnRhYikpXG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjID09PSBjb3VudClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgc2luZ2xlIHN0cmVhbS1sZXZlbCBncmFwaGVtZSBmcm9tIHRoZVxuXHRcdCAqIHBhcnNlIHN0cmVhbSwgdXNpbmcgdW5pY29kZS1hd2FyZSBleHRyYWN0aW9uIG1ldGhvZC5cblx0XHQgKiBJZiB0aGUgcGFyc2Ugc3RyZWFtIHNwZWNpZmllcyBhIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLFxuXHRcdCAqIHN1Y2ggYXMgXFx1RkZGRiwgdGhlc2UgYXJlIHNlZW4gYXMgNiBpbmRpdmlkdWFsIGdyYXBoZW1lcy5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBUaGUgcmVhZCBncmFwaGVtZSwgb3IgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBjYXNlXG5cdFx0ICogd2hlbiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHQgKi9cblx0XHRyZWFkR3JhcGhlbWUoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9wb3NpdGlvbiA+PSB0aGlzLmlucHV0Lmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvZGVBdEN1cnNvciA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5fcG9zaXRpb24pIHx8IC0xO1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gKz0gY29kZUF0Q3Vyc29yID4gMHhGRkZGID8gMiA6IDE7XG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZUF0Q3Vyc29yKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgZ3JhcGhlbWVzIGZyb20gdGhlIHBhcnNlIHN0cmVhbSwgdW50aWwgZWl0aGVyXG5cdFx0ICogdGhlIGN1cnNvciByZWFjaGVzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHF1aXQgdG9rZW5zLFxuXHRcdCAqIG9yIHRoZSBwYXJzZSBzdHJlYW0gdGVybWluYXRlcy5cblx0XHQgKi9cblx0XHRyZWFkVW50aWwoLi4ucXVpdFRva2Vuczogc3RyaW5nW10pXG5cdFx0e1xuXHRcdFx0bGV0IHN0cmVhbSA9IFwiXCI7XG5cdFx0XHRcblx0XHRcdHdoaWxlICh0aGlzLm1vcmUoKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKHF1aXRUb2tlbnMuc29tZSh0ID0+IHRoaXMucGVlayh0KSkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRzdHJlYW0gKz0gdGhpcy5yZWFkR3JhcGhlbWUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHN0cmVhbTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCB0aGUgc3BlY2lmaWVkIHRva2VuIGZyb20gdGhlIHBhcnNlIHN0cmVhbSxcblx0XHQgKiBpZiBhbmQgb25seSBpZiBpdCdzIGF0IHRoZSBlbmQgb2YgdGhlIHBhcnNlIHN0cmVhbS5cblx0XHQgKi9cblx0XHRyZWFkVGhlblRlcm1pbmFsKHRva2VuOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucGVlayh0b2tlbikgJiYgdGhpcy5fcG9zaXRpb24gPT09IHRoaXMuaW5wdXQubGVuZ3RoIC0gdG9rZW4ubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiArPSB0b2tlbi5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiB0b2tlbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZVxuXHRcdCAqIHNwZWNpZmllZCBzdHJpbmcgZXhpc3RzIGltbWVkaWF0ZWx5IGF0IHRoZSBwb3NpdGlvbiBvZlxuXHRcdCAqIHRoZSBjdXJzb3IuXG5cdFx0ICovXG5cdFx0cGVlayh0b2tlbjogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmlucHV0LnN1YnN0cih0aGlzLl9wb3NpdGlvbiwgdG9rZW4ubGVuZ3RoKSA9PT0gdG9rZW47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZVxuXHRcdCAqIHNwZWNpZmllZCBzdHJpbmcgZXhpc3RzIGltbWVkaWF0ZWx5IGF0IHRoZSBwb3NpdGlvbiBvZlxuXHRcdCAqIHRoZSBjdXJzb3IsIGFuZCBmb2xsb3dpbmcgdGhpcyB0b2tlbiBpcyB0aGUgZW5kIG9mIHRoZVxuXHRcdCAqIHBhcnNlIHN0cmVhbS5cblx0XHQgKi9cblx0XHRwZWVrVGhlblRlcm1pbmFsKHRva2VuOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gPT09IHRoaXMuaW5wdXQubGVuZ3RoIC0gdG9rZW4ubGVuZ3RoICYmXG5cdFx0XHRcdHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuX3Bvc2l0aW9uLCB0b2tlbi5sZW5ndGgpID09PSB0b2tlbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyXG5cdFx0ICogdGhlcmUgYXJlIG1vcmUgY2hhcmFjdGVycyB0byByZWFkIGluIHRoZSBpbnB1dC5cblx0XHQgKi9cblx0XHRtb3JlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb24gPCB0aGlzLmlucHV0Lmxlbmd0aDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBvciBzZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIGZyb20gd2hlcmVcblx0XHQgKiByZWFkaW5nIHRha2VzIHBsYWNlIGluIHRoZSBjdXJzb3IuXG5cdFx0ICovXG5cdFx0Z2V0IHBvc2l0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XG5cdFx0fVxuXHRcdHNldCBwb3NpdGlvbih2YWx1ZTogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSA8IDApXG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG5cdFx0fVxuXHRcdHByaXZhdGUgX3Bvc2l0aW9uID0gMDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGlucHV0OiBzdHJpbmc7XG5cdFx0XG5cdFx0XG5cdFx0Ly9cblx0XHQvLyBERUFEXG5cdFx0Ly9cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIGF0UmVhbEJhY2tzbGFzaCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXNjID0gU3ludGF4LmVzY2FwZUNoYXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5fcG9zaXRpb24sIDIpID09PSBlc2MgKyBlc2M7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYW5cblx0XHQgKiBlc2NhcGUgY2hhcmFjdGVyIGV4aXN0cyBiZWhpbmQgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuXHRcdCAqIFRoZSBhbGdvcml0aG0gdXNlZCBpcyByZXNwZWN0aXZlIG9mIHNlcXVlbmNlcyBvZlxuXHRcdCAqIG11bHRpcGxlIGVzY2FwZSBjaGFyYWN0ZXJzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgZXNjYXBlZCgpXG5cdFx0e1xuXHRcdFx0bGV0IGVzY2FwZWQgPSBmYWxzZTtcblx0XHRcdGxldCBiYWNrdHJhY2tQb3MgPSB0aGlzLl9wb3NpdGlvbjtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKC0tYmFja3RyYWNrUG9zID49IDApXG5cdFx0XHRcdGlmICh0aGlzLmlucHV0W2JhY2t0cmFja1Bvc10gPT09IFN5bnRheC5lc2NhcGVDaGFyKVxuXHRcdFx0XHRcdGVzY2FwZWQgPSAhZXNjYXBlZDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGVzY2FwZWQ7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHR0eXBlIFQgPSBbbnVtYmVyLCBudW1iZXJdO1xuXHR0eXBlIFRVbmljb2RlQmxvY2tzID0geyBbYmxvY2tOYW1lOiBzdHJpbmddOiBUIH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBuYW1lcyBpbiB0aGUgVW5pY29kZUJsb2NrcyBvYmplY3Rcblx0ICogdG8gYSBtYXAgd2l0aCBsb3dlciBjYXNlIGtleXMsIGZvciBlYXN5IGxvb2t1cC5cblx0ICovXG5cdGZ1bmN0aW9uIHRvTWFwKGJsb2NrczogVFVuaWNvZGVCbG9ja3MpXG5cdHtcblx0XHRjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYmxvY2tzKTtcblx0XHRjb25zdCBlbnRyaWVzRm10ID0gZW50cmllcy5tYXAoZW50cnkgPT4gPFtzdHJpbmcsIFRdPltlbnRyeVswXS50b0xvd2VyQ2FzZSgpLCBlbnRyeVsxXV0pO1xuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKG5ldyBNYXA8c3RyaW5nLCBUPihlbnRyaWVzRm10KSk7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcmVzIHRoZSBtYXhpbXVtIGNoYXJhY3RlciBjb2RlIGluIHRoZSB1bmljb2RlIHNldC5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBVbmljb2RlTWF4ID0gNjU1MzY7XG5cblx0LyoqXG5cdCAqIFN0b3JlcyBhIG1hcCBvZiB0aGUgbmFtZXMgb2YgYWxsIHVuaWNvZGUgYmxvY2tzLFxuXHQgKiBhbmQgdGhlaXIgY2hhcmFjdGVyIHJhbmdlcy5cblx0ICovXG5cdGV4cG9ydCBjb25zdCBVbmljb2RlQmxvY2tzID0gdG9NYXAoPFRVbmljb2RlQmxvY2tzPntcblx0XHRcIkNvbnRyb2wgY2hhcmFjdGVyXCI6IFsweDAwMDAsIDB4MDAxRl0sXG5cdFx0XCJCYXNpYyBMYXRpblwiOiBbMHgwMDIwLCAweDAwN0ZdLFxuXHRcdFwiTGF0aW4tMSBTdXBwbGVtZW50XCI6IFsweDAwODAsIDB4MDBGRl0sXG5cdFx0XCJMYXRpbiBFeHRlbmRlZC1BXCI6IFsweDAxMDAsIDB4MDE3Rl0sXG5cdFx0XCJMYXRpbiBFeHRlbmRlZC1CXCI6IFsweDAxODAsIDB4MDI0Rl0sXG5cdFx0XCJJUEEgRXh0ZW5zaW9uc1wiOiBbMHgwMjUwLCAweDAyQUZdLFxuXHRcdFwiU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzXCI6IFsweDAyQjAsIDB4MDJGRl0sXG5cdFx0XCJDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3NcIjogWzB4MDMwMCwgMHgwMzZGXSxcblx0XHRcIkdyZWVrIGFuZCBDb3B0aWNcIjogWzB4MDM3MCwgMHgwM0ZGXSxcblx0XHRcIkN5cmlsbGljXCI6IFsweDA0MDAsIDB4MDRGRl0sXG5cdFx0XCJDeXJpbGxpYyBTdXBwbGVtZW50XCI6IFsweDA1MDAsIDB4MDUyRl0sXG5cdFx0XCJBcm1lbmlhblwiOiBbMHgwNTMwLCAweDA1OEZdLFxuXHRcdFwiSGVicmV3XCI6IFsweDA1OTAsIDB4MDVGRl0sXG5cdFx0XCJBcmFiaWNcIjogWzB4MDYwMCwgMHgwNkZGXSxcblx0XHRcIlN5cmlhY1wiOiBbMHgwNzAwLCAweDA3NEZdLFxuXHRcdFwiQXJhYmljIFN1cHBsZW1lbnRcIjogWzB4MDc1MCwgMHgwNzdGXSxcblx0XHRcIlRoYWFuYVwiOiBbMHgwNzgwLCAweDA3QkZdLFxuXHRcdFwiTktvXCI6IFsweDA3QzAsIDB4MDdGRl0sXG5cdFx0XCJTYW1hcml0YW5cIjogWzB4MDgwMCwgMHgwODNGXSxcblx0XHRcIk1hbmRhaWNcIjogWzB4MDg0MCwgMHgwODVGXSxcblx0XHRcIlN5cmlhYyBTdXBwbGVtZW50XCI6IFsweDA4NjAsIDB4MDg2Rl0sXG5cdFx0XCJBcmFiaWMgRXh0ZW5kZWQtQVwiOiBbMHgwOEEwLCAweDA4RkZdLFxuXHRcdFwiRGV2YW5hZ2FyaVwiOiBbMHgwOTAwLCAweDA5N0ZdLFxuXHRcdFwiQmVuZ2FsaVwiOiBbMHgwOTgwLCAweDA5RkZdLFxuXHRcdFwiR3VybXVraGlcIjogWzB4MEEwMCwgMHgwQTdGXSxcblx0XHRcIkd1amFyYXRpXCI6IFsweDBBODAsIDB4MEFGRl0sXG5cdFx0XCJPcml5YVwiOiBbMHgwQjAwLCAweDBCN0ZdLFxuXHRcdFwiVGFtaWxcIjogWzB4MEI4MCwgMHgwQkZGXSxcblx0XHRcIlRlbHVndVwiOiBbMHgwQzAwLCAweDBDN0ZdLFxuXHRcdFwiS2FubmFkYVwiOiBbMHgwQzgwLCAweDBDRkZdLFxuXHRcdFwiTWFsYXlhbGFtXCI6IFsweDBEMDAsIDB4MEQ3Rl0sXG5cdFx0XCJTaW5oYWxhXCI6IFsweDBEODAsIDB4MERGRl0sXG5cdFx0XCJUaGFpXCI6IFsweDBFMDAsIDB4MEU3Rl0sXG5cdFx0XCJMYW9cIjogWzB4MEU4MCwgMHgwRUZGXSxcblx0XHRcIlRpYmV0YW5cIjogWzB4MEYwMCwgMHgwRkZGXSxcblx0XHRcIk15YW5tYXJcIjogWzB4MTAwMCwgMHgxMDlGXSxcblx0XHRcIkdlb3JnaWFuXCI6IFsweDEwQTAsIDB4MTBGRl0sXG5cdFx0XCJIYW5ndWwgSmFtb1wiOiBbMHgxMTAwLCAweDExRkZdLFxuXHRcdFwiRXRoaW9waWNcIjogWzB4MTIwMCwgMHgxMzdGXSxcblx0XHRcIkV0aGlvcGljIFN1cHBsZW1lbnRcIjogWzB4MTM4MCwgMHgxMzlGXSxcblx0XHRcIkNoZXJva2VlXCI6IFsweDEzQTAsIDB4MTNGRl0sXG5cdFx0XCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXCI6IFsweDE0MDAsIDB4MTY3Rl0sXG5cdFx0XCJPZ2hhbVwiOiBbMHgxNjgwLCAweDE2OUZdLFxuXHRcdFwiUnVuaWNcIjogWzB4MTZBMCwgMHgxNkZGXSxcblx0XHRcIlRhZ2Fsb2dcIjogWzB4MTcwMCwgMHgxNzFGXSxcblx0XHRcIkhhbnVub29cIjogWzB4MTcyMCwgMHgxNzNGXSxcblx0XHRcIkJ1aGlkXCI6IFsweDE3NDAsIDB4MTc1Rl0sXG5cdFx0XCJUYWdiYW53YVwiOiBbMHgxNzYwLCAweDE3N0ZdLFxuXHRcdFwiS2htZXJcIjogWzB4MTc4MCwgMHgxN0ZGXSxcblx0XHRcIk1vbmdvbGlhblwiOiBbMHgxODAwLCAweDE4QUZdLFxuXHRcdFwiVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljcyBFeHRlbmRlZFwiOiBbMHgxOEIwLCAweDE4RkZdLFxuXHRcdFwiTGltYnVcIjogWzB4MTkwMCwgMHgxOTRGXSxcblx0XHRcIlRhaSBMZVwiOiBbMHgxOTUwLCAweDE5N0ZdLFxuXHRcdFwiTmV3IFRhaSBMdWVcIjogWzB4MTk4MCwgMHgxOURGXSxcblx0XHRcIktobWVyIFN5bWJvbHNcIjogWzB4MTlFMCwgMHgxOUZGXSxcblx0XHRcIkJ1Z2luZXNlXCI6IFsweDFBMDAsIDB4MUExRl0sXG5cdFx0XCJUYWkgVGhhbVwiOiBbMHgxQTIwLCAweDFBQUZdLFxuXHRcdFwiQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzIEV4dGVuZGVkXCI6IFsweDFBQjAsIDB4MUFGRl0sXG5cdFx0XCJCYWxpbmVzZVwiOiBbMHgxQjAwLCAweDFCN0ZdLFxuXHRcdFwiU3VuZGFuZXNlXCI6IFsweDFCODAsIDB4MUJCRl0sXG5cdFx0XCJCYXRha1wiOiBbMHgxQkMwLCAweDFCRkZdLFxuXHRcdFwiTGVwY2hhXCI6IFsweDFDMDAsIDB4MUM0Rl0sXG5cdFx0XCJPbCBDaGlraVwiOiBbMHgxQzUwLCAweDFDN0ZdLFxuXHRcdFwiQ3lyaWxsaWMgRXh0ZW5kZWQgQ1wiOiBbMHgxQzgwLCAweDFDOEZdLFxuXHRcdFwiU3VuZGFuZXNlIFN1cHBsZW1lbnRcIjogWzB4MUNDMCwgMHgxQ0NGXSxcblx0XHRcIlZlZGljIEV4dGVuc2lvbnNcIjogWzB4MUNEMCwgMHgxQ0ZGXSxcblx0XHRcIlBob25ldGljIEV4dGVuc2lvbnNcIjogWzB4MUQwMCwgMHgxRDdGXSxcblx0XHRcIlBob25ldGljIEV4dGVuc2lvbnMgU3VwcGxlbWVudFwiOiBbMHgxRDgwLCAweDFEQkZdLFxuXHRcdFwiQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzIFN1cHBsZW1lbnRcIjogWzB4MURDMCwgMHgxREZGXSxcblx0XHRcIkxhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWxcIjogWzB4MUUwMCwgMHgxRUZGXSxcblx0XHRcIkdyZWVrIEV4dGVuZGVkXCI6IFsweDFGMDAsIDB4MUZGRl0sXG5cdFx0XCJHZW5lcmFsIFB1bmN0dWF0aW9uXCI6IFsweDIwMDAsIDB4MjA2Rl0sXG5cdFx0XCJTdXBlcnNjcmlwdHMgYW5kIFN1YnNjcmlwdHNcIjogWzB4MjA3MCwgMHgyMDlGXSxcblx0XHRcIkN1cnJlbmN5IFN5bWJvbHNcIjogWzB4MjBBMCwgMHgyMENGXSxcblx0XHRcIkNvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrcyBmb3IgU3ltYm9sc1wiOiBbMHgyMEQwLCAweDIwRkZdLFxuXHRcdFwiTGV0dGVybGlrZSBTeW1ib2xzXCI6IFsweDIxMDAsIDB4MjE0Rl0sXG5cdFx0XCJOdW1iZXIgRm9ybXNcIjogWzB4MjE1MCwgMHgyMThGXSxcblx0XHRcIkFycm93c1wiOiBbMHgyMTkwLCAweDIxRkZdLFxuXHRcdFwiTWF0aGVtYXRpY2FsIE9wZXJhdG9yc1wiOiBbMHgyMjAwLCAweDIyRkZdLFxuXHRcdFwiTWlzY2VsbGFuZW91cyBUZWNobmljYWxcIjogWzB4MjMwMCwgMHgyM0ZGXSxcblx0XHRcIkNvbnRyb2wgUGljdHVyZXNcIjogWzB4MjQwMCwgMHgyNDNGXSxcblx0XHRcIk9wdGljYWwgQ2hhcmFjdGVyIFJlY29nbml0aW9uXCI6IFsweDI0NDAsIDB4MjQ1Rl0sXG5cdFx0XCJFbmNsb3NlZCBBbHBoYW51bWVyaWNzXCI6IFsweDI0NjAsIDB4MjRGRl0sXG5cdFx0XCJCb3ggRHJhd2luZ1wiOiBbMHgyNTAwLCAweDI1N0ZdLFxuXHRcdFwiQmxvY2sgRWxlbWVudHNcIjogWzB4MjU4MCwgMHgyNTlGXSxcblx0XHRcIkdlb21ldHJpYyBTaGFwZXNcIjogWzB4MjVBMCwgMHgyNUZGXSxcblx0XHRcIk1pc2NlbGxhbmVvdXMgU3ltYm9sc1wiOiBbMHgyNjAwLCAweDI2RkZdLFxuXHRcdFwiRGluZ2JhdHNcIjogWzB4MjcwMCwgMHgyN0JGXSxcblx0XHRcIk1pc2NlbGxhbmVvdXMgTWF0aGVtYXRpY2FsIFN5bWJvbHMtQVwiOiBbMHgyN0MwLCAweDI3RUZdLFxuXHRcdFwiU3VwcGxlbWVudGFsIEFycm93cy1BXCI6IFsweDI3RjAsIDB4MjdGRl0sXG5cdFx0XCJCcmFpbGxlIFBhdHRlcm5zXCI6IFsweDI4MDAsIDB4MjhGRl0sXG5cdFx0XCJTdXBwbGVtZW50YWwgQXJyb3dzLUJcIjogWzB4MjkwMCwgMHgyOTdGXSxcblx0XHRcIk1pc2NlbGxhbmVvdXMgTWF0aGVtYXRpY2FsIFN5bWJvbHMtQlwiOiBbMHgyOTgwLCAweDI5RkZdLFxuXHRcdFwiU3VwcGxlbWVudGFsIE1hdGhlbWF0aWNhbCBPcGVyYXRvcnNcIjogWzB4MkEwMCwgMHgyQUZGXSxcblx0XHRcIk1pc2NlbGxhbmVvdXMgU3ltYm9scyBhbmQgQXJyb3dzXCI6IFsweDJCMDAsIDB4MkJGRl0sXG5cdFx0XCJHbGFnb2xpdGljXCI6IFsweDJDMDAsIDB4MkM1Rl0sXG5cdFx0XCJMYXRpbiBFeHRlbmRlZC1DXCI6IFsweDJDNjAsIDB4MkM3Rl0sXG5cdFx0XCJDb3B0aWNcIjogWzB4MkM4MCwgMHgyQ0ZGXSxcblx0XHRcIkdlb3JnaWFuIFN1cHBsZW1lbnRcIjogWzB4MkQwMCwgMHgyRDJGXSxcblx0XHRcIlRpZmluYWdoXCI6IFsweDJEMzAsIDB4MkQ3Rl0sXG5cdFx0XCJFdGhpb3BpYyBFeHRlbmRlZFwiOiBbMHgyRDgwLCAweDJEREZdLFxuXHRcdFwiQ3lyaWxsaWMgRXh0ZW5kZWQtQVwiOiBbMHgyREUwLCAweDJERkZdLFxuXHRcdFwiU3VwcGxlbWVudGFsIFB1bmN0dWF0aW9uXCI6IFsweDJFMDAsIDB4MkU3Rl0sXG5cdFx0XCJDSksgUmFkaWNhbHMgU3VwcGxlbWVudFwiOiBbMHgyRTgwLCAweDJFRkZdLFxuXHRcdFwiS2FuZ3hpIFJhZGljYWxzXCI6IFsweDJGMDAsIDB4MkZERl0sXG5cdFx0XCJJZGVvZ3JhcGhpYyBEZXNjcmlwdGlvbiBDaGFyYWN0ZXJzXCI6IFsweDJGRjAsIDB4MkZGRl0sXG5cdFx0XCJDSksgU3ltYm9scyBhbmQgUHVuY3R1YXRpb25cIjogWzB4MzAwMCwgMHgzMDNGXSxcblx0XHRcIkhpcmFnYW5hXCI6IFsweDMwNDAsIDB4MzA5Rl0sXG5cdFx0XCJLYXRha2FuYVwiOiBbMHgzMEEwLCAweDMwRkZdLFxuXHRcdFwiQm9wb21vZm9cIjogWzB4MzEwMCwgMHgzMTJGXSxcblx0XHRcIkhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cIjogWzB4MzEzMCwgMHgzMThGXSxcblx0XHRcIkthbmJ1blwiOiBbMHgzMTkwLCAweDMxOUZdLFxuXHRcdFwiQm9wb21vZm8gRXh0ZW5kZWRcIjogWzB4MzFBMCwgMHgzMUJGXSxcblx0XHRcIkNKSyBTdHJva2VzXCI6IFsweDMxQzAsIDB4MzFFRl0sXG5cdFx0XCJLYXRha2FuYSBQaG9uZXRpYyBFeHRlbnNpb25zXCI6IFsweDMxRjAsIDB4MzFGRl0sXG5cdFx0XCJFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXCI6IFsweDMyMDAsIDB4MzJGRl0sXG5cdFx0XCJDSksgQ29tcGF0aWJpbGl0eVwiOiBbMHgzMzAwLCAweDMzRkZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQVwiOiBbMHgzNDAwLCAweDREQkZdLFxuXHRcdFwiWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcIjogWzB4NERDMCwgMHg0REZGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHNcIjogWzB4NEUwMCwgMHg5RkZGXSxcblx0XHRcIllpIFN5bGxhYmxlc1wiOiBbMHhBMDAwLCAweEE0OEZdLFxuXHRcdFwiWWkgUmFkaWNhbHNcIjogWzB4QTQ5MCwgMHhBNENGXSxcblx0XHRcIkxpc3VcIjogWzB4QTREMCwgMHhBNEZGXSxcblx0XHRcIlZhaVwiOiBbMHhBNTAwLCAweEE2M0ZdLFxuXHRcdFwiQ3lyaWxsaWMgRXh0ZW5kZWQtQlwiOiBbMHhBNjQwLCAweEE2OUZdLFxuXHRcdFwiQmFtdW1cIjogWzB4QTZBMCwgMHhBNkZGXSxcblx0XHRcIk1vZGlmaWVyIFRvbmUgTGV0dGVyc1wiOiBbMHhBNzAwLCAweEE3MUZdLFxuXHRcdFwiTGF0aW4gRXh0ZW5kZWQtRFwiOiBbMHhBNzIwLCAweEE3RkZdLFxuXHRcdFwiU3lsb3RpIE5hZ3JpXCI6IFsweEE4MDAsIDB4QTgyRl0sXG5cdFx0XCJDb21tb24gSW5kaWMgTnVtYmVyIEZvcm1zXCI6IFsweEE4MzAsIDB4QTgzRl0sXG5cdFx0XCJQaGFncy1wYVwiOiBbMHhBODQwLCAweEE4N0ZdLFxuXHRcdFwiU2F1cmFzaHRyYVwiOiBbMHhBODgwLCAweEE4REZdLFxuXHRcdFwiRGV2YW5hZ2FyaSBFeHRlbmRlZFwiOiBbMHhBOEUwLCAweEE4RkZdLFxuXHRcdFwiS2F5YWggTGlcIjogWzB4QTkwMCwgMHhBOTJGXSxcblx0XHRcIlJlamFuZ1wiOiBbMHhBOTMwLCAweEE5NUZdLFxuXHRcdFwiSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQVwiOiBbMHhBOTYwLCAweEE5N0ZdLFxuXHRcdFwiSmF2YW5lc2VcIjogWzB4QTk4MCwgMHhBOURGXSxcblx0XHRcIk15YW5tYXIgRXh0ZW5kZWQtQlwiOiBbMHhBOUUwLCAweEE5RkZdLFxuXHRcdFwiQ2hhbVwiOiBbMHhBQTAwLCAweEFBNUZdLFxuXHRcdFwiTXlhbm1hciBFeHRlbmRlZC1BXCI6IFsweEFBNjAsIDB4QUE3Rl0sXG5cdFx0XCJUYWkgVmlldFwiOiBbMHhBQTgwLCAweEFBREZdLFxuXHRcdFwiTWVldGVpIE1heWVrIEV4dGVuc2lvbnNcIjogWzB4QUFFMCwgMHhBQUZGXSxcblx0XHRcIkV0aGlvcGljIEV4dGVuZGVkLUFcIjogWzB4QUIwMCwgMHhBQjJGXSxcblx0XHRcIkxhdGluIEV4dGVuZGVkLUVcIjogWzB4QUIzMCwgMHhBQjZGXSxcblx0XHRcIkNoZXJva2VlIFN1cHBsZW1lbnRcIjogWzB4QUI3MCwgMHhBQkJGXSxcblx0XHRcIk1lZXRlaSBNYXlla1wiOiBbMHhBQkMwLCAweEFCRkZdLFxuXHRcdFwiSGFuZ3VsIFN5bGxhYmxlc1wiOiBbMHhBQzAwLCAweEQ3QUZdLFxuXHRcdFwiSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQlwiOiBbMHhEN0IwLCAweEQ3RkZdLFxuXHRcdFwiSGlnaCBTdXJyb2dhdGVzXCI6IFsweEQ4MDAsIDB4REI3Rl0sXG5cdFx0XCJIaWdoIFByaXZhdGUgVXNlIFN1cnJvZ2F0ZXNcIjogWzB4REI4MCwgMHhEQkZGXSxcblx0XHRcIkxvdyBTdXJyb2dhdGVzXCI6IFsweERDMDAsIDB4REZGRl0sXG5cdFx0XCJQcml2YXRlIFVzZSBBcmVhXCI6IFsweEUwMDAsIDB4RjhGRl0sXG5cdFx0XCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXCI6IFsweEY5MDAsIDB4RkFGRl0sXG5cdFx0XCJBbHBoYWJldGljIFByZXNlbnRhdGlvbiBGb3Jtc1wiOiBbMHhGQjAwLCAweEZCNEZdLFxuXHRcdFwiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXCI6IFsweEZCNTAsIDB4RkRGRl0sXG5cdFx0XCJWYXJpYXRpb24gU2VsZWN0b3JzXCI6IFsweEZFMDAsIDB4RkUwRl0sXG5cdFx0XCJWZXJ0aWNhbCBGb3Jtc1wiOiBbMHhGRTEwLCAweEZFMUZdLFxuXHRcdFwiQ29tYmluaW5nIEhhbGYgTWFya3NcIjogWzB4RkUyMCwgMHhGRTJGXSxcblx0XHRcIkNKSyBDb21wYXRpYmlsaXR5IEZvcm1zXCI6IFsweEZFMzAsIDB4RkU0Rl0sXG5cdFx0XCJTbWFsbCBGb3JtIFZhcmlhbnRzXCI6IFsweEZFNTAsIDB4RkU2Rl0sXG5cdFx0XCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcIjogWzB4RkU3MCwgMHhGRUZGXSxcblx0XHRcIkhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXCI6IFsweEZGMDAsIDB4RkZFRl0sXG5cdFx0XCJTcGVjaWFsc1wiOiBbMHhGRkYwLCAweEZGRkZdLFxuXHRcdFwiTGluZWFyIEIgU3lsbGFiYXJ5XCI6IFsweDEwMDAwLCAweDEwMDdGXSxcblx0XHRcIkxpbmVhciBCIElkZW9ncmFtc1wiOiBbMHgxMDA4MCwgMHgxMDBGRl0sXG5cdFx0XCJBZWdlYW4gTnVtYmVyc1wiOiBbMHgxMDEwMCwgMHgxMDEzRl0sXG5cdFx0XCJBbmNpZW50IEdyZWVrIE51bWJlcnNcIjogWzB4MTAxNDAsIDB4MTAxOEZdLFxuXHRcdFwiQW5jaWVudCBTeW1ib2xzXCI6IFsweDEwMTkwLCAweDEwMUNGXSxcblx0XHRcIlBoYWlzdG9zIERpc2NcIjogWzB4MTAxRDAsIDB4MTAxRkZdLFxuXHRcdFwiTHljaWFuXCI6IFsweDEwMjgwLCAweDEwMjlGXSxcblx0XHRcIkNhcmlhblwiOiBbMHgxMDJBMCwgMHgxMDJERl0sXG5cdFx0XCJDb3B0aWMgRXBhY3QgTnVtYmVyc1wiOiBbMHgxMDJFMCwgMHgxMDJGRl0sXG5cdFx0XCJPbGQgSXRhbGljXCI6IFsweDEwMzAwLCAweDEwMzJGXSxcblx0XHRcIkdvdGhpY1wiOiBbMHgxMDMzMCwgMHgxMDM0Rl0sXG5cdFx0XCJPbGQgUGVybWljXCI6IFsweDEwMzUwLCAweDEwMzdGXSxcblx0XHRcIlVnYXJpdGljXCI6IFsweDEwMzgwLCAweDEwMzlGXSxcblx0XHRcIk9sZCBQZXJzaWFuXCI6IFsweDEwM0EwLCAweDEwM0RGXSxcblx0XHRcIkRlc2VyZXRcIjogWzB4MTA0MDAsIDB4MTA0NEZdLFxuXHRcdFwiU2hhdmlhblwiOiBbMHgxMDQ1MCwgMHgxMDQ3Rl0sXG5cdFx0XCJPc21hbnlhXCI6IFsweDEwNDgwLCAweDEwNEFGXSxcblx0XHRcIk9zYWdlXCI6IFsweDEwNEIwLCAweDEwNEZGXSxcblx0XHRcIkVsYmFzYW5cIjogWzB4MTA1MDAsIDB4MTA1MkZdLFxuXHRcdFwiQ2F1Y2FzaWFuIEFsYmFuaWFuXCI6IFsweDEwNTMwLCAweDEwNTZGXSxcblx0XHRcIkxpbmVhciBBXCI6IFsweDEwNjAwLCAweDEwNzdGXSxcblx0XHRcIkN5cHJpb3QgU3lsbGFiYXJ5XCI6IFsweDEwODAwLCAweDEwODNGXSxcblx0XHRcIkltcGVyaWFsIEFyYW1haWNcIjogWzB4MTA4NDAsIDB4MTA4NUZdLFxuXHRcdFwiUGFsbXlyZW5lXCI6IFsweDEwODYwLCAweDEwODdGXSxcblx0XHRcIk5hYmF0YWVhblwiOiBbMHgxMDg4MCwgMHgxMDhBRl0sXG5cdFx0XCJIYXRyYW5cIjogWzB4MTA4RTAsIDB4MTA4RkZdLFxuXHRcdFwiUGhvZW5pY2lhblwiOiBbMHgxMDkwMCwgMHgxMDkxRl0sXG5cdFx0XCJMeWRpYW5cIjogWzB4MTA5MjAsIDB4MTA5M0ZdLFxuXHRcdFwiTWVyb2l0aWMgSGllcm9nbHlwaHNcIjogWzB4MTA5ODAsIDB4MTA5OUZdLFxuXHRcdFwiTWVyb2l0aWMgQ3Vyc2l2ZVwiOiBbMHgxMDlBMCwgMHgxMDlGRl0sXG5cdFx0XCJLaGFyb3NodGhpXCI6IFsweDEwQTAwLCAweDEwQTVGXSxcblx0XHRcIk9sZCBTb3V0aCBBcmFiaWFuXCI6IFsweDEwQTYwLCAweDEwQTdGXSxcblx0XHRcIk9sZCBOb3J0aCBBcmFiaWFuXCI6IFsweDEwQTgwLCAweDEwQTlGXSxcblx0XHRcIk1hbmljaGFlYW5cIjogWzB4MTBBQzAsIDB4MTBBRkZdLFxuXHRcdFwiQXZlc3RhblwiOiBbMHgxMEIwMCwgMHgxMEIzRl0sXG5cdFx0XCJJbnNjcmlwdGlvbmFsIFBhcnRoaWFuXCI6IFsweDEwQjQwLCAweDEwQjVGXSxcblx0XHRcIkluc2NyaXB0aW9uYWwgUGFobGF2aVwiOiBbMHgxMEI2MCwgMHgxMEI3Rl0sXG5cdFx0XCJQc2FsdGVyIFBhaGxhdmlcIjogWzB4MTBCODAsIDB4MTBCQUZdLFxuXHRcdFwiT2xkIFR1cmtpY1wiOiBbMHgxMEMwMCwgMHgxMEM0Rl0sXG5cdFx0XCJPbGQgSHVuZ2FyaWFuXCI6IFsweDEwQzgwLCAweDEwQ0ZGXSxcblx0XHRcIlJ1bWkgTnVtZXJhbCBTeW1ib2xzXCI6IFsweDEwRTYwLCAweDEwRTdGXSxcblx0XHRcIkJyYWhtaVwiOiBbMHgxMTAwMCwgMHgxMTA3Rl0sXG5cdFx0XCJLYWl0aGlcIjogWzB4MTEwODAsIDB4MTEwQ0ZdLFxuXHRcdFwiU29yYSBTb21wZW5nXCI6IFsweDExMEQwLCAweDExMEZGXSxcblx0XHRcIkNoYWttYVwiOiBbMHgxMTEwMCwgMHgxMTE0Rl0sXG5cdFx0XCJNYWhhamFuaVwiOiBbMHgxMTE1MCwgMHgxMTE3Rl0sXG5cdFx0XCJTaGFyYWRhXCI6IFsweDExMTgwLCAweDExMURGXSxcblx0XHRcIlNpbmhhbGEgQXJjaGFpYyBOdW1iZXJzXCI6IFsweDExMUUwLCAweDExMUZGXSxcblx0XHRcIktob2praVwiOiBbMHgxMTIwMCwgMHgxMTI0Rl0sXG5cdFx0XCJNdWx0YW5pXCI6IFsweDExMjgwLCAweDExMkFGXSxcblx0XHRcIktodWRhd2FkaVwiOiBbMHgxMTJCMCwgMHgxMTJGRl0sXG5cdFx0XCJHcmFudGhhXCI6IFsweDExMzAwLCAweDExMzdGXSxcblx0XHRcIk5ld2FcIjogWzB4MTE0MDAsIDB4MTE0N0ZdLFxuXHRcdFwiVGlyaHV0YVwiOiBbMHgxMTQ4MCwgMHgxMTRERl0sXG5cdFx0XCJTaWRkaGFtXCI6IFsweDExNTgwLCAweDExNUZGXSxcblx0XHRcIk1vZGlcIjogWzB4MTE2MDAsIDB4MTE2NUZdLFxuXHRcdFwiTW9uZ29saWFuIFN1cHBsZW1lbnRcIjogWzB4MTE2NjAsIDB4MTE2N0ZdLFxuXHRcdFwiVGFrcmlcIjogWzB4MTE2ODAsIDB4MTE2Q0ZdLFxuXHRcdFwiQWhvbVwiOiBbMHgxMTcwMCwgMHgxMTczRl0sXG5cdFx0XCJXYXJhbmcgQ2l0aVwiOiBbMHgxMThBMCwgMHgxMThGRl0sXG5cdFx0XCJaYW5hYmF6YXIgU3F1YXJlXCI6IFsweDExQTAwLCAweDExQTRGXSxcblx0XHRcIlNveW9tYm9cIjogWzB4MTFBNTAsIDB4MTFBQUZdLFxuXHRcdFwiUGF1IENpbiBIYXVcIjogWzB4MTFBQzAsIDB4MTFBRkZdLFxuXHRcdFwiQmhhaWtzdWtpXCI6IFsweDExQzAwLCAweDExQzZGXSxcblx0XHRcIk1hcmNoZW5cIjogWzB4MTFDNzAsIDB4MTFDQkZdLFxuXHRcdFwiTWFzYXJhbSBHb25kaVwiOiBbMHgxMUQwMCwgMHgxMUQ1Rl0sXG5cdFx0XCJDdW5laWZvcm1cIjogWzB4MTIwMDAsIDB4MTIzRkZdLFxuXHRcdFwiQ3VuZWlmb3JtIE51bWJlcnMgYW5kIFB1bmN0dWF0aW9uXCI6IFsweDEyNDAwLCAweDEyNDdGXSxcblx0XHRcIkVhcmx5IER5bmFzdGljIEN1bmVpZm9ybVwiOiBbMHgxMjQ4MCwgMHgxMjU0Rl0sXG5cdFx0XCJFZ3lwdGlhbiBIaWVyb2dseXBoc1wiOiBbMHgxMzAwMCwgMHgxMzQyRl0sXG5cdFx0XCJBbmF0b2xpYW4gSGllcm9nbHlwaHNcIjogWzB4MTQ0MDAsIDB4MTQ2N0ZdLFxuXHRcdFwiQmFtdW0gU3VwcGxlbWVudFwiOiBbMHgxNjgwMCwgMHgxNkEzRl0sXG5cdFx0XCJNcm9cIjogWzB4MTZBNDAsIDB4MTZBNkZdLFxuXHRcdFwiQmFzc2EgVmFoXCI6IFsweDE2QUQwLCAweDE2QUZGXSxcblx0XHRcIlBhaGF3aCBIbW9uZ1wiOiBbMHgxNkIwMCwgMHgxNkI4Rl0sXG5cdFx0XCJNaWFvXCI6IFsweDE2RjAwLCAweDE2RjlGXSxcblx0XHRcIklkZW9ncmFwaGljIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXCI6IFsweDE2RkUwLCAweDE2RkZGXSxcblx0XHRcIlRhbmd1dFwiOiBbMHgxNzAwMCwgMHgxODdGRl0sXG5cdFx0XCJUYW5ndXQgQ29tcG9uZW50c1wiOiBbMHgxODgwMCwgMHgxOEFGRl0sXG5cdFx0XCJLYW5hIFN1cHBsZW1lbnRcIjogWzB4MUIwMDAsIDB4MUIwRkZdLFxuXHRcdFwiS2FuYSBFeHRlbmRlZC1BXCI6IFsweDFCMTAwLCAweDFCMTJGXSxcblx0XHRcIk51c2h1XCI6IFsweDFCMTcwLCAweDFCMkZGXSxcblx0XHRcIkR1cGxveWFuXCI6IFsweDFCQzAwLCAweDFCQzlGXSxcblx0XHRcIlNob3J0aGFuZCBGb3JtYXQgQ29udHJvbHNcIjogWzB4MUJDQTAsIDB4MUJDQUZdLFxuXHRcdFwiQnl6YW50aW5lIE11c2ljYWwgU3ltYm9sc1wiOiBbMHgxRDAwMCwgMHgxRDBGRl0sXG5cdFx0XCJNdXNpY2FsIFN5bWJvbHNcIjogWzB4MUQxMDAsIDB4MUQxRkZdLFxuXHRcdFwiQW5jaWVudCBHcmVlayBNdXNpY2FsIE5vdGF0aW9uXCI6IFsweDFEMjAwLCAweDFEMjRGXSxcblx0XHRcIlRhaSBYdWFuIEppbmcgU3ltYm9sc1wiOiBbMHgxRDMwMCwgMHgxRDM1Rl0sXG5cdFx0XCJDb3VudGluZyBSb2QgTnVtZXJhbHNcIjogWzB4MUQzNjAsIDB4MUQzN0ZdLFxuXHRcdFwiTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzXCI6IFsweDFENDAwLCAweDFEN0ZGXSxcblx0XHRcIlN1dHRvbiBTaWduV3JpdGluZ1wiOiBbMHgxRDgwMCwgMHgxREFBRl0sXG5cdFx0XCJHbGFnb2xpdGljIFN1cHBsZW1lbnRcIjogWzB4MUUwMDAsIDB4MUUwMkZdLFxuXHRcdFwiTWVuZGUgS2lrYWt1aVwiOiBbMHgxRTgwMCwgMHgxRThERl0sXG5cdFx0XCJBZGxhbVwiOiBbMHgxRTkwMCwgMHgxRTk1Rl0sXG5cdFx0XCJBcmFiaWMgTWF0aGVtYXRpY2FsIEFscGhhYmV0aWMgU3ltYm9sc1wiOiBbMHgxRUUwMCwgMHgxRUVGRl0sXG5cdFx0XCJNYWhqb25nIFRpbGVzXCI6IFsweDFGMDAwLCAweDFGMDJGXSxcblx0XHRcIkRvbWlubyBUaWxlc1wiOiBbMHgxRjAzMCwgMHgxRjA5Rl0sXG5cdFx0XCJQbGF5aW5nIENhcmRzXCI6IFsweDFGMEEwLCAweDFGMEZGXSxcblx0XHRcIkVuY2xvc2VkIEFscGhhbnVtZXJpYyBTdXBwbGVtZW50XCI6IFsweDFGMTAwLCAweDFGMUZGXSxcblx0XHRcIkVuY2xvc2VkIElkZW9ncmFwaGljIFN1cHBsZW1lbnRcIjogWzB4MUYyMDAsIDB4MUYyRkZdLFxuXHRcdFwiTWlzY2VsbGFuZW91cyBTeW1ib2xzIGFuZCBQaWN0b2dyYXBoc1wiOiBbMHgxRjMwMCwgMHgxRjVGRl0sXG5cdFx0XCJFbW9qaVwiOiBbMHgxRjYwMCwgMHgxRjY0Rl0sXG5cdFx0XCJPcm5hbWVudGFsIERpbmdiYXRzXCI6IFsweDFGNjUwLCAweDFGNjdGXSxcblx0XHRcIlRyYW5zcG9ydCBhbmQgTWFwIFN5bWJvbHNcIjogWzB4MUY2ODAsIDB4MUY2RkZdLFxuXHRcdFwiQWxjaGVtaWNhbCBTeW1ib2xzXCI6IFsweDFGNzAwLCAweDFGNzdGXSxcblx0XHRcIkdlb21ldHJpYyBTaGFwZXMgRXh0ZW5kZWRcIjogWzB4MUY3ODAsIDB4MUY3RkZdLFxuXHRcdFwiU3VwcGxlbWVudGFsIEFycm93cy1DXCI6IFsweDFGODAwLCAweDFGOEZGXSxcblx0XHRcIlN1cHBsZW1lbnRhbCBTeW1ib2xzIGFuZCBQaWN0b2dyYXBoc1wiOiBbMHgxRjkwMCwgMHgxRjlGRl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBCXCI6IFsweDIwMDAwLCAweDJBNkRGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIENcIjogWzB4MkE3MDAsIDB4MkI3M0ZdLFxuXHRcdFwiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gRFwiOiBbMHgyQjc0MCwgMHgyQjgxRl0sXG5cdFx0XCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBFXCI6IFsweDJCODIwLCAweDJDRUFGXSxcblx0XHRcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEZcIjogWzB4MkNFQjAsIDB4MkVCRUZdLFxuXHRcdFwiQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBocyBTdXBwbGVtZW50XCI6IFsweDJGODAwLCAweDJGQTFGXSxcblx0XHRcIlRhZ3NcIjogWzB4RTAwMDAsIDB4RTAwN0ZdLFxuXHRcdFwiVmFyaWF0aW9uIFNlbGVjdG9ycyBTdXBwbGVtZW50XCI6IFsweEUwMTAwLCAweEUwMUVGXVxuXHR9KTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogU3RvcmVzIHVuc29ydGVkIGdlbmVyYWwgdXRpbGl0eSBtZXRob2RzLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIE1pc2Ncblx0e1xuXHRcdC8qKlxuXHRcdCAqIENvdW50cyBpbmNyZW1lbnRhbGx5IHRocm91Z2ggbnVtYmVycywgdXNpbmcgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHJhZGl4IHNlcXVlbmNlLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHJhZGl4ZXMgWzIsIDIsIDJdIHdlcmUgdG9cblx0XHQgKiBiZSBzcGVjaWZpZWQsIHRoaXMgd291bGQgcmVzdWx0IGluIGJpbmFyeSBjb3VudGluZyBzdGFydGluZyBhdFxuXHRcdCAqIFswLCAwLCAwXSBhbmQgZW5kaW5nIGF0IFsxLCAxLCAxXS5cblx0XHQgKi9cblx0XHRzdGF0aWMgKnZhcmlhYmxlUmFkaXhDb3VudGVyKHJhZGl4ZXM6IG51bWJlcltdKVxuXHRcdHtcblx0XHRcdGlmIChyYWRpeGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRpZiAocmFkaXhlcy5sZW5ndGggPT09IDEpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcmFkaXhlc1swXTspXG5cdFx0XHRcdFx0eWllbGQgW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCB0b3RhbCA9IHJhZGl4ZXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG5cdFx0XHRjb25zdCBkaWdpdHMgPSByYWRpeGVzLm1hcCgoKSA9PiAwKTtcblx0XHRcdGNvbnN0IGRpdmlkZUZhY3RvcnMgPSBbMV07XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGJhc2VJZHggPSByYWRpeGVzLmxlbmd0aCAtIDE7IC0tYmFzZUlkeCA+PSAwOylcblx0XHRcdFx0ZGl2aWRlRmFjdG9ycy51bnNoaWZ0KHJhZGl4ZXMuc2xpY2UoYmFzZUlkeCArIDEpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgY291bnQgPSAtMTsgKytjb3VudCA8IHRvdGFsOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc2VxdWVuY2U6IG51bWJlcltdID0gW107XG5cdFx0XHRcdGxldCByZW1haW5kZXIgPSBjb3VudDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGRpZ2l0SWR4ID0gLTE7ICsrZGlnaXRJZHggPCBkaWdpdHMubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRpdiA9IGRpdmlkZUZhY3RvcnNbZGlnaXRJZHhdO1xuXHRcdFx0XHRcdHNlcXVlbmNlLnB1c2gocmVtYWluZGVyIC8gZGl2IHwgMCk7XG5cdFx0XHRcdFx0cmVtYWluZGVyICU9IGRpdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQgc2VxdWVuY2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHN0YXRpYyBjYWxjdWxhdGVQb3dlcnNldDxUPihhcnJheTogVFtdKTogVFtdW11cblx0XHR7XG5cdFx0XHRjb25zdCByZXN1bHQ6IFRbXVtdID0gW1tdXTtcblx0XHRcdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGZvciAobGV0IG4gPSAwOyBuIDwgcmVzdWx0Lmxlbmd0aDsgbisrKVxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHJlc3VsdFtuXS5jb25jYXQoYXJyYXlbaV0pKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgV2hldGhlciB0aGUgaXRlbXMgb2YgdGhlIGZpcnN0IHNldCBvYmplY3QgZm9ybVxuXHRcdCAqIGEgc3Vic2V0IChub3QgYSBwcm9wZXIgc3Vic2V0KSBvZiB0aGUgaXRlbXMgb2YgdGhlIHNlY29uZFxuXHRcdCAqIHNldC5cblx0XHQgKi9cblx0XHRzdGF0aWMgaXNTdWJzZXQoXG5cdFx0XHRzb3VyY2VTZXQ6IFJlYWRvbmx5U2V0PHVua25vd24+LFxuXHRcdFx0cG9zc2libGVTdWJzZXQ6IFJlYWRvbmx5U2V0PHVua25vd24+KVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBwb3NzaWJsZVN1YnNldClcblx0XHRcdFx0aWYgKCFzb3VyY2VTZXQuaGFzKGl0ZW0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGl0ZW1zIG9mIHRoZSBmaXJzdCBzZXQgb2JqZWN0IGZvcm1cblx0XHQgKiBhIHN1cGVyc2V0IChub3QgYSBwcm9wZXIgc3VwZXJzZXQpIG9mIHRoZSBpdGVtcyBvZiB0aGVcblx0XHQgKiBzZWNvbmQgc2V0LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBpc1N1cGVyc2V0KFxuXHRcdFx0c291cmNlU2V0OiBSZWFkb25seVNldDx1bmtub3duPixcblx0XHRcdHBvc3NpYmxlU3VwZXJzZXQ6IFJlYWRvbmx5U2V0PHVua25vd24+KVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2VTZXQpXG5cdFx0XHRcdGlmICghcG9zc2libGVTdXBlcnNldC5oYXMoaXRlbSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGFyZSBtaXNzaW5nXG5cdFx0ICogZnJvbSB0aGUgc2Vjb25kIHNldCB0aGF0IGV4aXN0IGluIHRoZSBmaXJzdCBzZXQuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNvbXB1dGVTdWJzZXRGYWN0b3IoXG5cdFx0XHRhOiByZWFkb25seSB1bmtub3duW10sXG5cdFx0XHRiOiByZWFkb25seSB1bmtub3duW10pXG5cdFx0e1xuXHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIGEpXG5cdFx0XHRcdGNvdW50ICs9IGIuaW5jbHVkZXMoaXRlbSkgPyAwIDogMTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhIHJlY3Vyc2l2ZSByZWR1Y3Rpb24gb3BlcmF0aW9uIG9uIGFuIGluaXRpYWwgb2JqZWN0XG5cdFx0ICogdGhhdCByZXByZXNlbnRzIHNvbWUgYWJzdHJhY3Qgbm9kZSBvZiBhIGdyYXBoLiBUaGUgdHJhdmVyc2FsXG5cdFx0ICogYWxnb3JpdGhtIHVzZWQgZW5zdXJlcyBhbGwgcHJvdmlkZWQgbm9kZXMgYXJlIG9ubHkgdmlzaXRlZFxuXHRcdCAqIG9uY2UuXG5cdFx0ICovXG5cdFx0c3RhdGljIHJlZHVjZVJlY3Vyc2l2ZTxUUmV0LCBUPihcblx0XHRcdGluaXRpYWxPYmplY3Q6IFQsXG5cdFx0XHRmb2xsb3dGbjogKGZyb206IFQpID0+IEl0ZXJhYmxlPFQ+LFxuXHRcdFx0cmVkdWNlRm46IChjdXJyZW50OiBULCBuZXN0ZWRSZXN1bHRzOiByZWFkb25seSBUUmV0W10pID0+IFRSZXRcblx0XHQpOiBUUmV0XG5cdFx0e1xuXHRcdFx0Y29uc3QgdmlzaXRlZCA9IG5ldyBTZXQ8VD4oKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVjdXJzZSA9IChvYmplY3Q6IFQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHZpc2l0ZWQuYWRkKG9iamVjdCk7XG5cdFx0XHRcdGNvbnN0IHJlZHVjZVJlc3VsdDogVFJldFtdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IG5leHQgb2YgZm9sbG93Rm4ob2JqZWN0KSlcblx0XHRcdFx0XHRpZiAoIXZpc2l0ZWQuaGFzKG5leHQpKVxuXHRcdFx0XHRcdFx0cmVkdWNlUmVzdWx0LnB1c2gocmVjdXJzZShuZXh0KSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcmVkdWNlRm4ob2JqZWN0LCBPYmplY3QuZnJlZXplKHJlZHVjZVJlc3VsdCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlY3Vyc2UoaW5pdGlhbE9iamVjdCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgcHJveHkgb2YgdGhlIHNwZWNpZmllZCBvYmplY3QsIHdob3NlIG1lbWJlcnNcblx0XHQgKiBoYXZlIGJlZW4gcGF0Y2hlZCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF0Y2ggb2JqZWN0LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBwYXRjaDxUIGV4dGVuZHMgb2JqZWN0Pihzb3VyY2U6IFQsIHBhdGNoOiBQYXJ0aWFsPFQ+KVxuXHRcdHtcblx0XHRcdHR5cGUgSyA9IHJlYWRvbmx5IChrZXlvZiBUKVtdO1xuXHRcdFx0Y29uc3QgcGF0Y2hLZXlzID0gPEs+T2JqZWN0LmZyZWV6ZShPYmplY3Qua2V5cyhwYXRjaCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IFByb3h5KHNvdXJjZSwge1xuXHRcdFx0XHRnZXQodGFyZ2V0OiBULCBrZXk6IGtleW9mIFQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0Y2hLZXlzLmluY2x1ZGVzKGtleSkgP1xuXHRcdFx0XHRcdFx0cGF0Y2hba2V5XSA6XG5cdFx0XHRcdFx0XHRzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNhZmVseSBwYXJzZXMgYSBKU09OIG9iamVjdCwgc2lsZW5jaW5nIGFueSB0aHJvd24gcGFyc2UgZXhjZXB0aW9ucy5cblx0XHQgKi9cblx0XHRzdGF0aWMgdHJ5UGFyc2VKc29uKGpzb25UZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGpzb25UZXh0KTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHt9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBUaGUgdG9wLWxldmVsIG9iamVjdCB0aGF0IG1hbmFnZXMgVHJ1dGggZG9jdW1lbnRzLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFByb2dyYW1cblx0e1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBuZXcgUHJvZ3JhbSwgaW50byB3aGljaCBEb2N1bWVudHMgbWF5XG5cdFx0ICogYmUgYWRkZWQsIGFuZCB2ZXJpZmllZC5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3RvcigpXG5cdFx0e1xuXHRcdFx0dGhpcy5fdmVyc2lvbiA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBvcmRlcmluZyBvZiB0aGVzZSBpbnN0YW50YXRpb25zIGlzIHJlbGV2YW50LFxuXHRcdFx0Ly8gYmVjYXVzZSBpdCByZWZsZWN0cyB0aGUgb3JkZXIgaW4gd2hpY2ggZWFjaCBvZlxuXHRcdFx0Ly8gdGhlc2Ugc2VydmljZXMgYXJlIGdvaW5nIHRvIHByb2Nlc3MgaG9va3MuXG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VEb2N1bWVudENyZWF0ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnVudmVyaWZpZWREb2N1bWVudHMucHVzaChkYXRhLmRvY3VtZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlRG9jdW1lbnREZWxldGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaWR4ID0gdGhpcy51bnZlcmlmaWVkRG9jdW1lbnRzLmluZGV4T2YoZGF0YS5kb2N1bWVudCk7XG5cdFx0XHRcdGlmIChpZHggPiAtMSlcblx0XHRcdFx0XHR0aGlzLnVudmVyaWZpZWREb2N1bWVudHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5vbihDYXVzZURvY3VtZW50VXJpQ2hhbmdlLCAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLm9uKENhdXNlQWdlbnREZXRhY2gsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbY2F1c2UsIGF0dGFjaG1lbnRzXSBvZiB0aGlzLmNhdXNlcylcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHMpXG5cdFx0XHRcdFx0XHRpZiAoYXR0YWNobWVudC51cmkgJiYgYXR0YWNobWVudC51cmkuZXF1YWxzKGRhdGEudXJpKSlcblx0XHRcdFx0XHRcdFx0dGhpcy5jYXVzZXMuZGVsZXRlKGNhdXNlLCBhdHRhY2htZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFnZW50Q2FjaGUgPSBuZXcgQWdlbnRDYWNoZSh0aGlzKTtcblx0XHRcdHRoaXMuZG9jdW1lbnRzID0gbmV3IERvY3VtZW50R3JhcGgodGhpcyk7XG5cdFx0XHR0aGlzLmdyYXBoID0gbmV3IEh5cGVyR3JhcGgodGhpcyk7XG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VSZXZhbGlkYXRlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IGkgPSB0aGlzLnVudmVyaWZpZWRTdGF0ZW1lbnRzLmxlbmd0aDsgaS0tID4gMDspXG5cdFx0XHRcdFx0aWYgKHRoaXMudW52ZXJpZmllZFN0YXRlbWVudHNbaV0uaXNEaXNwb3NlZClcblx0XHRcdFx0XHRcdHRoaXMudW52ZXJpZmllZFN0YXRlbWVudHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBzdGF0ZW1lbnQgb2YgZGF0YS5wYXJlbnRzKVxuXHRcdFx0XHRcdGlmICghc3RhdGVtZW50LmlzQ3J1ZnQpXG5cdFx0XHRcdFx0XHR0aGlzLnVudmVyaWZpZWRTdGF0ZW1lbnRzLnB1c2goc3RhdGVtZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmZhdWx0cyA9IG5ldyBGYXVsdFNlcnZpY2UodGhpcyk7XG5cdFx0XHRcblx0XHRcdHRoaXMub24oQ2F1c2VFZGl0Q29tcGxldGUsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3ZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGFnZW50Q2FjaGU6IEFnZW50Q2FjaGU7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgZG9jdW1lbnRzOiBEb2N1bWVudEdyYXBoO1xuXHRcdFxuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRyZWFkb25seSBncmFwaDogSHlwZXJHcmFwaDtcblx0XHRcblx0XHQvKiogICovXG5cdFx0cmVhZG9ubHkgZmF1bHRzOiBGYXVsdFNlcnZpY2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IHZlcnNpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl92ZXJzaW9uO1xuXHRcdH1cblx0XHRwcml2YXRlIF92ZXJzaW9uOiBWZXJzaW9uU3RhbXA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvYmVzIHRoZSBwcm9ncmFtIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCB0aGUgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgYSBjYXVzZSBvZiB0aGUgc3BlY2lmaWVkXG5cdFx0ICogdHlwZSBpcyBicm9hZGNhc3RlZC4gRXNzZW50aWFsbHksIHRoaXMgbWV0aG9kIGFuc3dlcnMgdGhlIHF1ZXN0aW9uLCBcblx0XHQgKiBcIldobyBpcyBsaXN0ZW5pbmcgZm9yIENhdXNlcyBvZiB0eXBlIFg/XCIuXG5cdFx0ICogXG5cdFx0ICogSWYgbm8gYWdlbnRzIGhhdmUgYXR0YWNoZWQgdG8gdGhlIHNwZWNpZmllZCB0eXBlLCBhbiBlbXB0eSBhcnJheVxuXHRcdCAqIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdHByb2JlKGNhdXNlVHlwZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBzY29wZTogQXR0YWNobWVudFNjb3BlID0gdGhpcylcblx0XHR7XG5cdFx0XHRpZiAoc2NvcGUgaW5zdGFuY2VvZiBUeXBlKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVzdWx0czogeyB1cmk6IFVyaSB8IG51bGw7IHNjb3BlOiBBdHRhY2htZW50U2NvcGUgfVtdID0gW107XG5cdFx0XHRjb25zdCBwdXNoID0gKGNhOiBDYXVzZUF0dGFjaG1lbnQpID0+XG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7IHVyaTogY2EudXJpLCBzY29wZTogY2Euc2NvcGUgfSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2NhdXNlVHlwZUtleSwgYXR0YWNobWVudHNdIG9mIHRoaXMuY2F1c2VzKVxuXHRcdFx0XHRpZiAoY2F1c2VUeXBlID09PSBjYXVzZVR5cGVLZXkpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjYSBvZiBhdHRhY2htZW50cylcblx0XHRcdFx0XHRcdGlmIChzY29wZSA9PT0gY2Euc2NvcGUgfHwgXG5cdFx0XHRcdFx0XHRcdHNjb3BlIGluc3RhbmNlb2YgUHJvZ3JhbSAmJiBjYS5zY29wZSBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0XHRcdFx0XHRwdXNoKGNhKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdG9uPFQgZXh0ZW5kcyBDYXVzZTxhbnk+Pihcblx0XHRcdGNhdXNlVHlwZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVCxcblx0XHRcdGZuOiAoZGF0YTogVENhdXNlRGF0YTxUPikgPT4gVENhdXNlUmV0dXJuPFQ+LFxuXHRcdFx0c2NvcGU/OiBEb2N1bWVudCB8IFR5cGUpOiB2b2lkXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5mbyA9IGdldEhvbGRlckluZm8odGhpcyk7XG5cdFx0XHRjb25zdCB1c2luZ1Njb3BlOiBBdHRhY2htZW50U2NvcGUgPSBzY29wZSB8fCBpbmZvLnNjb3BlIHx8IHRoaXM7XG5cdFx0XHRjb25zdCBjYSA9IG5ldyBDYXVzZUF0dGFjaG1lbnQoaW5mby51cmksIGZuLCB1c2luZ1Njb3BlKTtcblx0XHRcdHRoaXMuY2F1c2VzLmFkZChjYXVzZVR5cGUsIGNhKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvZ2F0ZXMgdGhlIHNwZWNpZmllZCBDYXVzZSBvYmplY3QgdG8gYWxsIHN1YnNjcmliZXJzIHRoYXRcblx0XHQgKiBhcmUgbGlzdGVuaW5nIGZvciBjYXVzZXMgb2Ygb2JqZWN0J3MgdHlwZS4gXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGNhdXNlIEEgcmVmZXJlbmNlIHRvIHRoZSBDYXVzZSBpbnN0YW5jZSB0byBicm9hZGNhc3QuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGZpbHRlciBBbiBvcHRpb25hbCBhcnJheSBvZiBVcmkgaW5zdGFuY2VzIHRoYXRcblx0XHQgKiBzcGVjaWZ5IHRoZSBvcmlnaW4gZnJvbSB3aGVyZSBhbiBhZ2VudCB0aGF0IGlzIGF0dGFjaGVkXG5cdFx0ICogdG8gdGhlIGNhdXNlIG11c3QgbG9hZGVkIGluIG9yZGVyIHRvIGJlIGRlbGl2ZXJlZCB0aGVcblx0XHQgKiBjYXVzZSBpbnN0YW5jZS5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBbiBvYmplY3QgdGhhdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG5cdFx0ICogY2F1c2UgcmVzdWx0cyB0aGF0IHdlcmUgcmV0dXJuZWQsIGFuZCB0aGUgVVJJIG9mIHRoZSBcblx0XHQgKiBhZ2VudCB0aGF0IHByb2R1Y2VkIHRoZSByZXN1bHQuIEluIHRoZSBjYXNlIHdoZW4gdGhlXG5cdFx0ICogYWdlbnQgd2FzIGF0dGFjaGVkIHByb2dyYW1tYXRpY2FsbHksIHRoZSBVUkkgdmFsdWUgXG5cdFx0ICogd2lsbCBiZSBudWxsLlxuXHRcdCAqL1xuXHRcdGNhdXNlPFI+KGNhdXNlOiBDYXVzZTxSPiwgLi4uZmlsdGVyczogVXJpW10pXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2F1c2VUeXBlID0gPHR5cGVvZiBDYXVzZT5jYXVzZS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IGF0dGFjaG1lbnRzQWxsID0gdGhpcy5jYXVzZXMuZ2V0KGNhdXNlVHlwZSkgfHwgW107XG5cdFx0XHRjb25zdCBhdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzQWxsLmZpbHRlcihhdHRhY2htZW50ID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG90aGVyVXJpID0gYXR0YWNobWVudC51cmk7XG5cdFx0XHRcdGlmIChvdGhlclVyaSA9PT0gbnVsbClcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmaWx0ZXJzLmZpbmQodXJpID0+IHVyaS5lcXVhbHMob3RoZXJVcmkpKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoYXR0YWNobWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlc3VsdDogeyBmcm9tOiBVcmkgfCBudWxsOyByZXR1cm5lZDogUiB9W10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZXR1cm5lZDogUiA9IGF0dGFjaG1lbnQuY2FsbGJhY2soY2F1c2UpO1xuXHRcdFx0XHRpZiAocmV0dXJuZWQgIT09IG51bGwgJiYgcmV0dXJuZWQgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRyZXN1bHQucHVzaCh7IGZyb206IGF0dGFjaG1lbnQudXJpLCByZXR1cm5lZCB9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgY2F1c2VzID0gbmV3IE11bHRpTWFwPHR5cGVvZiBDYXVzZSwgQ2F1c2VBdHRhY2htZW50PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF1Z21lbnRzIHRoZSBnbG9iYWwgc2NvcGUgb2YgdGhlIGFnZW50cyBhdHRhY2hlZCB0byB0aGlzXG5cdFx0ICogcHJvZ3JhbSB3aXRoIGEgdmFyaWFibGUgd2hvc2UgbmFtZSBhbmQgdmFsdWUgYXJlIHNwZWNpZmllZFxuXHRcdCAqIGluIHRoZSBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QuIChOb3RlIHRoYXQgdGhpcyBvbmx5IGFmZmVjdHNcblx0XHQgKiBhZ2VudHMgdGhhdCBhcmUgYXR0YWNoZWQgKmFmdGVyKiB0aGlzIGNhbGwgaGFzIGJlZW4gbWFkZS4pXG5cdFx0ICovXG5cdFx0YXVnbWVudChuYW1lOiBzdHJpbmcsIHZhbHVlOiBvYmplY3QpXG5cdFx0e1xuXHRcdFx0dGhpcy5hZ2VudENhY2hlLmF1Z21lbnQobmFtZSwgdmFsdWUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRhdHRhY2goYWdlbnRVcmk6IFVyaSk6IFByb21pc2U8RXJyb3IgfCB2b2lkPlxuXHRcdHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRkZXRhY2goYWdlbnRVcmk6IFVyaSlcblx0XHR7XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGUgcHJvZ3JhbSBmb3IgdGhlIHJvb3QtbGV2ZWwgdHlwZXMgdGhhdCBleGlzdCB3aXRoaW5cblx0XHQgKiB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcXVlcnkuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgdG9wLWxldmVsIHR5cGVzIHRoYXQgYXJlXG5cdFx0ICogZGVmaW5lZCB3aXRoaW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRxdWVyeShkb2N1bWVudDogRG9jdW1lbnQpOiBUeXBlW107XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGUgcHJvZ3JhbSBmb3IgdGhlIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluXG5cdFx0ICogdGhlIHNwZWNpZmllZCBkb2N1bWVudCwgYXQgdGhlIHNwZWNpZmllZCB0eXBlIHBhdGguXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBxdWVyeS5cblx0XHQgKiBAcGFyYW0gdHlwZVBhdGggVGhlIHR5cGUgcGF0aCB3aXRoaW4gdGhlIGRvY3VtZW50IHRvIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZ1bGx5IGNvbnN0cnVjdGVkIFR5cGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0b1xuXHRcdCAqIHRoZSB0eXBlIGF0IHRoZSBVUkkgc3BlY2lmaWVkLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gbm8gdHlwZVxuXHRcdCAqIGNvdWxkIGJlIGZvdW5kLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KGRvY3VtZW50OiBEb2N1bWVudCwgLi4udHlwZVBhdGg6IHN0cmluZ1tdKTogVHlwZSB8IG51bGw7XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGUgcHJvZ3JhbSBmb3IgdHlwZXMgdGhhdCBleGlzdCB3aXRoaW4gdGhpcyBwcm9ncmFtLFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgdHlwZSBVUkkuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHVyaSBUaGUgVVJJIG9mIHRoZSBkb2N1bWVudCB0byBxdWVyeS4gSWYgdGhlIFVSSSBjb250YWluc1xuXHRcdCAqIGEgdHlwZSBwYXRoLCBpdCBpcyBmYWN0b3JlZCBpbnRvIHRoZSBzZWFyY2guXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgdG9wLWxldmVsIHR5cGVzIHRoYXQgYXJlXG5cdFx0ICogZGVmaW5lZCB3aXRoaW4gdGhlIHNwZWNpZmllZCBkb2N1bWVudC4gSWYgdGhlIHNwZWNpZmllZCBVUkkgaGFzIGFcblx0XHQgKiB0eXBlIHBhdGgsIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnRhaW4gYSBzaW5nbGUgVHlwZSBpbnN0YW5jZVxuXHRcdCAqIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIFR5cGUgZm91bmQuIEluIHRoZSBjYXNlIHdoZW4gbm8gdHlwZVxuXHRcdCAqIGNvdWxkIGJlIGZvdW5kIGF0IHRoZSB0eXBlIHBhdGgsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KHVyaTogVXJpKTogVHlwZVtdO1xuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhlIHByb2dyYW0gZm9yIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluIHRoaXMgcHJvZ3JhbSxcblx0XHQgKiBhdCB0aGUgc3BlY2lmaWVkIFVSSSBhbmQgdHlwZSBwYXRoLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB1cmkgVGhlIFVSSSBvZiB0aGUgZG9jdW1lbnQgdG8gcXVlcnkuIElmIHRoZSBVUkkgY29udGFpbnNcblx0XHQgKiBhIHR5cGUgcGF0aCwgaXQgaXMgZmFjdG9yZWQgaW50byB0aGUgc2VhcmNoLlxuXHRcdCAqIEBwYXJhbSB0eXBlUGF0aCBUaGUgdHlwZSBwYXRoIHdpdGhpbiB0aGUgZG9jdW1lbnQgdG8gc2VhcmNoLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgZnVsbHkgY29uc3RydWN0ZWQgVHlwZSBpbnN0YW5jZSB0aGF0IGNvcnJlc3BvbmRzIHRvXG5cdFx0ICogdGhlIHR5cGUgYXQgdGhlIFVSSSBzcGVjaWZpZWQsIG9yIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiBubyB0eXBlXG5cdFx0ICogY291bGQgYmUgZm91bmQuXG5cdFx0ICovXG5cdFx0cXVlcnkodXJpOiBVcmksIC4uLnR5cGVQYXRoOiBzdHJpbmdbXSk6IFR5cGUgfCBudWxsO1xuXHRcdC8qKlxuXHRcdCAqIFF1ZXJpZXMgdGhlIHByb2dyYW0gZm9yIHR5cGVzIHRoYXQgZXhpc3Qgd2l0aGluIHRoaXMgZG9jdW1lbnQsXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBVUkkuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHVyaSBUaGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVSSSBvZiB0aGUgZG9jdW1lbnRcblx0XHQgKiB0byBxdWVyeS4gSWYgdGhlIFVSSSBjb250YWlucyBhIHR5cGUgcGF0aCwgaXQgaXMgZmFjdG9yZWQgaW50byB0aGUgc2VhcmNoLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRvcC1sZXZlbCB0eXBlcyB0aGF0IGFyZVxuXHRcdCAqIGRlZmluZWQgd2l0aGluIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuIElmIHRoZSBzcGVjaWZpZWQgVVJJIGhhcyBhXG5cdFx0ICogdHlwZSBwYXRoLCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb250YWluIGEgc2luZ2xlIFR5cGUgaW5zdGFuY2Vcblx0XHQgKiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBUeXBlIGZvdW5kLiBJbiB0aGUgY2FzZSB3aGVuIG5vIHR5cGVcblx0XHQgKiBjb3VsZCBiZSBmb3VuZCBhdCB0aGUgdHlwZSBwYXRoLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRxdWVyeSh1cmk6IHN0cmluZyk6IFR5cGVbXTtcblx0XHQvKipcblx0XHQgKiBRdWVyaWVzIHRoZSBwcm9ncmFtIGZvciB0eXBlcyB0aGF0IGV4aXN0IHdpdGhpbiB0aGlzIHByb2dyYW0sXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBVUkkgYW5kIHR5cGUgcGF0aC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gdXJpIFRoZSBVUkkgb2YgdGhlIGRvY3VtZW50IHRvIHF1ZXJ5LiBJZiB0aGUgVVJJIGNvbnRhaW5zXG5cdFx0ICogYSB0eXBlIHBhdGgsIGl0IGlzIGZhY3RvcmVkIGludG8gdGhlIHNlYXJjaC5cblx0XHQgKiBAcGFyYW0gdHlwZVBhdGggVGhlIHR5cGUgcGF0aCB3aXRoaW4gdGhlIGRvY3VtZW50IHRvIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZ1bGx5IGNvbnN0cnVjdGVkIFR5cGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0b1xuXHRcdCAqIHRoZSB0eXBlIGF0IHRoZSBVUkkgc3BlY2lmaWVkLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gbm8gdHlwZVxuXHRcdCAqIGNvdWxkIGJlIGZvdW5kLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KHVyaTogc3RyaW5nLCAuLi50eXBlUGF0aDogc3RyaW5nW10pOiBUeXBlIHwgbnVsbDtcblx0XHRxdWVyeShyb290OiBEb2N1bWVudCB8IFVyaSB8IHN0cmluZywgLi4udHlwZVBhdGg6IHN0cmluZ1tdKTogXG5cdFx0XHRyZWFkb25seSBUeXBlW10gfCBUeXBlIHwgbnVsbFxuXHRcdHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlUGF0aC5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5wYXNzZWRBcnJheUNhbm5vdEJlRW1wdHkoXCJ0eXBlUGF0aFwiKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudClcblx0XHRcdHtcblx0XHRcdFx0aWYgKHR5cGVQYXRoLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gVHlwZS5jb25zdHJ1Y3RSb290cyhyb290KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHVyaSA9IHJvb3Quc291cmNlVXJpLmV4dGVuZFR5cGUodHlwZVBhdGgpO1xuXHRcdFx0XHRyZXR1cm4gVHlwZS5jb25zdHJ1Y3QodXJpLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZG9jVXJpID0gVXJpLm1heWJlUGFyc2Uocm9vdCk7XG5cdFx0XHRpZiAoZG9jVXJpID09PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uYWJzb2x1dGVVcmlFeHBlY3RlZCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50cy5nZXQocm9vdCk7XG5cdFx0XHRpZiAoIWRvYylcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHR5cGVzID0gZG9jVXJpLnR5cGVzLm1hcCh0ID0+IHQudG9TdHJpbmcoKSkuY29uY2F0KHR5cGVQYXRoKTtcblx0XHRcdGlmICh0eXBlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBUeXBlLmNvbnN0cnVjdFJvb3RzKGRvYyk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZ1bGxVcmkgPSBkb2NVcmkuZXh0ZW5kVHlwZSh0eXBlUGF0aCk7XG5cdFx0XHRjb25zdCBjb25zdHJ1Y3RlZCA9IFR5cGUuY29uc3RydWN0KGZ1bGxVcmksIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZVBhdGgubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gY29uc3RydWN0ZWQgP1xuXHRcdFx0XHRcdE9iamVjdC5mcmVlemUoW2NvbnN0cnVjdGVkXSkgOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY29uc3RydWN0ZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEJlZ2luIGluc3BlY3RpbmcgYSBkb2N1bWVudCBsb2FkZWRcblx0XHQgKiBpbnRvIHRoaXMgcHJvZ3JhbSwgYSBzcGVjaWZpYyBsb2NhdGlvbi5cblx0XHQgKi9cblx0XHRpbnNwZWN0KFxuXHRcdFx0ZG9jdW1lbnQ6IERvY3VtZW50LFxuXHRcdFx0bGluZTogbnVtYmVyLFxuXHRcdFx0b2Zmc2V0OiBudW1iZXIpOiBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdFxuXHRcdHtcblx0XHRcdGNvbnN0IHN0YXRlbWVudCA9IGRvY3VtZW50LnJlYWQobGluZSk7XG5cdFx0XHRjb25zdCByZWdpb24gPSBzdGF0ZW1lbnQuZ2V0UmVnaW9uKG9mZnNldCk7XG5cdFx0XHRcblx0XHRcdHN3aXRjaCAocmVnaW9uKVxuXHRcdFx0e1xuXHRcdFx0XHRjYXNlIFN0YXRlbWVudFJlZ2lvbi52b2lkOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQobnVsbCwgc3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFJldHVybiBhbGwgdGhlIHR5cGVzIGluIHRoZSBkZWNsYXJhdGlvbiBzaWRlIG9mIHRoZSBwYXJlbnQuXG5cdFx0XHRcdGNhc2UgU3RhdGVtZW50UmVnaW9uLndoaXRlc3BhY2U6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5nZXRQYXJlbnRGcm9tUG9zaXRpb24obGluZSwgb2Zmc2V0KTtcblx0XHRcdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KHBhcmVudCwgc3RhdGVtZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0eXBlcyA9IHBhcmVudC5kZWNsYXJhdGlvbnNcblx0XHRcdFx0XHRcdC5tYXAoZGVjbCA9PiBkZWNsLmZhY3RvcigpKVxuXHRcdFx0XHRcdFx0LnJlZHVjZSgoc3BpbmVzLCBzKSA9PiBzcGluZXMuY29uY2F0KHMpLCBbXSlcblx0XHRcdFx0XHRcdC5tYXAoc3BpbmUgPT4gVHlwZS5jb25zdHJ1Y3Qoc3BpbmUsIHRoaXMpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0KHR5cGVzLCBzdGF0ZW1lbnQsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGNhc2UgU3RhdGVtZW50UmVnaW9uLnBhdHRlcm46XG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBUT0RPOiBUaGlzIHNob3VsZCBub3QgYmUgcmV0dXJuaW5nIGEgUGF0dGVybkxpdGVyYWwsXG5cdFx0XHRcdFx0Ly8gYnV0IHJhdGhlciBhIGZ1bGx5IGNvbnN0cnVjdGVkIElQYXR0ZXJuIG9iamVjdC4gVGhpc1xuXHRcdFx0XHRcdC8vIGNvZGUgaXMgb25seSBoZXJlIGFzIGEgc2hpbS5cblx0XHRcdFx0XHRjb25zdCBwYXR0ZXJuVHlwZXM6IFR5cGVbXSA9IFtdO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQocGF0dGVyblR5cGVzLCBzdGF0ZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFJldHVybiBhbGwgdGhlIHR5cGVzIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNsYXJhdGlvbi5cblx0XHRcdFx0Y2FzZSBTdGF0ZW1lbnRSZWdpb24uZGVjbGFyYXRpb246XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkZWNsID0gc3RhdGVtZW50LmdldERlY2xhcmF0aW9uKG9mZnNldCk7XG5cdFx0XHRcdFx0aWYgKCFkZWNsKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHR5cGVzID0gZGVjbFxuXHRcdFx0XHRcdFx0LmZhY3RvcigpXG5cdFx0XHRcdFx0XHQubWFwKHNwaW5lID0+IFR5cGUuY29uc3RydWN0KHNwaW5lLCB0aGlzKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdCh0eXBlcywgc3RhdGVtZW50LCBkZWNsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBcblx0XHRcdFx0Y2FzZSBTdGF0ZW1lbnRSZWdpb24uYW5ub3RhdGlvbjpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGFubm8gPSBzdGF0ZW1lbnQuZ2V0QW5ub3RhdGlvbihvZmZzZXQpO1xuXHRcdFx0XHRcdGlmICghYW5ubylcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBzcGluZSA9IHN0YXRlbWVudC5kZWNsYXJhdGlvbnNbMF0uZmFjdG9yKClbMF07XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IFR5cGUuY29uc3RydWN0KHNwaW5lLCB0aGlzKTtcblx0XHRcdFx0XHRjb25zdCBhbm5vVGV4dCA9IGFubm8uYm91bmRhcnkuc3ViamVjdC50b1N0cmluZygpO1xuXHRcdFx0XHRcdGNvbnN0IGJhc2UgPSB0eXBlLmJhc2VzLmZpbmQoYiA9PiBiLm5hbWUgPT09IGFubm9UZXh0KTtcblx0XHRcdFx0XHRjb25zdCBiYXNlcyA9IGJhc2UgPyBbYmFzZV0gOiBudWxsO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvZ3JhbUluc3BlY3Rpb25SZXN1bHQoYmFzZXMsIHN0YXRlbWVudCwgYW5ubyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBQcm9ncmFtSW5zcGVjdGlvblJlc3VsdChudWxsLCBzdGF0ZW1lbnQsIG51bGwpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhIGZ1bGwgdmVyaWZpY2F0aW9uIG9mIGFsbCBkb2N1bWVudHMgbG9hZGVkIGludG8gdGhlIHByb2dyYW0uXG5cdFx0ICogVGhpcyBQcm9ncmFtJ3MgLmZhdWx0cyBmaWVsZCBpcyBwb3B1bGF0ZWQgd2l0aCBhbnkgZmF1bHRzIGdlbmVyYXRlZCBhc1xuXHRcdCAqIGEgcmVzdWx0IG9mIHRoZSB2ZXJpZmljYXRpb24uIElmIG5vIGRvY3VtZW50cyBsb2FkZWQgaW50byB0aGlzIHByb2dyYW1cblx0XHQgKiBoYXMgYmVlbiBlZGl0ZWQgc2luY2UgdGhlIGxhc3QgdmVyaWZpY2F0aW9uLCB2ZXJpZmljYXRpb24gaXMgbm90IHJlLWF0dGVtcHRlZC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBbiBlbnRyeXBvaW50IGludG8gcGVyZm9ybWluZyBhbmFseXNpcyBvZiB0aGUgVHlwZXMgdGhhdFxuXHRcdCAqIGhhdmUgYmVlbiBkZWZpbmVkIGluIHRoaXMgcHJvZ3JhbS5cblx0XHQgKi9cblx0XHR2ZXJpZnkoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZG9jIG9mIHRoaXMuZG9jdW1lbnRzLmVhY2goKSlcblx0XHRcdFx0Zm9yIChjb25zdCB7IHN0YXRlbWVudCB9IG9mIGRvYy5lYWNoRGVzY2VuZGFudCgpKVxuXHRcdFx0XHRcdHRoaXMudmVyaWZ5QXNzb2NpYXRlZERlY2xhcmF0aW9ucyhzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5hbGl6ZVZlcmlmaWNhdGlvbigpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyB2ZXJpZmljYXRpb24gb24gdGhlIHBhcnRzIG9mIHRoZSBkb2N1bWVudCB0aGF0IGhhdmVcblx0XHQgKiBub3QgYmVlbiB2ZXJpZmllZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgbWV0aG9kLiBPbmNlIHRoaXNcblx0XHQgKiBtZXRob2QgaGFzIGNvbXBsZXRlZCwgYW55IGRldGVjdGVkIGZhdWx0cyB3aWxsIGJlIGF2YWlsYWJsZVxuXHRcdCAqIGJ5IHVzaW5nIHRoZSBtZXRob2RzIGxvY2F0ZWQgaW4gdGhlIGAuZmF1bHRzYCBwcm9wZXJ0eSBvZiB0aGlzXG5cdFx0ICogaW5zdGFuY2UuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdmVyaWZpY2F0aW9uXG5cdFx0ICogY29tcGxldGVkIHdpdGhvdXQgZGV0ZWN0aW5nIGFueSBmYXVsdHMgaW4gdGhpcyBQcm9ncmFtLlxuXHRcdCAqL1xuXHRcdHJldmVyaWZ5KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGRvYyBvZiB0aGlzLnVudmVyaWZpZWREb2N1bWVudHMpXG5cdFx0XHRcdGZvciAoY29uc3QgeyBzdGF0ZW1lbnQgfSBvZiBkb2MuZWFjaERlc2NlbmRhbnQoKSlcblx0XHRcdFx0XHR0aGlzLnZlcmlmeUFzc29jaWF0ZWREZWNsYXJhdGlvbnMoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgdGhpcy51bnZlcmlmaWVkU3RhdGVtZW50cylcblx0XHRcdFx0dGhpcy52ZXJpZnlBc3NvY2lhdGVkRGVjbGFyYXRpb25zKHNtdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZpbmFsaXplVmVyaWZpY2F0aW9uKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgdmVyaWZ5QXNzb2NpYXRlZERlY2xhcmF0aW9ucyhzdGF0ZW1lbnQ6IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHRpZiAoIXN0YXRlbWVudC5pc0Rpc3Bvc2VkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGRlY2wgb2Ygc3RhdGVtZW50LmRlY2xhcmF0aW9ucylcblx0XHRcdFx0XHRkZWNsLmZhY3RvcigpLm1hcChzcGluZSA9PiBcblx0XHRcdFx0XHRcdFR5cGUuY29uc3RydWN0KHNwaW5lLCB0aGlzKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgZmluYWxpemVWZXJpZmljYXRpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuZmF1bHRzLnJlZnJlc2goKTtcblx0XHRcdHRoaXMudW52ZXJpZmllZERvY3VtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy51bnZlcmlmaWVkU3RhdGVtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmF1bHRzLmNvdW50ID09PSAwO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHVudmVyaWZpZWRTdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgdW52ZXJpZmllZERvY3VtZW50czogRG9jdW1lbnRbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWdlbnQgdGhhdCBob2xkcyB0aGUgcmVmZXJlbmNlXG5cdFx0ICogdG8gdGhpcyBQcm9ncmFtIGluc3RhbmNlLiBUaGUgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGluIHRoZVxuXHRcdCAqIGNhc2Ugd2hlbiB0aGUgaW5zdGFuY2UgaXMgbm90IGhlbGQgYnkgYW4gYWdlbnQuXG5cdFx0ICogXG5cdFx0ICogVGhpcyB2YWx1ZSBpcyBhcHBsaWVkIHRocm91Z2ggdGhlIE1pc2MucGF0Y2goKSBmdW5jdGlvbiwgd2hpY2hcblx0XHQgKiB1c2VzIGEgUHJveHkgb2JqZWN0IHRvIHByb3ZpZGUgXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaW5zdGFuY2VIb2xkZXI/OiB7XG5cdFx0XHR1cmk6IFVyaTtcblx0XHRcdHNjb3BlOiBBdHRhY2htZW50U2NvcGU7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IHRoYXQgaG9sZHMgXG5cdCAqIHRoZSBzcGVjaWZpZWQgUHJvZ3JhbSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIGdldEhvbGRlckluZm8ocHJvZ3JhbTogUHJvZ3JhbSlcblx0e1xuXHRcdGNvbnN0IGloID0gcHJvZ3JhbS5pbnN0YW5jZUhvbGRlcjtcblx0XHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0dXJpOiA8VXJpIHwgbnVsbD4oaWggPyBpaC51cmkgOiBudWxsKSxcblx0XHRcdHNjb3BlOiA8QXR0YWNobWVudFNjb3BlPihpaCA/IGloLnNjb3BlIDogcHJvZ3JhbSlcblx0XHR9O1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXR0YWNobWVudFxuXHQgKiBvZiBhIGNhdXNlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0Y2xhc3MgQ2F1c2VBdHRhY2htZW50XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHVyaTogVXJpIHwgbnVsbCxcblx0XHRcdHJlYWRvbmx5IGNhbGxiYWNrOiAoZGF0YTogYW55KSA9PiBhbnksXG5cdFx0XHRyZWFkb25seSBzY29wZTogQXR0YWNobWVudFNjb3BlKVxuXHRcdHsgfVxuXHR9XG5cblxuXHQvKipcblx0ICogRGVzY3JpYmVzIGEgcGxhY2UgaW4gdGhlIHByb2dyYW0gd2hlcmUgYSBDYXVzZSBpcyBhdHRhY2hlZC5cblx0ICovXG5cdGV4cG9ydCB0eXBlIEF0dGFjaG1lbnRTY29wZSA9IFByb2dyYW0gfCBEb2N1bWVudCB8IFR5cGU7XG5cblxuXHQvKipcblx0ICogU3RvcmVzIHRoZSBkZXRhaWxzIGFib3V0IGEgcHJlY2lzZSBsb2NhdGlvbiBpbiBhIERvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFByb2dyYW1JbnNwZWN0aW9uUmVzdWx0XG5cdHtcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgY29tcGlsYXRpb24gb2JqZWN0IHRoYXQgbW9zdCBjbG9zZWx5IHJlcHJlc2VudHNcblx0XHRcdCAqIHdoYXQgd2FzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uIFN0b3JlcyBudWxsIGluIHRoZVxuXHRcdFx0ICogY2FzZSB3aGVuIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gY29udGFpbnMgYW4gb2JqZWN0IHRoYXRcblx0XHRcdCAqIGhhcyBiZWVuIG1hcmtlZCBhcyBjcnVmdCAodGhlIHN0YXRlbWVudCBhbmQgc3BhbiBmaWVsZHNcblx0XHRcdCAqIGFyZSBzdGlsbCBwb3B1bGF0ZWQgaW4gdGhpcyBjYXNlKS5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgZm91bmRPYmplY3Q6IERvY3VtZW50IHwgVHlwZVtdIHwgbnVsbCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIFN0YXRlbWVudCBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzdGF0ZW1lbnQ6IFN0YXRlbWVudCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIFNwYW4gZm91bmQgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiwgb3Jcblx0XHRcdCAqIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiBubyBTcGFuIHdhcyBmb3VuZCwgc3VjaCBhcyBpZlxuXHRcdFx0ICogdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBpcyB3aGl0ZXNwYWNlIG9yIGEgY29tbWVudC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgc3BhbjogU3BhbiB8IG51bGwgPSBudWxsKVxuXHRcdHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGZvdW5kT2JqZWN0KSAmJiBmb3VuZE9iamVjdC5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRoaXMuZm91bmRPYmplY3QgPSBudWxsO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIGNhY2hlIHRoYXQgc3RvcmVzIGFnZW50IGJ1aWxkIGZ1bmN0aW9uIGxvYWRlZCBieSBhIHNpbmdsZSBwcm9ncmFtIGluc3RhbmNlLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEFnZW50Q2FjaGVcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlVXJpUmVmZXJlbmNlQWRkLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnVyaS5leHQgPT09IFVyaUV4dGVuc2lvbi5qcylcblx0XHRcdFx0XHR0aGlzLmF0dGFjaEFnZW50KGRhdGEudXJpLCBkYXRhLnN0YXRlbWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVVyaVJlZmVyZW5jZVJlbW92ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZGF0YS51cmkuZXh0ID09PSBVcmlFeHRlbnNpb24uanMpXG5cdFx0XHRcdFx0dGhpcy5kZXRhY2hBZ2VudChkYXRhLnVyaSwgZGF0YS5zdGF0ZW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgYXN5bmMgYXR0YWNoQWdlbnQodXJpOiBVcmksIHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVsbClcblx0XHR7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RvcmVTdHJpbmcoKTtcblx0XHRcdGNvbnN0IGV4aXN0aW5nQ2FjaGVTZXQgPSB0aGlzLmNhY2hlLmdldCh1cmlUZXh0KTtcblx0XHRcdGNvbnN0IHJlZmVyZW5jZSA9IHN0YXRlbWVudCB8fCB0aGlzLnByb2dyYW07XG5cdFx0XHRcblx0XHRcdGlmIChleGlzdGluZ0NhY2hlU2V0KVxuXHRcdFx0e1xuXHRcdFx0XHRleGlzdGluZ0NhY2hlU2V0LmFkZChyZWZlcmVuY2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNjb3BlID0gc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50ID9cblx0XHRcdFx0c3RhdGVtZW50LmRvY3VtZW50IDpcblx0XHRcdFx0dGhpcy5wcm9ncmFtO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzb3VyY2VSYXcgPSBhd2FpdCBVcmlSZWFkZXIudHJ5UmVhZCh1cmkpO1xuXHRcdFx0aWYgKHNvdXJjZVJhdyBpbnN0YW5jZW9mIEVycm9yKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlUmF3O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLm1heWJlQWRqdXN0U291cmNlTWFwKHVyaSwgc291cmNlUmF3KTtcblx0XHRcdGNvbnN0IHBhdGNoZWRQcm9ncmFtID0gTWlzYy5wYXRjaCh0aGlzLnByb2dyYW0sIHtcblx0XHRcdFx0aW5zdGFuY2VIb2xkZXI6IHsgdXJpLCBzY29wZSB9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcGFyYW1zID0gW1xuXHRcdFx0XHRcInByb2dyYW1cIixcblx0XHRcdFx0XCJUcnV0aFwiLFxuXHRcdFx0XHRcInJlcXVpcmVcIixcblx0XHRcdFx0Li4udGhpcy5hZ2VudEZ1bmN0aW9uUGFyYW1ldGVycy5rZXlzKCksXG5cdFx0XHRcdHNvdXJjZVxuXHRcdFx0XTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYXJncyA9IFtcblx0XHRcdFx0cGF0Y2hlZFByb2dyYW0sXG5cdFx0XHRcdFRydXRoLFxuXHRcdFx0XHRBZ2VudENhY2hlLmhpamFja2VkUmVxdWlyZUZuLFxuXHRcdFx0XHQuLi50aGlzLmFnZW50RnVuY3Rpb25QYXJhbWV0ZXJzLnZhbHVlcygpXG5cdFx0XHRdO1xuXHRcdFx0XG5cdFx0XHR0cnlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZm4gPSBPYmplY3QuZnJlZXplKEZ1bmN0aW9uLmFwcGx5KEZ1bmN0aW9uLCBwYXJhbXMpKTtcblx0XHRcdFx0YXdhaXQgZm4uYXBwbHkoZm4sIDxhbnk+YXJncyk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5yZXBvcnRVc2VyTGFuZEVycm9yKGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VBZ2VudEF0dGFjaCh1cmksIHNjb3BlKSk7XG5cdFx0XHRjb25zdCBzZXQgPSBuZXcgU2V0PFN0YXRlbWVudCB8IFByb2dyYW0+KFtyZWZlcmVuY2VdKTtcblx0XHRcdHRoaXMuY2FjaGUuc2V0KHVyaVRleHQsIHNldCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgZGV0YWNoQWdlbnQodXJpOiBVcmksIHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVsbClcblx0XHR7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RvcmVTdHJpbmcoKTtcblx0XHRcdGNvbnN0IGV4aXN0aW5nQ2FjaGVTZXQgPSB0aGlzLmNhY2hlLmdldCh1cmlUZXh0KTtcblx0XHRcdGlmICghZXhpc3RpbmdDYWNoZVNldClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRleGlzdGluZ0NhY2hlU2V0LmRlbGV0ZShzdGF0ZW1lbnQgfHwgdGhpcy5wcm9ncmFtKTtcblx0XHRcdGlmIChleGlzdGluZ0NhY2hlU2V0LnNpemUgPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY2FjaGUuZGVsZXRlKHVyaVRleHQpO1xuXHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlQWdlbnREZXRhY2godXJpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIChDYWxsZWQgYnkgUHJvZ3JhbSlcblx0XHQgKi9cblx0XHRhdWdtZW50KG5hbWU6IHN0cmluZywgdmFsdWU6IG9iamVjdClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5hZ2VudEZ1bmN0aW9uUGFyYW1ldGVycy5oYXMobmFtZSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5jYXVzZVBhcmFtZXRlck5hbWVJblVzZShuYW1lKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5hZ2VudEZ1bmN0aW9uUGFyYW1ldGVycy5zZXQoXG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdHZhbHVlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBhZ2VudEZ1bmN0aW9uUGFyYW1ldGVycyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRqdXN0cyB0aGUgY29udGVudCBvZiB0aGUgc291cmNlbWFwIGluIHRoZSBzcGVjaWZpZWQgc291cmNlIGNvZGUgXG5cdFx0ICogZmlsZSwgdG8gYWNjb3VudCBmb3IgdGhlIGRpc2NyZXBlbmNpZXMgaW50cm9kdWNlZCBieSB3cmFwcGluZyBKYXZhU2NyaXB0XG5cdFx0ICogc291cmNlIGNvZGUgaW4gYSBuZXcgRnVuY3Rpb24oKSBjb25zdHJ1Y3Rvci5cblx0XHQgKi9cblx0XHRwcml2YXRlIG1heWJlQWRqdXN0U291cmNlTWFwKHNvdXJjZVVyaTogVXJpLCBzb3VyY2VDb2RlOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZG8gYW55IG9mIHRoaXMgc291cmNlIG1hcCBtdXRhdGlvbiB3aXRob3V0IE5vZGUuSlNcblx0XHRcdC8vIGFjY2VzcyByaWdodCBub3cuIE1heWJlIHRoaXMgd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblx0XHRcdGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbGFzdExpbmVTdGFydCA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCBpID0gc291cmNlQ29kZS5sZW5ndGg7IGktLSA+IDE7KVxuXHRcdFx0XHRcdGlmIChzb3VyY2VDb2RlW2kgLSAxXSA9PT0gXCJcXG5cIilcblx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGxhc3RMaW5lU3RhcnQgPCAwKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlTWFwVXJsID0gW1wiLy9cIiwgXCIjXCIsIFwiIHNvdXJjZVwiLCBcIk1hcHBpbmdVUkw9XCJdLmpvaW4oXCJcIik7XG5cdFx0XHRpZiAoc291cmNlQ29kZS5zdWJzdHIobGFzdExpbmVTdGFydCwgc291cmNlTWFwVXJsLmxlbmd0aCkgIT09IHNvdXJjZU1hcFVybClcblx0XHRcdFx0cmV0dXJuIHNvdXJjZUNvZGU7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0YXJ0UG9zID0gbGFzdExpbmVTdGFydCArIHNvdXJjZU1hcFVybC5sZW5ndGg7XG5cdFx0XHRjb25zdCBlbmRpbmcgPSBcIjtiYXNlNjQsXCI7XG5cdFx0XHRjb25zdCBlbmRQb3MgPSBzb3VyY2VDb2RlLmluZGV4T2YoZW5kaW5nLCBzdGFydFBvcykgKyBlbmRpbmcubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHQvLyBVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGZvcm1hdC5cblx0XHRcdGlmIChlbmRQb3MgPCBlbmRpbmcubGVuZ3RoKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlTWFwUmF3ID0gdGhpcy5mcm9tQmFzZTY0KHNvdXJjZUNvZGUuc2xpY2UoZW5kUG9zKSk7XG5cdFx0XHRcblx0XHRcdC8vIFRoZXJlJ3MgcHJvYmFibHkgc29tZSBlcnJvciBpbiB0aGUgc291cmNlIG1hcFxuXHRcdFx0aWYgKCFzb3VyY2VNYXBSYXcpXG5cdFx0XHRcdHJldHVybiBzb3VyY2VDb2RlO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgc291cmNlIG1hcCBpc24ndCBwYXJzaW5nIGFzIGEgSlNPTiBvYmplY3QgLi4uIHByb2JhYmx5IGJyb2tlbiBzb21laG93XG5cdFx0XHRjb25zdCBzb3VyY2VNYXA6IElTb3VyY2VNYXAgPSBNaXNjLnRyeVBhcnNlSnNvbihzb3VyY2VNYXBSYXcpO1xuXHRcdFx0aWYgKCFzb3VyY2VNYXApXG5cdFx0XHRcdHJldHVybiBzb3VyY2VDb2RlO1xuXHRcdFx0XG5cdFx0XHQvLyBVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIHZlcnNpb25cblx0XHRcdGlmICh0eXBlb2Ygc291cmNlTWFwLm1hcHBpbmdzICE9PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRyZXR1cm4gc291cmNlQ29kZTtcblx0XHRcdFxuXHRcdFx0Ly8gUGxhY2luZyBhIDsgaW4gdGhlIFwibWFwcGluZ3NcIiBwcm9wZXJ0eSBvZiB0aGUgc291cmNlIG1hcCBvYmplY3Rcblx0XHRcdC8vIHNoaWZ0cyB0aGUgbGluZXMgZG93biBieSAxLiBJdCBuZWVkcyB0byBiZSArIDEsIGJlY2F1c2Ugd2Ugd3JhcFxuXHRcdFx0Ly8gdGhlIGNvZGUgaW4gb3VyIG93biBzZXRUaW1lb3V0KCkgYmxvY2suXG5cdFx0XHRjb25zdCBwcmVmaXggPSBcIjtcIi5yZXBlYXQodGhpcy5zb3VyY2VNYXBMaW5lT2Zmc2V0ICsgMSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhdGhNb2R1bGUgPSA8dHlwZW9mIGltcG9ydChcInBhdGhcIik+cmVxdWlyZShcInBhdGhcIik7XG5cdFx0XHRjb25zdCBiYXNlUGF0aCA9IHNvdXJjZVVyaS50b1N0b3JlU3RyaW5nKHRydWUpO1xuXHRcdFx0c291cmNlTWFwLm1hcHBpbmdzID0gcHJlZml4ICsgc291cmNlTWFwLm1hcHBpbmdzO1xuXHRcdFx0XG5cdFx0XHRpZiAoc291cmNlTWFwLnNvdXJjZXMgaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0c291cmNlTWFwLnNvdXJjZXMgPSBzb3VyY2VNYXAuc291cmNlcy5tYXAocyA9PiBcblx0XHRcdFx0XHRwYXRoTW9kdWxlLmpvaW4oYmFzZVBhdGgsIHMpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbmV3U291cmNlTWFwID0gdGhpcy50b0Jhc2U2NChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKTtcblx0XHRcdGNvbnN0IG5ld1NvdXJjZUNvZGUgPSBzb3VyY2VDb2RlLnNsaWNlKDAsIGxhc3RMaW5lU3RhcnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgc291cmNlIGNvZGUgaXMgd3JhcHBlZCBpbiBhIHNldFRpbWVvdXQgaW4gb3JkZXJcblx0XHRcdC8vIHRvIGdpdmUgYW55IGF0dGFjaGVkIGRlYnVnZ2VycyBhIGNoYW5jZSB0byBjb25uZWN0LlxuXHRcdFx0Y29uc3QgdmFyTmFtZSA9IFwiJCRfX1JFU09MVkVfRlVOQ1RJT05fXyQkXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG5ld1NvdXJjZUNvZGVEZWxheWVkID0gXG5cdFx0XHRcdGByZXR1cm4gbmV3IFByb21pc2UoJHt2YXJOYW1lfSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcXG5gICsgXG5cdFx0XHRcdG5ld1NvdXJjZUNvZGUgKyBcblx0XHRcdFx0YDsgJHt2YXJOYW1lfSgpOyB9LCAxKSlcXG5gO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBuZXdQcmVmaXggPSBzb3VyY2VDb2RlLnNsaWNlKGxhc3RMaW5lU3RhcnQsIGVuZFBvcyk7XG5cdFx0XHRyZXR1cm4gbmV3U291cmNlQ29kZURlbGF5ZWQgKyBuZXdQcmVmaXggKyBuZXdTb3VyY2VNYXA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVwb3J0VXNlckxhbmRFcnJvcihlOiBFcnJvcilcblx0XHR7XG5cdFx0XHQvLyBOT1RFOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSByZXBvcnRpbmcgdGhlIGVycm9yXG5cdFx0XHQvLyBzb21ld2hlcmUgd2hlcmUgaXQncyB2aXNpYmxlLlxuXHRcdFx0ZGVidWdnZXI7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHRvQmFzZTY0KHBsYWluOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0XHRidG9hKHBsYWluKSA6XG5cdFx0XHRcdEJ1ZmZlci5mcm9tKHBsYWluLCBcImFzY2lpXCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGZyb21CYXNlNjQoZW5jb2RlZDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0eXBlb2YgYXRvYiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdFx0YXRvYihlbmNvZGVkKSA6XG5cdFx0XHRcdEJ1ZmZlci5mcm9tKGVuY29kZWQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYXNjaWlcIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXF1aXJlKCkgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYW5cblx0XHQgKiBhZ2VudCBmb3IgbnVtZXJvdXMgKGFuZCBub24tb2J2aW91cykgcmVhc29ucy4gVGhpcyBmdW5jdGlvblxuXHRcdCAqIGlzIGZlZCBpbnRvIGFsbCBhZ2VudCBmdW5jdGlvbnMgdG8gcHJldmVudCBhbnkgb3RoZXJ3aXNlIGF2YWlsYWJsZVxuXHRcdCAqIHJlcXVpcmUoKSBmdW5jdGlvbiBmcm9tIGJlaW5nIGFjY2Vzc2VkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGhpamFja2VkUmVxdWlyZUZuID0gT2JqZWN0LmZyZWV6ZSgoc3BlY2lmaWVyOiBzdHJpbmcpID0+XG5cdFx0e1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcIlRoZSByZXF1aXJlKCkgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGNvbnRleHQuIFwiICtcblx0XHRcdFx0XCJNdWx0aS1maWxlIGFnZW50cyBzaG91bGQgYmUgYnVuZGxlZCB3aXRoIGEgYnVuZGxlciBcIiArIFxuXHRcdFx0XHRcInN1Y2ggYXMgUm9sbHVwSlMuXCIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbnVtYmVyIG9mIGxpbmVzIHRoYXQgYXJlIGludHJvZHVjZWQgYnkgdGhlIHNjcmlwdFxuXHRcdCAqIGVuZ2luZSB3aGVuIGEgY29kZSBibG9jayBpcyB3cmFwcGVkIGluIGEgbmV3IEZ1bmN0aW9uKClcblx0XHQgKiBibG9jaywgd2hpY2ggaXMgdGhlbiB0b1N0cmluZygpJ2QuIFRoaXMgaXMgdXNlZCBpbiBvcmRlciB0byBjYWxjdWxhdGVcblx0XHQgKiBzb3VyY2UgbWFwIGxpbmUgb2Zmc2V0cyAod2hpY2ggdmFyaWVzIGJ5IGVuZ2luZSkuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBzb3VyY2VNYXBMaW5lT2Zmc2V0ID0gKCgpID0+XG5cdFx0e1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cdFx0XHRjb25zdCB0ZXN0Rm4gPSBuZXcgRnVuY3Rpb24oXCJhXCIsIFwiYlwiLCBcImNcIiwgXCI7XCIpO1xuXHRcdFx0Y29uc3QgbGluZUNvdW50ID0gdGVzdEZuLnRvU3RyaW5nKCkuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuXHRcdFx0cmV0dXJuIGxpbmVDb3VudCAtIDI7IFxuXHRcdH0pKCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIHdob3NlIGtleXMgYXJlIGFnZW50IFVSSXMsIGFuZCB3aG9zZSB2YWx1ZXNcblx0XHQgKiBhcmUgYSBzZXQgb2YgU3RhdGVtZW50IGluc3RhbmNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgYWdlbnQsXG5cdFx0ICogb3IsIGluIHRoZSBjYXNlIHdoZW4gdGhlIGFnZW50IGlzIGFkZGVkIHRvIHRoZSBwcm9ncmFtXG5cdFx0ICogdGhyb3VnaCBhbm90aGVyIG1lYW5zIChzdWNoIGFzIHByb2dyYW1tYXRpY2FsbHkpLFxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBwcm9ncmFtIGlzIHN0b3JlZCBpbnN0ZWFkLlxuXHRcdCAqIFxuXHRcdCAqIFRlY2huaWNhbGx5IGFuIGFnZW50IHNob3VsZCBiZSBhdHRhY2hlZCBpbiBvbmx5IG9uZSBwbGFjZVxuXHRcdCAqIGluIHRoZSBwcm9ncmFtLCBob3dldmVyLCB0aGlzIG1heSBub3QgYWx3YXlzIGJlIHRoZSBjYXNlLFxuXHRcdCAqIGFuZCB0aGUgc3lzdGVtIG5lZWRzIHRvIGJlIGFibGUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW5cblx0XHQgKiBpdCBpc24ndC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGFycmF5IGlzIHVzZWQgdG8gcmVmZXJlbmNlIGNvdW50IC8gZ2FyYmFnZSBjb2xsZWN0XG5cdFx0ICogdGhlIGF0dGFjaGVkIGFnZW50cy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFNldDxTdGF0ZW1lbnQgfCBQcm9ncmFtPj4oKTtcblx0fVxuXG5cdGRlY2xhcmUgZnVuY3Rpb24gYXRvYihpbnB1dDogc3RyaW5nKTogc3RyaW5nO1xuXHRkZWNsYXJlIGZ1bmN0aW9uIGJ0b2EoaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcblxuXHQvKipcblx0ICogQSBzaW1wbGUgdHlwZSBkZWZpbml0aW9uIGZvciBhIFYzIHNvdXJjZSBtYXAgb2JqZWN0LlxuXHQgKi9cblx0aW50ZXJmYWNlIElTb3VyY2VNYXBcblx0e1xuXHRcdHZlcnNpb246IDM7XG5cdFx0ZmlsZT86IHN0cmluZztcblx0XHRzb3VyY2VSb290Pzogc3RyaW5nO1xuXHRcdHNvdXJjZXM/OiBzdHJpbmdbXTtcblx0XHRuYW1lcz86IHN0cmluZ1tdO1xuXHRcdG1hcHBpbmdzOiBzdHJpbmc7XG5cdFx0c291cmNlc0NvbnRlbnQ/OiBzdHJpbmdbXTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBDYXVzZXMgZGVmaW5lZCBib3RoIHdpdGhpblxuXHQgKiB0aGUgY29tcGlsZXIgY29yZSwgYW5kIGluIHVzZXIgY29kZS5cblx0ICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYXVzZTxSID0gdm9pZD5cblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIENhdXNlLCBpZiBhbnkuIEluIGEgY2F1c2UgY2FsbGJhY2sgZnVuY3Rpb24sXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSBleGlzdHMgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiByZXR1cm5lZFxuXHRcdCAqIGZyb20gb3RoZXIgY2F1c2UgYWlkcy5cblx0XHQgKi9cblx0XHRyZWFkb25seSByZXR1cm5zOiBSID0gbnVsbCE7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyB0aGUgKlJlc3VsdCogdHlwZSBwYXJhbWV0ZXIgb2YgYSBDYXVzZS5cblx0ICovXG5cdGV4cG9ydCB0eXBlIFRDYXVzZVJldHVybjxUPiA9IFQgZXh0ZW5kcyB7IHJldHVybnM6IGluZmVyIFIgfSA/IFIgOiBuZXZlcjtcblxuXG5cdC8qKlxuXHQgKiBNYXBzIGEgQ2F1c2UgdHlwZSBvdmVyIHRvIGl0J3MgY29ycmVzcG9uZGluZyBvYmplY3Rcblx0ICogdGhhdCBpcyBmZWQgaW50byBhbGwgY2F1c2UgY2FsbGJhY2sgZnVuY3Rpb25zLlxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgVENhdXNlRGF0YTxUPiA9IHtcblx0XHRbUCBpbiBrZXlvZiBUXTogUCBleHRlbmRzIFwicmV0dXJuc1wiID9cblx0XHRcdHJlYWRvbmx5IFRbUF1bXSA6IFxuXHRcdFx0VFtQXTtcblx0fTtcblxuXG5cdC8vIFxuXHQvLyBDYXVzZXNcblx0Ly8gXG5cblxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlQWdlbnRBdHRhY2ggZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgVVJJIGZyb20gd2hlcmUgdGhlIGFnZW50IHdhcyBsb2FkZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHVyaTogVXJpLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgc2NvcGUgb2Ygd2hlcmUgdGhlIGFnZW50XG5cdFx0XHQgKiBhcHBsaWVzLlxuXHRcdFx0ICogXG5cdFx0XHQgKiBJZiB0aGUgdmFsdWUgaXMgYGluc3RhbmNlb2YgUHJvZ3JhbWAsIHRoaXMgaW5kaWNhdGVzIHRoYXRcblx0XHRcdCAqIHRoZSBhZ2VudCdzIGNhdXNlcyBhcmUgc2NvcGVkIHRvIGEgcGFydGljdWxhciBwcm9ncmFtICh3aGljaFxuXHRcdFx0ICogaXMgZWZmZWN0aXZlbHkgXCJ1bnNjb3BlZFwiKS5cblx0XHRcdCAqIFxuXHRcdFx0ICogSWYgdGhlIHZhbHVlIGlzIGBpbnN0YW5jZW9mIERvY3VtZW50YCwgdGhpcyBpbmRpY2F0ZXMgdGhhdFxuXHRcdFx0ICogdGhlIGFnZW50J3MgY2F1c2VzIGFyZSBzY29wZWQgdG8gdGhlIGNhdXNlcyB0aGF0IGNhblxuXHRcdFx0ICogb3JpZ2luYXRlIGZyb20gYSBzaW5nbGUgZG9jdW1lbnQuXG5cdFx0XHQgKiBcblx0XHRcdCAqIChOb3QgaW1wbGVtZW50ZWQpLiBJZiB0aGUgdmFsdWUgaXMgYGluc3RhbmNlb2YgVHlwZWAsIHRoaXMgXG5cdFx0XHQgKiBpbmRpY2F0ZXMgdGhhdCB0aGUgYWdlbnQncyBjYXVzZXMgYXJlIHNjb3BlZCB0byB0aGUgY2F1c2VzXG5cdFx0XHQgKiB0aGF0IGNhbiBvcmlnaW5hdGUgZnJvbSBhIHNpbmdsZSB0eXBlLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzY29wZTogUHJvZ3JhbSB8IERvY3VtZW50IHwgVHlwZSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VBZ2VudERldGFjaCBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3RvcihyZWFkb25seSB1cmk6IFVyaSkgeyBzdXBlcigpOyB9XG5cdH1cblxuXHQvKiogQSBjYXVzZSB0aGF0IHJ1bnMgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBkb2N1bWVudCBoYXMgYmVlbiBjcmVhdGVkLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VEb2N1bWVudENyZWF0ZSBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3RvcihyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQpIHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGRvY3VtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgcHJvZ3JhbS4gKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlRG9jdW1lbnREZWxldGUgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50KSB7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiBBIGNhdXNlIHRoYXQgcnVucyB3aGVuIGEgZG9jdW1lbnQncyBmaWxlIG5hbWUgY2hhbmdlcy4gKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlRG9jdW1lbnRVcmlDaGFuZ2UgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXG5cdFx0XHRyZWFkb25seSBuZXdVcmk6IFVyaSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiBBYnN0cmFjdCBjYXVzZSBjbGFzcyBmb3IgdGhlIHJlc29sdXRpb24gY2F1c2VzICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYXVzZVJlc29sdmUgZXh0ZW5kcyBDYXVzZTxJUmVzb2x1dGlvblJldHVybj5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSxcblx0XHRcdHJlYWRvbmx5IHNwaW5lOiBTcGluZSlcblx0XHR7IHN1cGVyKCk7IH1cblx0fVxuXG5cdC8qKiBPdXRwdXQgZm9yIHJlc29sdXRpb24gaG9va3MgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJUmVzb2x1dGlvblJldHVyblxuXHR7XG5cdFx0cmVhZG9ubHkgcmVzb2x2ZXM6IGJvb2xlYW47XG5cdH1cblxuXHQvKiogQSBjYXVzZSB0aGF0IHJ1bnMgYmVmb3JlIHRoZSBjb21waWxlciBpcyBhYm91dCB0byByZXNvbHZlIGEgdGVybS4gKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlQmVmb3JlUmVzb2x2ZSBleHRlbmRzIENhdXNlUmVzb2x2ZSB7IH1cblxuXHQvKiogQSBjYXVzZSB0aGF0IHJ1bnMgYWZ0ZXIgdGhlIGNvbXBpbGVyIGhhcyByZXNvbHZlZCBhIHRlcm0uICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUFmdGVyUmVzb2x2ZSBleHRlbmRzIENhdXNlUmVzb2x2ZSB7IH1cblxuXHQvKiogQSBjYXVzZSB0aGF0IHJ1bnMgd2hlbiB0aGUgY29tcGlsZXIgaXMgdW5hYmxlIHRvIHJlc29sdmUgYSB0ZXJtLiAqL1xuXHRleHBvcnQgY2xhc3MgQ2F1c2VOb3RSZXNvbHZlZCBleHRlbmRzIENhdXNlUmVzb2x2ZSB7IH1cblxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlSW52YWxpZGF0ZSBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50IG9iamVjdCBpbiB3aGljaCB0aGUgSW52YWxpZGF0aW9uIG9jY3VyZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGRvY3VtZW50OiBEb2N1bWVudCxcblx0XHRcdC8qKlxuXHRcdFx0ICogQW4gYXJyYXkgb2Ygc3RhdGVtZW50cyB3aG9zZSBkZXNjZW5kYW50cyBzaG91bGQgYmUgaW52YWxpZGF0ZWQuXG5cdFx0XHQgKiBJZiB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZSBlbnRpcmUgZG9jdW1lbnQgc2hvdWxkIGJlIGludmFsaWRhdGVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBwYXJlbnRzOiByZWFkb25seSBTdGF0ZW1lbnRbXSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQW4gYXJyYXkgb2YgaW5kZXhlcyB3aG9zZSBsZW5ndGggaXMgdGhlIHNhbWUgYXMgdGhlIHBhcmVudHMgZmllbGQsXG5cdFx0XHQgKiB0aGF0IHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIGVhY2ggcGFyZW50IHdpdGhpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGluZGV4ZXM6IHJlYWRvbmx5IG51bWJlcltdKVxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0LyoqICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZVJldmFsaWRhdGUgZXh0ZW5kcyBDYXVzZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBEb2N1bWVudCBvYmplY3QgaW4gd2hpY2ggdGhlIFJldmFsaWRhdGlvbiB3aWxsIG9jY3VyLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGFycmF5IG9mIHN0YXRlbWVudHMgd2hvc2UgZGVzY2VuZGFudHMgc2hvdWxkIGJlIHJldmFsaWRhdGVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBwYXJlbnRzOiByZWFkb25seSBTdGF0ZW1lbnRbXSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQW4gYXJyYXkgb2YgaW5kZXhlcyB3aG9zZSBsZW5ndGggaXMgdGhlIHNhbWUgYXMgdGhlIHBhcmVudHMgZmllbGQsXG5cdFx0XHQgKiB0aGF0IHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIGVhY2ggcGFyZW50IHdpdGhpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGluZGV4ZXM6IHJlYWRvbmx5IG51bWJlcltdKVxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0LyoqIEEgY2F1c2UgdGhhdCBydW5zIHdoZW4gYSBkb2N1bWVudCBlZGl0IHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUVkaXRDb21wbGV0ZSBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3RvcihyZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQpIHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0LyoqICovXG5cdGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYXVzZVVyaVJlZmVyZW5jZSBleHRlbmRzIENhdXNlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIFN0YXRlbWVudCBpbnN0YW5jZSB0aGF0IHJlZmVyZW5jZXNcblx0XHRcdCAqIHRoaXMgVVJJLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gdGhlIHByb2dyYW0gaXRzZWxmXG5cdFx0XHQgKiByZWZlcmVuY2VzIHRoZSBVUkkgYnkgYW5vdGhlciBtZWFucy5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudWxsLFxuXHRcdFx0cmVhZG9ubHkgdXJpOiBVcmkpIFxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEEgaG9vayB0aGF0IHJ1bnMgd2hlbiBhIFVSSSByZWZlcmVuY2UgaXMgYWRkZWQgdG8gYSBkb2N1bWVudCwgXG5cdCAqIGJ1dCBiZWZvcmUgaXQgcmVzb2x2ZXMgdG8gYSByZXNvdXJjZS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZVVyaVJlZmVyZW5jZUFkZCBleHRlbmRzIENhdXNlVXJpUmVmZXJlbmNlIHsgfVxuXG5cdC8qKlxuXHQgKiBBIGhvb2sgdGhhdCBydW5zIHdoZW4gYSBVUkkgcmVmZXJlbmNlIGlzIHJlbW92ZWQgZnJvbSBhIGRvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIENhdXNlVXJpUmVmZXJlbmNlUmVtb3ZlIGV4dGVuZHMgQ2F1c2VVcmlSZWZlcmVuY2UgeyB9XG5cblx0LyoqXG5cdCAqIEEgaG9vayB0aGF0IHJ1bnMgd2hlbiB0aGUgc2V0IG9mIGZhdWx0cyB0aGF0IGFyZSBkZXRlY3RlZFxuXHQgKiB3aXRoaW4gdGhlIGRvY3VtZW50IGhhdmUgY2hhbmdlZC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDYXVzZUZhdWx0Q2hhbmdlIGV4dGVuZHMgQ2F1c2Vcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgZmF1bHRzQWRkZWQ6IEZhdWx0W10sXG5cdFx0XHRyZWFkb25seSBmYXVsdHNSZW1vdmVkOiBGYXVsdFtdKVxuXHRcdHsgc3VwZXIoKTsgfVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKiogQGludGVybmFsICovXG5cdGV4cG9ydCBjbGFzcyBFeGNlcHRpb25cblx0e1xuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBvYmplY3REaXJ0eSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0Q2Fubm90IGNhbGwgdGhpcyBtZXRob2Qgb3IgYWNjZXNzIHRoaXMgcHJvcGVydHksXG5cdFx0XHRcdGJlY2F1c2UgdGhlIGRvY3VtZW50IGhhcyBjaGFuZ2VkIHNpbmNlIGl0XG5cdFx0XHRcdHdhcyBjcmVhdGVkLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZEFyZ3VtZW50KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50LlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHBhc3NlZEFycmF5Q2Fubm90QmVFbXB0eShwYXJhbU5hbWU6IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJBcnJheSBjYW5ub3QgYmUgZW1wdHkgZm9yIHBhcmFtZXRlcjogXCIgKyBwYXJhbU5hbWUpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgdW5rbm93blN0YXRlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJBbiB1bmtub3duIHN0YXRlIGhhcyBiZWVuIHJlYWNoZWQgaW4gdGhlIHByb2dyYW0uXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZENhbGwoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIkNhbm5vdCBjYWxsIHRoaXMgbWV0aG9kIGdpdmVuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwcm9ncmFtLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG5vdEltcGxlbWVudGVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgYWdlbnROb3RSZWFkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRDYW5ub3QgaW5zdGFudGlhdGUgYW4gYWdlbnQgb2YgdGhpcyB0eXBlLFxuXHRcdFx0XHRhZGRlZC4gU2VlIGFnZW50cy5hZGQuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBhZ2VudE1pc3NpbmcocmF3VXJpOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBDb3VsZCBub3QgbG9hZCBhbiBhZ2VudCBmcm9tIHRoZSBVUkkgJHtyYXdVcml9YCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBhZ2VudEltcG9ydEVycm9yKGFnZW50VXJpOiBzdHJpbmcsIGVycm9yVGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgdHJ5aW5nIHRvIGV2YWx1YXRlIHRoZSBhZ2VudCBhdCBcIiR7YWdlbnRVcml9XCIuXG5cdFx0XHRcdFRoZSBlcnJvciBtZXNzYWdlIHJldHVybmVkIHdhczogJHtlcnJvclRleHR9YCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBhZ2VudEludmFsaWQocmF3VXJpOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0VGhlIGNvZGUgZmlsZSBhdCAke3Jhd1VyaX0gZG9lcyBub3QgZXhwb3J0IGEgZnVuY3Rpb24uIENvbnNpZGVyIGxvb2tpbmdcblx0XHRcdFx0YXQgdGhlIGRvY3VtZW50aW9uIGFuZCBleGFtcGxlcyBmb3IgdGhlIHByb3BlciB3YXkgdG8gc3R1Y3R1cmUgYW5cblx0XHRcdFx0YWdlbnQgY29kZSBmaWxlLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgbm9SZW1vdGVBZ2VudHMoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdEFnZW50cyBjYW5ub3QgYmUgbG9hZGVkIGZyb20gcmVtb3RlIFVSSXMgaW4gdGhpcyBjb250ZXh0LlxuXHRcdFx0XHQoTW9zdCBsaWtlbHksIHRoaXMgY29kZSBpcyBydW5uaW5nIGluIE5vZGUuanMgd2hlcmUgdGhlIGxvYWRpbmdcblx0XHRcdFx0b2YgcmVtb3RlIGNvZGUgaXMgYSBzZWN1cml0eSByaXNrKS5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGNhdXNlUGFyYW1ldGVyTmFtZUluVXNlKHBhcmFtTmFtZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdENhbm5vdCB1c2UgdGhlIG5hbWUgXCIke3BhcmFtTmFtZX1cIiBhcyBhIHBhcmFtZXRlclxuXHRcdFx0XHRuYW1lIGJlY2F1c2UgaXQncyBhbHJlYWR5IGluIHVzZS5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGRvdWJsZVRyYW5zYWN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJDYW5ub3Qgc3RhcnQgYSBuZXcgdHJhbnNhY3Rpb24gd2hpbGUgYW5vdGhlciBpcyBleGVjdXRpbmcuXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZFVyaVJldHJhY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIlVSSSBjb250YWlucyB0b28gZmV3IHBhdGggc2VnbWVudHMgdG8gcGVyZm9ybSB0aGlzIHJldHJhY3Rpb24uXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZFVyaShyYXdVcmk/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiSW52YWxpZCBVUklcIiArICh0eXBlb2YgcmF3VXJpID09PSBcInN0cmluZ1wiID8gXCI6IFwiICsgcmF3VXJpIDogXCJcIikpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgdXJpTm90U3VwcG9ydGVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJVUklzIG9mIHRoaXMgdHlwZSBhcmUgbm90IHN1cHBvcnRlZC5cIik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBjYW5ub3RNYWtlQWJzb2x1dGUoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdENhbm5vdCBtYWtlIHRoaXMgVVJJIGFic29sdXRlIGJlY2F1c2Ugbm8gXG5cdFx0XHRcdHByb2Nlc3Mgb3Igd2luZG93IG9iamVjdCBjb3VsZCBiZSBmb3VuZGApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgYWJzb2x1dGVVcmlFeHBlY3RlZCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBUaGlzIG1ldGhvZCBleHBlY3RzIGFuIGFic29sdXRlIFVSSSB0byBiZSBzcGVjaWZpZWQuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBtdXN0U3BlY2lmeVZpYSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBcblx0XHRcdFx0TXVzdCBzcGVjaWZ5IHRoZSBcInZpYVwiIGFyZ3VtZW50IGJlY2F1c2UgdGhlIHBhcnNlZCBVUkkgXG5cdFx0XHRcdHdhcyBmb3VuZCB0byBiZSByZWxhdGl2ZWApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgdmlhQ2Fubm90QmVSZWxhdGl2ZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKGBVUkkgaW5zdGFuY2VzIHNwZWNpZmllZCBpbiB0aGUgXCJ2aWFcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSByZWxhdGl2ZWApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZFR5cGVQYXRoKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRPbmUgb3IgbW9yZSBvZiB0aGUgdHlwZXMgaW4gdGhlIHNwZWNpZmllZCB0eXBlIHBhdGggYXJlIGludmFsaWQsXG5cdFx0XHRcdGJlY2F1c2UgdGhleSBjb250YWluIGVpdGhlciBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UsIG9yXG5cdFx0XHRcdGlzIGFuIGVtcHR5IHN0cmluZy5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGludmFsaWRFeHRlbnNpb24ocmVxdWlyZWRFeHRlbnNpb246IHN0cmluZylcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRUaGlzIG1ldGhvZCByZXF1aXJlcyBVUklzIHRoYXQgaGF2ZSB0aGUgXG5cdFx0XHRcdFwiLiR7cmVxdWlyZWRFeHRlbnNpb259XCIgZXh0ZW5zaW9uLmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZERvY3VtZW50UmVmZXJlbmNlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoYFxuXHRcdFx0XHRUaGlzIGRvY3VtZW50IGNhbm5vdCBiZSBhZGRlZCBhcyBhIGRlcGVuZGVuY3lcblx0XHRcdFx0b2YgdGhlIHRhcmdldCBkb2N1bWVudCBiZWNhdXNlIGl0J3Mgc3RvcmFnZSBsb2NhdGlvblxuXHRcdFx0XHQobWVtb3J5IG9yIGRpc2spIGRpZmZlcnMgZnJvbSB0aGUgdGhhdCBvZiB0aGUgdGFyZ2V0LmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgbm9uRW1wdHlEb2N1bWVudCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGVycm9yKFwiQ2Fubm90IGNhbGwgdGhpcyBtZXRob2Qgb24gYSBub24tZW1wdHkgZG9jdW1lbnQuXCIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgaW52YWxpZFdoaWxlSW5FZGl0VHJhbnNhY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcblx0XHRcdFx0YENhbm5vdCBjYWxsIHRoaXMgbWV0aG9kLCBvciBydW4gdGhpcyBob29rIHdoaWxlIGFuIGVkaXRcblx0XHRcdFx0dHJhbnNhY3Rpb24gaXMgdW5kZXJ3YXkuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyB1bmNhY2hhYmxlRG9jdW1lbnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdENhbm5vdCBjYWNoZSB0aGlzIGRvY3VtZW50IGJlY2F1c2UgaXQgd2FzIG5vdCBsb2FkZWQgZnJvbSBhIGZpbGUuYCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBkb2N1bWVudEFscmVhZHlMb2FkZWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdEEgZG9jdW1lbnQgd2l0aCB0aGlzIFVSSSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuXG5cdFx0XHRcdFVzZSBEb2N1bWVudC5mcm9tVXJpKCkgaW5zdGVhZC5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGRvY3VtZW50Tm90TG9hZGVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZXJyb3IoXCJUaGlzIGRvY3VtZW50IGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byB0aGUgY3VycmVudCBwcm9ncmFtLlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGNhbm5vdFJlZnJlc2goKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdFRoaXMgcmVzb3VyY2UgY2Fubm90IGJlIHJlbG9hZGVkIGJlY2F1c2UgaXQgb25seSBleGlzdHMgaW4gbWVtb3J5LmApO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzdGF0aWMgb2Zmc2V0UmVxdWlyZWQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihgXG5cdFx0XHRcdE9mZnNldCBhcmd1bWVudCBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSBhIHdoaXRlc3BhY2Utb25seVxuXHRcdFx0XHRzdGF0ZW1lbnQgd2FzIHBhc3NlZC5gKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHVuc3VwcG9ydGVkUGxhdGZvcm0oKVxuXHRcdHtcblx0XHRcdHJldHVybiBlcnJvcihcIlRoaXMgY29kZSBhcHBlYXJzIHRvIGJlIG9wZXJhdGluZyBpbiBhbiB1bnN1cHBvcnRlZCBwbGF0Zm9ybS5cIik7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgcHJvcGVyIGVycm9yIG9iamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKG1zZzogc3RyaW5nKVxuXHR7XG5cdFx0cmV0dXJuIG5ldyBFcnJvcihtc2cudHJpbSgpLnJlcGxhY2UoL1xcc1xccysvZywgXCIgXCIpKTtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFVuaXZlcnNhbCBjbGFzcyBmb3IgaGFuZGxpbmcgVVJJcyB0aGF0IGV4aXN0IHdpdGhpbiBhIFRydXRoIGRvY3VtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFVyaVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQ29uc3RydWN0cyBhIG5ldyBVcmkgaW5zdGFuY2UgdGhhdCBwb2ludHMgdG8gYSAocG9zc2libHkgbmVzdGVkKVxuXHRcdCAqIHR5cGUgZGVmaW5lZCBpbiB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBmcm9tKGRvY3VtZW50OiBEb2N1bWVudCwgLi4udHlwZXM6IHN0cmluZ1tdKVxuXHRcdHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5zb3VyY2VVcmkuZXh0ZW5kVHlwZSh0eXBlcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIHBhcnNlIHRoZSBzcGVjaWZpZWQgc3RyaW5nIG9yIFVyaSBpbnRvXG5cdFx0ICogYW5vdGhlciBVcmkgaW5zdGFuY2UuIElmIHRoZSBwYXJhbWV0ZXIgaXMgYWxyZWFkeVxuXHRcdCAqIGEgVXJpLCBpdCBpcyByZXR1cm5lZCB3aXRob3V0IGZ1cnRoZXIgcHJvY2Vzc2luZy5cblx0XHQgKi9cblx0XHRzdGF0aWMgbWF5YmVQYXJzZSh2YWx1ZTogc3RyaW5nIHwgVXJpKTogVXJpIHwgbnVsbFxuXHRcdHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVyaSlcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXZhbHVlKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMudHJ5UGFyc2UodmFsdWUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byBwYXJzZSB0aGUgc3BlY2lmaWVkIHN0cmluZyBpbnRvIGEgVXJpIGluc3RhbmNlLlxuXHRcdCAqIFJldHVybnMgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIHRoZSBVcmkgY291bGQgbm90IGJlIHBhcnNlZC5cblx0XHQgKi9cblx0XHRzdGF0aWMgdHJ5UGFyc2UodXJpOiBzdHJpbmcgfCBVcmksIHZpYT86IFVyaSB8IHN0cmluZyk6IFVyaSB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAoIXVyaSlcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHVyaUxpa2UgPSB0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0VXJpUGFyc2VyLnBhcnNlKHVyaSkgOlxuXHRcdFx0XHR1cmk7XG5cdFx0XHRcblx0XHRcdGlmICh1cmlMaWtlID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgb3V0VXJpID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghKHVyaUxpa2UuaXNSZWxhdGl2ZSAmJiB2aWEpKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXJpKHVyaUxpa2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgdmlhUGFyc2VkID0gdHlwZW9mIHZpYSA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0VXJpUGFyc2VyLnBhcnNlKHZpYSkgOlxuXHRcdFx0XHRcdHZpYTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh2aWFQYXJzZWQgPT09IG51bGwpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRVcmkoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh2aWFQYXJzZWQuaXNSZWxhdGl2ZSlcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udmlhQ2Fubm90QmVSZWxhdGl2ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgdXJpU3RvcmVzID0gTm90LnVuZGVmaW5lZCh1cmlMaWtlLnN0b3Jlcyk7XG5cdFx0XHRcdGNvbnN0IHZpYVN0b3JlcyA9IE5vdC51bmRlZmluZWQodmlhUGFyc2VkLnN0b3Jlcyk7XG5cdFx0XHRcdGNvbnN0IHJldHJhY3QgPSB1cmlMaWtlLnJldHJhY3Rpb25Db3VudCB8fCAwO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZpYVN0b3Jlcy5sZW5ndGggPCByZXRyYWN0KVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkVXJpKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IFVyaSh1cmlMaWtlLCB7XG5cdFx0XHRcdFx0cHJvdG9jb2w6IHZpYVBhcnNlZC5wcm90b2NvbCxcblx0XHRcdFx0XHRzdG9yZXM6IHJldHJhY3QgPiAwID9cblx0XHRcdFx0XHRcdHZpYVN0b3Jlcy5zbGljZSgwLCAtcmV0cmFjdCkuY29uY2F0KHVyaVN0b3JlcykgOlxuXHRcdFx0XHRcdFx0dmlhU3RvcmVzLmNvbmNhdCh1cmlTdG9yZXMpLFxuXHRcdFx0XHRcdHJldHJhY3Rpb25Db3VudDogLTEsXG5cdFx0XHRcdFx0aXNSZWxhdGl2ZTogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBSZXR1cm4gbnVsbCB3aGVuIGFuIGV4dGVuc2lvbiB3YXMgZm91bmQgdGhhdCBpc24ndFxuXHRcdFx0Ly8gdW5rbm93biAoYWxzbyB3aGVuIG5vIGV4dGVuc2lvbiB3YXMgZm91bmQpLiBUaGlzXG5cdFx0XHQvLyBpcyBpbiBvcmRlciB0byByZWR1Y2UgdGhlIG51bWJlciBvZiB0ZXJtcyB0aGF0IGhhdmVcblx0XHRcdC8vIGEgc3BlY2lhbCBtZWFuaW5nIGluIGEgdHJ1dGggZG9jdW1lbnQuXG5cdFx0XHRpZiAob3V0VXJpLmV4dCA9PT0gVXJpRXh0ZW5zaW9uLnVua25vd24pXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHQvLyBZb3UgY2FuJ3QgaGF2ZSBhIHR5cGUgcGF0aCB0aGF0IHBvaW50cyB0byBhIFxuXHRcdFx0Ly8gbm9uLXRydXRoIGZpbGUsIHNvIG51bGwgaXMgcmV0dXJuZWQgaW4gdGhpcyBjYXNlLlxuXHRcdFx0aWYgKG91dFVyaS50eXBlcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRpZiAob3V0VXJpLmV4dCAhPT0gVXJpRXh0ZW5zaW9uLnRydXRoKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0VXJpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb3BpZXMgdGhlIHNwZWNpZmllZCBVUkkgb3IgU3BpbmUgaW50byBhbm90aGVyIFVSSSBpbnN0YW5jZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgY2xvbmUodmFsdWU6IFNwaW5lIHwgVXJpKTogVXJpXG5cdFx0e1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgVXJpKVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNyY1VyaSA9IHZhbHVlLmRvY3VtZW50LnNvdXJjZVVyaTtcblx0XHRcdGNvbnN0IHR5cGVTZWdtZW50cyA9IHZhbHVlLnZlcnRlYnJhZS5tYXAodmVydCA9PlxuXHRcdFx0XHRuZXcgVXJpQ29tcG9uZW50KHZlcnQudG9TdHJpbmcodHJ1ZSkpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBVcmkoc3JjVXJpLCB7IHR5cGVzOiB0eXBlU2VnbWVudHMgfSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIENyZWF0ZXMgYW4gaW50ZXJuYWwgVVJJIHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYVxuXHRcdCAqIGRvY3VtZW50IHRoYXQgZXhpc3RzIG9ubHkgaW4gbWVtb3J5LlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBjcmVhdGVJbnRlcm5hbCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgbWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0XHRjb25zdCBleHQgPSBVcmlFeHRlbnNpb24udHJ1dGg7XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgVXJpKHtcblx0XHRcdFx0cHJvdG9jb2w6IFVyaVByb3RvY29sLmludGVybmFsLFxuXHRcdFx0XHRmaWxlOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpLnRvU3RyaW5nKDM2KSArIGV4dCxcblx0XHRcdFx0ZXh0XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBjb25zdHJ1Y3RvciguLi51cmlMaWtlOiBQYXJ0aWFsPFVyaT5bXSlcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHVyaVByb3BzIG9mIHVyaUxpa2UpXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24odGhpcywgdXJpUHJvcHMpO1xuXHRcdFx0XG5cdFx0XHRPYmplY3QuZnJlZXplKHRoaXMuc3RvcmVzKTtcblx0XHRcdE9iamVjdC5mcmVlemUodGhpcy50eXBlcyk7XG5cdFx0XHRPYmplY3QuZnJlZXplKHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBEZWJ1Z2dpbmcgdXRpbGl0eS4gRG8gbm90IHVzZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMudG9UeXBlU3RyaW5nKCk7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRyZWFkb25seSBwcm90b2NvbDogVXJpUHJvdG9jb2wgPSBVcmlQcm90b2NvbC5maWxlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSByZWZlcmVuY2VkIGluIHRoZSBVUkksIGluY2x1ZGluZyBhbnkgZXh0ZW5zaW9uLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGZpbGU6IHN0cmluZyA9IFwiXCI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBleHRlbnNpb24gb2YgdGhlIGZpbGUgcmVmZXJlbmNlZCBpbiB0aGUgVVJJLCBpZiBhbnkuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZXh0OiBVcmlFeHRlbnNpb24gPSBVcmlFeHRlbnNpb24udHJ1dGg7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBzdG9yZS1zaWRlIGNvbXBvbmVudHMgb2YgdGhpcyBVUkkuXG5cdFx0ICogRXhjbHVkZXMgdGhlIGZpbGUgbmFtZS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzdG9yZXM6IHJlYWRvbmx5IFVyaUNvbXBvbmVudFtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSB0eXBlLXNpZGUgY29tcG9uZW50cyBvZiB0aGlzIFVSSS5cblx0XHQgKi9cblx0XHRyZWFkb25seSB0eXBlczogcmVhZG9ubHkgVXJpQ29tcG9uZW50W10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIG51bWJlciBvZiByZXRyYWN0aW9ucyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoaXNcblx0XHQgKiBVUkksIGluIHRoZSBjYXNlIHdoZW4gdGhlIFVSSSBpcyByZWxhdGl2ZS5cblx0XHQgKi9cblx0XHRyZWFkb25seSByZXRyYWN0aW9uQ291bnQ6IG51bWJlciA9IDA7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhlIFVSSSBpcyBhIHJlbGF0aXZlIHBhdGguXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaXNSZWxhdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBuZXcgVXJpIHdob3NlIHBhdGggb2YgdHlwZXMgaXNcblx0XHQgKiByZXRyYWN0ZWQgYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbGV2ZWxzXG5cdFx0ICogb2YgZGVwdGguXG5cdFx0ICovXG5cdFx0cmV0cmFjdFR5cGUoZmFjdG9yOiBudW1iZXIpOiBVcmlcblx0XHR7XG5cdFx0XHRjb25zdCB0eXBlcyA9IHRoaXMudHlwZXMuc2xpY2UoMCwgLWZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gbmV3IFVyaSh0aGlzLCB7IHR5cGVzIH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFVyaSwgd2hvc2UgcGF0aCBvZiB0eXBlcyBpc1xuXHRcdCAqIHJldHJhY3RlZCB0byB0aGUgc3BlY2lmaWVkIGxldmVsIG9mIGRlcHRoLlxuXHRcdCAqL1xuXHRcdHJldHJhY3RUeXBlVG8oZGVwdGg6IG51bWJlcik6IFVyaVxuXHRcdHtcblx0XHRcdHJldHVybiBkZXB0aCA8IHRoaXMudHlwZXMubGVuZ3RoID9cblx0XHRcdFx0dGhpcy5yZXRyYWN0VHlwZSh0aGlzLnR5cGVzLmxlbmd0aCAtIGRlcHRoKSA6XG5cdFx0XHRcdHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBuZXcgVXJpIHdob3NlIHBhdGggb2Ygc3RvcmVzIGlzXG5cdFx0ICogcmV0cmFjdGVkIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGxldmVsc1xuXHRcdCAqIG9mIGRlcHRoLlxuXHRcdCAqL1xuXHRcdHJldHJhY3RTdG9yZShmYWN0b3I6IG51bWJlcik6IFVyaVxuXHRcdHtcblx0XHRcdGNvbnN0IGZvbGRlcnMgPSB0aGlzLnN0b3Jlcy5zbGljZSgwLCAtZmFjdG9yKTtcblx0XHRcdHJldHVybiBuZXcgVXJpKHRoaXMsIHsgc3RvcmVzOiBmb2xkZXJzIH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgbmV3IFVyaSwgd2hvc2UgcGF0aCBvZiBmb2xkZXJzIGlzXG5cdFx0ICogcmV0cmFjdGVkIHRvIHRoZSBzcGVjaWZpZWQgbGV2ZWwgb2YgZGVwdGguXG5cdFx0ICovXG5cdFx0cmV0cmFjdFN0b3JlVG8oZGVwdGg6IG51bWJlcik6IFVyaVxuXHRcdHtcblx0XHRcdHJldHVybiBkZXB0aCA8IHRoaXMuc3RvcmVzLmxlbmd0aCA/XG5cdFx0XHRcdHRoaXMucmV0cmFjdFR5cGUodGhpcy5zdG9yZXMubGVuZ3RoIC0gZGVwdGgpIDpcblx0XHRcdFx0dGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0ZXh0ZW5kVHlwZShhZGRpdGlvbmFsVHlwZU5hbWVzOiBzdHJpbmcgfCByZWFkb25seSBzdHJpbmdbXSk6IFVyaVxuXHRcdHtcblx0XHRcdGlmICghYWRkaXRpb25hbFR5cGVOYW1lcylcblx0XHRcdFx0cmV0dXJuIG5ldyBVcmkodGhpcyk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvbXBvbmVudHMgPSB0eXBlb2YgYWRkaXRpb25hbFR5cGVOYW1lcyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFtuZXcgVXJpQ29tcG9uZW50KGFkZGl0aW9uYWxUeXBlTmFtZXMpXSA6XG5cdFx0XHRcdGFkZGl0aW9uYWxUeXBlTmFtZXMubWFwKHQgPT4gbmV3IFVyaUNvbXBvbmVudCh0KSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgVXJpKHRoaXMsIHsgdHlwZXM6IHRoaXMudHlwZXMuY29uY2F0KGNvbXBvbmVudHMpIH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRleHRlbmRTdG9yZShhZGRpdGlvbmFsU3RvcmVzOiBzdHJpbmcgfCByZWFkb25seSBzdHJpbmdbXSk6IFVyaVxuXHRcdHtcblx0XHRcdGlmICghYWRkaXRpb25hbFN0b3Jlcylcblx0XHRcdFx0cmV0dXJuIG5ldyBVcmkodGhpcyk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0b3JlcyA9IHR5cGVvZiBhZGRpdGlvbmFsU3RvcmVzID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0W25ldyBVcmlDb21wb25lbnQoYWRkaXRpb25hbFN0b3JlcyldIDpcblx0XHRcdFx0YWRkaXRpb25hbFN0b3Jlcy5tYXAocyA9PiBuZXcgVXJpQ29tcG9uZW50KHMpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBVcmkodGhpcywgeyBzdG9yZXMgfSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoaXNcblx0XHQgKiBVcmkgaXMgc3RydWN0dXJhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIHNwZWNpZmllZCBVcmkuXG5cdFx0ICovXG5cdFx0ZXF1YWxzKG90aGVyOiBVcmksIGNvbXBhcmVUeXBlcz86IGJvb2xlYW4pOiBib29sZWFuXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMgPT09IG90aGVyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0aWYgKGNvbXBhcmVUeXBlcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMudHlwZXMubGVuZ3RoICE9PSBvdGhlci50eXBlcy5sZW5ndGgpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMudHlwZXMuc29tZSgodCwgaSkgPT4gdC52YWx1ZSAhPT0gb3RoZXIudHlwZXNbaV0udmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMucHJvdG9jb2wgIT09IG90aGVyLnByb3RvY29sKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnN0b3Jlcy5zb21lKChzLCBpKSA9PiBzLnZhbHVlICE9PSBvdGhlci5zdG9yZXNbaV0udmFsdWUpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHR0b0Fic29sdXRlKClcblx0XHR7XG5cdFx0XHRpZiAoIXRoaXMuaXNSZWxhdGl2ZSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHZpYTogc3RyaW5nIHwgbnVsbCA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0cnlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIilcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcHJvY2Vzcy5jd2QgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3MuY3dkKCkgfHwgbnVsbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHRcdFx0XHRcdGlmICh0eXBlb2Ygd2luZG93LmxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7IH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHZpYSA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmNhbm5vdE1ha2VBYnNvbHV0ZSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gVXJpLnRyeVBhcnNlKHRoaXMsIHZpYSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBwYXRoIG9mIHR5cGVzIGNvbnRhaW5lZCBieSB0aGlzIFVSSSwgXG5cdFx0ICogY29uY2F0ZW5hdGVkIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHRvVHlwZVN0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudHlwZXMubWFwKHQgPT4gdC50b1N0cmluZ0VuY29kZWQoKSlcblx0XHRcdFx0LmpvaW4oVXJpU3ludGF4LmNvbXBvbmVudFNlcGFyYXRvcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBwYXRoIG9mIHN0b3JlcyBjb250YWluZWQgYnkgdGhpcyBVUkksIFxuXHRcdCAqIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIHN0cmluZy5cblx0XHQgKi9cblx0XHR0b1N0b3JlU3RyaW5nKG9taXRGaWxlID0gZmFsc2UpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdGhpc0Fic29sdXRlID0gTm90Lm51bGwodGhpcy5pc1JlbGF0aXZlID8gdGhpcy50b0Fic29sdXRlKCkgOiB0aGlzKTtcblx0XHRcdFxuXHRcdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlbiB0aGUgc3BlY2lmaWVkIHByb3RvY29sIGlzIFwiZmlsZVwiLFxuXHRcdFx0Ly8gdGhlIHN0cmluZyBzaG91bGQgc3RhcnQgd2l0aCBhIC8gc28gdGhhdCB3ZSBnZXRcblx0XHRcdC8vIGFuZCBvdXRwdXQgdGhhdCBsb29rcyBsaWtlIC9Vc2Vycy9wZXJzb24vLi4uLlxuXHRcdFx0Y29uc3QgcHJvdG8gPSB0aGlzQWJzb2x1dGUucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmZpbGUgP1xuXHRcdFx0XHRcIi9cIiA6XG5cdFx0XHRcdHRoaXNBYnNvbHV0ZS5wcm90b2NvbCArIFwiLy9cIjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaXNXZWIgPSBcblx0XHRcdFx0dGhpc0Fic29sdXRlLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5odHRwIHx8IFxuXHRcdFx0XHR0aGlzQWJzb2x1dGUucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmh0dHBzO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb21wb25lbnRzID0gdGhpc0Fic29sdXRlLnN0b3Jlc1xuXHRcdFx0XHQuY29uY2F0KG9taXRGaWxlID8gW10gOiBbbmV3IFVyaUNvbXBvbmVudCh0aGlzLmZpbGUpXSlcblx0XHRcdFx0Lm1hcCgodCwgaSkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBpID09PSAwICYmIGlzV2ViID9cblx0XHRcdFx0XHRcdHQudG9TdHJpbmdIb3N0KCkgOlxuXHRcdFx0XHRcdFx0dC50b1N0cmluZ0VuY29kZWQoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmpvaW4oVXJpU3ludGF4LmNvbXBvbmVudFNlcGFyYXRvcik7XG5cdFx0XHRcblx0XHRcdHJldHVybiBwcm90byArIGNvbXBvbmVudHM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRsZXQgb3V0ID0gdGhpcy50b1N0b3JlU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnR5cGVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdG91dCArPSBVcmlTeW50YXgudHlwZVNlcGFyYXRvciArIHRoaXMudG9UeXBlU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXHR9XG5cblx0ZGVjbGFyZSBjb25zdCB3aW5kb3c6IGFueTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IGxpc3RzIGFsbCBhdmFpbGJsZSBwcm90b2NvbHNcblx0ICogc3VwcG9ydGVkIGJ5IHRoZSBzeXN0ZW0uIFRoZSBsaXN0IGNhbiBiZSBlbnVtZXJhdGVkXG5cdCAqIHZpYSBVcmkuZWFjaFByb3RvY29sKClcblx0ICovXG5cdGV4cG9ydCBlbnVtIFVyaVByb3RvY29sXG5cdHtcblx0XHRub25lID0gXCJcIixcblx0XHR1bmtub3duID0gXCI/XCIsXG5cdFx0ZmlsZSA9IFwiZmlsZTpcIixcblx0XHRodHRwcyA9IFwiaHR0cHM6XCIsXG5cdFx0aHR0cCA9IFwiaHR0cDpcIixcblx0XHRpbnRlcm5hbCA9IFwiaW50ZXJuYWw6XCJcblx0fVxuXG5cdGV4cG9ydCBuYW1lc3BhY2UgVXJpUHJvdG9jb2xcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgVXJpUHJvdG9jb2wgbWVtYmVyIGZyb20gdGhlIHNwZWNpZmllZCBzdHJpbmcuXG5cdFx0ICovXG5cdFx0ZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IFVyaVByb3RvY29sIHwgbnVsbFxuXHRcdHtcblx0XHRcdGNvbnN0IHZhbHMgPSA8c3RyaW5nW10+T2JqZWN0LnZhbHVlcyhVcmlQcm90b2NvbCk7XG5cdFx0XHRjb25zdCBpZHggPSB2YWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0cmV0dXJuIGlkeCA8IDAgPyBudWxsIDogPFVyaVByb3RvY29sPnZhbHNbaWR4XTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBVcmlQYXJzZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHN0YXRpYyBwYXJzZShyYXc6IHN0cmluZyk6IFBhcnRpYWw8VXJpPiB8IG51bGxcblx0XHR7XG5cdFx0XHRsZXQgaXNSZWxhdGl2ZSA9IGZhbHNlO1xuXHRcdFx0bGV0IHJldHJhY3Rpb25Db3VudCA9IDA7XG5cdFx0XHRsZXQgcHJvdG9jb2wgPSBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHJhdyk7XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZHMgLi9cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkQ3VycmVudCgpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoVXJpU3ludGF4LmN1cnJlbnQpKVxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChVcmlTeW50YXguY29tcG9uZW50U2VwYXJhdG9yKSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uID0gbWFyaztcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWRzIC4uLy4uLy4uL1xuXHRcdFx0ICogQHJldHVybnMgVHJ1ZSBpZiBhdCBsZWFzdCBvbmUgcmV0cmFjdGlvbiB3YXMgcmVhZCwgb3RoZXJ3aXNlIGZhbHNlLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZWFkUmV0cmFjdGlvbnMoKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB0b2tlbiA9IFVyaVN5bnRheC5yZXRyYWN0ICsgVXJpU3ludGF4LmNvbXBvbmVudFNlcGFyYXRvcjtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZCh0b2tlbikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXRyYWN0aW9uQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJldHJhY3Rpb25Db3VudCA+IDA7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZHMgcHJvdG86XG5cdFx0XHQgKiBBc3NpZ25zIHRoZSBsb2NhbCBwcm90b2NvbCB2YXJpYWJsZSBpZiBuZWNlc3NhcnkuXG5cdFx0XHQgKiBAcmV0dXJucyBUcnVzIGlmIGEgcHJvdG9jb2wgd2FzIGZvdW5kLCBvdGhlcndpc2UgZmFsc2UuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFByb3RvY29sKClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0bGV0IHJhd1Byb3RvID0gXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChVcmlTeW50YXgucHJvdG9jb2xSZWxhdGl2ZSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwcm90b2NvbCA9IFVyaVByb3RvY29sLnVua25vd247XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNhbmNlbCA9ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgY2hhciA9IHBhcnNlci5yZWFkR3JhcGhlbWUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaXNVcHBlckFzY2lpKGNoYXIpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJhd1Byb3RvICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhci5jaGFyQ29kZUF0KDApICsgMzIpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpc0xvd2VyQXNjaWkoY2hhcikpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmF3UHJvdG8gKz0gY2hhcjtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjaGFyID09PSBcIjpcIilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyYXdQcm90byArPSBcIjpcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gY2FuY2VsKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFByb3RvY29scyBuZWVkIHRvIGhhdmUgdGhlIC8vIHN1ZmZpeCBhZnRlciB0aGVtIC4uLiBmb3Igbm93LlxuXHRcdFx0XHRpZiAoIXBhcnNlci5yZWFkKFwiLy9cIikpXG5cdFx0XHRcdFx0cmV0dXJuIGNhbmNlbCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIChwcm90b2NvbCA9IHJhd1Byb3RvKSAhPT0gXCJcIjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWFkcyB0aGUgc3RvcmUgc2lkZSBvciB0aGUgdHlwZSBzaWRlIG9mIGEgVVJJLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZWFkQ29tcG9uZW50cyhzaWRlOiBcInN0b3JlXCIgfCBcInR5cGVcIilcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3Qgb3V0OiBVcmlDb21wb25lbnRbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY2FuY2VsID0gKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbiA9IG1hcms7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGNvbXAgPSByZWFkQ29tcG9uZW50KCk7XG5cdFx0XHRcdFx0aWYgKGNvbXAgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBVUklzIGNhbm5vdCBoYXZlIHR5cGUtc2lkZS1vbmx5IGNvbXBvbmVudHMgb24gdGhlaXIgc3RvcmUgc2lkZVxuXHRcdFx0XHRcdGlmIChzaWRlID09PSBcInN0b3JlXCIpXG5cdFx0XHRcdFx0XHRpZiAoY29tcC5pbmRleCA+PSAwIHx8IGNvbXAuaXNQYXR0ZXJuKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2FuY2VsKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3V0LnB1c2goY29tcCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNpZGUgPT09IFwic3RvcmVcIiAmJiBwYXJzZXIucmVhZChVcmlTeW50YXgudHlwZVNlcGFyYXRvcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoVXJpU3ludGF4LmNvbXBvbmVudFNlcGFyYXRvcikpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWFkcyBhIHNpbmdsZSBVUkkgY29tcG9uZW50LlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZWFkQ29tcG9uZW50KClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgZW5jQ2hhcnMgPSBcIi5fLX4lXCIuc3BsaXQoXCJcIik7XG5cdFx0XHRcdGNvbnN0IHBvcnRDaGFyID0gXCI6XCI7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IFwiXCI7XG5cdFx0XHRcdGxldCBwb3J0ID0gXCJcIjtcblx0XHRcdFx0bGV0IGlzUGFyc2luZ1BvcnQgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGFub25Db21wID0gbWF5YmVSZWFkQW5vbnltb3VzQ29tcG9uZW50KCk7XG5cdFx0XHRcdGlmIChhbm9uQ29tcClcblx0XHRcdFx0XHRyZXR1cm4gYW5vbkNvbXA7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBxdWl0ID0gKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbiA9IG1hcms7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChwYXJzZXIucGVlayhVcmlTeW50YXguY29tcG9uZW50U2VwYXJhdG9yKSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGcgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGcgPT09IHBvcnRDaGFyKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmICghaXNWYWxpZEhvc3ROYW1lKHZhbHVlKSB8fCAhaXNWYWxpZElQdjRBZGRyZXNzKHZhbHVlKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHF1aXQoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aXNQYXJzaW5nUG9ydCA9IHRydWU7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGlzUGFyc2luZ1BvcnQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKCFpc0RpZ2l0KGcpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcXVpdCgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRwb3J0ICs9IGc7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChwb3J0Lmxlbmd0aCA+IDUpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBxdWl0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCFlbmNDaGFycy5pbmNsdWRlcyhnKSAmJiAhaXNVcHBlckFzY2lpKGcpICYmICFpc0xvd2VyQXNjaWkoZykgJiYgIWlzRGlnaXQoZykpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmV0dXJuIHF1aXQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB2YWx1ZSArPSBnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodmFsdWUgPT09IFwiXCIpXG5cdFx0XHRcdFx0cmV0dXJuIHF1aXQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgVXJpQ29tcG9uZW50KHBvcnQgPyB2YWx1ZSArIHBvcnRDaGFyICsgcG9ydCA6IHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkQW5vbnltb3VzQ29tcG9uZW50KClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNhbmNlbCA9ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IGFub24gPSBwYXJzZXIucmVhZChVcmlTeW50YXguaW5kZXhlclN0YXJ0KTtcblx0XHRcdFx0aWYgKCFhbm9uKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChVcmlTeW50YXguaW5kZXhlckVuZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gYW5vbi5sZW5ndGggPiAwID9cblx0XHRcdFx0XHRcdFx0bmV3IFVyaUNvbXBvbmVudChhbm9uICsgVXJpU3ludGF4LmluZGV4ZXJFbmQpIDpcblx0XHRcdFx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZyA9IHBhcnNlci5yZWFkR3JhcGhlbWUoKTtcblx0XHRcdFx0XHRpZiAoIWlzRGlnaXQoZykpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGFub24gKz0gZztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGNhbmNlbCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobWF5YmVSZWFkQ3VycmVudCgpIHx8IHJlYWRSZXRyYWN0aW9ucygpKVxuXHRcdFx0e1xuXHRcdFx0XHRpc1JlbGF0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG1heWJlUmVhZFByb3RvY29sKCkpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIERvIG5vdGhpbmdcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHBhcnNlci5yZWFkKFVyaVN5bnRheC5jb21wb25lbnRTZXBhcmF0b3IpKVxuXHRcdFx0e1xuXHRcdFx0XHRwcm90b2NvbCA9IFVyaVByb3RvY29sLmZpbGU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdG9yZXMgPSByZWFkQ29tcG9uZW50cyhcInN0b3JlXCIpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3RvcmVzID09PSBudWxsIHx8IHN0b3Jlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHQvLyBVUkkgZW5kcyB3aXRoIGEgLywgdGhpcyBpc24ndCBhIHZhbGlkIFVSSVxuXHRcdFx0aWYgKHBhcnNlci5yZWFkVGhlblRlcm1pbmFsKFVyaVN5bnRheC5jb21wb25lbnRTZXBhcmF0b3IpKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gVVJJIGVuZHMgd2l0aCBhIC8vLCB0aGlzIGlzbid0IGEgdmFsaWQgVVJJXG5cdFx0XHRpZiAocGFyc2VyLnJlYWRUaGVuVGVybWluYWwoVXJpU3ludGF4LnR5cGVTZXBhcmF0b3IpKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdHlwZXMgPSByZWFkQ29tcG9uZW50cyhcInR5cGVcIik7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlcyA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlcy5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBXZSBzaG91bGQgYmUgZG9uZSBieSBub3cuIFxuXHRcdFx0XHQvLyBJZiB3ZSdyZSBub3QsIHRoZXJlJ3Mgc29tZSBnYXJiYWdlIGF0IHRoZSBcblx0XHRcdFx0Ly8gZW5kIG9mIHRoZSBVUkksIHN1Y2ggYXMgYSBmb3J3YXJkIHNsYXNoLlxuXHRcdFx0XHRpZiAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZmlsZSA9IHN0b3Jlc1tzdG9yZXMubGVuZ3RoIC0gMV0udmFsdWU7XG5cdFx0XHRjb25zdCBleHQgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGZpbGUuZW5kc1dpdGgoVXJpRXh0ZW5zaW9uLnRydXRoKSlcblx0XHRcdFx0XHRyZXR1cm4gVXJpRXh0ZW5zaW9uLnRydXRoO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGZpbGUuZW5kc1dpdGgoVXJpRXh0ZW5zaW9uLmpzKSlcblx0XHRcdFx0XHRyZXR1cm4gVXJpRXh0ZW5zaW9uLmpzO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGZpbGUuZW5kc1dpdGgoVXJpRXh0ZW5zaW9uLndhc20pKVxuXHRcdFx0XHRcdHJldHVybiBVcmlFeHRlbnNpb24ud2FzbTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBVcmlFeHRlbnNpb24udW5rbm93bjtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdC8vIElmIGFuIGV4dGVuc2lvbiB3YXMgZGV0ZWN0ZWQsIHRoZSBsYXN0IGNvbXBvbmVudFxuXHRcdFx0Ly8gZnJvbSB0aGUgZW5kIG9mIHRoZSBVUkkgc2hvdWxkIGJlIHJlbW92ZWQsIGJlY2F1c2Vcblx0XHRcdC8vIFwic3RvcmVzXCIgZG9lcyBub3QgaW5jbHVkZSBmaWxlIG5hbWVzLlxuXHRcdFx0aWYgKGV4dCAhPT0gVXJpRXh0ZW5zaW9uLnVua25vd24pXG5cdFx0XHRcdHN0b3Jlcy5wb3AoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cHJvdG9jb2w6IFVyaVByb3RvY29sLnJlc29sdmUocHJvdG9jb2wpIHx8IFVyaVByb3RvY29sLnVua25vd24sXG5cdFx0XHRcdGZpbGU6IGV4dCA/IGZpbGUgOiBcIlwiLFxuXHRcdFx0XHRleHQsXG5cdFx0XHRcdHJldHJhY3Rpb25Db3VudCxcblx0XHRcdFx0aXNSZWxhdGl2ZSxcblx0XHRcdFx0c3RvcmVzOiBPYmplY3QuZnJlZXplKHN0b3JlcyksXG5cdFx0XHRcdHR5cGVzOiBPYmplY3QuZnJlZXplKHR5cGVzKVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvKiogKi9cblx0ZnVuY3Rpb24gaXNVcHBlckFzY2lpKGNoYXI6IHN0cmluZylcblx0e1xuXHRcdGNvbnN0IHBvaW50ID0gY2hhci5jb2RlUG9pbnRBdCgwKSB8fCAwO1xuXHRcdHJldHVybiBwb2ludCA+PSA2NSAmJiBwb2ludCA8PSA5MDtcblx0fVxuXG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIGlzTG93ZXJBc2NpaShjaGFyOiBzdHJpbmcpXG5cdHtcblx0XHRjb25zdCBwb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCkgfHwgMDtcblx0XHRyZXR1cm4gcG9pbnQgPj0gOTcgJiYgcG9pbnQgPD0gMTIyO1xuXHR9XG5cblxuXHQvKiogKi9cblx0ZnVuY3Rpb24gaXNEaWdpdChjaGFyOiBzdHJpbmcpXG5cdHtcblx0XHRjb25zdCBwb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCkgfHwgMDtcblx0XHRyZXR1cm4gcG9pbnQgPj0gNDggJiYgcG9pbnQgPD0gNTc7XG5cdH1cblxuXHQvKiogKi9cblx0ZnVuY3Rpb24gaXNWYWxpZElQdjRBZGRyZXNzKG1heWJlSVA6IHN0cmluZylcblx0e1xuXHRcdGlmICghbWF5YmVJUClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRjb25zdCBpcFBhcnRzID0gbWF5YmVJUC5zcGxpdChcIi5cIikuZmlsdGVyKHMgPT4gcyk7XG5cdFx0XG5cdFx0aWYgKGlwUGFydHMubGVuZ3RoICE9PSA0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdGlmIChpcFBhcnRzLnNvbWUocyA9PiAhL15cXGR7MSwzfSQvLnRlc3QocykpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdGlmIChpcFBhcnRzLnNvbWUocyA9PiBwYXJzZUludChzLCAxMCkgPiAyNTUpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIGlzVmFsaWRIb3N0TmFtZShtYXliZUhvc3ROYW1lOiBzdHJpbmcpXG5cdHtcblx0XHRpZiAoIW1heWJlSG9zdE5hbWUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XG5cdFx0Y29uc3QgaG9zdFBhcnRzID0gbWF5YmVIb3N0TmFtZS5zcGxpdChcIi5cIik7XG5cdFx0aWYgKGhvc3RQYXJ0cy5zb21lKHMgPT4gcy5sZW5ndGggPT09IDApKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgaG9zdFBhcnQgb2YgaG9zdFBhcnRzKVxuXHRcdHtcblx0XHRcdC8vIE5PVEU6IFRoaXMgaXMgYSBtYWtlLXNoaWZ0IGhvc3QgbmFtZSB2YWxpZGF0aW9uXG5cdFx0XHQvLyBtZXRob2QuIEl0IHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHNvbWV0aGluZ1xuXHRcdFx0Ly8gdGhhdCBjb25mb3JtcyB0byB0aGUgcmVsZXZhbnQgUkZDIHNwZWNpZmljYXRpb25zLlxuXHRcdFx0Y29uc3QgaG9zdFNlZ21lbnRQYXJ0cyA9IGhvc3RQYXJ0LnNwbGl0KC8tfC0tLyk7XG5cdFx0XHRmb3IgKGNvbnN0IGhvc3RTZWdtZW50UGFydCBvZiBob3N0U2VnbWVudFBhcnRzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoaG9zdFNlZ21lbnRQYXJ0Lmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGNwIG9mIFsuLi5ob3N0U2VnbWVudFBhcnRdLm1hcChzID0+IHMuY29kZVBvaW50QXQoMCkpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCFjcCB8fCAhKFxuXHRcdFx0XHRcdFx0Y3AgPj0gNDggJiYgY3AgPD0gNTcgfHxcblx0XHRcdFx0XHRcdGNwID49IDY1ICYmIGNwIDw9IDkwIHx8XG5cdFx0XHRcdFx0XHRjcCA+PSA5NyAmJiBjcCA8PSAxMjIgfHxcblx0XHRcdFx0XHRcdGNwID49IDEyOCAmJiBjcCA8PSAxNjUgfHxcblx0XHRcdFx0XHRcdGNwID49IDI1NSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdGNvbnN0IGhhc2hSZWdleCA9IG5ldyBSZWdFeHAoXCJbYS1mMC05XXtcIiArIEhhc2gubGVuZ3RoICsgXCJ9XCIsIFwiaVwiKTtcblxuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzaW5nbGUgY29tcG9uZW50IG9mIGEgVXJpLlxuXHQgKiBIYW5kbGVkIGVuY29kaW5nIGFuZCBkZWNvZGluZyBvZiB0aGUgdW5kZXJseWluZyB2YWx1ZS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBVcmlDb21wb25lbnRcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHJhdzogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHRoaXMuaXNSZXRyYWN0ID0gcmF3ID09PSBcIi4uXCI7XG5cdFx0XHR0aGlzLmlzQ3VycmVudCA9IHJhdyA9PT0gXCIuXCI7XG5cdFx0XHR0aGlzLmhhc2ggPSB0aGlzLnRyeUV4dHJhY3RIYXNoKHJhdyk7XG5cdFx0XHRcblx0XHRcdGlmIChyYXcubGVuZ3RoID4gMilcblx0XHRcdFx0aWYgKHJhd1swXSA9PT0gVXJpU3ludGF4LmluZGV4ZXJTdGFydClcblx0XHRcdFx0XHRpZiAocmF3W3Jhdy5sZW5ndGggLSAxXSA9PT0gVXJpU3ludGF4LmluZGV4ZXJFbmQpXG5cdFx0XHRcdFx0XHRpZiAoL1xcZCsvLnRlc3QocmF3LnNsaWNlKDEsIC0xKSkpXG5cdFx0XHRcdFx0XHRcdHRoaXMuaW5kZXggPSArcmF3LnNsaWNlKDEsIC0xKTtcblx0XHRcdFxuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuaW5kZXggPj0gMCA/XG5cdFx0XHRcdHRoaXMuaW5kZXgudG9TdHJpbmcoKSA6XG5cdFx0XHRcdHVuZXNjYXBlKHJhdyk7XG5cdFx0XHRcblx0XHRcdE9iamVjdC5mcmVlemUodGhpcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgdHJ5RXh0cmFjdEhhc2godGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlbGltID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbjtcblx0XHRcdGNvbnN0IGRlbGltRXNjID0gZXNjYXBlKGRlbGltKTtcblx0XHRcdGNvbnN0IGRlbGltTGVuID1cblx0XHRcdFx0dGV4dC5zdGFydHNXaXRoKGRlbGltKSA/IGRlbGltLmxlbmd0aCA6XG5cdFx0XHRcdHRleHQuc3RhcnRzV2l0aChkZWxpbUVzYykgPyBkZWxpbUVzYy5sZW5ndGggOlxuXHRcdFx0XHQtMTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaGFzaExlbiA9IEhhc2gubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGVsaW1MZW4gPCAwIHx8IHRleHQubGVuZ3RoIDwgZGVsaW1MZW4gKyBoYXNoTGVuICsgMSlcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGhhc2ggPSB0ZXh0LnN1YnN0cihkZWxpbUxlbiwgaGFzaExlbik7XG5cdFx0XHRpZiAoaGFzaC5sZW5ndGggIT09IGhhc2hMZW4gfHwgIWhhc2hSZWdleC50ZXN0KGhhc2gpKVxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgd2hldGhlciB0aGlzIGNvbXBvbmVudCByZXByZXNlbnRzIGEgcGF0dGVybi4gKi9cblx0XHRnZXQgaXNQYXR0ZXJuKCkgeyByZXR1cm4gdGhpcy5oYXNoICE9PSBcIlwiOyB9XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyB3aGV0aGVyIHRoaXMgY29tcG9uZW50IGlzIHRoZSByZXRyYWN0aW9uIGluZGljYXRvciAoLi4pICovXG5cdFx0cmVhZG9ubHkgaXNSZXRyYWN0OiBib29sZWFuO1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgd2hldGhlciB0aGlzIGNvbXBvbmVudCBpcyB0aGUgY3VycmVudCBpbmRpY2F0b3IgKC4pICovXG5cdFx0cmVhZG9ubHkgaXNDdXJyZW50OiBib29sZWFuO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG51bWJlciB0aGF0IGluZGljYXRlcyBhIHR5cGUgaW5kZXggdGhhdCB0aGlzIFVyaUNvbXBvbmVudCwgXG5cdFx0ICogcmVmZXJzIHRvLCB1c2VkIGluIHRoZSBjYXNlIHdoZW4gdGhpcyBVcmlDb21wb25lbnQgaXMgcmVmZXJyaW5nIHRvXG5cdFx0ICogYW4gYW5vbnltb3VzIHR5cGUuXG5cdFx0ICogXG5cdFx0ICogU3RvcmVzIC0xIGluIHRoZSBjYXNlIHdoZW4gYW4gaW5kZXggdmFsdWUgaXMgbm90IHJlbGV2YW50IHRvIHRoaXNcblx0XHQgKiBVcmlDb21wb25lbnQgaW5zdGFuY2UuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaW5kZXg6IG51bWJlciA9IC0xO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgZGVjb2RlZCB0ZXh0IHZhbHVlIG9mIHRoaXMgVXJpQ29tcG9uZW50LlxuXHRcdCAqIFN0b3JlcyBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSAuaW5kZXggcHJvcGVydHkgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdCAqIGl0IGlzIGdyZWF0ZXIgdGhhbiAtMS5cblx0XHQgKiBUaGlzIGhhcyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgcmVzdWx0IG9mIHRoZSAudG9TdHJpbmcoKSBtZXRob2QuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdmFsdWU6IHN0cmluZyA9IFwiXCI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcGF0dGVybiBoYXNoLCBpbiB0aGUgY2FzZSB3aGVuIHRoaXMgVXJpQ29tcG9uZW50XG5cdFx0ICogcmVsYXRlcyB0byBhIHBhdHRlcm4uIFN0b3JlcyBhbiBlbXB0eSBzdHJpbmcgaW4gb3RoZXIgY2FzZXMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBoYXNoOiBzdHJpbmcgPSBcIlwiO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSByYXcgZGVjb2RlZCB0ZXh0IHZhbHVlIG9mIHRoaXMgVXJpQ29tcG9uZW50LlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIFVSTCBlbmNvZGVkIHRleHQgdmFsdWUgb2YgdGhpcyBVcmlDb21wb25lbnQuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmdFbmNvZGVkKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pc1BhdHRlcm4pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGRlID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbjtcblx0XHRcdFx0cmV0dXJuIGRlICsgZXNjYXBlKHRoaXMudmFsdWUuc2xpY2UoZGUubGVuZ3RoKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmluZGV4ID49IDApXG5cdFx0XHRcdHJldHVybiBVcmlTeW50YXguaW5kZXhlclN0YXJ0ICsgdGhpcy5pbmRleCArIFVyaVN5bnRheC5pbmRleGVyRW5kO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZXNjYXBlKHRoaXMudmFsdWUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgdGV4dCB2YWx1ZSBvZiB0aGlzIFVyaUNvbXBvbmVudCwgdXNpbmcgYW5cblx0XHQgKiBlbmNvZGluZyB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBhbiBSRkMgMzk4NiBob3N0IG5hbWUuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmdIb3N0KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IFVSTChcImh0dHA6Ly9cIiArIHRoaXMudmFsdWUpLmhvc3Q7XG5cdFx0fVxuXHR9XG5cblx0ZGVjbGFyZSBjb25zdCBVUkw6IHR5cGVvZiBpbXBvcnQoXCJ1cmxcIikuVVJMO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqICovXG5cdGV4cG9ydCBjb25zdCBVcmlSZWFkZXIgPSBuZXcgY2xhc3MgVXJpUmVhZGVyXG5cdHtcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byByZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gVVJJLlxuXHRcdCAqIElmIGFuIGVycm9yIGlzIGdlbmVyYXRlZCB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhIGZpbGUgXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiwgdGhlIGVycm9ycyBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRhc3luYyB0cnlSZWFkKHVyaTogVXJpKVxuXHRcdHtcblx0XHRcdGlmICh1cmkucHJvdG9jb2wgPT09IFVyaVByb3RvY29sLmZpbGUpXG5cdFx0XHRcdHJldHVybiBhd2FpdCByZWFkRmlsZSh1cmkudG9TdG9yZVN0cmluZygpKTtcblx0XHRcdFxuXHRcdFx0ZWxzZSBpZiAodXJpLnByb3RvY29sID09PSBVcmlQcm90b2NvbC5odHRwIHx8XG5cdFx0XHRcdHVyaS5wcm90b2NvbCA9PT0gVXJpUHJvdG9jb2wuaHR0cHMpXG5cdFx0XHRcdHJldHVybiBhd2FpdCBGZXRjaC5leGVjKHVyaS50b1N0b3JlU3RyaW5nKCkpO1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHR9XG5cdH0oKTtcblxuXG5cdC8qKiAqL1xuXHRjb25zdCBmaWxlRXhpc3RzID0gKHBhdGg6IHN0cmluZykgPT5cblx0XHRuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSwgcmVqZWN0KSA9PlxuXHRcdHtcblx0XHRcdEZzLm1vZHVsZS5leGlzdHMocGF0aCwgcmVzb2x2ZSk7XG5cdFx0fSk7XG5cblxuXHQvKiogKi9cblx0Y29uc3QgcmVhZEZpbGUgPSAocGF0aDogc3RyaW5nLCBvcHRzID0gXCJ1dGY4XCIpID0+XG5cdFx0bmV3IFByb21pc2U8c3RyaW5nIHwgRXJyb3I+KHJlc29sdmUgPT5cblx0XHR7XG5cdFx0XHRGcy5tb2R1bGUucmVhZEZpbGUocGF0aCwgb3B0cywgKGVycm9yLCBkYXRhKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXNvbHZlKGVycm9yICYmIGVycm9yLmVycm5vID9cblx0XHRcdFx0XHRlcnJvciA6XG5cdFx0XHRcdFx0ZGF0YSB8fCBcIlwiKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cblx0LyoqICovXG5cdGNvbnN0IHdyaXRlRmlsZSA9IChwYXRoOiBzdHJpbmcsIGRhdGE6IHN0cmluZywgb3B0cyA9IFwidXRmOFwiKSA9PlxuXHRcdG5ldyBQcm9taXNlPG51bGwgfCBFcnJvcj4ocmVzb2x2ZSA9PlxuXHRcdHtcblx0XHRcdEZzLm1vZHVsZS53cml0ZUZpbGUocGF0aCwgZGF0YSwgb3B0cywgZXJyb3IgPT5cblx0XHRcdHtcblx0XHRcdFx0cmVzb2x2ZShlcnJvciB8fCBudWxsKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIGxhbmd1YWdlIHN5bnRheCB0b2tlbnMuXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgZW51bSBTeW50YXhcblx0e1xuXHRcdHRhYiA9IFwiXFx0XCIsXG5cdFx0c3BhY2UgPSBcIiBcIixcblx0XHR0ZXJtaW5hbCA9IFwiXFxuXCIsXG5cdFx0Y29tYmluYXRvciA9IFwiLFwiLFxuXHRcdGpvaW50ID0gXCI6XCIsXG5cdFx0bGlzdCA9IFwiLi4uXCIsXG5cdFx0ZXNjYXBlQ2hhciA9IFwiXFxcXFwiLFxuXHRcdGNvbW1lbnQgPSBcIi8vXCJcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gVXJpU3ludGF4XG5cdHtcblx0XHRyZXRyYWN0ID0gXCIuLlwiLFxuXHRcdGN1cnJlbnQgPSBcIi5cIixcblx0XHRjb21wb25lbnRTZXBhcmF0b3IgPSBcIi9cIixcblx0XHR0eXBlU2VwYXJhdG9yID0gXCIvL1wiLFxuXHRcdHByb3RvY29sUmVsYXRpdmUgPSBcIi8vXCIsXG5cdFx0aW5kZXhlclN0YXJ0ID0gXCJbXCIsXG5cdFx0aW5kZXhlckVuZCA9IFwiXVwiLFxuXHR9XG5cblxuXHQvKipcblx0ICogQSBjb25zdGFudCBlbnVtZXJhdGlvbnMgdGhhdCBzdG9yZXMgdGhlIHZhbGlkIGV4dGVuc2lvbnNcblx0ICogdGhhdCBtdXN0IGJlIHByZXNlbnQgaW4gYSBwYXJzYWJsZSBVUkkuXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgZW51bSBVcmlFeHRlbnNpb25cblx0e1xuXHRcdHVua25vd24gPSBcIlwiLFxuXHRcdHRydXRoID0gXCIudHJ1dGhcIixcblx0XHRqcyA9IFwiLnRydXRoLmpzXCIsXG5cdFx0d2FzbSA9IFwiLnRydXRoLndhc21cIlxuXHR9XG5cblxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBzdG9yZXMgdGhlIGVzY2FwZSBzZXF1ZW5jZXNcblx0ICogdGhhdCBvbmx5IG1hdGNoIGEgc2luZ2xlIGtpbmQgb2YgY2hhcmFjdGVyLiBcIlNpZ25cIiBpblxuXHQgKiB0aGlzIGNhc2UgcmVmZXJzIHRvIHRoZSBmYWN0IHRoYXQgdGhlc2UgYXJlIGVzY2FwZVxuXHQgKiBzZXF1ZW5jZXMgdGhhdCByZWZlciB0byBhbm90aGVyIGNoYXJhY3Rlci5cblx0ICovXG5cdGV4cG9ydCBlbnVtIFJlZ2V4U3ludGF4U2lnblxuXHR7XG5cdFx0dGFiID0gXCJcXFxcdFwiLFxuXHRcdGxpbmVGZWVkID0gXCJcXFxcblwiLFxuXHRcdGNhcnJpYWdlUmV0dXJuID0gXCJcXFxcclwiLFxuXHRcdGVzY2FwZWRGaW5hbGl6ZXIgPSBcIlxcXFwvXCIsXG5cdFx0YmFja3NsYXNoID0gXCJcXFxcXFxcXFwiXG5cdH1cblxuXHRleHBvcnQgbmFtZXNwYWNlIFJlZ2V4U3ludGF4U2lnblxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBSZWdleFN5bnRheFNpZ24gbWVtYmVyIGZyb20gdGhlXG5cdFx0ICogc3BlY2lmaWVkIHNpZ24gbGl0ZXJhbCAoZXg6IFwiXFx0XCIpIG9yIHJhdyBzaWduYWJsZVxuXHRcdCAqIGNoYXJhY3RlciAoZXg6IFwiXHRcIikuXG5cdFx0ICovXG5cdFx0ZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IFJlZ2V4U3ludGF4U2lnbiB8IG51bGxcblx0XHR7XG5cdFx0XHRpZiAodmFsdWUubGVuZ3RoIDwgMSB8fCB2YWx1ZS5sZW5ndGggPiAyKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdmFscyA9IDxzdHJpbmdbXT5PYmplY3QudmFsdWVzKFJlZ2V4U3ludGF4U2lnbik7XG5cdFx0XHRjb25zdCBpZHggPSB2YWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0cmV0dXJuIGlkeCA8IDAgPyBudWxsIDogPFJlZ2V4U3ludGF4U2lnbj52YWxzW2lkeF07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZSh2YWx1ZTogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHN3aXRjaCAodmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLnRhYjogcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KDkpO1xuXHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4U2lnbi5saW5lRmVlZDogcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KDEwKTtcblx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheFNpZ24uY2FycmlhZ2VSZXR1cm46IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCgxMyk7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLmVzY2FwZWRGaW5hbGl6ZXI6IHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCg0Nyk7XG5cdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhTaWduLmJhY2tzbGFzaDogcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KDkyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBzdG9yZXMgdGhlIGVzY2FwZSBzZXF1ZW5jZXNcblx0ICogdGhhdCBjYW4gbWF0Y2ggbW9yZSB0aGFuIG9uZSBraW5kIG9mIGNoYXJhY3Rlci5cblx0ICovXG5cdGV4cG9ydCBlbnVtIFJlZ2V4U3ludGF4S25vd25TZXRcblx0e1xuXHRcdGRpZ2l0ID0gXCJcXFxcZFwiLFxuXHRcdGRpZ2l0Tm9uID0gXCJcXFxcRFwiLFxuXHRcdGFscGhhbnVtZXJpYyA9IFwiXFxcXHdcIixcblx0XHRhbHBoYW51bWVyaWNOb24gPSBcIlxcXFxXXCIsXG5cdFx0d2hpdGVzcGFjZSA9IFwiXFxcXHNcIixcblx0XHR3aGl0ZXNwYWNlTm9uID0gXCJcXFxcU1wiLFxuXHRcdHdpbGQgPSBcIi5cIixcblx0fVxuXG5cdGV4cG9ydCBuYW1lc3BhY2UgUmVnZXhTeW50YXhLbm93blNldFxuXHR7XG5cdFx0Y29uc3QgdmFscyA9IDxzdHJpbmdbXT5PYmplY3QudmFsdWVzKFJlZ2V4U3ludGF4S25vd25TZXQpO1xuXHRcdFxuXHRcdGV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKHZhbHVlOiBzdHJpbmcpOiBSZWdleFN5bnRheEtub3duU2V0IHwgbnVsbFxuXHRcdHtcblx0XHRcdGNvbnN0IGlkeCA9IHZhbHMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gaWR4IDwgMCA/IG51bGwgOiA8UmVnZXhTeW50YXhLbm93blNldD52YWxzW2lkeF07XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBzdG9yZXMgdGhlIGRlbGltaXRlcnMgYXZhaWxhYmxlXG5cdCAqIGluIHRoZSBzeXN0ZW0ncyByZWd1bGFyIGV4cHJlc3Npb24gZmxhdm9yLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gUmVnZXhTeW50YXhEZWxpbWl0ZXJcblx0e1xuXHRcdG1haW4gPSBcIi9cIixcblx0XHR1dGYxNkdyb3VwU3RhcnQgPSBcIlxcXFx1e1wiLFxuXHRcdHV0ZjE2R3JvdXBFbmQgPSBcIn1cIixcblx0XHRncm91cFN0YXJ0ID0gXCIoXCIsXG5cdFx0Z3JvdXBFbmQgPSBcIilcIixcblx0XHRhbHRlcm5hdG9yID0gXCJ8XCIsXG5cdFx0c2V0U3RhcnQgPSBcIltcIixcblx0XHRzZXRFbmQgPSBcIl1cIixcblx0XHRxdWFudGlmaWVyU3RhcnQgPSBcIntcIixcblx0XHRxdWFudGlmaWVyRW5kID0gXCJ9XCIsXG5cdFx0cXVhbnRpZmllclNlcGFyYXRvciA9IFwiLFwiLFxuXHRcdHJhbmdlID0gXCItXCIsXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBbiBlbnVtZXJhdGlvbiB0aGF0IHN0b3JlcyBtaXNjZWxsYW5lb3VzIHJlZ3VsYXJcblx0ICogZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCBkb24ndCBmaXQgaW50b1xuXHQgKiB0aGUgb3RoZXIgZW51bWVyYXRpb25zLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gUmVnZXhTeW50YXhNaXNjXG5cdHtcblx0XHRzdGFyID0gXCIqXCIsXG5cdFx0cGx1cyA9IFwiK1wiLFxuXHRcdG5lZ2F0ZSA9IFwiXlwiLFxuXHRcdHJlc3RyYWluZWQgPSBcIj9cIixcblx0XHRib3VuZGFyeSA9IFwiXFxcXGJcIixcblx0XHRib3VuZGFyeU5vbiA9IFwiXFxcXEJcIixcblx0fVxuXG5cblx0LyoqXG5cdCAqIEFuIGVudW1lcmF0aW9uIHRoYXQgc3RvcmVzIHRoZSBkZWxpbWl0ZXJzIGF2YWlsYWJsZVxuXHQgKiBpbiB0aGUgaW5maXggc3ludGF4LlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gSW5maXhTeW50YXhcblx0e1xuXHRcdHN0YXJ0ID0gXCI8XCIsXG5cdFx0ZW5kID0gXCI+XCIsXG5cdFx0bm9taW5hbFN0YXJ0ID0gXCI8PFwiLFxuXHRcdG5vbWluYWxFbmQgPSBcIj4+XCIsXG5cdFx0cGF0dGVyblN0YXJ0ID0gXCI8L1wiLFxuXHRcdHBhdHRlcm5FbmQgPSBcIi8+XCJcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCBtYW5hZ2VzIHRoZSBkaWFnbm9zdGljcyB0aGF0IGhhdmUgYmVlbiBcblx0ICogcmVwb3J0ZWQgZm9yIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwcm9ncmFtLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEZhdWx0U2VydmljZVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtKVxuXHRcdHtcblx0XHRcdC8vIExpc3RlbiBmb3IgaW52YWxpZGF0aW9ucyBhbmQgY2xlYXIgb3V0IGFueSBmYXVsdHNcblx0XHRcdC8vIHRoYXQgY29ycmVzcG9uZCB0byBvYmplY3RzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gdGhlXG5cdFx0XHQvLyBkb2N1bWVudCBhbnltb3JlLiBcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZUludmFsaWRhdGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGRhdGEucGFyZW50cy5sZW5ndGggPiAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgZGF0YS5wYXJlbnRzKVxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCB7IHN0YXRlbWVudCB9IG9mIHNtdC5kb2N1bWVudC5lYWNoRGVzY2VuZGFudChzbXQsIHRydWUpKVxuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbW92ZVN0YXRlbWVudEZhdWx0cyhzdGF0ZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgZm9yIChjb25zdCB7IHN0YXRlbWVudCB9IG9mIGRhdGEuZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQoKSlcblx0XHRcdFx0XHR0aGlzLnJlbW92ZVN0YXRlbWVudEZhdWx0cyhzdGF0ZW1lbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5pbkVkaXRUcmFuc2FjdGlvbiA9IHRydWU7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZUVkaXRDb21wbGV0ZSwgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5pbkVkaXRUcmFuc2FjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGluRWRpdFRyYW5zYWN0aW9uID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhbGwgZmF1bHRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlbW92ZVN0YXRlbWVudEZhdWx0cyhzdGF0ZW1lbnQ6IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLnJlbW92ZVNvdXJjZShzdGF0ZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2Ygc3RhdGVtZW50LmFsbFNwYW5zKVxuXHRcdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLnJlbW92ZVNvdXJjZShzcGFuKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2Ygc3RhdGVtZW50LmluZml4U3BhbnMpXG5cdFx0XHRcdHRoaXMuYnVmZmVyRnJhbWUucmVtb3ZlU291cmNlKGluZml4U3Bhbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVudW1lcmF0ZXMgdGhyb3VnaCB0aGUgdW5yZWN0aWZpZWQgZmF1bHRzIHJldGFpbmVkXG5cdFx0ICogYnkgdGhpcyBGYXVsdFNlcnZpY2UuXG5cdFx0ICovXG5cdFx0KmVhY2goKVxuXHRcdHtcblx0XHRcdGNvbnN0IGZhdWx0c1NvcnRlZCA9IFxuXHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuYXN5bmNGcmFtZS5mYXVsdHMudmFsdWVzKCkpXG5cdFx0XHRcdFx0LmNvbmNhdChBcnJheS5mcm9tKHRoaXMudmlzaWJsZUZyYW1lLmZhdWx0cy52YWx1ZXMoKSkpXG5cdFx0XHRcdFx0Lm1hcChmYXVsdE1hcCA9PiBBcnJheS5mcm9tKGZhdWx0TWFwLnZhbHVlcygpKSlcblx0XHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pXG5cdFx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IGEubGluZSAtIGIubGluZSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZmF1bHQgb2YgZmF1bHRzU29ydGVkKVxuXHRcdFx0XHR5aWVsZCBmYXVsdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZlxuXHRcdCAqIHVucmVjdGlmaWVkIGZhdWx0cyByZXRhaW5lZCBieSB0aGlzIEZhdWx0U2VydmljZS5cblx0XHQgKi9cblx0XHRnZXQgY291bnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnZpc2libGVGcmFtZS5mYXVsdHMuc2l6ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVwb3J0cyBhIGZhdWx0LiBJZiBhIHNpbWlsYXIgRmF1bHQgb24gdGhlIHNhbWUgYXJlYVxuXHRcdCAqIG9mIHRoZSBkb2N1bWVudCBoYXNuJ3QgYmVlbiByZXBvcnRlZCwgdGhlIG1ldGhvZFxuXHRcdCAqIHJ1bnMgdGhlIEZhdWx0UmVwb3J0ZWQgaG9vay5cblx0XHQgKi9cblx0XHRyZXBvcnQoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdHRoaXMuYnVmZmVyRnJhbWUuYWRkRmF1bHQoZmF1bHQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBvcnRzIGEgZmF1bHQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiBhbiBlZGl0IHRyYW5zYWN0aW9uLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIHRvIGJlIHVzZWQgZm9yIGZhdWx0cyB0aGF0IGFyZSByZXBvcnRlZCBpblxuXHRcdCAqIGFzeW5jaHJvbm91cyBjYWxsYmFja3MsIHN1Y2ggYXMgbmV0d29yayBlcnJvcnMuXG5cdFx0ICovXG5cdFx0cmVwb3J0QXN5bmMoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdHRoaXMuYnVmZmVyRnJhbWUuYWRkRmF1bHQoZmF1bHQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRoaXMuaW5FZGl0VHJhbnNhY3Rpb24pXG5cdFx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXNcblx0XHQgKiBGYXVsdFNlcnZpY2UgcmV0YWlucyBhIGZhdWx0IHRoYXQgaXMgc2ltaWxhciB0byB0aGUgc3BlY2lmaWVkXG5cdFx0ICogZmF1bHQgKG1lYW5pbmcgdGhhdCBpdCBoYXMgdGhlIHNhbWUgY29kZSBhbmQgc291cmNlKS5cblx0XHQgKi9cblx0XHRoYXMoc2ltaWxhckZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHJldGFpbmVkRmF1bHQgb2YgdGhpcy5lYWNoKCkpXG5cdFx0XHRcdGlmIChyZXRhaW5lZEZhdWx0LnR5cGUuY29kZSA9PT0gc2ltaWxhckZhdWx0LnR5cGUuY29kZSlcblx0XHRcdFx0XHRpZiAocmV0YWluZWRGYXVsdC5zb3VyY2UgPT09IHNpbWlsYXJGYXVsdC5zb3VyY2UpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBGYXVsdCBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIHJlcG9ydGVkXG5cdFx0ICogYXQgdGhlIHNwZWNpZmllZCBzb3VyY2UuIElmIHRoZSBzb3VyY2UgaGFzIG5vIGZhdWx0cywgYW4gZW1wdHlcblx0XHQgKiBhcnJheSBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRjaGVjazxUU291cmNlIGV4dGVuZHMgb2JqZWN0Pihzb3VyY2U6IFRTb3VyY2UpOiBGYXVsdDxUU291cmNlPltdXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb3V0OiBGYXVsdDxUU291cmNlPltdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmV0YWluZWRGYXVsdCBvZiB0aGlzLmVhY2goKSlcblx0XHRcdFx0aWYgKHJldGFpbmVkRmF1bHQuc291cmNlID09PSBzb3VyY2UpXG5cdFx0XHRcdFx0b3V0LnB1c2goPEZhdWx0PFRTb3VyY2U+PnJldGFpbmVkRmF1bHQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBVc2VkIGludGVybmFsbHkgdG8gaW5mb3JtIHRoZSBGYXVsdFNlcnZpY2UgdGhhdCB0eXBlLWxldmVsIGZhdWx0XG5cdFx0ICogYW5hbHlzaXMgaXMgYmVpbmcgZG9uZSBvbiB0aGUgcHJvdmlkZWQgTm9kZS4gVGhpcyBpcyBuZWNlc3Nhcnlcblx0XHQgKiBiZWNhdXNlIHR5cGUtbGV2ZWwgZmF1bHRzIGRvIG5vdCBsaXZlIGJleW9uZCBhIHNpbmdsZSBlZGl0IGZyYW1lLFxuXHRcdCAqIHNvIHRoZSBGYXVsdFNlcnZpY2UgbmVlZHMgdG8ga25vdyB3aGljaCBOb2RlcyB3ZXJlIGFuYWx5emVkXG5cdFx0ICogc28gdGhhdCBuZXdseSByZWN0aWZpZWQgZmF1bHRzIGNhbiBiZSBjbGVhcmVkIG91dC5cblx0XHQgKiBcblx0XHQgKiBXaGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYW55IHRoZSBmYXVsdHMgY29ycmVzcG9uZGluZyB0byB0aGVcblx0XHQgKiBzcGVjaWZpZWQgTm9kZSBhcmUgY2xlYXJlZCBvdXQsIGFuZCBhcmUgb25seSBhZGRlZCBiYWNrIGluIGlmXG5cdFx0ICogdGhleSB3ZXJlIHJlLWRldGVjdGVkIGR1cmluZyB0aGlzIGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICovXG5cdFx0aW5mb3JtKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210cyA9IG5vZGUuc3RhdGVtZW50cy5maWx0ZXIoc210ID0+ICFzbXQuaXNEaXNwb3NlZCk7XG5cdFx0XHRcblx0XHRcdC8vIENsZWFyIG91dCBhbnkgc3RhdGVtZW50LWxldmVsIGZhdWx0cyB0aGF0IHRvdWNoIHRoZSBub2RlXG5cdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzbXRzKVxuXHRcdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLnJlbW92ZVNvdXJjZShzbXQpO1xuXHRcdFx0XHRcblx0XHRcdC8vIENsZWFyIG91dCBhbnkgc3Bhbi1sZXZlbCBmYXVsdHMgdGhhdCB0b3VjaCB0aGUgbm9kZVxuXHRcdFx0Y29uc3Qgc3BhbnMgPSBzbXRzXG5cdFx0XHRcdC5tYXAoc210ID0+IHNtdC5zcGFucylcblx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKVxuXHRcdFx0XHR0aGlzLmJ1ZmZlckZyYW1lLnJlbW92ZVNvdXJjZShzcGFuKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2xlYXIgb3V0IGFueSBpbmZpeC1sZXZlbCBmYXVsdHMgdGhhdCB0b3VjaCB0aGUgbm9kZVxuXHRcdFx0Y29uc3QgaW5maXhlcyA9IHNtdHNcblx0XHRcdFx0Lm1hcChzbXQgPT4gc210LmluZml4U3BhbnMgfHwgW10pXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaW5maXggb2YgaW5maXhlcylcblx0XHRcdFx0dGhpcy5idWZmZXJGcmFtZS5yZW1vdmVTb3VyY2UoaW5maXgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKi9cblx0XHRyZWZyZXNoKClcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNBZGRlZDogRmF1bHRbXSA9IFtdO1xuXHRcdFx0Y29uc3QgZmF1bHRzUmVtb3ZlZDogRmF1bHRbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IG1hcCBvZiB0aGlzLmJ1ZmZlckZyYW1lLmZhdWx0cy52YWx1ZXMoKSlcblx0XHRcdFx0Zm9yIChjb25zdCBmYXVsdCBvZiBtYXAudmFsdWVzKCkpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLnZpc2libGVGcmFtZS5oYXNGYXVsdChmYXVsdCkpXG5cdFx0XHRcdFx0XHRmYXVsdHNBZGRlZC5wdXNoKGZhdWx0KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBtYXAgb2YgdGhpcy52aXNpYmxlRnJhbWUuZmF1bHRzLnZhbHVlcygpKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGZhdWx0IG9mIG1hcC52YWx1ZXMoKSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuYnVmZmVyRnJhbWUuaGFzRmF1bHQoZmF1bHQpKVxuXHRcdFx0XHRcdFx0ZmF1bHRzUmVtb3ZlZC5wdXNoKGZhdWx0KTtcblx0XHRcdFxuXHRcdFx0dGhpcy52aXNpYmxlRnJhbWUgPSB0aGlzLmJ1ZmZlckZyYW1lO1xuXHRcdFx0dGhpcy5idWZmZXJGcmFtZSA9IHRoaXMuYnVmZmVyRnJhbWUuY2xvbmUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZhdWx0c0FkZGVkLmxlbmd0aCArIGZhdWx0c1JlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZUZhdWx0Q2hhbmdlKFxuXHRcdFx0XHRcdGZhdWx0c0FkZGVkLFxuXHRcdFx0XHRcdGZhdWx0c1JlbW92ZWQpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBmYXVsdHMgdGhhdCBhcmUgcHJlc2VudGVkIHRvIGV4dGVybmFsIGNvbnN1bWVyXG5cdFx0ICogb2YgdGhlIGZhdWx0IHNlcnZpY2Ugd2hlbiB0aGV5IHVzZSB0aGUgYWNjZXNzb3IgbWV0aG9kcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHZpc2libGVGcmFtZSA9IG5ldyBGYXVsdEZyYW1lKCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBmYXVsdHMgdGhhdCBoYXZlIGJlZW4gYnVpbHQgdXAgZHVyaW5nIGFuIGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICogVGhlc2UgZmF1bHRzIGFyZSBjb3BpZWQgdG8gdGhlIGB2aXNpYmxlRnJhbWVgIHdoZW4gdGhlIGVkaXRcblx0XHQgKiB0cmFuc2FjdGlvbiBjb21wbGV0ZXMuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBidWZmZXJGcmFtZSA9IG5ldyBGYXVsdEZyYW1lKCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBmYXVsdHMgdGhhdCB3ZXJlIHJlcG9ydGVkIGFzeW5jaHJvbm91c2x5LCBhbmQgdGhlcmVmb3JlXG5cdFx0ICogYXJlIG5vdCBib3VuZCB0byBhbnkgZWRpdCB0cmFuc2FjdGlvbi5cblx0XHQgKi9cblx0XHRwcml2YXRlIGFzeW5jRnJhbWUgPSBuZXcgRmF1bHRGcmFtZSgpO1xuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRjbGFzcyBGYXVsdEZyYW1lXG5cdHtcblx0XHQvKiogKi9cblx0XHRjbG9uZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgbmV3RnJhbWUgPSBuZXcgRmF1bHRGcmFtZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtmYXVsdFNvdXJjZSwgZXhpc3RpbmdNYXBdIG9mIHRoaXMuZmF1bHRzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXdNYXA6IFRGYXVsdE1hcCA9IG5ldyBNYXAoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgW2NvZGUsIGZhdWx0XSBvZiBleGlzdGluZ01hcClcblx0XHRcdFx0XHRuZXdNYXAuc2V0KGNvZGUsIGZhdWx0KTtcblx0XHRcdFx0XG5cdFx0XHRcdG5ld0ZyYW1lLmZhdWx0cy5zZXQoZmF1bHRTb3VyY2UsIG5ld01hcCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXdGcmFtZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRkRmF1bHQoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdGNvbnN0IGZhdWx0c0ZvclNvdXJjZSA9IHRoaXMuZmF1bHRzLmdldChmYXVsdC5zb3VyY2UpO1xuXHRcdFx0aWYgKGZhdWx0c0ZvclNvdXJjZSlcblx0XHRcdHtcblx0XHRcdFx0ZmF1bHRzRm9yU291cmNlLnNldChmYXVsdC50eXBlLmNvZGUsIGZhdWx0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwOiBURmF1bHRNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdG1hcC5zZXQoZmF1bHQudHlwZS5jb2RlLCBmYXVsdCk7XG5cdFx0XHRcdHRoaXMuZmF1bHRzLnNldChmYXVsdC5zb3VyY2UsIG1hcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlbW92ZVNvdXJjZShzb3VyY2U6IFRGYXVsdFNvdXJjZSlcblx0XHR7XG5cdFx0XHR0aGlzLmZhdWx0cy5kZWxldGUoc291cmNlKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFN0YXRlbWVudClcblx0XHRcdFx0Zm9yIChjb25zdCBjcnVmdE9iamVjdCBvZiBzb3VyY2UuY3J1ZnRPYmplY3RzKVxuXHRcdFx0XHRcdHRoaXMuZmF1bHRzLmRlbGV0ZShjcnVmdE9iamVjdCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlbW92ZUZhdWx0KGZhdWx0OiBGYXVsdClcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdHNGb3JTb3VyY2UgPSB0aGlzLmZhdWx0cy5nZXQoZmF1bHQuc291cmNlKTtcblx0XHRcdGlmIChmYXVsdHNGb3JTb3VyY2UpXG5cdFx0XHRcdGZhdWx0c0ZvclNvdXJjZS5kZWxldGUoZmF1bHQudHlwZS5jb2RlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzRmF1bHQoZmF1bHQ6IEZhdWx0KVxuXHRcdHtcblx0XHRcdGNvbnN0IGZhdWx0c0ZvclNvdXJjZSA9IHRoaXMuZmF1bHRzLmdldChmYXVsdC5zb3VyY2UpO1xuXHRcdFx0cmV0dXJuIGZhdWx0c0ZvclNvdXJjZSA/XG5cdFx0XHRcdGZhdWx0c0ZvclNvdXJjZS5oYXMoZmF1bHQudHlwZS5jb2RlKSA6XG5cdFx0XHRcdGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBIGRvdWJseS1uZXN0ZWQgbWFwIG9mIGZhdWx0IHNvdXJjZXMsIGZhdWx0IGNvZGVzLCBhbmQgdGhlIGFjdHVhbCBmYXVsdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBmYXVsdHMgPSBuZXcgTWFwPFRGYXVsdFNvdXJjZSwgVEZhdWx0TWFwPigpO1xuXHR9XG5cblx0dHlwZSBURmF1bHRNYXAgPSBNYXA8bnVtYmVyLCBGYXVsdD47XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSB0eXBlIHRoYXQgZGVzY3JpYmVzIHRoZSBwb3NzaWJsZSBvYmplY3RzIHdpdGhpbiBhIGRvY3VtZW50XG5cdCAqIHRoYXQgbWF5IGJlIHJlc3BvbnNpYmxlIGZvciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGZhdWx0LlxuXHQgKi9cblx0ZXhwb3J0IHR5cGUgVEZhdWx0U291cmNlID0gU3RhdGVtZW50IHwgU3BhbiB8IEluZml4U3BhbjtcblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgRmF1bHQ8VFNvdXJjZSA9IFRGYXVsdFNvdXJjZT5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqICovXG5cdFx0XHRyZWFkb25seSB0eXBlOiBGYXVsdFR5cGU8VFNvdXJjZT4sXG5cdFx0XHRcblx0XHRcdC8qKiBUaGUgZG9jdW1lbnQgb2JqZWN0IHRoYXQgY2F1c2VkIHRoZSBmYXVsdCB0byBiZSByZXBvcnRlZC4gKi9cblx0XHRcdHJlYWRvbmx5IHNvdXJjZTogVFNvdXJjZSxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UgdGhhdCBjb250YWlucyBtb3JlIGluLWRlcHRoIGRldGFpbFxuXHRcdFx0ICogb2YgdGhlIGZhdWx0IHRoYXQgb2NjdXJlZCwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIG1lc3NhZ2UuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGFkZGl0aW9uYWxEZXRhaWw6IHN0cmluZyA9IFwiXCIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy5zb3VyY2U7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSArMSdzIGFyZSBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gZGVhbCB3aXRoIHRoZSBmYWN0IHRoYXRcblx0XHRcdC8vIG1vc3QgZWRpdG9ycyBhcmUgMS1iYXNlZCB3aGVyZWFzIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuXHRcdFx0Ly8gb2Ygc3RhdGVtZW50IHN0cmluZ3MgYXJlIDAtYmFzZWQuXG5cdFx0XHRcblx0XHRcdGlmIChzcmMgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFRoZSBUYWJzQW5kU3BhY2VzIGZhdWx0IGlzIHRoZSBvbmx5IGZhdWx0IHRoYXQgbmVlZHMgYVxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2Ugd2hlcmUgaXQgaGFzIGEgZGlmZmVyZW50IHJlcG9ydGluZyBsb2NhdGlvbi5cblx0XHRcdFx0dGhpcy5yYW5nZSA9IHR5cGUuY29kZSA9PT0gRmF1bHRzLlRhYnNBbmRTcGFjZXMuY29kZSA/XG5cdFx0XHRcdFx0WzEsIHNyYy5pbmRlbnQgKyAxXSA6XG5cdFx0XHRcdFx0W3NyYy5pbmRlbnQgKyAxLCBzcmMuc291cmNlVGV4dC5sZW5ndGggKyAxXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFNwYW4gfHwgc3JjIGluc3RhbmNlb2YgSW5maXhTcGFuKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnJhbmdlID0gW1xuXHRcdFx0XHRcdHNyYy5ib3VuZGFyeS5vZmZzZXRTdGFydCArIDEsXG5cdFx0XHRcdFx0c3JjLmJvdW5kYXJ5Lm9mZnNldEVuZCArIDFcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgdGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIGZhdWx0IGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sXG5cdFx0ICogc3VpdGFibGUgZm9yIG91dHB1dCBhcyBhbiBlcnJvciBtZXNzYWdlLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBhdm9pZFByb3RvY29scyA9IFtcblx0XHRcdFx0VXJpUHJvdG9jb2wuaW50ZXJuYWwsXG5cdFx0XHRcdFVyaVByb3RvY29sLm5vbmUsXG5cdFx0XHRcdFVyaVByb3RvY29sLnVua25vd25cblx0XHRcdF07XG5cdFx0XHRcblx0XHRcdGNvbnN0IHVyaVRleHQgPSBhdm9pZFByb3RvY29scy5pbmNsdWRlcyhkb2Muc291cmNlVXJpLnByb3RvY29sKSA/XG5cdFx0XHRcdFwiXCIgOiBkb2Muc291cmNlVXJpLnRvU3RvcmVTdHJpbmcoKSArIFwiIFwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb2xOdW1zID0gdGhpcy5yYW5nZS5qb2luKFwiLVwiKTtcblx0XHRcdGNvbnN0IGNvbFRleHQgPSBjb2xOdW1zID8gXCIsIENvbCBcIiArIGNvbE51bXMgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYCR7dGhpcy50eXBlLm1lc3NhZ2V9ICgke3VyaVRleHR9TGluZSAke3RoaXMubGluZX0ke2NvbFRleHR9KWA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSByZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50IGluIHdoaWNoIHRoaXMgRmF1bHQgd2FzIGRldGVjdGVkLlxuXHRcdCAqL1xuXHRcdGdldCBkb2N1bWVudCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50LmRvY3VtZW50O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBTdGF0ZW1lbnQgaW4gd2hpY2ggdGhpcyBGYXVsdCB3YXMgZGV0ZWN0ZWQuXG5cdFx0ICovXG5cdFx0Z2V0IHN0YXRlbWVudCgpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy5zb3VyY2U7XG5cdFx0XHRyZXR1cm4gTm90Lm51bGwoXG5cdFx0XHRcdHNyYyBpbnN0YW5jZW9mIFN0YXRlbWVudCA/IHNyYyA6XG5cdFx0XHRcdHNyYyBpbnN0YW5jZW9mIFNwYW4gPyBzcmMuc3RhdGVtZW50IDpcblx0XHRcdFx0c3JjIGluc3RhbmNlb2YgSW5maXhTcGFuID8gc3JjLnN0YXRlbWVudCA6XG5cdFx0XHRcdG51bGwpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBsaW5lIG51bWJlciBvZiB0aGUgU3RhdGVtZW50IGluIHdoaWNoIHRoaXMgRmF1bHQgd2FzIGRldGVjdGVkLlxuXHRcdCAqL1xuXHRcdGdldCBsaW5lKClcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnN0YXRlbWVudDtcblx0XHRcdHJldHVybiBzbXQuZG9jdW1lbnQuZ2V0TGluZU51bWJlcihzbXQpICsgMTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgY2hhcmFjdGVyIG9mZnNldHNcblx0XHQgKiB3aXRoaW4gdGhlIFN0YXRlbWVudCBpbiB3aGljaCB0aGlzIEZhdWx0IHdhcyBkZXRlY3RlZC4gVGhlIGNoYXJhY3RlclxuXHRcdCAqIG9mZnNldHMgYXJlIDEtYmFzZWQgKG5vdCAwLWJhc2VkKSB0byBjb21wbHkgd2l0aCB0aGUgYmVoYXZpb3VyIG9mIFxuXHRcdCAqIG1vc3QgdGV4dCBlZGl0b3JzLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHJhbmdlOiBudW1iZXJbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGYXVsdFR5cGU8VFNvdXJjZSA9IFRGYXVsdFNvdXJjZT5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBlcnJvciBjb2RlLCB1c2VmdWwgZm9yIHJlZmVyZW5jZSBwdXJwb3Nlcywgb3IgZGlzcGxheSBpbiBhIHVzZXIgaW50ZXJmYWNlLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBjb2RlOiBudW1iZXIsXG5cdFx0XHQvKipcblx0XHRcdCAqIEEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGZhdWx0LlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBtZXNzYWdlOiBzdHJpbmcsXG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBzZXZlcml0eTogRmF1bHRTZXZlcml0eSlcblx0XHR7XG5cdFx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIGZhdWx0IG9mIHRoaXMgdHlwZS5cblx0XHQgKi9cblx0XHRjcmVhdGUoc291cmNlOiBUU291cmNlKVxuXHRcdHtcblx0XHRcdHJldHVybiBuZXcgRmF1bHQ8VFNvdXJjZT4odGhpcywgc291cmNlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGZvbGxvd2luZyBkZWZpbml0aW9ucyBhcmUgaW50ZW50aW9uYWxseSBlcXVpdmFsZW50XG5cdCAqIHRvIHRoZSBzZXZlcml0eSBjb2RlcyBmcm9tIHRoZSBtb25hY28gZWRpdG9yLlxuXHQgKi9cblx0ZXhwb3J0IGNvbnN0IGVudW0gRmF1bHRTZXZlcml0eVxuXHR7XG5cdFx0LyoqIFVudXNlZC4gKi9cblx0XHRoaW50ID0gMSxcblx0XHRcblx0XHQvKiogVW51c2VkLiAqL1xuXHRcdGluZm8gPSAyLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgc2V2ZXJpdHkgb2YgYSBmYXVsdCBpcyBcIndhcm5pbmdcIiwgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdCAqIHRoZSBhc3NvY2lhdGVkIG9iamVjdCB3aWxsIHN0aWxsIGJlIHByb2Nlc3NlZCBkdXJpbmcgdHlwZSBhbmFseXNpcy5cblx0XHQgKi9cblx0XHR3YXJuaW5nID0gNCxcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIHNldmVyaXR5IG9mIGEgZmF1bHQgaXMgXCJlcnJvclwiLCB3aGljaCBtZWFucyB0aGF0XG5cdFx0ICogdGhlIGFzc29jaWF0ZWQgb2JqZWN0IHdpbGwgYmUgaWdub3JlZCBkdXJpbmcgdHlwZSBhbmFseXNpcy5cblx0XHQgKi9cblx0XHRlcnJvciA9IDhcblx0fVxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBmcm96ZW4gZmF1bHQgaW5zdGFuY2VzLlxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlRmF1bHQ8VD4oXG5cdFx0Y29kZTogbnVtYmVyLFxuXHRcdG1lc3NhZ2U6IHN0cmluZyxcblx0XHRzZXZlcml0eSA9IEZhdWx0U2V2ZXJpdHkuZXJyb3IpXG5cdHtcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgRmF1bHRUeXBlPFQ+KGNvZGUsIG1lc3NhZ2UsIHNldmVyaXR5KSk7XG5cdH1cblxuXHRjb25zdCBxdWFudGlmaWVycyA9IFxuXHRcdGAoJHtSZWdleFN5bnRheE1pc2Muc3Rhcn0sIFxuXHRcdCR7UmVnZXhTeW50YXhNaXNjLnBsdXN9LFxuXHRcdCR7UmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclN0YXJ0fS4uJHtSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyRW5kfSlgO1xuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjb25zdCBGYXVsdHMgPSBPYmplY3QuZnJlZXplKHtcblx0XHRcblx0XHQvKiogKi9cblx0XHQqZWFjaCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gPEZhdWx0VHlwZTxvYmplY3Q+W10+T2JqZWN0LnZhbHVlcyhGYXVsdHMpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0VHlwZSBvZiB2YWx1ZXMpXG5cdFx0XHRcdGlmIChmYXVsdFR5cGUgaW5zdGFuY2VvZiBGYXVsdFR5cGUpXG5cdFx0XHRcdFx0eWllbGQgZmF1bHRUeXBlO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIEZhdWx0VHlwZSBpbnN0YW5jZVxuXHRcdCAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmF1bHQgd2l0aCB0aGUgc3BlY2lmaWVkIGNvZGUsIGFzXG5cdFx0ICogd2VsbCBhcyB0aGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UuIEluIHRoZSBjYXNlIHdoZW4gdGhlXG5cdFx0ICogZmF1bHRDb2RlIHdhcyBub3QgZm91bmQsIG51bGwgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0bmFtZU9mKGZhdWx0Q29kZTogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IGVudHJpZXMgPSA8W3N0cmluZywgRmF1bHRUeXBlPG9iamVjdD5dW10+T2JqZWN0LmVudHJpZXMoRmF1bHRzKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbbmFtZSwgdHlwZV0gb2YgZW50cmllcylcblx0XHRcdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBGYXVsdFR5cGUpXG5cdFx0XHRcdFx0aWYgKHR5cGUuY29kZSA9PT0gZmF1bHRDb2RlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0sXG5cdFx0XG5cdFx0Ly8jIFJlc291cmNlLXJlbGF0ZWQgZmF1bHRzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VW5yZXNvbHZlZFJlc291cmNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAwLFxuXHRcdFx0XCJVUkkgcG9pbnRzIHRvIGEgcmVzb3VyY2UgdGhhdCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdENpcmN1bGFyUmVzb3VyY2VSZWZlcmVuY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDIsXG5cdFx0XHRcIlVSSSBwb2ludHMgdG8gYSByZXNvdXJjZSB0aGF0IHdvdWxkIGNhdXNlIGEgY2lyY3VsYXIgcmVmZXJlbmNlLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbnNlY3VyZVJlc291cmNlUmVmZXJlbmNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTA0LFxuXHRcdFx0YERvY3VtZW50cyBsb2FkZWQgZnJvbSByZW1vdGUgbG9jYXRpb25zXG5cdFx0XHRjYW5ub3QgcmVmZXJlbmNlIGRvY3VtZW50cyBzdG9yZWQgbG9jYWxseS5gKSxcblx0XHRcblx0XHQvLyMgVHlwZSB2ZXJpZmljYXRpb24gZmF1bHRzXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0VW5yZXNvbHZlZEFubm90YXRpb246IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MjAxLFxuXHRcdFx0XCJVbnJlc29sdmVkIGFubm90YXRpb24uXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdENpcmN1bGFyVHlwZVJlZmVyZW5jZTogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQyMDMsXG5cdFx0XHRcIkNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIGRldGVjdGVkLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRDb250cmFjdFZpb2xhdGlvbjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdC8vISBDSEFOR0UgVEhJUyBUTyAyMDRcblx0XHRcdDIwNSxcblx0XHRcdFwiT3ZlcnJpZGRlbiB0eXBlcyBtdXN0IGV4cGxpY2l0bHkgZXhwYW5kIHRoZSB0eXBlIGFzIGRlZmluZWQgaW4gdGhlIGJhc2UuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFR5cGVDYW5ub3RCZVJlZnJlc2hlZDogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDIwNixcblx0XHRcdGBUaGlzIHR5cGUgY2Fubm90IGJlIHJlZnJlc2hlZCwgYmVjYXVzZSBvbmUgb3IgbW9yZSBiYXNlXG5cdFx0XHR0eXBlcyBhcmUgaW1wb3NpbmcgYSBzcGVjaWZpYyB0eXBlIGNvbnRyYWN0IG9uIGl0LiBDb25zaWRlclxuXHRcdFx0b21pdHRpbmcgdGhlICR7U3ludGF4LmpvaW50fSBvcGVyYXRvciBoZXJlLmAsXG5cdFx0XHRGYXVsdFNldmVyaXR5Lndhcm5pbmcpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdElnbm9yZWRBbm5vdGF0aW9uOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDIwNyxcblx0XHRcdGBUaGlzIGFubm90YXRpb24gaXMgaWdub3JlZCBiZWNhdXNlIGFub3RoZXIgYW5ub3RhdGlvblxuXHRcdFx0aW4gdGhpcyBzdGF0ZW1lbnQgcmVzb2x2ZXMgdG8gdGhlIHNhbWUgdHlwZS5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJZ25vcmVkQWxpYXM6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MjA5LFxuXHRcdFx0YEFsaWFzZXMgKG1lYW5pbmcgYW5ub3RhdGlvbnMgdGhhdCBhcmUgbWF0Y2hlZCBieSBwYXR0ZXJucylcblx0XHRcdGNhbid0IGJlIGFkZGVkIG9udG8gdHlwZXMgdGhhdCBoYXZlIGEgY29udHJhY3QgcHV0IGluIHBsYWNlXG5cdFx0XHRieSBhIGJhc2UgdHlwZS5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRUeXBlU2VsZlJlZmVyZW50aWFsOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDIxMSxcblx0XHRcdFwiVHlwZXMgY2Fubm90IGJlIHNlbGYtcmVmZXJlbnRpYWxcIiksXG5cdFx0XG5cdFx0Ly8jIExpc3QtcmVsYXRlZCBmYXVsdHNcblx0XHRcblx0XHQvKiogKi9cblx0XHRBbm9ueW1vdXNJbkxpc3RJbnRyaW5zaWM6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQzMDAsXG5cdFx0XHRcIlR5cGVzIGNvbnRhaW5lZCBkaXJlY3RseSBieSBMaXN0LWludHJpbnNpYyB0eXBlcyBjYW5ub3QgYmUgYW5vbnltb3VzLlwiLFxuXHRcdFx0RmF1bHRTZXZlcml0eS53YXJuaW5nKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRMaXN0Q29udHJhY3RWaW9sYXRpb246IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MzAxLFxuXHRcdFx0XCJUaGUgY29udGFpbmluZyBsaXN0IGNhbm5vdCBjb250YWluIGNoaWxkcmVuIG9mIHRoaXMgdHlwZS5cIixcblx0XHRcdEZhdWx0U2V2ZXJpdHkud2FybmluZyksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0TGlzdEludHJpbnNpY0V4dGVuZGluZ0xpc3Q6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MzAzLFxuXHRcdFx0XCJMaXN0IGludHJpbnNpYyB0eXBlcyBjYW5ub3QgZXh0ZW5kIGZyb20gb3RoZXIgbGlzdHMuXCIpLFxuXHRcdFxuXHRcdC8qKiAoVGhpcyBpcyB0aGUgc2FtZSB0aGluZyBhcyBhIGxpc3QgZGltZW5zaW9uYWxpdHkgY29uZmxpY3QpICovXG5cdFx0TGlzdEV4dHJpbnNpY0V4dGVuZGluZ05vbkxpc3Q6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MzA1LFxuXHRcdFx0XCJMaXN0cyBjYW5ub3QgZXh0ZW5kIGZyb20gbm9uLWxpc3RzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRMaXN0RGltZW5zaW9uYWxEaXNjcmVwYW5jeUZhdWx0OiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDMwNyxcblx0XHRcdGBBIHVuaW9uIGNhbm5vdCBiZSBjcmVhdGVkIGJldHdlZW4gdGhlc2UgdHdvIHR5cGVzXG5cdFx0XHRiZWNhdXNlIHRoZXkgYXJlIGxpc3RzIG9mIGRpZmZlcmVudCBkaW1lbnNpb25zLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdExpc3RBbm5vdGF0aW9uQ29uZmxpY3Q6IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0MzA5LFxuXHRcdFx0YEFsbCBmcmFnbWVudHMgb2YgdGhpcyBhbm5vdGF0aW9uIG5lZWQgdG8gaGF2ZVxuXHRcdFx0YSBsaXN0IG9wZXJhdG9yICgke1N5bnRheC5saXN0fSlgKSxcblx0XHRcblx0XHQvLyMgUGF0dGVybi1yZWxhdGVkIGZhdWx0c1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5JbnZhbGlkOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDAwLFxuXHRcdFx0XCJJbnZhbGlkIHBhdHRlcm4uXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5XaXRob3V0QW5ub3RhdGlvbjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQwMixcblx0XHRcdFwiUGF0dGVybiBoYXMgbm8gYW5ub3RhdGlvbnMuXCIsXG5cdFx0XHRGYXVsdFNldmVyaXR5Lndhcm5pbmcpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5DYW5NYXRjaEVtcHR5OiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDA0LFxuXHRcdFx0XCJQYXR0ZXJucyBtdXN0IG5vdCBiZSBhYmxlIHRvIG1hdGNoIGFuIGVtcHR5IGlucHV0LlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuTWF0Y2hpbmdUeXBlc0FscmVhZHlFeGlzdHM6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MDYsXG5cdFx0XHRgQSBwYXR0ZXJuIG1hdGNoaW5nIHRoZXNlIHR5cGVzIGhhcyBcblx0XHRcdGFscmVhZHkgYmVlbiBkZWZpbmVkIGluIHRoaXMgc2NvcGUuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybk1hdGNoaW5nTGlzdDogY3JlYXRlRmF1bHQ8U3Bhbj4oXG5cdFx0XHQ0MDcsXG5cdFx0XHRcIkEgcGF0dGVybiBjYW5ub3QgbWF0Y2ggYSBsaXN0IHR5cGUuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5DYW5NYXRjaFdoaXRlc3BhY2VPbmx5OiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDIwLFxuXHRcdFx0XCJQYXR0ZXJucyBtdXN0IG5vdCBiZSBhYmxlIHRvIG1hdGNoIGFuIGlucHV0IFwiICtcblx0XHRcdFwiY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybkFjY2VwdHNMZWFkaW5nV2hpdGVzcGFjZTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQyMixcblx0XHRcdFwiUGF0dGVybnMgbXVzdCBub3QgYmUgYWJsZSB0byBtYXRjaCBhbiBpbnB1dCBcIiArXG5cdFx0XHRcImNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBhdHRlcm5SZXF1aXJlc0xlYWRpbmdXaGl0ZXNwYWNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDI0LFxuXHRcdFx0XCJQYXR0ZXJucyBtdXN0IG5vdCBiZSBhYmxlIHRvIG1hdGNoIGFuIGlucHV0IFwiICtcblx0XHRcdFwiY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVybkFjY2VwdHNUcmFpbGluZ1doaXRlc3BhY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MjYsXG5cdFx0XHRcIlBhdHRlcm5zIG11c3Qgbm90IGJlIGFibGUgdG8gbWF0Y2ggYW4gaW5wdXQgXCIgK1xuXHRcdFx0XCJjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuUmVxdWlyZXNUcmFpbGluZ1doaXRlc3BhY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ0MjgsXG5cdFx0XHRcIlBhdHRlcm5zIG11c3Qgbm90IGJlIGFibGUgdG8gbWF0Y2ggYW4gaW5wdXQgXCIgK1xuXHRcdFx0XCJjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuTm9uQ292YXJpYW50OiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NDQwLFxuXHRcdFx0XCJQYXR0ZXJuIGRvZXMgbm90IG1hdGNoIGl0J3MgYmFzZSB0eXBlcy5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0UGF0dGVyblBhcnRpYWxXaXRoQ29tYmluYXRvcjogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDQ0Mixcblx0XHRcdFwiUGFydGlhbCBwYXR0ZXJucyBjYW5ub3QgZXhwbGljaXRseSBtYXRjaCB0aGUgY29tbWEgY2hhcmFjdGVyLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQYXR0ZXJuc0Zvcm1EaXNjcmVwYW50VW5pb246IGNyZWF0ZUZhdWx0PFNwYW4+KFxuXHRcdFx0NDk5LFxuXHRcdFx0XCJBIHVuaW9uIGNhbm5vdCBiZSBjcmVhdGVkIGJldHdlZW4gdGhlc2UgdHlwZXMgYmVjYXVzZSB0aGVpciBcIiArIFxuXHRcdFx0XCJhc3NvY2lhdGVkIHBhdHRlcm5zIGNvbmZsaWN0IHdpdGggZWFjaCBvdGhlci5cIiksXG5cdFx0XG5cdFx0Ly8jIEluZml4IHJlbGF0ZWRcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeEhhc1F1YW50aWZpZXI6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQvLy8wLFxuXHRcdFx0NTAwLFxuXHRcdFx0YEluZml4ZXMgY2Fubm90IGhhdmUgcXVhbnRpZmllcnMgJHtxdWFudGlmaWVyc30gYXBwbGllZCB0byB0aGVtYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhIYXNEdXBsaWNhdGVJZGVudGlmaWVyOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vMCxcblx0XHRcdDUwMSxcblx0XHRcdFwiSW5maXhlcyBjYW5ub3QgaGF2ZSBkdXBsaWNhdGUgaWRlbnRpZmllcnMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4SGFzU2VsZlJlZmVyZW50aWFsVHlwZTogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQxMCxcblx0XHRcdDUwMyxcblx0XHRcdFwiSW5maXhlcyBjYW5ub3QgYmUgc2VsZi1yZWZlcmVudGlhbC5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhOb25Db252YXJpYW50OiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDEyLFxuXHRcdFx0NTA1LFxuXHRcdFx0XCJJbmZpeGVzIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHRoZWlyIGJhc2VzLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeENhbm5vdERlZmluZU5ld1R5cGVzOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDIyLFxuXHRcdFx0NTA3LFxuXHRcdFx0YEEgdHlwZSByZWZlcmVuY2VkIGluIGFuIGluZml4IG11c3QgYmUgY29udGFpbmVkXG5cdFx0XHRieSB0aGUgcGF0dGVybiBzdGF0ZW1lbnQgZGlyZWN0bHksIG9yIGJlIGNvbnRhaW5lZFxuXHRcdFx0Ynkgb25lIG9mIGl0J3MgbWF0Y2hlZCBiYXNlcy5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeFJlZmVyZW5jZWRUeXBlTXVzdEhhdmVQYXR0ZXJuOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDE0LFxuXHRcdFx0NTA5LFxuXHRcdFx0XCJUeXBlcyBhcHBsaWVkIHRvIGFuIGluZml4IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYXNzb2NpYXRlZCBwYXR0ZXJuLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeFJlZmVyZW5jZWRUeXBlQ2Fubm90QmVSZWN1cnNpdmU6IGNyZWF0ZUZhdWx0PEluZml4U3Bhbj4oXG5cdFx0XHQvLy80MTYsXG5cdFx0XHQ1MTEsXG5cdFx0XHRcIlR5cGVzIGFwcGxpZWQgdG8gYW4gaW5maXggbXVzdCBub3QgY3JlYXRlIGEgcmVjdXJzaXZlIHN0cnVjdHVyZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0SW5maXhDb250cmFjdFZpb2xhdGlvbjogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQyNCxcblx0XHRcdDUxMyxcblx0XHRcdFwiSW5maXggdHlwZSBhbm5vdGF0aW9ucyBtdXN0IGV4cGxpY2l0bHkgZXhwYW5kIHRoZSB0eXBlIGFzIGRlZmluZWQgYnkgdGhlIGJhc2UuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdEluZml4UG9wdWxhdGlvbkNoYWluaW5nOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDI2LFxuXHRcdFx0NTE1LFxuXHRcdFx0XCJQb3B1bGF0aW9uIGluZml4ZXMgY2Fubm90IGhhdmUgbXVsdGlwbGUgZGVjbGFyYXRpb25zLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeFVzaW5nTGlzdE9wZXJhdG9yOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vMCxcblx0XHRcdDUxNyxcblx0XHRcdGBJbmZpeCBpZGVudGlmaWVycyBjYW5ub3QgZW5kIHdpdGggdGhlIGxpc3Qgb3BlcmF0b3IgKCR7U3ludGF4Lmxpc3R9KS5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRJbmZpeFJlZmVyZW5jaW5nTGlzdDogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQyOCxcblx0XHRcdDUxOSxcblx0XHRcdFwiSW5maXhlcyBjYW5ub3QgcmVmZXJlbmNlIGxpc3QgdHlwZXMuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBvcnRhYmlsaXR5SW5maXhIYXNNdWx0aXBsZURlZmluaXRpb25zOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vNDE4LFxuXHRcdFx0NTIxLFxuXHRcdFx0YFBvcnRhYmlsaXR5IGluZml4ZXMgd2l0aCBjb21wYXRpYmxlIHR5cGVzIGNhbm5vdFxuXHRcdFx0YmUgc3BlY2lmaWVkIG1vcmUgdGhhbiBvbmNlLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFBvcnRhYmlsaXR5SW5maXhIYXNVbmlvbjogY3JlYXRlRmF1bHQ8SW5maXhTcGFuPihcblx0XHRcdC8vLzQxOCxcblx0XHRcdDUyMyxcblx0XHRcdFwiUG9ydGFiaWxpdHkgaW5maXhlcyB3aXRoIHVuaW9uZWQgdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYXQgdGhpcyB0aW1lLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRQb3B1bGF0aW9uSW5maXhIYXNNdWx0aXBsZURlZmluaXRpb25zOiBjcmVhdGVGYXVsdDxJbmZpeFNwYW4+KFxuXHRcdFx0Ly8vMCxcblx0XHRcdDUyNSxcblx0XHRcdGBEZWNsYXJhdGlvbnMgaW4gYSBwb3B1bGF0aW9uIGluZml4IGNhbm5vdCBiZSBcblx0XHRcdGRlZmluZWQgdHdpY2UgaW4gdGhlIHNhbWUgcGF0dGVybmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdE5vbWluYWxJbmZpeE11c3RTdWJ0eXBlOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdC8vLzQzMCxcblx0XHRcdDUyNyxcblx0XHRcdFwiUGF0dGVybnMgd2l0aCBub21pbmFsIGluZml4ZXMgcmVxdWlyZSBhbiBpbnB1dCB0aGF0IGlzIFwiICtcblx0XHRcdFwiYSBzdWJ0eXBlIG9mIHRoZSB0eXBlIHNwZWNpZmllZCwgbm90IHRoZSB0eXBlIGl0c2VsZi5cIiksXG5cdFx0XG5cdFx0Ly8jIFBhcnNlIGVycm9yc1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFN0YXRlbWVudEJlZ2luc1dpdGhDb21tYTogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDYwMCxcblx0XHRcdFwiU3RhdGVtZW50cyBjYW5ub3QgYmVnaW4gd2l0aCBhIGNvbW1hLlwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRTdGF0ZW1lbnRCZWdpbnNXaXRoRWxsaXBzaXM6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ2MDIsXG5cdFx0XHRcIlN0YXRlbWVudHMgY2Fubm90IGJlZ2luIHdpdGggYW4gZWxsaXBzaXMgKC4uLikuXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFN0YXRlbWVudEJlZ2luc1dpdGhFc2NhcGVkU3BhY2U6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQ2MDQsXG5cdFx0XHRcIlN0YXRlbWVudHMgY2Fubm90IGJlZ2luIHdpdGggYW4gZXNjYXBlIGNoYXJhY3RlciAoXFxcXCkgXCIgKyBcblx0XHRcdFwidGhhdCBpcyBmb2xsb3dlZCBieSBhIHRhYiBvciBzcGFjZS5cIiksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0U3RhdGVtZW50Q29udGFpbnNPbmx5RXNjYXBlQ2hhcmFjdGVyOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NjA2LFxuXHRcdFx0XCJBIHN0YXRlbWVudCBjYW5ub3QgY29uc2lzdCBvZiBhIHNpbmdsZSBlc2NhcGUgY2hhcmFjdGVyIChcXFxcKVwiKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRTdGF0ZW1lbnRCZWdpbnNXaXRoSW52YWxpZFNlcXVlbmNlOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0NjA4LFxuXHRcdFx0XCJBIHN0YXRlbWVudCBjYW5ub3QgYmVnaW4gd2l0aCB0aGUgc2VxdWVuY2VzOiAvKiwgLyssIG9yIC8/XCIpLFxuXHRcdFxuXHRcdC8vIyBQYXJzaW5nIEZhdWx0c1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFRhYnNBbmRTcGFjZXM6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDAwLFxuXHRcdFx0XCJTdGF0ZW1lbnQgaW5kZW50IGNvbnRhaW5zIGEgbWl4dHVyZSBvZiB0YWJzIGFuZCBzcGFjZXMuXCIsXG5cdFx0XHRGYXVsdFNldmVyaXR5Lndhcm5pbmcpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdER1cGxpY2F0ZURlY2xhcmF0aW9uOiBjcmVhdGVGYXVsdDxTcGFuPihcblx0XHRcdDEwMDEsXG5cdFx0XHRcIkR1cGxpY2F0ZWQgZGVjbGFyYXRpb24uXCIpLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdFVudGVybWluYXRlZENoYXJhY3RlclNldDogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMDIsXG5cdFx0XHRgVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBzZXQuIFBhdHRlcm4gaGFzIGFuIG9wZW5pbmdcblx0XHRcdFwiJHtSZWdleFN5bnRheERlbGltaXRlci5zZXRTdGFydH1cIiBjaGFyYWN0ZXIgd2l0aG91dCBhIG1hdGNoaW5nXG5cdFx0XHRcIiR7UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0RW5kfVwiIGNoYXJhY3Rlci5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRVbnRlcm1pbmF0ZWRHcm91cDogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMDQsXG5cdFx0XHRgVW50ZXJtaW5hdGVkIGdyb3VwLiBQYXR0ZXJuIGhhcyBhbiBvcGVuaW5nXG5cdFx0XHRcIiR7UmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBTdGFydH1cIiBjaGFyYWN0ZXIgd2l0aG91dCBhIG1hdGNoaW5nXG5cdFx0XHRcIiR7UmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBFbmR9XCIgY2hhcmFjdGVyLmApLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdER1cGxpY2F0ZVF1YW50aWZpZXI6IGNyZWF0ZUZhdWx0PFN0YXRlbWVudD4oXG5cdFx0XHQxMDA2LFxuXHRcdFx0YE11bHRpcGxlIGNvbnNlY3V0aXZlIHF1YW50aWZpZXJzICR7cXVhbnRpZmllcnN9IGFyZSBub3QgYWxsb3dlZC5gKSxcblx0XHRcblx0XHQvKiogKi9cblx0XHRVbnRlcm1pbmF0ZWRJbmZpeDogY3JlYXRlRmF1bHQ8U3RhdGVtZW50Pihcblx0XHRcdDEwMDgsXG5cdFx0XHRgVW50ZXJtaW5hdGVkIGluZml4LiBQYXR0ZXJuIGhhcyBhbiBvcGVuaW5nICR7SW5maXhTeW50YXguc3RhcnR9LFxuXHRcdFx0JHtJbmZpeFN5bnRheC5ub21pbmFsU3RhcnR9LCAke0luZml4U3ludGF4LnBhdHRlcm5TdGFydH0gZGVsaW1pdGVyIHdpdGhvdXRcblx0XHRcdGEgbWF0Y2hpbmcgY2xvc2luZyBkZWxpbWl0ZXIuYCksXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0RW1wdHlQYXR0ZXJuOiBjcmVhdGVGYXVsdDxTdGF0ZW1lbnQ+KFxuXHRcdFx0MTAxMCxcblx0XHRcdFwiUGF0dGVybiBoYXMgbm8gbWF0Y2hhYmxlIGNvbnRlbnQuXCIpXG5cdH0pO1xuXG5cblx0Ly8gQWRkaXRpb25hbCBzYWZldHlcblx0QXJyYXkuZnJvbShGYXVsdHMuZWFjaCgpKS5ldmVyeShPYmplY3QuZnJlZXplKTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBJbmZpbml0ZSBpbmNyZW1lbnRhbCBjb3VudGVyLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFZlcnNpb25TdGFtcFxuXHR7XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIG5leHQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNyZWF0ZVN0YW1wID0gKHN0YW1wOiBUU3RhbXBOdW1iZXIpID0+XG5cdFx0XHRcdG5ldyBWZXJzaW9uU3RhbXAoT2JqZWN0LmZyZWV6ZShzdGFtcCkpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMubmV4dFN0YW1wID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW1wKHRoaXMubmV4dFN0YW1wID0gQmlnSW50KDEpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzEwNTc0XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm5leHRTdGFtcCA9PT0gXCJiaWdpbnRcIilcblx0XHRcdFx0XHRyZXR1cm4gY3JlYXRlU3RhbXAoKyt0aGlzLm5leHRTdGFtcCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLm5leHRTdGFtcCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5uZXh0U3RhbXAgPSBbMV07XG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW1wKHRoaXMubmV4dFN0YW1wLnNsaWNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBucyA9IHRoaXMubmV4dFN0YW1wO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobnMpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gUG9seWZpbGwgaW5maW5pdGUgbnVtYmVyIGNvdW50ZXIgZm9yIHVzZSBpbiB0aGUgXG5cdFx0XHRcdFx0Ly8gYWJzZW5jZSBvZiBhIG5hdGl2ZSBCaWdJbnQgaW1wbGVtZW50YXRpb24uXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IG5zLmxlbmd0aDsgaS0tID4gMDspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKG5zW2ldID09PSA5OTlfOTk5Xzk5OV85OTkpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG5zW2ldID0gMDtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKVxuXHRcdFx0XHRcdFx0XHRcdG5zLnVuc2hpZnQoMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG5zW2ldKys7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gY3JlYXRlU3RhbXAobnMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyBuZXh0U3RhbXA6IFRTdGFtcE51bWJlcjtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcm90ZWN0ZWQgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzdGFtcDogVFN0YW1wTnVtYmVyKSB7IH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRuZXdlclRoYW4ob3RoZXJTdGFtcDogVmVyc2lvblN0YW1wKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN0YW1wID4gb3RoZXJTdGFtcC5zdGFtcDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuc3RhbXApID9cblx0XHRcdFx0dGhpcy5zdGFtcC5qb2luKFwiXCIpIDpcblx0XHRcdFx0dGhpcy5zdGFtcC50b1N0cmluZygpO1xuXHRcdH1cblx0fVxuXG5cdHR5cGUgVFN0YW1wTnVtYmVyID0gYmlnaW50IHwgcmVhZG9ubHkgYmlnaW50W10gfCBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBBbHBoYWJldFJhbmdlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGZyb206IG51bWJlcixcblx0XHRcdHJlYWRvbmx5IHRvOiBudW1iZXIpXG5cdFx0eyB9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBBbHBoYWJldFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoLi4ucmFuZ2VzOiBBbHBoYWJldFJhbmdlW10pXG5cdFx0e1xuXHRcdFx0dGhpcy5yYW5nZXMgPSByYW5nZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgZGVmaW5lZCBpbiB0aGUgYWxwaGFiZXQuXG5cdFx0ICovXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMucmFuZ2VzKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8PSByYW5nZS50bzsgaSsrKVxuXHRcdFx0XHRcdHlpZWxkIFN0cmluZy5mcm9tQ29kZVBvaW50KGkpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBkZWZpbmVkIHJhbmdlcyBpbiB0aGUgYWxwaGFiZXQsXG5cdFx0ICogZXhjbHVkaW5nIHRoZSB3aWxkY2FyZCByYW5nZS5cblx0XHQgKi9cblx0XHQqZWFjaFJhbmdlKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXNXaWxkY2FyZCgpKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCByYW5nZUlkeCA9IDA7IHJhbmdlSWR4IDwgdGhpcy5yYW5nZXMubGVuZ3RoIC0gMTspXG5cdFx0XHRcdFx0eWllbGQgdGhpcy5yYW5nZXNbcmFuZ2VJZHgrK107XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdHlpZWxkIHJhbmdlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoc3ltYm9sOiBzdHJpbmcgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKHN5bWJvbCA9PT0gQWxwaGFiZXQud2lsZGNhcmQpXG5cdFx0XHRcdHJldHVybiB0aGlzLmhhc1dpbGRjYXJkKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvZGUgPSB0b0NoYXJDb2RlKHN5bWJvbCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdGlmIChyYW5nZS5mcm9tID49IGNvZGUgJiYgcmFuZ2UudG8gPD0gY29kZSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXNXaWxkY2FyZCgpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgcm5nID0gdGhpcy5yYW5nZXM7XG5cdFx0XHRyZXR1cm4gcm5nLmxlbmd0aCA+IDAgJiYgcm5nW3JuZy5sZW5ndGggLSAxXSA9PT0gQWxwaGFiZXQud2lsZGNhcmRSYW5nZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QsIFxuXHRcdCAqIGZvciB0ZXN0aW5nIGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN5bWJvbHM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdHN5bWJvbHMucHVzaChyYW5nZS5mcm9tID09PSByYW5nZS50byA/XG5cdFx0XHRcdFx0U3RyaW5nLmZyb21Db2RlUG9pbnQocmFuZ2UuZnJvbSkgOlxuXHRcdFx0XHRcdFN0cmluZy5mcm9tQ29kZVBvaW50KHJhbmdlLmZyb20pICsgXCIgLSBcIiArIFN0cmluZy5mcm9tQ29kZVBvaW50KHJhbmdlLnRvKSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmhhc1dpbGRjYXJkKCkpXG5cdFx0XHRcdHN5bWJvbHMucHVzaChBbHBoYWJldC53aWxkY2FyZCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBcIltcIiArIHN5bWJvbHMuam9pbihcIiwgXCIpICsgXCJdXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcmFuZ2VzOiByZWFkb25seSBBbHBoYWJldFJhbmdlW10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBzcGVjaWFsIHRva2VuIHRoYXQgdGhlIHN5c3RlbSB1bmRlcnN0YW5kcyB0byBiZSB0aGVcblx0XHQgKiB3aWxkY2FyZCBjaGFyYWN0ZXIuIFRoZSBsZW5ndGggb2YgdGhlIHRva2VuIGlzIGxvbmdlciB0aGFuIGFueVxuXHRcdCAqIG90aGVyIHRva2VuIHRoYXQgY291bGQgb3RoZXJ3aXNlIGJlIGZvdW5kIGluIHRoZSBhbHBoYWJldC5cblx0XHQgKi9cblx0XHRzdGF0aWMgcmVhZG9ubHkgd2lsZGNhcmQgPSBcIigod2lsZCkpXCI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcmFuZ2UgdGhhdCByZXByZXNlbnRzIHRoZSB3aWxkY2FyZCBjaGFyYWN0ZXIuXG5cdFx0ICogVGhlIHJhbmdlIG9mIHRoZSB3aWxkY2FyZCBpcyBwb3NpdGl2ZSBpbmZpbml0eSBpbiBib3RoIGRpcmVjdGlvbnMsXG5cdFx0ICogdG8gZW5zdXJlIHRoYXQgaXQncyBhbHdheXMgc29ydGVkIGxhc3QgaW4gdGhlIHJhbmdlcyBhcnJheS5cblx0XHQgKi9cblx0XHRzdGF0aWMgcmVhZG9ubHkgd2lsZGNhcmRSYW5nZSA9IE9iamVjdC5mcmVlemUobmV3IEFscGhhYmV0UmFuZ2UoSW5maW5pdHksIEluZmluaXR5KSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICogQSBkaXNwb3NhYmxlIGNsYXNzIGZvciBlYXNpbHkgY3JlYXRpbmcgQWxwaGFiZXQgaW5zdGFuY2VzXG5cdCAqIChUaGlzIGRlc2lnbiBhdm9pZHMgaW50cm9kdWNpbmcgbXV0YWJpbGl0eSBpbnRvIHRoZSBBbHBoYWJldCBjbGFzcykuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQWxwaGFiZXRCdWlsZGVyXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3RvciguLi5vdGhlcnM6IChBbHBoYWJldCB8IEFscGhhYmV0UmFuZ2UgfCBzdHJpbmcgfCBudW1iZXIpW10pXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIG90aGVycylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBBbHBoYWJldClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHRoZVJhbmdlcyA9IEFycmF5LmZyb20oaXRlbS5lYWNoUmFuZ2UoKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCByYW5nZSBvZiB0aGVSYW5nZXMpXG5cdFx0XHRcdFx0XHR0aGlzLnJhbmdlcy5wdXNoKHJhbmdlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQWxwaGFiZXRSYW5nZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMucmFuZ2VzLnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgY29kZSA9IHRvQ2hhckNvZGUoaXRlbSk7XG5cdFx0XHRcdFx0dGhpcy5yYW5nZXMucHVzaChuZXcgQWxwaGFiZXRSYW5nZShjb2RlLCBjb2RlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhbiBlbnRyeSB0byB0aGUgYWxwaGFiZXQuXG5cdFx0ICogSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGVudHJ5IHJlZmVycyB0byBhXG5cdFx0ICogc2luZ2xlIGNoYXJhY3RlciwgcmF0aGVyIHRoYW4gYSByYW5nZSBvZiBjaGFyYWN0ZXJzLlxuXHRcdCAqL1xuXHRcdGFkZChmcm9tOiBzdHJpbmcgfCBudW1iZXIsIHRvPzogc3RyaW5nIHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRvQXNOdW0gPSB0byA9PT0gdW5kZWZpbmVkID8gZnJvbSA6IHRvO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnJhbmdlcy5wdXNoKG5ldyBBbHBoYWJldFJhbmdlKFxuXHRcdFx0XHR0b0NoYXJDb2RlKGZyb20pLFxuXHRcdFx0XHR0b0NoYXJDb2RlKHRvQXNOdW0pKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGRXaWxkKClcblx0XHR7XG5cdFx0XHR0aGlzLnJhbmdlcy5wdXNoKEFscGhhYmV0LndpbGRjYXJkUmFuZ2UpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIG9wdGltaXplZCBBbHBoYWJldCBpbnN0YW5jZXMgY29tcG9zZWQgXG5cdFx0ICogZnJvbSB0aGUgY2hhcmFjdGVycyBhbmQgcmFuZ2VzIGFwcGxpZWQgdG8gdGhpcyBBbHBoYWJldEJ1aWxkZXIuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGludmVydCBJbiB0cnVlLCBjYXVzZXMgdGhlIGVudHJpZXMgaW4gdGhlIGdlbmVyYXRlZFxuXHRcdCAqIEFscGhhYmV0IHRvIGJlIHJldmVyc2VkLCBzdWNoIHRoYXQgZXZlcnkgY2hhcmFjdGVyIG1hcmtlZFxuXHRcdCAqIGFzIGluY2x1ZGVkIGlzIGV4Y2x1ZGVkLCBhbmQgdmljZSB2ZXJzYS5cblx0XHQgKi9cblx0XHR0b0FscGhhYmV0KGludmVydD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucmFuZ2VzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIG5ldyBBbHBoYWJldCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByYW5nZXMgPSB0aGlzLnJhbmdlc1xuXHRcdFx0XHQuc2xpY2UoKVxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcblx0XHRcdFxuXHRcdFx0Ly8gUXVpY2sgb3B0aW1pemF0aW9uIG9mIHJhbmdlc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoIC0gMTsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB0aGlzUmFuZ2UgPSByYW5nZXNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoaSA8IHJhbmdlcy5sZW5ndGggLSAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dFJhbmdlID0gcmFuZ2VzW2kgKyAxXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBPbWl0XG5cdFx0XHRcdFx0aWYgKHRoaXNSYW5nZS50byA+PSBuZXh0UmFuZ2UudG8pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmFuZ2VzLnNwbGljZShpICsgMSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENvbmNhdFxuXHRcdFx0XHRcdGVsc2UgaWYgKHRoaXNSYW5nZS50byArIDEgPj0gbmV4dFJhbmdlLmZyb20pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cmFuZ2VzLnNwbGljZShpICsgMSwgMSk7XG5cdFx0XHRcdFx0XHRyYW5nZXNbaV0gPSBuZXcgQWxwaGFiZXRSYW5nZSh0aGlzUmFuZ2UuZnJvbSwgbmV4dFJhbmdlLnRvKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTmV4dFxuXHRcdFx0XHRcdGVsc2UgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGludmVydClcblx0XHRcdHtcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVGhpcyBhbHBoYWJldCBpbnZlcnNpb24gYWxnb3JpdGhtIGhhcyB0byBkZWFsIHdpdGggNCBjYXNlcyxcblx0XHRcdFx0Ly8gZGVwZW5kaW5nIG9uIHRoZSBwYXR0ZXJuIG9mIHRoZSByYW5nZXMgYW5kIHRoZSBzcGFjZXMuXG5cdFx0XHRcdC8vIEFmdGVyIHRoZSByYW5nZXMgYXJlIHNvcnRlZCBhbmQgb3B0aW1pemVkLCB0aGUgcmFuZ2VzXG5cdFx0XHRcdC8vIGFycmF5IHJlcHJlc2VudHMgYSBsYXlvdXQgdGhhdCBhbHRlcm5hdGVzIGJldHdlZW4gcmFuZ2VzXG5cdFx0XHRcdC8vIGFuZCBzcGFjZXMuIFRoZXJlIGFyZSA0IGJhc2ljIGxheW91dHMgKFIgPSBSYW5nZSwgUyA9IFNwYWNlKTpcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gUlNSUyAtIFN0YXJ0cyB3aXRoIGEgcmFuZ2UsIGVuZHMgd2l0aCBhIHNwYWNlXG5cdFx0XHRcdC8vIFNSU1IgLSBTdGFydHMgd2l0aCBhIHNwYWNlLCBlbmRzIHdpdGggYSByYW5nZVxuXHRcdFx0XHQvLyBSU1JTUiAtIFN0YXJ0cyB3aXRoIGEgcmFuZ2UsIGVuZHMgd2l0aCBhIHJhbmdlXG5cdFx0XHRcdC8vIFNSU1JTIC0gU3RhcnRzIHdpdGggYSBzcGFjZSwgZW5kcyB3aXRoIGEgc3BhY2Vcblx0XHRcdFx0Ly8gXG5cdFx0XHRcdC8vIFRoZSBhbGdvcml0aG0gZGVhbCB3aXRoIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlXG5cdFx0XHRcdC8vIHNlcGFyYXRlbHksIHRvIG1ha2UgdGhlIGxvb3BpbmcgbGVzcyBjb21wbGljYXRlZC4gXG5cdFx0XHRcdC8vIFxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmFuZ2VzSW52OiBBbHBoYWJldFJhbmdlW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlc1plcm8gPSByYW5nZXNbMF0uZnJvbSA9PT0gMDtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlc01heCA9IGxhc3RSYW5nZS50byA9PT0gVW5pY29kZU1heDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtYXRjaGVzWmVybyAmJiBtYXRjaGVzTWF4ICYmIHJhbmdlcy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBBbHBoYWJldCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFtYXRjaGVzWmVybylcblx0XHRcdFx0XHRyYW5nZXNJbnYucHVzaChuZXcgQWxwaGFiZXRSYW5nZSgwLCByYW5nZXNbMF0uZnJvbSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZW5kQXQgPSBtYXRjaGVzTWF4ID9cblx0XHRcdFx0XHRsYXN0UmFuZ2UuZnJvbSA6XG5cdFx0XHRcdFx0VW5pY29kZU1heDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcHJldlJhbmdlRW5kID0gcmFuZ2VzW2ldLnRvO1xuXHRcdFx0XHRcdGNvbnN0IG5leHRSYW5nZVN0YXJ0ID0gaSA8IHJhbmdlcy5sZW5ndGggLSAxID8gXG5cdFx0XHRcdFx0XHRyYW5nZXNbaSArIDFdLmZyb20gOlxuXHRcdFx0XHRcdFx0VW5pY29kZU1heCArIDE7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmFuZ2VzSW52LnB1c2gobmV3IEFscGhhYmV0UmFuZ2UoXG5cdFx0XHRcdFx0XHRwcmV2UmFuZ2VFbmQgKyAxLFxuXHRcdFx0XHRcdFx0bmV4dFJhbmdlU3RhcnQgLSAxKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5leHRSYW5nZVN0YXJ0ID49IGVuZEF0KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmICghbWF0Y2hlc01heClcblx0XHRcdFx0XHRyYW5nZXNJbnYucHVzaChuZXcgQWxwaGFiZXRSYW5nZShsYXN0UmFuZ2UuZnJvbSwgVW5pY29kZU1heCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IEFscGhhYmV0KC4uLnJhbmdlcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcmFuZ2VzOiBBbHBoYWJldFJhbmdlW10gPSBbXTtcblx0fVxuXG5cblx0LyoqICovXG5cdGZ1bmN0aW9uIHRvQ2hhckNvZGUoc3ltYm9sOiBzdHJpbmcgfCBudW1iZXIpXG5cdHtcblx0XHRyZXR1cm4gdHlwZW9mIHN5bWJvbCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRzeW1ib2wuY2hhckNvZGVBdCgwKSA6XG5cdFx0XHRzeW1ib2w7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUcmFuc2l0aW9uTWFwXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcih0cmFuc2l0aW9uTGl0ZXJhbD86IElUcmFuc2l0aW9uTGl0ZXJhbClcblx0XHR7XG5cdFx0XHRjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBUcmFuc2l0aW9uU3RhdGU+KCk7XG5cdFx0XHRcblx0XHRcdGlmICh0cmFuc2l0aW9uTGl0ZXJhbClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFRleHQsIHRzbE9iamVjdF0gb2YgT2JqZWN0LmVudHJpZXModHJhbnNpdGlvbkxpdGVyYWwpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhdGVJZCA9IHBhcnNlSW50KHN0YXRlSWRUZXh0LCAxMCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHN0YXRlSWQgIT09IHN0YXRlSWQpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCF0c2xPYmplY3QgfHwgdHlwZW9mIHRzbE9iamVjdCAhPT0gXCJvYmplY3RcIilcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB0c2w6IElUcmFuc2l0aW9uU3RhdGVMaXRlcmFsID0gdHNsT2JqZWN0O1xuXHRcdFx0XHRcdHRyYW5zaXRpb25zLnNldChzdGF0ZUlkLCBuZXcgVHJhbnNpdGlvblN0YXRlKHRzbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkLCB0cmFuc2l0aW9uU3RhdGVdIG9mIHRoaXMudHJhbnNpdGlvbnMuZW50cmllcygpKVxuXHRcdFx0XHR5aWVsZCA8W251bWJlciwgVHJhbnNpdGlvblN0YXRlXT5bc3RhdGVJZCwgdHJhbnNpdGlvblN0YXRlXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y2xvbmUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IG5ldyBUcmFuc2l0aW9uTWFwKHt9KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy50cmFuc2l0aW9ucylcblx0XHRcdFx0b3V0LnRyYW5zaXRpb25zLnNldChrZXksIHZhbHVlLmNsb25lKCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRoYXMoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHJhbnNpdGlvblN0YXRlID0gdGhpcy50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdGlmICghdHJhbnNpdGlvblN0YXRlKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChzeW1ib2wgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuICEhdHJhbnNpdGlvblN0YXRlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJhbnNpdGlvblN0YXRlLmhhcyhzeW1ib2wpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQoc3RhdGVJZDogbnVtYmVyKTogVHJhbnNpdGlvblN0YXRlIHwgdW5kZWZpbmVkO1xuXHRcdGdldChzdGF0ZUlkOiBudW1iZXIsIHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXHRcdGdldChzdGF0ZUlkOiBudW1iZXIsIHN5bWJvbD86IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCB0cmFuc2l0aW9uU3RhdGUgPSB0aGlzLnRyYW5zaXRpb25zLmdldChzdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0aWYgKCF0cmFuc2l0aW9uU3RhdGUpXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcblx0XHRcdGlmIChzeW1ib2wgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb25TdGF0ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRyYW5zaXRpb25TdGF0ZS5nZXQoc3ltYm9sKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWNxdWlyZShzdGF0ZUlkOiBudW1iZXIpOiBUcmFuc2l0aW9uU3RhdGU7XG5cdFx0YWNxdWlyZShzdGF0ZUlkOiBudW1iZXIsIHN5bWJvbDogc3RyaW5nKTogbnVtYmVyO1xuXHRcdGFjcXVpcmUoc3RhdGVJZDogbnVtYmVyLCBzeW1ib2w/OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHJhbnNpdGlvblN0YXRlID0gdGhpcy50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcblx0XHRcdGlmICghdHJhbnNpdGlvblN0YXRlKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHN5bWJvbCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvblN0YXRlO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdWJTdGF0ZUlkID0gdHJhbnNpdGlvblN0YXRlLmdldChzeW1ib2wpO1xuXHRcdFx0aWYgKHN1YlN0YXRlSWQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdWJTdGF0ZUlkO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqZWFjaFN0YXRlSWQoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVJZCBvZiB0aGlzLnRyYW5zaXRpb25zLmtleXMoKSlcblx0XHRcdFx0eWllbGQgc3RhdGVJZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QsIFxuXHRcdCAqIGZvciB0ZXN0aW5nIGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IFtcIntcIl07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3N0YXRlSWQsIHRTdGF0ZV0gb2YgdGhpcy50cmFuc2l0aW9ucylcblx0XHRcdFx0b3V0LnB1c2goXCJcXHRcIiArIHN0YXRlSWQgKyBcIjogXCIgKyB0U3RhdGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcblx0XHRcdG91dC5wdXNoKFwifVwiKTtcblx0XHRcdHJldHVybiBvdXQuam9pbihcIlxcblwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJvdGVjdGVkIHJlYWRvbmx5IHRyYW5zaXRpb25zOiBNYXA8bnVtYmVyLCBUcmFuc2l0aW9uU3RhdGU+O1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTXV0YWJsZVRyYW5zaXRpb25NYXAgZXh0ZW5kcyBUcmFuc2l0aW9uTWFwXG5cdHtcblx0XHQvKiogKi9cblx0XHRpbml0aWFsaXplKHNyY1N0YXRlSWQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zLnNldChzcmNTdGF0ZUlkLCBuZXcgVHJhbnNpdGlvblN0YXRlKCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRzZXQoc3JjU3RhdGVJZDogbnVtYmVyLCBzeW1ib2w6IHN0cmluZywgZHN0U3RhdGVJZDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHRTdGF0ZSA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlSWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRTdGF0ZSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdFN0YXRlID0gbmV3IFRyYW5zaXRpb25TdGF0ZSgpO1xuXHRcdFx0XHR0U3RhdGUuc2V0KHN5bWJvbCwgZHN0U3RhdGVJZCk7XG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlSWQsIHRTdGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRTdGF0ZS5zZXQoc3ltYm9sLCBkc3RTdGF0ZUlkKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBpbnRlcmZhY2UgSVRyYW5zaXRpb25MaXRlcmFsXG5cdHtcblx0XHRbc3RhdGVJZDogbnVtYmVyXTogSVRyYW5zaXRpb25TdGF0ZUxpdGVyYWw7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBUcmFuc2l0aW9uU3RhdGVcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKHNvdXJjZT86IElUcmFuc2l0aW9uU3RhdGVMaXRlcmFsKVxuXHRcdHtcblx0XHRcdHRoaXMuc3RhdGVNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcblx0XHRcdGlmIChzb3VyY2UpXG5cdFx0XHRcdGZvciAoY29uc3QgW3N5bWJvbCwgc3RhdGVJZF0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSlcblx0XHRcdFx0XHR0aGlzLnN0YXRlTWFwLnNldChzeW1ib2wsIHN0YXRlSWQpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRjbG9uZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2xvbmVkID0gbmV3IFRyYW5zaXRpb25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzeW1ib2wsIHN0YXRlSWRdIG9mIHRoaXMuc3RhdGVNYXApXG5cdFx0XHRcdGNsb25lZC5zdGF0ZU1hcC5zZXQoc3ltYm9sLCBzdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNsb25lZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzKHN5bWJvbDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXRlTWFwLmhhcyhzeW1ib2wpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQoc3ltYm9sOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVNYXAuZ2V0KHN5bWJvbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHNldChzeW1ib2w6IHN0cmluZywgc3RhdGVJZDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdHRoaXMuc3RhdGVNYXAuc2V0KHN5bWJvbCwgc3RhdGVJZCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoU3ltYm9sKClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiB0aGlzLnN0YXRlTWFwLmtleXMoKSlcblx0XHRcdFx0eWllbGQgc3ltYm9sO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdCwgXG5cdFx0ICogZm9yIHRlc3RpbmcgYW5kIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzeW1ib2wsIHN0YXRlSWRdIG9mIHRoaXMuc3RhdGVNYXApXG5cdFx0XHRcdG91dC5wdXNoKFwieyBcIiArIHN5bWJvbCArIFwiOiBcIiArIHN0YXRlSWQgKyBcIiB9XCIpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0Lmxlbmd0aCA/IG91dC5qb2luKFwiLCBcIikgOiBcInt9XCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByb3RlY3RlZCByZWFkb25seSBzdGF0ZU1hcDogTWFwPHN0cmluZywgbnVtYmVyPjtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJVHJhbnNpdGlvblN0YXRlTGl0ZXJhbFxuXHR7XG5cdFx0W3N5bWJvbDogc3RyaW5nXTogbnVtYmVyO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgR3VpZGVcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKGZyb20/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdW10gfCBHdWlkZSlcblx0XHR7XG5cdFx0XHRpZiAoZnJvbSBpbnN0YW5jZW9mIEd1aWRlKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmhhc0RzdCA9IGZyb20uaGFzRHN0O1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiBmcm9tLmFycm93cylcblx0XHRcdFx0XHR0aGlzLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIilcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5hZGQoZnJvbSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChmcm9tKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiBmcm9tKVxuXHRcdFx0XHRcdHRoaXMuYXJyb3dzLnNldChzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y2xvbmUoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNsb25lZCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiB0aGlzLmFycm93cylcblx0XHRcdFx0Y2xvbmVkLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjbG9uZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGhhcyhzdGF0ZUlkU3JjOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyb3dzLmhhcyhzdGF0ZUlkU3JjKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0KHN0YXRlSWRTcmM6IG51bWJlcilcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJvd3MuZ2V0KHN0YXRlSWRTcmMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGQoc3RhdGVJZFNyYzogbnVtYmVyLCBzdGF0ZUlkRHN0OiBudW1iZXIgfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pc0Zyb3plbilcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QgPT09IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYXJyb3dzLnNldChzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0aWYgKHN0YXRlSWREc3QgIT09IHN0YXRlSWREc3QpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMuaGFzRHN0ID09PSB0cnVlICYmIHR5cGVvZiBzdGF0ZUlkRHN0ICE9PSBcIm51bWJlclwiIHx8XG5cdFx0XHRcdFx0dGhpcy5oYXNEc3QgPT09IGZhbHNlICYmIHR5cGVvZiBzdGF0ZUlkRHN0ID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgbmVlZCB0byBiZSBrZXB0IGNvbnNpc3RlbnQgYWNyb3NzIHRoZSBpbnN0YW5jZS5cIik7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmFycm93cy5zZXQoc3RhdGVJZFNyYywgc3RhdGVJZERzdCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuaGFzRHN0ID0gc3RhdGVJZERzdCAhPT0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YXBwZW5kKG90aGVyOiBHdWlkZSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pc0Zyb3plbilcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QgPT09IG51bGwpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3NyYywgZHN0XSBvZiBvdGhlci5hcnJvd3MpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmhhc0RzdCA9IHR5cGVvZiBkc3QgPT09IFwibnVtYmVyXCI7XG5cdFx0XHRcdFx0dGhpcy5hcnJvd3Muc2V0KHNyYywgZHN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3RoZXIuaGFzRHN0ID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAob3RoZXIuc2l6ZSAhPT0gMClcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3NyYywgZHN0XSBvZiBvdGhlci5hcnJvd3MpXG5cdFx0XHRcdFx0dGhpcy5hcnJvd3Muc2V0KHNyYywgZHN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Zmlyc3QoKVxuXHRcdHtcblx0XHRcdGNvbnN0IG91dCA9IHRoaXMuYXJyb3dzLmdldCgwKTtcblx0XHRcdGlmIChvdXQgPT09IG51bGwgfHwgb3V0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqa2V5cygpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBzcmMgb2YgdGhpcy5hcnJvd3Mua2V5cygpKVxuXHRcdFx0XHR5aWVsZCBzcmM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCp2YWx1ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmhhc0RzdCA9PT0gdHJ1ZSlcblx0XHRcdFx0Zm9yIChjb25zdCBkc3Qgb2YgdGhpcy5hcnJvd3MudmFsdWVzKCkpXG5cdFx0XHRcdFx0eWllbGQgTm90Lm51bGwoZHN0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVudHJpZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmhhc0RzdCA9PT0gZmFsc2UpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBlbnVtZXJhdGUgdGhlIGZ1bGwgZW50cmllcyBvZiB0aGlzIGluc3RhbmNlLlwiKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3RhdGVJZFNyYywgc3RhdGVJZERzdF0gb2YgdGhpcy5hcnJvd3MpXG5cdFx0XHRcdHlpZWxkIDxbbnVtYmVyLCBudW1iZXJdPltzdGF0ZUlkU3JjLCBOb3QubnVsbChzdGF0ZUlkRHN0KV07XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5hcnJvd3Muc2l6ZTsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb250ZW50c1xuXHRcdCAqIG9mIHRoaXMgZ3VpZGUgbWF0Y2ggdGhlIGNvbnRlbnRzIG9mIHRoZSBndWlkZSBzcGVjaWZpZWQgaW4gdGhlXG5cdFx0ICogcGFyYW1ldGVyLlxuXHRcdCAqL1xuXHRcdGVxdWFscyhvdGhlcjogR3VpZGUpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtzcmMsIGRzdF0gb2YgdGhpcy5hcnJvd3MpXG5cdFx0XHRcdGlmIChvdGhlci5hcnJvd3MuZ2V0KHNyYykgIT09IGRzdClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRmcmVlemUoKVxuXHRcdHtcblx0XHRcdHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCBcblx0XHQgKiBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5oYXNEc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxpdGVyYWw6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdGF0ZUlkU3JjLCBzdGF0ZUlkRHN0XSBvZiB0aGlzLmFycm93cylcblx0XHRcdFx0XHRsaXRlcmFsLnB1c2goc3RhdGVJZFNyYyArIFwiOiBcIiArIHN0YXRlSWREc3QpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIFwieyBcIiArIGxpdGVyYWwuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gXCJbXCIgKyBBcnJheS5mcm9tKHRoaXMuYXJyb3dzLmtleXMoKSkuam9pbihcIiwgXCIpICsgXCJdXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgaGFzRHN0OiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBpc0Zyb3plbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgYXJyb3dzID0gbmV3IE1hcDxudW1iZXIsIG51bWJlciB8IG51bGw+KCk7XG5cdH1cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGNvZGUgaXMgYSBUeXBlU2NyaXB0IGNvbnZlcnNpb24gb2YgYSBwb3J0aW9uIG9mIHRoZSB0aGUgUHl0aG9uXG4gKiBwcm9qZWN0IFwiZ3JlZW5lcnlcIiwgZnJvbSBHaXRIdWIgdXNlciBcInFudG1cIi4gXG4gKiBcbiAqIFRoZSBncmVlbmVyeSBwcm9qZWN0IGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3FudG0vZ3JlZW5lcnlcbiAqIFxuICogU3BlY2lmaWNhbGx5LCB0aGUgY29kZSBmcm9tIHdoZXJlIHRoaXMgY29kZSBkcmV3IGluc3BpcmF0aW9uIGlzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3FudG0vZ3JlZW5lcnkvYmxvYi9tYXN0ZXIvZ3JlZW5lcnkvZnNtLnB5XG4gKiBcbiAqIFBvc3NpYmx5IHJlbGV2YW50IGJsb2cgcG9zdDpcbiAqIGh0dHBzOi8vcW50bS5vcmcvYWxnb1xuICogXG4gKiBUaGUgb3JpZ2luYWwgTUlUIGxpY2Vuc2UgZnJvbSBncmVlbmVyeSBpcyBhcyBmb2xsb3dzOlxuICogXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgdG8gMjAxNyBieSBxbnRtXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIFxuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRVxuICogT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogT2JsaXZpb24gaXMgYSBTeW1ib2wgb2JqZWN0IHRoYXQgaXMgcmV0dXJuZWQgd2hpbGUgY2FsbGluZyBjcmF3bCgpIGlmIHRoZSBGc21cblx0ICogaXMgdHJhbnNpdGlvbmVkIHRvIHRoZSBvYmxpdmlvbiBzdGF0ZS4gRm9yIGV4YW1wbGUgd2hpbGUgY3Jhd2xpbmcgdHdvIEZzbXNcblx0ICogaW4gcGFyYWxsZWwgd2UgbWF5IHRyYW5zaXRpb24gdG8gdGhlIG9ibGl2aW9uIHN0YXRlIG9mIGJvdGggRnNtcyBhdCBvbmNlLlxuXHQgKiBUaGlzIHdhcnJhbnRzIGFuIG91dC1vZi1ib3VuZCBzaWduYWwgd2hpY2ggd2lsbCByZWR1Y2UgdGhlIGNvbXBsZXhpdHkgb2Zcblx0ICogdGhlIG5ldyBGc20ncyBtYXAuXG5cdCAqL1xuXHRjb25zdCBPYmxpdmlvbiA9IFN5bWJvbCgpO1xuXG5cblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBBIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIG9yIEZzbSBoYXMgYW4gYWxwaGFiZXQgYW5kIGEgc2V0IG9mIHN0YXRlcy4gQXQgYW55XG5cdCAqIGdpdmVuIG1vbWVudCwgdGhlIEZzbSBpcyBpbiBvbmUgc3RhdGUuIFdoZW4gcGFzc2VkIGEgc3ltYm9sIGZyb20gdGhlXG5cdCAqIGFscGhhYmV0LCB0aGUgRnNtIGp1bXBzIHRvIGFub3RoZXIgc3RhdGUgKG9yIHBvc3NpYmx5IHRoZSBzYW1lIHN0YXRlKS5cblx0ICogQSBUcmFuc2l0aW9uTWFwIGluZGljYXRlcyB3aGVyZSB0byBqdW1wLiBPbmUgc3RhdGUgaXMgbm9taW5hdGVkIGFzIHRoZVxuXHQgKiBpbml0aWFsIHN0YXRlLiBaZXJvIG9yIG1vcmUgc3RhdGVzIGFyZSBub21pbmF0ZWQgYXMgZmluYWwgc3RhdGVzLiBJZiwgYWZ0ZXJcblx0ICogY29uc3VtaW5nIGEgc3RyaW5nIG9mIHN5bWJvbHMsIHRoZSBGc20gaXMgaW4gYSBmaW5hbCBzdGF0ZSwgdGhlbiBpdCBpcyBzYWlkXG5cdCAqIHRvIFwiYWNjZXB0XCIgdGhlIHN0cmluZy5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBGc21cblx0e1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZSB0aGF0IGFjY2VwdFxuXHRcdCAqIG5vIGlucHV0cywgbm90IGV2ZW4gYW4gZW1wdHkgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBlbXB0eShhbHBoYWJldDogQWxwaGFiZXQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHNsOiBJVHJhbnNpdGlvblN0YXRlTGl0ZXJhbCA9IHt9O1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiBhbHBoYWJldClcblx0XHRcdFx0dHNsW3N5bWJvbF0gPSAwO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbmV3IEZzbShcblx0XHRcdFx0YWxwaGFiZXQsXG5cdFx0XHRcdG5ldyBTZXQoWzBdKSxcblx0XHRcdFx0MCxcblx0XHRcdFx0bmV3IFNldCgpLFxuXHRcdFx0XHRuZXcgVHJhbnNpdGlvbk1hcCh7IDA6IHRzbCB9KSk7XG5cdFx0fVxuXG5cblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBGc20gdGhhdCBtYXRjaGVzIG9ubHkgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBlcHNpbG9uKGFscGhhYmV0OiBBbHBoYWJldClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IEZzbShcblx0XHRcdFx0YWxwaGFiZXQsXG5cdFx0XHRcdG5ldyBTZXQoWzBdKSxcblx0XHRcdFx0MCxcblx0XHRcdFx0bmV3IFNldChbMF0pLFxuXHRcdFx0XHRuZXcgVHJhbnNpdGlvbk1hcCgpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIEFuIGl0ZXJhYmxlIG9mIHN5bWJvbHMgdGhlIEZzbSBjYW4gYmUgZmVkLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBhbHBoYWJldDogQWxwaGFiZXQsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHNldCBvZiBwb3NzaWJsZSBzdGF0ZXMgZm9yIHRoZSBGc20uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHN0YXRlczogUmVhZG9ubHlTZXQ8bnVtYmVyPixcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgRnNtLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBpbml0aWFsOiBudW1iZXIsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHNldCBvZiBzdGF0ZXMgdGhhdCB0aGUgRnNtIGFjY2VwdHMuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGZpbmFsczogUmVhZG9ubHlTZXQ8bnVtYmVyPixcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNYXkgYmUgc3BhcnNlIChpLmUuIGl0IG1heSBvbWl0IHRyYW5zaXRpb25zKS4gXG5cdFx0XHQgKiBJbiB0aGUgY2FzZSBvZiBvbWl0dGVkIHRyYW5zaXRpb25zLCBhIG5vbi1maW5hbFxuXHRcdFx0ICogXCJvYmxpdmlvblwiIHN0YXRlIGlzIHNpbXVsYXRlZC5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25NYXApXG5cdFx0eyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHByZXNlbnQgRnNtXG5cdFx0ICogYWNjZXB0cyB0aGUgc3VwcGxpZWQgYXJyYXkgb2Ygc3ltYm9scy4gRXF1aXZhbGVudGx5LCBjb25zaWRlciB0aGlzXG5cdFx0ICogRnNtIGluc3RhbmNlIGFzIGEgcG9zc2libHktaW5maW5pdGUgc2V0IG9mIHN0cmluZ3MgYW5kIHRlc3Qgd2hldGhlclxuXHRcdCAqIHRoZSBpbnB1dCBpcyBhIG1lbWJlciBvZiBpdC5cblx0XHQgKiBcblx0XHQgKiBJZiB0aGUgd2lsZGNhcmQgY2hhcmFjdGVyIGlzIHByZXNlbnQgaW4gdGhlIHNwZWNpZmllZCBhbHBoYWJldCwgdGhlblxuXHRcdCAqIGFueSBzeW1ib2wgbm90IGluIHRoZSBzcGVjaWZpZWQgYWxwaGFiZXQgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIFxuXHRcdCAqIHdpbGRjYXJkLlxuXHRcdCAqL1xuXHRcdGFjY2VwdHMoaW5wdXQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCB0aGlzSGFzV2lsZCA9IHRoaXMuYWxwaGFiZXQuaGFzV2lsZGNhcmQoKTtcblx0XHRcdGxldCBzdGF0ZUlkID0gdGhpcy5pbml0aWFsO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGNoYXIgb2YgaW5wdXQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN5bWJvbCA9IHRoaXNIYXNXaWxkICYmICF0aGlzLmFscGhhYmV0LmhhcyhjaGFyKSA/XG5cdFx0XHRcdFx0QWxwaGFiZXQud2lsZGNhcmQgOlxuXHRcdFx0XHRcdGNoYXI7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBNaXNzaW5nIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIHRvIGRlYWQgc3RhdGVcblx0XHRcdFx0aWYgKCF0aGlzLnRyYW5zaXRpb25zLmhhcyhzdGF0ZUlkLCBzeW1ib2wpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG5ld1N0YXRlSWQgPSB0aGlzLnRyYW5zaXRpb25zLmdldChzdGF0ZUlkLCBzeW1ib2wpO1xuXHRcdFx0XHRpZiAobmV3U3RhdGVJZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigpO1xuXHRcdFx0XHRcblx0XHRcdFx0c3RhdGVJZCA9IG5ld1N0YXRlSWQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZpbmFscy5oYXMoc3RhdGVJZCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgcmVkdWNlZCB2ZXJzaW9uIG9mIHRoZSBGc20sIGRvd24gdG8gYSBtaW5pbWFsIGZpbml0ZVxuXHRcdCAqIHN0YXRlIG1hY2hpbmUgZXF1aXZhbGVudC5cblx0XHQgKiBcblx0XHQgKiAoQSByZXN1bHQgYnkgQnJ6b3pvd3NraSAoMTk2Mykgc2hvd3MgdGhhdCBhIG1pbmltYWwgZmluaXRlIHN0YXRlXG5cdFx0ICogbWFjaGluZSBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBjYW4gYmUgb2J0YWluZWQgYnkgcmV2ZXJzaW5nXG5cdFx0ICogdGhlIG9yaWdpbmFsIHR3aWNlLilcblx0XHQgKi9cblx0XHRyZWR1Y2UoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnJldmVyc2UoKS5yZXZlcnNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbmNhdGVuYXRpb25cblx0XHQgKiBvZiB0aGUgc3BlY2lmaWVkIHNlcmllcyBvZiBmaW5pdGUgc3RhdGUgbWFjaGluZXMuXG5cdFx0ICovXG5cdFx0Y29uY2F0ZW5hdGUoLi4uZnNtczogRnNtW10pXG5cdFx0e1xuXHRcdFx0aWYgKGZzbXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZnNtcy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdHJldHVybiBmc21zWzBdO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRha2UgYSBzdGF0ZSBpbiB0aGUgbnVtYmVyZWQgRnNtIGFuZCByZXR1cm4gYSBzZXQgY29udGFpbmluZyBpdCxcblx0XHRcdCAqIHBsdXMgKGlmIGl0J3MgZmluYWwpIHRoZSBmaXJzdCBzdGF0ZSBmcm9tIHRoZSBuZXh0IEZzbSwgXG5cdFx0XHQgKiBwbHVzIChpZiB0aGF0J3MgZmluYWwpIHRoZSBmaXJzdCBzdGF0ZSBmcm9tIHRoZSBuZXh0IGJ1dCBvbmUgRnNtLCBcblx0XHRcdCAqIHBsdXMuLi5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgY29ubmVjdEFsbCA9IChpZHg6IG51bWJlciwgc3Vic3RhdGVJZDogbnVtYmVyKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0cmVzdWx0LmFkZChpZHgsIHN1YnN0YXRlSWQpO1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IGkgPSBpZHg7XG5cdFx0XHRcdGxldCBpZCA9IHN1YnN0YXRlSWQ7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoaSA8IGZzbXMubGVuZ3RoIC0gMSAmJiBmc21zW2ldLmZpbmFscy5oYXMoaWQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGlkID0gZnNtc1tpXS5pbml0aWFsO1xuXHRcdFx0XHRcdHJlc3VsdC5hZGQoaSwgaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBVc2UgYSBzdXBlcnNldCBjb250YWluaW5nIHN0YXRlcyBmcm9tIGFsbCBGc21zIGF0IG9uY2UuXG5cdFx0XHQgKiBXZSBzdGFydCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IEZzbS4gSWYgdGhpcyBzdGF0ZSBpcyBmaW5hbCBpbiB0aGVcblx0XHRcdCAqIGZpcnN0IEZzbSwgdGhlbiB3ZSBhcmUgYWxzbyBhdCB0aGUgc3RhcnQgb2YgdGhlIHNlY29uZCBGc20uIEFuZCBzbyBvbi5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZnNtcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRpbml0aWFsLmFwcGVuZChjb25uZWN0QWxsKDAsIGZzbXNbMF0uaW5pdGlhbCkpO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIElmIHlvdSdyZSBpbiBhIGZpbmFsIHN0YXRlIG9mIHRoZSBmaW5hbCBGc20sIGl0J3MgZmluYWwuXG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGZpbmFsRm4gPSAoZ3VpZGU6IEd1aWRlKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtpLCBzdWJzdGF0ZUlkXSBvZiBndWlkZS5lbnRyaWVzKCkpXG5cdFx0XHRcdFx0aWYgKGkgPT09IGZzbXMubGVuZ3RoIC0gMSAmJiBmc21zW2ldLmZpbmFscy5oYXMoc3Vic3RhdGVJZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZm9sbG93Rm4gPSAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dCA9IG5ldyBHdWlkZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBbaSwgc3Vic3RhdGVJZF0gb2YgZ3VpZGUuZW50cmllcygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZnNtID0gZnNtc1tpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZnNtLnRyYW5zaXRpb25zLmhhcyhzdWJzdGF0ZUlkLCBzeW1ib2wpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0b3JlZFZhbHVlID0gZnNtLnRyYW5zaXRpb25zLmFjcXVpcmUoc3Vic3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0XHRcdG5leHQuYXBwZW5kKGNvbm5lY3RBbGwoaSwgc3RvcmVkVmFsdWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXh0LnNpemUgPT09IDAgP1xuXHRcdFx0XHRcdE9ibGl2aW9uIDpcblx0XHRcdFx0XHRuZXh0O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYWxwaGFiZXRzID0gZnNtcy5tYXAoZnNtID0+IGZzbS5hbHBoYWJldCk7XG5cdFx0XHRjb25zdCBhbHBoYWJldCA9IG5ldyBBbHBoYWJldEJ1aWxkZXIoLi4uYWxwaGFiZXRzKS50b0FscGhhYmV0KCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjcmF3bChhbHBoYWJldCwgaW5pdGlhbCwgZmluYWxGbiwgZm9sbG93Rm4pO1xuXHRcdH1cblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb25jYXRlbmF0ZSB0d28gZmluaXRlIHN0YXRlIG1hY2hpbmVzIHRvZ2V0aGVyLlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGFjY2VwdHMgXCIwKlwiIGFuZCBvdGhlciBhY2NlcHRzIFwiMSsoMHwxKVwiLFxuXHRcdCAqIHdpbGwgcmV0dXJuIGEgZmluaXRlIHN0YXRlIG1hY2hpbmUgYWNjZXB0aW5nIFwiMCoxKygwfDEpXCIuXG5cdFx0ICogQWNjb21wbGlzaGVkIGJ5IGVmZmVjdGl2ZWx5IGZvbGxvd2luZyBub24tZGV0ZXJtaW5pc3RpY2FsbHkuXG5cdFx0ICovXG5cdFx0YWRkKG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uY2F0ZW5hdGUodGhpcywgb3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgcHJlc2VudCBGc20gYWNjZXB0cyBYLCByZXR1cm5zIGFuIEZzbSBhY2NlcHRpbmcgWCpcblx0XHQgKiAoaS5lLiAwIG9yIG1vcmUgaW5zdGFuY2VzIG9mIFgpLiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgYXMgc2ltcGxlXG5cdFx0ICogYXMgbmFpdmVseSBjb25uZWN0aW5nIHRoZSBmaW5hbCBzdGF0ZXMgYmFjayB0byB0aGUgaW5pdGlhbCBzdGF0ZTogXG5cdFx0ICogc2VlIChiKmFiKSogZm9yIGV4YW1wbGUuXG5cdFx0ICovXG5cdFx0c3RhcigpXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZSh0aGlzLmluaXRpYWwpO1xuXHRcdFx0XG5cdFx0XHQvKiogKi9cblx0XHRcdGNvbnN0IGZvbGxvd0ZuID0gKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic3RhdGVJZCBvZiBndWlkZS5rZXlzKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5oYXMoc3Vic3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHRcdG5leHQuYWRkKHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZShzdWJzdGF0ZUlkLCBzeW1ib2wpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJZiBvbmUgb2Ygb3VyIHN1YnN0YXRlcyBpcyBmaW5hbCwgdGhlbiB3ZSBjYW4gYWxzbyBjb25zaWRlclxuXHRcdFx0XHRcdC8vIHRyYW5zaXRpb25zIGZyb20gdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIG9yaWdpbmFsIEZzbS5cblx0XHRcdFx0XHRpZiAodGhpcy5maW5hbHMuaGFzKHN1YnN0YXRlSWQpICYmIHRoaXMudHJhbnNpdGlvbnMuaGFzKHRoaXMuaW5pdGlhbCwgc3ltYm9sKSlcblx0XHRcdFx0XHRcdG5leHQuYWRkKHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZSh0aGlzLmluaXRpYWwsIHN5bWJvbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dC5zaXplID09PSAwID9cblx0XHRcdFx0XHRPYmxpdmlvbiA6XG5cdFx0XHRcdFx0bmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic3RhdGVJZCBvZiBndWlkZS5rZXlzKCkpXG5cdFx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyhzdWJzdGF0ZUlkKSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNyYXdsKHRoaXMuYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKS5vcihGc20uZXBzaWxvbih0aGlzLmFscGhhYmV0KSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdpdmVuIGFuIEZzbSBhbmQgYSBtdWx0aXBsaWNhdGlvbiBmYWN0b3IsIHJldHVybiB0aGUgbXVsdGlwbGllZCBGc20uXG5cdFx0ICovXG5cdFx0bXVsdGlwbHkoZmFjdG9yOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKGZhY3RvciA8IDApXG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUoW1t0aGlzLmluaXRpYWwsIDBdXSk7XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgW3N1YnN0YXRlSWQsIGl0ZXJhdGlvbl0gb2YgZ3VpZGUuZW50cmllcygpKVxuXHRcdFx0XHRcdGlmICh0aGlzLmluaXRpYWwgPT09IHN1YnN0YXRlSWQpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5maW5hbHMuaGFzKHRoaXMuaW5pdGlhbCkgfHwgaXRlcmF0aW9uID09PSBmYWN0b3IpXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmb2xsb3dGbiA9IChndWlkZTogR3VpZGUsIHN5bWJvbDogc3RyaW5nKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzdWJzdGF0ZUlkLCBpdGVyYXRpb25dIG9mIGd1aWRlLmVudHJpZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChpdGVyYXRpb24gPCBmYWN0b3IgJiYgdGhpcy50cmFuc2l0aW9ucy5oYXMoc3Vic3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBudW0gPSB0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUoc3Vic3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0XHRcdG5leHQuYWRkKG51bSwgaXRlcmF0aW9uKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZmluYWxzLmhhcyhudW0pKVxuXHRcdFx0XHRcdFx0XHRuZXh0LmFkZCh0aGlzLmluaXRpYWwsIGl0ZXJhdGlvbiArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5leHQuc2l6ZSA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gT2JsaXZpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBjcmF3bCh0aGlzLmFscGhhYmV0LCBpbml0aWFsLCBmaW5hbEZuLCBmb2xsb3dGbikucmVkdWNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBvYmplY3QgdGhhdCBwcmVzZW50cyB0aGUgdW5pb24gb2Zcblx0XHQgKiBhbGwgc3VwcGxpZWQgRnNtIGluc3RhbmNlcy5cblx0XHQgKi9cblx0XHR1bmlvbiguLi5mc21zOiBGc21bXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gY3Jhd2xQYXJhbGxlbChcblx0XHRcdFx0cHJlcGVuZEZzbSh0aGlzLCBmc21zKSwgXG5cdFx0XHRcdGFjY2VwdHMgPT4gYWNjZXB0cy5zb21lKHZhbCA9PiB2YWwpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgbG9naWNhbCBhbHRlcm5hdGlvbiBiZXR3ZWVuIHRoaXMgRnNtLCBhbmQgdGhlIEZzbVxuXHRcdCAqIGluc3RhbmNlIHN1cHBsaWVkIGluIHRoZSBhcmd1bWVudC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZpbml0ZSBzdGF0ZSBtYWNoaW5lIHdoaWNoIGFjY2VwdHMgYW55IHNlcXVlbmNlIG9mXG5cdFx0ICogc3ltYm9scyB0aGF0IGlzIGFjY2VwdGVkIGJ5IGVpdGhlciBzZWxmIG9yIG90aGVyLiBOb3RlIHRoYXQgdGhlIHNldFxuXHRcdCAqIG9mIHN0cmluZ3MgcmVjb2duaXNlZCBieSB0aGUgdHdvIEZzbXMgdW5kZXJnb2VzIGEgc2V0IHVuaW9uLlxuXHRcdCAqL1xuXHRcdG9yKG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudW5pb24ob3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGVcblx0XHQgKiBpbnRlcnNlY3Rpb24gb2YgYWxsIHN1cHBsaWVkIEZzbSBpbnN0YW5jZXMuXG5cdFx0ICovXG5cdFx0aW50ZXJzZWN0aW9uKC4uLmZzbXM6IEZzbVtdKVxuXHRcdHtcblx0XHRcdHJldHVybiBjcmF3bFBhcmFsbGVsKFxuXHRcdFx0XHRwcmVwZW5kRnNtKHRoaXMsIGZzbXMpLCBcblx0XHRcdFx0YWNjZXB0cyA9PiBhY2NlcHRzLmV2ZXJ5KHZhbCA9PiB2YWwpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVHJlYXQgdGhlIEZzbXMgYXMgc2V0cyBvZiBzdHJpbmdzIGFuZCByZXR1cm4gdGhlXG5cdFx0ICogaW50ZXJzZWN0aW9uIG9mIHRob3NlIHNldHMgaW4gdGhlIGZvcm0gb2YgYSBuZXcgRnNtLlxuXHRcdCAqL1xuXHRcdGFuZChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdGlvbihvdGhlcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb21wdXRlZFxuXHRcdCAqIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIGFsbCBzdXBwbGVkIEZzbSBpbnN0YW5jZXMuXG5cdFx0ICovXG5cdFx0c3ltbWV0cmljRGlmZmVyZW5jZSguLi5mc21zOiBGc21bXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gY3Jhd2xQYXJhbGxlbChcblx0XHRcdFx0cHJlcGVuZEZzbSh0aGlzLCBmc21zKSwgXG5cdFx0XHRcdGFjY2VwdHMgPT4gYWNjZXB0cy5maWx0ZXIodmFsID0+IHZhbCkubGVuZ3RoICUgMiA9PT0gMSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZXMgdGhhdCByZWNvZ25pc2VzIG9ubHkgdGhlIHN0cmluZ3Ncblx0XHQgKiByZWNvZ25pc2VkIGJ5IHRoaXMgRnNtLCBvciB0aGUgRnNtIGluc3RhbmNlIHN1cHBsaWVkIGluIHRoZSBcblx0XHQgKiBvdGhlciBhcmd1bWVudCwgYnV0IG5vdCBib3RoLlxuXHRcdCAqL1xuXHRcdHhvcihvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIG5ldyBGc20gaW5zdGFuY2UgdGhhdCByZWNvZ2l6ZXMgYWxsIGlucHV0cyB0aGF0XG5cdFx0ICogd291bGQgbm90IGJlIGFjY2VwdGVkIGJ5IHRoaXMgRnNtLlxuXHRcdCAqL1xuXHRcdG5vdCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5pdGlhbCA9IG5ldyBHdWlkZShbWzAsIHRoaXMuaW5pdGlhbF1dKTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmb2xsb3dGbiA9IChndWlkZTogR3VpZGUsIHN5bWJvbDogc3RyaW5nKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcdGNvbnN0IGZpcnN0ID0gZ3VpZGUuZmlyc3QoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChmaXJzdCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25zLmhhcyhmaXJzdCwgc3ltYm9sKSlcblx0XHRcdFx0XHRcdG5leHQuYWRkKDAsIHRoaXMudHJhbnNpdGlvbnMuZ2V0KGZpcnN0LCBzeW1ib2wpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXh0O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRjb25zdCBmaW5hbEZuID0gKGd1aWRlOiBHdWlkZSkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZmlyc3QgPSBndWlkZS5maXJzdCgpO1xuXHRcdFx0XHRyZXR1cm4gIShmaXJzdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmluYWxzLmhhcyhmaXJzdCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGNyYXdsKHRoaXMuYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBuZXcgRnNtIHN1Y2ggdGhhdCBmb3IgZXZlcnkgaW5wdXQgdGhhdCB0aGUgc3VwcGxpZWRcblx0XHQgKiBGc20gYWNjZXB0cywgdGhlIG5ldyBGc20gYWNjZXB0cyB0aGUgc2FtZSBpbnB1dCwgYnV0IHJldmVyc2VkLlxuXHRcdCAqL1xuXHRcdHJldmVyc2UoKVxuXHRcdHtcblx0XHRcdC8vIFN0YXJ0IGZyb20gYSBjb21wb3NpdGUgXCJzdGF0ZS1zZXRcIiBjb25zaXN0aW5nIG9mIGFsbCBmaW5hbCBzdGF0ZXMuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gZmluYWwgc3RhdGVzLCB0aGlzIHNldCBpcyBlbXB0eSBhbmQgd2UnbGwgZmluZCB0aGF0XG5cdFx0XHQvLyBubyBvdGhlciBzdGF0ZXMgZ2V0IGdlbmVyYXRlZC5cblx0XHRcdGNvbnN0IGluaXRpYWwgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzdGF0ZUlkIG9mIHRoaXMuZmluYWxzKVxuXHRcdFx0XHRpbml0aWFsLmFkZChzdGF0ZUlkKTtcblx0XHRcdFxuXHRcdFx0Ly8gRmluZCBldmVyeSBwb3NzaWJsZSB3YXkgdG8gcmVhY2ggdGhlIGN1cnJlbnQgc3RhdGUtc2V0XG5cdFx0XHQvLyB1c2luZyB0aGlzIHN5bWJvbC5cblx0XHRcdGNvbnN0IGZvbGxvd0ZuID0gKGd1aWRlOiBHdWlkZSwgc3ltYm9sOiBzdHJpbmcpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBuZXcgR3VpZGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgcHJldlN0YXRlSWQgb2YgdGhpcy50cmFuc2l0aW9ucy5lYWNoU3RhdGVJZCgpKVxuXHRcdFx0XHRcdGZvciAoY29uc3Qgc3RhdGVJZCBvZiBndWlkZS5rZXlzKCkpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy50cmFuc2l0aW9ucy5oYXMocHJldlN0YXRlSWQsIHN5bWJvbCkpXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25zLmdldChwcmV2U3RhdGVJZCwgc3ltYm9sKSA9PT0gc3RhdGVJZClcblx0XHRcdFx0XHRcdFx0XHRuZXh0LmFkZChwcmV2U3RhdGVJZCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV4dC5zaXplID09PSAwID9cblx0XHRcdFx0XHRPYmxpdmlvbiA6XG5cdFx0XHRcdFx0bmV4dDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+IGd1aWRlLmhhcyh0aGlzLmluaXRpYWwpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY3Jhd2wodGhpcy5hbHBoYWJldCwgaW5pdGlhbCwgZmluYWxGbiwgZm9sbG93Rm4pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgRnNtIGluc3RhbmNlXG5cdFx0ICogYWNjZXB0cyB0aGUgc2FtZSBzZXQgb2YgaW5wdXRzIGFzIHRoZSBGc20gaW5zdGFuY2Ugc3BlY2lmaWVkXG5cdFx0ICogaW4gdGhlIGFyZ3VtZW50LlxuXHRcdCAqL1xuXHRcdGVxdWl2YWxlbnQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy54b3Iob3RoZXIpLmlzRW1wdHkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIEZzbSBpbnN0YW5jZVxuXHRcdCAqIGRvZXMgbm90IGFjY2VwdCB0aGUgc2FtZSBzZXQgb2YgaW5wdXRzIGFzIHRoZSBGc20gaW5zdGFuY2Vcblx0XHQgKiBzcGVjaWZpZWQgaW4gdGhlIGFyZ3VtZW50LlxuXHRcdCAqL1xuXHRcdHVuZXF1aXZhbGVudChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiAhdGhpcy54b3Iob3RoZXIpLmlzRW1wdHkoKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gRnNtIGluc3RhbmNlIHdoaWNoIHJlY29nbmlzZXMgb25seSB0aGUgaW5wdXRzXG5cdFx0ICogcmVjb2duaXNlZCBieSB0aGUgZmlyc3QgRnNtIGluc3RhbmNlIGluIHRoZSBsaXN0LCBidXQgbm9uZSBvZiBcblx0XHQgKiB0aGUgb3RoZXJzLlxuXHRcdCAqL1xuXHRcdGRpZmZlcmVuY2UoLi4uZnNtczogRnNtW10pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGNyYXdsUGFyYWxsZWwoXG5cdFx0XHRcdHByZXBlbmRGc20odGhpcywgZnNtcyksIFxuXHRcdFx0XHRhY2NlcHRzID0+IGFjY2VwdHNbMF0gJiYgYWNjZXB0cy5zbGljZSgxKS5ldmVyeShhY2NlcHRzID0+ICFhY2NlcHRzKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgZmluYWwgc3RhdGVcblx0XHQgKiBjYW4gYmUgcmVhY2hlZCBmcm9tIHRoZSBzcGVjaWZpZWQgc3RhdGUuXG5cdFx0ICovXG5cdFx0aXNTdGF0ZUxpdmUoc3RhdGVJZDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHJlYWNoYWJsZSA9IFtzdGF0ZUlkXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCByZWFjaGFibGUubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlSWQgPSByZWFjaGFibGVbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5maW5hbHMuaGFzKGN1cnJlbnRTdGF0ZUlkKSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25zLmhhcyhjdXJyZW50U3RhdGVJZCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uU3RhdGUgPSB0aGlzLnRyYW5zaXRpb25zLmFjcXVpcmUoY3VycmVudFN0YXRlSWQpO1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc3ltYm9sIG9mIHRyYW5zaXRpb25TdGF0ZS5lYWNoU3ltYm9sKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dCA9IHRoaXMudHJhbnNpdGlvbnMuYWNxdWlyZShjdXJyZW50U3RhdGVJZCwgc3ltYm9sKTtcblx0XHRcdFx0XHRcdGlmICghcmVhY2hhYmxlLmluY2x1ZGVzKG5leHQpKVxuXHRcdFx0XHRcdFx0XHRyZWFjaGFibGUucHVzaChuZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBbiBGc20gaXMgZW1wdHkgaWYgaXQgcmVjb2duaXNlcyBubyBzdHJpbmdzLiBBbiBGc20gbWF5IGJlIGFyYml0cmFyaWx5XG5cdFx0ICogY29tcGxpY2F0ZWQgYW5kIGhhdmUgYXJiaXRyYXJpbHkgbWFueSBmaW5hbCBzdGF0ZXMgd2hpbGUgc3RpbGwgcmVjb2duaXNpbmdcblx0XHQgKiBubyBzdHJpbmdzIGJlY2F1c2UgdGhvc2UgZmluYWwgc3RhdGVzIG1heSBhbGwgYmUgaW5hY2Nlc3NpYmxlIGZyb20gdGhlXG5cdFx0ICogaW5pdGlhbCBzdGF0ZS4gRXF1YWxseSwgYW4gRnNtIG1heSBiZSBub24tZW1wdHkgZGVzcGl0ZSBoYXZpbmcgYW4gZW1wdHlcblx0XHQgKiBhbHBoYWJldCBpZiB0aGUgaW5pdGlhbCBzdGF0ZSBpcyBmaW5hbC5cblx0XHQgKi9cblx0XHRpc0VtcHR5KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gIXRoaXMuaXNTdGF0ZUxpdmUodGhpcy5pbml0aWFsKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGUgc3RyaW5ncyAobGlzdHMgb2Ygc3ltYm9scykgdGhhdCB0aGlzIEZzbSBhY2NlcHRzLiBTaW5jZSB0aGVyZSBtYXlcblx0XHQgKiBiZSBpbmZpbml0ZWx5IG1hbnkgb2YgdGhlc2Ugd2UgdXNlIGEgZ2VuZXJhdG9yIGluc3RlYWQgb2YgY29uc3RydWN0aW5nIGFcblx0XHQgKiBzdGF0aWMgbGlzdC4gU3RyaW5ncyB3aWxsIGJlIHNvcnRlZCBpbiBvcmRlciBvZiBsZW5ndGggYW5kIHRoZW4gbGV4aWNhbGx5LlxuXHRcdCAqIFRoaXMgcHJvY2VkdXJlIHVzZXMgYXJiaXRyYXJ5IGFtb3VudHMgb2YgbWVtb3J5IGJ1dCBpcyB2ZXJ5IGZhc3QuIFRoZXJlXG5cdFx0ICogbWF5IGJlIG1vcmUgZWZmaWNpZW50IHdheXMgdG8gZG8gdGhpcywgdGhhdCBJIGhhdmVuJ3QgaW52ZXN0aWdhdGVkIHlldC5cblx0XHQgKiBZb3UgY2FuIHVzZSB0aGlzIGluIGxpc3QgY29tcHJlaGVuc2lvbnMuXG5cdFx0ICovXG5cdFx0KmVhY2hTdHJpbmcoKVxuXHRcdHtcblx0XHRcdFwiTm90IGltcGxlbWVudGVkXCI7XG5cdFx0XHRkZWJ1Z2dlcjtcblx0XHRcdHlpZWxkIFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBhY3Qgb2YgbWVyZ2luZ1xuXHRcdCAqIHRoaXMgRnNtIGluc3RhbmNlIHdpdGggdGhlIEZzbSBpbnN0YW5jZSBzdXBwbGllZCBpbiB0aGUgYXJndW1lbnRcblx0XHQgKiB3b3VsZCByZXN1bHQgaW4gYW4gRnNtIGluc3RhbmNlIHRoYXQgYWNjZXB0cyBubyBpbnB1dHMuXG5cdFx0ICovXG5cdFx0aXNEaXNjcmVwYW50KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5kKG90aGVyKS5pc0VtcHR5KCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzZXQgb2YgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgdGhpcyBGc20gaW5zdGFuY2UgaXMgYSBzdWJzZXQgb2YgdGhlIGlucHV0cyBhY2NlcHRlZCBieSBcblx0XHQgKiBvdGhlciBGc20gaW5zdGFuY2Ugc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdGlzU3Vic2V0KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlmZmVyZW5jZShvdGhlcikuaXNFbXB0eSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IG9mIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IHRoaXMgRnNtIGluc3RhbmNlIGlzIGEgcHJvcGVyIHN1YnNldCBvZiB0aGUgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgb3RoZXIgRnNtIGluc3RhbmNlIHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRpc1Byb3BlclN1YnNldChvdGhlcjogRnNtKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmRpZmZlcmVuY2Uob3RoZXIpLmlzRW1wdHkoKSAmJiB0aGlzLnVuZXF1aXZhbGVudChvdGhlcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzZXQgb2YgaW5wdXRzXG5cdFx0ICogYWNjZXB0ZWQgYnkgdGhpcyBGc20gaW5zdGFuY2UgaXMgYSBzdXBlcnNldCBvZiB0aGUgaW5wdXRzIGFjY2VwdGVkXG5cdFx0ICogYnkgb3RoZXIgRnNtIGluc3RhbmNlIHNwZWNpZmllZC5cblx0XHQgKi9cblx0XHRpc1N1cGVyc2V0KG90aGVyOiBGc20pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG90aGVyLmRpZmZlcmVuY2UodGhpcykuaXNFbXB0eSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2V0IG9mIGlucHV0c1xuXHRcdCAqIGFjY2VwdGVkIGJ5IHRoaXMgRnNtIGluc3RhbmNlIGlzIGEgcHJvcGVyIHN1cGVyc2V0IG9mIHRoZSBpbnB1dHNcblx0XHQgKiBhY2NlcHRlZCBieSBvdGhlciBGc20gaW5zdGFuY2Ugc3BlY2lmaWVkLlxuXHRcdCAqL1xuXHRcdGlzUHJvcGVyU3VwZXJzZXQob3RoZXI6IEZzbSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gb3RoZXIuZGlmZmVyZW5jZSh0aGlzKS5pc0VtcHR5KCkgJiYgb3RoZXIudW5lcXVpdmFsZW50KHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb21wdXRlIHRoZSBCcnpvem93c2tpIGRlcml2YXRpdmUgb2YgdGhpcyBGc20gd2l0aCByZXNwZWN0IHRvIHRoZSBpbnB1dFxuXHRcdCAqIHN0cmluZyBvZiBzeW1ib2xzLiA8aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJ6b3pvd3NraV9kZXJpdmF0aXZlPlxuXHRcdCAqIElmIGFueSBvZiB0aGUgc3ltYm9scyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIGFscGhhYmV0LCB0aGF0J3MgYSBLZXlFcnJvci5cblx0XHQgKiBJZiB5b3UgZmFsbCBpbnRvIG9ibGl2aW9uLCB0aGVuIHRoZSBkZXJpdmF0aXZlIGlzIGFuIEZzbSBhY2NlcHRpbmcgbm9cblx0XHQgKiBzdHJpbmdzLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgbmV3IEZzbSBpbnN0YW5jZSB3aXRoIHRoZSBjb21wdXRlZCBjaGFyYWN0ZXJpc3RpY3MuXG5cdFx0ICovXG5cdFx0ZGVyaXZlKGlucHV0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0bGV0IHN0YXRlSWQ6IG51bWJlciA9IHRoaXMuaW5pdGlhbDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjaGFyIG9mIGlucHV0KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzeW1ib2wgPSAoKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICh0aGlzLmFscGhhYmV0LmhhcyhjaGFyKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuYWxwaGFiZXQuaGFzV2lsZGNhcmQpXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihjaGFyKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIEFscGhhYmV0LndpbGRjYXJkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gY2hhcjtcblx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghdGhpcy50cmFuc2l0aW9ucy5oYXMoc3RhdGVJZCwgc3ltYm9sKSlcblx0XHRcdFx0XHRyZXR1cm4gT2JsaXZpb247XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGF0ZUlkID0gdGhpcy50cmFuc2l0aW9ucy5hY3F1aXJlKHN0YXRlSWQsIHN5bWJvbCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgRnNtKFxuXHRcdFx0XHR0aGlzLmFscGhhYmV0LFxuXHRcdFx0XHR0aGlzLnN0YXRlcyxcblx0XHRcdFx0c3RhdGVJZCxcblx0XHRcdFx0dGhpcy5maW5hbHMsXG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbnMuY2xvbmUoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LCBcblx0XHQgKiBmb3IgdGVzdGluZyBhbmQgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcImFscGhhYmV0ID0gXCIgKyB0aGlzLmFscGhhYmV0LnRvU3RyaW5nKCksXG5cdFx0XHRcdFwic3RhdGVzID0gXCIgKyBBcnJheS5mcm9tKHRoaXMuc3RhdGVzKS5qb2luKCksXG5cdFx0XHRcdFwiaW5pdGFsID0gXCIgKyB0aGlzLmluaXRpYWwsXG5cdFx0XHRcdFwiZmluYWxzID0gXCIgKyBBcnJheS5mcm9tKHRoaXMuZmluYWxzKS5qb2luKCksXG5cdFx0XHRcdFwidHJhbnNpdGlvbnMgPSBcIiArIHRoaXMudHJhbnNpdGlvbnMudG9TdHJpbmcoKVxuXHRcdFx0XS5qb2luKFwiXFxuXCIpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHJlcGVuZCBhbiBGc20gaW5zdGFuY2UgdG8gYW4gRnNtIGFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gcHJlcGVuZEZzbShmc206IEZzbSwgZnNtczogRnNtW10pXG5cdHtcblx0XHRyZXR1cm4gW2ZzbV0uY29uY2F0KC4uLmZzbXMpO1xuXHR9XG5cblxuXHQvKipcblx0ICogQ3Jhd2wgc2V2ZXJhbCBGc21zIGluIHBhcmFsbGVsLCBtYXBwaW5nIHRoZSBzdGF0ZXMgb2YgYSBsYXJnZXIgbWV0YS1Gc20uXG5cdCAqIFRvIGRldGVybWluZSB3aGV0aGVyIGEgc3RhdGUgaW4gdGhlIGxhcmdlciBGc20gaXMgZmluYWwsIHBhc3MgYWxsIG9mIHRoZVxuXHQgKiBmaW5hbGl0eSBzdGF0dXNlcyAoZS5nLiBbdHJ1ZSwgZmFsc2UsIGZhbHNlXSB0byB0ZXN0Rm4uXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmF3bFBhcmFsbGVsKGZzbXM6IEZzbVtdLCB0ZXN0Rm46IChhY2NlcHRzOiBib29sZWFuW10pID0+IGJvb2xlYW4pXG5cdHtcblx0XHRjb25zdCBpbml0aWFsID0gbmV3IEd1aWRlKCk7XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBbaW5kZXgsIGZzbV0gb2YgZnNtcy5lbnRyaWVzKCkpXG5cdFx0XHRpbml0aWFsLmFkZChpbmRleCwgZnNtLmluaXRpYWwpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERlZGljYXRlZCBmdW5jdGlvbiBhY2NlcHRzIGEgXCJzdXBlcnNldFwiIGFuZCByZXR1cm5zIHRoZSBuZXh0IFwic3VwZXJzZXRcIlxuXHRcdCAqIG9idGFpbmVkIGJ5IGZvbGxvd2luZyB0aGlzIHRyYW5zaXRpb24gaW4gdGhlIG5ldyBGc20uXG5cdFx0ICovXG5cdFx0Y29uc3QgZm9sbG93Rm4gPSAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT5cblx0XHR7XG5cdFx0XHRjb25zdCBuZXh0ID0gbmV3IEd1aWRlKCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2luZGV4LCBmc21dIG9mIGZzbXMuZW50cmllcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdGF0ZUlkID0gZ3VpZGUuZ2V0KGluZGV4KTtcblx0XHRcdFx0aWYgKHN0YXRlSWQgPT09IG51bGwgfHwgc3RhdGVJZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc3Vic3RhdGVJZCA9IGZzbS50cmFuc2l0aW9ucy5nZXQoc3RhdGVJZCk7XG5cdFx0XHRcdGlmIChzdWJzdGF0ZUlkID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBhbHBoYSA9IGZzbS5hbHBoYWJldDtcblx0XHRcdFx0Y29uc3QgYWN0dWFsU3ltYm9sID0gYWxwaGEuaGFzKHN5bWJvbCkgJiYgYWxwaGEuaGFzV2lsZGNhcmQoKSA/XG5cdFx0XHRcdFx0QWxwaGFiZXQud2lsZGNhcmQgOlxuXHRcdFx0XHRcdHN5bWJvbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdWJzdGF0ZUlkLmhhcyhhY3R1YWxTeW1ib2wpKVxuXHRcdFx0XHRcdG5leHQuYWRkKGluZGV4LCBmc20udHJhbnNpdGlvbnMuZ2V0KHN0YXRlSWQsIGFjdHVhbFN5bWJvbCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobmV4dC5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gT2JsaXZpb247XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXh0O1xuXHRcdH07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lIHRoZSBcImlzIGZpbmFsP1wiIGNvbmRpdGlvbiBvZiBlYWNoIHN1YnN0YXRlSWQsIHRoZW4gcGFzcyBpdCB0byB0aGVcblx0XHQgKiB0ZXN0IHRvIGRldGVybWluZSBmaW5hbGl0eSBvZiB0aGUgb3ZlcmFsbCBGc20uXG5cdFx0ICovXG5cdFx0Y29uc3QgZmluYWxGbiA9IChndWlkZTogR3VpZGUpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgYWNjZXB0czogYm9vbGVhbltdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2lkeCwgZnNtXSBvZiBmc21zLmVudHJpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3Vic3RhdGVJZCA9IGd1aWRlLmdldChpZHgpO1xuXHRcdFx0XHRpZiAoc3Vic3RhdGVJZCAhPT0gbnVsbCAmJiBzdWJzdGF0ZUlkICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0YWNjZXB0cy5wdXNoKGd1aWRlLmhhcyhpZHgpICYmIGZzbS5maW5hbHMuaGFzKHN1YnN0YXRlSWQpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRlc3RGbihhY2NlcHRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdGNvbnN0IGFscGhhYmV0cyA9IGZzbXMubWFwKGZzbSA9PiBmc20uYWxwaGFiZXQpO1xuXHRcdGNvbnN0IGFscGhhYmV0ID0gbmV3IEFscGhhYmV0QnVpbGRlciguLi5hbHBoYWJldHMpLnRvQWxwaGFiZXQoKTtcblx0XHRyZXR1cm4gY3Jhd2woYWxwaGFiZXQsIGluaXRpYWwsIGZpbmFsRm4sIGZvbGxvd0ZuKS5yZWR1Y2UoKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEdpdmVuIHRoZSBhYm92ZSBjb25kaXRpb25zIGFuZCBpbnN0cnVjdGlvbnMsIGNyYXdsIGEgbmV3IHVua25vd24gRnNtLFxuXHQgKiBtYXBwaW5nIGl0cyBzdGF0ZXMsIGZpbmFsIHN0YXRlcyBhbmQgdHJhbnNpdGlvbnMuIFJldHVybiB0aGUgbmV3IEZzbS5cblx0ICovXG5cdGZ1bmN0aW9uIGNyYXdsKFxuXHRcdGFscGhhYmV0OiBBbHBoYWJldCxcblx0XHRpbml0aWFsOiBHdWlkZSxcblx0XHRmaW5hbEZuOiAoZ3VpZGU6IEd1aWRlKSA9PiBib29sZWFuLFxuXHRcdGZvbGxvd0ZuOiAoZ3VpZGU6IEd1aWRlLCBzeW1ib2w6IHN0cmluZykgPT4gR3VpZGUgfCB0eXBlb2YgT2JsaXZpb24pXG5cdHtcblx0XHRjb25zdCBkZWJ1Z0xpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGd1aWRlcyA9IFtpbml0aWFsXTtcblx0XHRjb25zdCBmaW5hbHMgPSBuZXcgU2V0PG51bWJlcj4oKTtcblx0XHRjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNdXRhYmxlVHJhbnNpdGlvbk1hcCgpO1xuXHRcdFxuXHRcdC8vIEl0ZXJhdGUgb3ZlciBhIGdyb3dpbmcgbGlzdFxuXHRcdGZvciAoY29uc3QgW2ksIGd1aWRlXSBvZiBndWlkZXMuZW50cmllcygpKVxuXHRcdHtcblx0XHRcdC8vIEFkZCB0byBmaW5hbHNcblx0XHRcdGlmIChmaW5hbEZuKGd1aWRlKSlcblx0XHRcdFx0ZmluYWxzLmFkZChpKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29tcHV0ZSB0cmFuc2l0aW9ucyBmb3IgdGhpcyBzdGF0ZVxuXHRcdFx0dHJhbnNpdGlvbnMuaW5pdGlhbGl6ZShpKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzeW1ib2wgb2YgYWxwaGFiZXQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5leHQgPSBmb2xsb3dGbihndWlkZSwgc3ltYm9sKTtcblx0XHRcdFx0aWYgKG5leHQgIT09IE9ibGl2aW9uKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGV0IG5leHRJZHggPSBndWlkZXMuZmluZEluZGV4KGd1aWRlID0+IGd1aWRlLmVxdWFscyhuZXh0KSk7XG5cdFx0XHRcdFx0aWYgKG5leHRJZHggPCAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG5leHRJZHggPSBndWlkZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Z3VpZGVzLnB1c2gobmV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRyYW5zaXRpb25zLnNldChpLCBzeW1ib2wsIG5leHRJZHgpO1xuXHRcdFx0XHRcdGRlYnVnTGluZXMucHVzaChuZXh0LnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBuZXcgRnNtKFxuXHRcdFx0YWxwaGFiZXQsXG5cdFx0XHRuZXcgU2V0KEFycmF5KGd1aWRlcy5sZW5ndGgpLmtleXMoKSksXG5cdFx0XHQwLFxuXHRcdFx0ZmluYWxzLFxuXHRcdFx0dHJhbnNpdGlvbnMpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFRyYW5zbGF0ZXMgUGF0dGVybiBpbnN0YW5jZXMgaW50byBhIGNvcnJlc3BvbmRpbmcgRnNtLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEZzbVRyYW5zbGF0b3Jcblx0e1xuXHRcdC8qKiAqL1xuXHRcdHN0YXRpYyBleGVjKHVuaXRzOiBJdGVyYWJsZTxSZWdleFVuaXQ+KVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiB1bml0cylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleFNldClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyb3VwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JhcGhlbWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhTaWduKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiA8RnNtPm51bGwhO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyB0cmFuc2xhdGVTZXQoXG5cdFx0XHRzZXQ6IFJlZ2V4U2V0LFxuXHRcdFx0YWxwaGE6IEFscGhhYmV0QnVpbGRlciB8IG51bGwgPSBudWxsKVxuXHRcdHtcblx0XHRcdFxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyB0cmFuc2xhdGVHcm91cChcblx0XHRcdGdyb3VwOiBSZWdleEdyb3VwLFxuXHRcdFx0YWxwaGE6IEFscGhhYmV0QnVpbGRlciB8IG51bGwgPSBudWxsKVxuXHRcdHtcblx0XHRcdGNvbnN0IGJ1aWxkZXIgPSBhbHBoYSB8fCBuZXcgQWxwaGFiZXRCdWlsZGVyKCkuYWRkV2lsZCgpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyBjcmVhdGVHcm91cEFscGhhYmV0KGdyb3VwOiBSZWdleEdyb3VwKVxuXHRcdHtcblx0XHRcdGNvbnN0IGJ1aWxkZXIgPSBuZXcgQWxwaGFiZXRCdWlsZGVyKCk7XG5cdFx0XHRidWlsZGVyLmFkZFdpbGQoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBlbGVtZW50IG9mIGdyb3VwLmNhc2VzKVxuXHRcdFx0e1xuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgdHJhbnNsYXRlR3JhcGhlbWUoXG5cdFx0XHRncmFwaGVtZTogUmVnZXhHcmFwaGVtZSxcblx0XHRcdGFscGhhOiBBbHBoYWJldEJ1aWxkZXIgfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgdHJhbnNsYXRlU2lnbihcblx0XHRcdHNpZ246IFJlZ2V4U2lnbixcblx0XHRcdGFscGhhOiBBbHBoYWJldEJ1aWxkZXIgfCBudWxsID0gbnVsbClcblx0XHR7XG5cdFx0XHRcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBEb2N1bWVudFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW50ZXJuYWwgY29uc3RydWN0b3IgZm9yIERvY3VtZW50IG9iamVjdHMuXG5cdFx0ICogRG9jdW1lbnQgb2JqZWN0cyBhcmUgY3JlYXRlZCB2aWEgYSBQcm9ncmFtXG5cdFx0ICogb2JqZWN0LlxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKHByb2dyYW06IFByb2dyYW0sIHNvdXJjZVVyaTogVXJpLCBzb3VyY2VUZXh0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKHNvdXJjZVVyaS50eXBlcy5sZW5ndGgpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcblx0XHRcdHRoaXMuX3NvdXJjZVVyaSA9IHNvdXJjZVVyaTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaW5FZGl0KVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uZG91YmxlVHJhbnNhY3Rpb24oKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50VGV4dCBvZiByZWFkTGluZXMoc291cmNlVGV4dCkpXG5cdFx0XHRcdHRoaXMuc3RhdGVtZW50cy5wdXNoKG5ldyBTdGF0ZW1lbnQodGhpcywgc3RhdGVtZW50VGV4dCkpO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlRG9jdW1lbnRVcmlDaGFuZ2UsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGRhdGEuZG9jdW1lbnQgPT09IHRoaXMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy5pbkVkaXQpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZFdoaWxlSW5FZGl0VHJhbnNhY3Rpb24oKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMuX3NvdXJjZVVyaSA9IGRhdGEubmV3VXJpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyB0aGlzIGRvY3VtZW50IGZvciB0aGUgcm9vdC1sZXZlbCB0eXBlcy5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gdXJpIFRoZSBVUkkgb2YgdGhlIGRvY3VtZW50IHRvIHF1ZXJ5LiBJZiB0aGUgVVJJIGNvbnRhaW5zXG5cdFx0ICogYSB0eXBlIHBhdGgsIGl0IGlzIGZhY3RvcmVkIGludG8gdGhlIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gdHlwZVBhdGggVGhlIHR5cGUgcGF0aCB3aXRoaW4gdGhlIGRvY3VtZW50IHRvIHNlYXJjaC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIGZ1bGx5IGNvbnN0cnVjdGVkIFR5cGUgaW5zdGFuY2UgdGhhdCBjb3JyZXNwb25kcyB0b1xuXHRcdCAqIHRoZSB0eXBlIGF0IHRoZSBVUkkgc3BlY2lmaWVkLCBvciBudWxsIGluIHRoZSBjYXNlIHdoZW4gbm8gdHlwZVxuXHRcdCAqIGNvdWxkIGJlIGZvdW5kLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KC4uLnR5cGVQYXRoOiBzdHJpbmdbXSk6IFR5cGUgfCBudWxsXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMucHJvZ3JhbS5xdWVyeSh0aGlzLCAuLi50eXBlUGF0aCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIHJvb3QtbGV2ZWwgdHlwZXMgdGhhdCBhcmUgZGVmaW5lZCB3aXRoaW4gdGhpcyBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRnZXQgdHlwZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl90eXBlcylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGVzO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZXMgPSBPYmplY3QuZnJlZXplKHRoaXMucHJvZ3JhbS5xdWVyeSh0aGlzKSk7XG5cdFx0fVxuXHRcdHByaXZhdGUgX3R5cGVzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBTdGF0ZW1lbnQgb2JqZWN0cyB0aGF0IHJlcHJlc2VudFxuXHRcdCAqIGFuY2VzdHJ5IG9mIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50LiBJZiB0aGUgc3BlY2lmaWVkXG5cdFx0ICogc3RhdGVtZW50IGlzIG5vdCBpbiB0aGlzIGRvY3VtZW50LCB0aGUgcmV0dXJuZWQgdmFsdWVcblx0XHQgKiBpcyBudWxsLlxuXHRcdCAqL1xuXHRcdGdldEFuY2VzdHJ5KHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNtdCA9IHRoaXMudG9TdGF0ZW1lbnQoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIHN0YXRlbWVudCBpcyByb290LWxldmVsLCBpdCBjYW4ndCBoYXZlIGFuIGFuY2VzdHJ5LlxuXHRcdFx0aWYgKHNtdC5pbmRlbnQgPT09IDApXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3RhcnRpbmdJbmRleCA9IHRoaXMudG9MaW5lTnVtYmVyKHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGlmIChzdGFydGluZ0luZGV4IDwgMClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChzdGFydGluZ0luZGV4ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFuY2VzdHJ5ID0gW3NtdF07XG5cdFx0XHRsZXQgaW5kZW50VG9CZWF0ID0gc210LmluZGVudDtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaWR4ID0gc3RhcnRpbmdJbmRleDsgLS1pZHggPiAtMTspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZW1lbnQgPSB0aGlzLnN0YXRlbWVudHNbaWR4XTtcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaXNOb29wKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50IDwgaW5kZW50VG9CZWF0KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YW5jZXN0cnkudW5zaGlmdChjdXJyZW50U3RhdGVtZW50KTtcblx0XHRcdFx0XHRpbmRlbnRUb0JlYXQgPSBjdXJyZW50U3RhdGVtZW50LmluZGVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50ID09PSAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYW5jZXN0cnkuc2xpY2UoMCwgLTEpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgcGFyZW50IFN0YXRlbWVudCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZFxuXHRcdCAqIFN0YXRlbWVudC4gSWYgdGhlIHN0YXRlbWVudCBpcyB0b3AgbGV2ZWwsIGEgcmVmZXJlbmNlIHRvXG5cdFx0ICogdGhpcyBkb2N1bWVudCBvYmplY3QgaXMgcmV0dXJuZWQuIElmIHRoZSBzdGF0ZW1lbnQgaXNcblx0XHQgKiBub3QgZm91bmQgaW4gdGhlIGRvY3VtZW50LCBvciB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudFxuXHRcdCAqIGlzIGEgbm8tb3AsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudWxsLlxuXHRcdCAqL1xuXHRcdGdldFBhcmVudChzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnRvU3RhdGVtZW50KHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGlmIChzbXQuaXNOb29wKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIHN0YXRlbWVudCBpcyByb290LWxldmVsLCBpdCBjYW4ndCBoYXZlIGEgcGFyZW50LlxuXHRcdFx0aWYgKHNtdC5pbmRlbnQgPT09IDApXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdGFydGluZ0luZGV4ID0gdGhpcy50b0xpbmVOdW1iZXIoc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0aW5nSW5kZXggPCAwKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0aW5nSW5kZXggPT09IDApXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjdXJyZW50SW5kZW50ID0gc210LmluZGVudDtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaWR4ID0gc3RhcnRpbmdJbmRleDsgLS1pZHggPiAtMTspXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZW1lbnQgPSB0aGlzLnN0YXRlbWVudHNbaWR4XTtcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaXNOb29wKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50IDwgY3VycmVudEluZGVudClcblx0XHRcdFx0XHRyZXR1cm4gY3VycmVudFN0YXRlbWVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgYSBwYXJlbnQgc3RhdGVtZW50IHdhc24ndCBmb3VuZCwgdGhlbiB0aGVcblx0XHRcdC8vIGlucHV0IHN0YXRlbWVudCBpcyB0b3AtbGV2ZWwsIGFuZCBhIHJlZmVyZW5jZVxuXHRcdFx0Ly8gdG8gdGhpcyBEb2N1bWVudCBvYmplY3QgaXMgcmV0dXJuZWQuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIFN0YXRlbWVudCB0aGF0IHdvdWxkIGFjdCBhcyB0aGUgcGFyZW50IFxuXHRcdCAqIGlmIGEgc3RhdGVtZW50IHdoZXJlIHRvIGJlIGluc2VydGVkIGF0IHRoZSBzcGVjaWZpZWRcblx0XHQgKiB2aXJ0dWFsIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC4gSWYgYW4gaW5zZXJ0ZWRcblx0XHQgKiBzdGF0ZW1lbnQgd291bGQgYmUgdG9wLWxldmVsLCBhIHJlZmVyZW5jZSB0byB0aGlzIFxuXHRcdCAqIGRvY3VtZW50IG9iamVjdCBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRnZXRQYXJlbnRGcm9tUG9zaXRpb24odmlydHVhbExpbmU6IG51bWJlciwgdmlydHVhbE9mZnNldDogbnVtYmVyKTogU3RhdGVtZW50IHwgdGhpc1xuXHRcdHtcblx0XHRcdGlmICh2aXJ0dWFsTGluZSA9PT0gMCB8fCB2aXJ0dWFsT2Zmc2V0IDwgMSB8fCB0aGlzLnN0YXRlbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0Y29uc3QgbGluZSA9IGFwcGx5Qm91bmRzKHZpcnR1YWxMaW5lLCB0aGlzLnN0YXRlbWVudHMubGVuZ3RoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaWR4ID0gbGluZTsgaWR4LS07KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjdXJyZW50U3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzW2lkeF07XG5cdFx0XHRcdGlmICghY3VycmVudFN0YXRlbWVudC5pc05vb3AgJiYgY3VycmVudFN0YXRlbWVudC5pbmRlbnQgPCB2aXJ0dWFsT2Zmc2V0KVxuXHRcdFx0XHRcdHJldHVybiBjdXJyZW50U3RhdGVtZW50O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIHNpYmxpbmcgU3RhdGVtZW50IG9iamVjdHMgb2YgdGhlIFxuXHRcdCAqIHNwZWNpZmllZCBTdGF0ZW1lbnQuIElmIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50XG5cdFx0ICogaXMgbm90IGZvdW5kIGluIHRoZSBkb2N1bWVudCwgb3IgaXMgYSBuby1vcCwgdGhlXG5cdFx0ICogcmV0dXJuZWQgdmFsdWUgaXMgbnVsbC5cblx0XHQgKi9cblx0XHRnZXRTaWJsaW5ncyhzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlcilcblx0XHR7XG5cdFx0XHRjb25zdCBzbXQgPSB0aGlzLnRvU3RhdGVtZW50KHN0YXRlbWVudCk7XG5cdFx0XHRcblx0XHRcdGlmIChzbXQuaXNOb29wKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHNtdC5pbmRlbnQgPT09IDApXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldENoaWxkcmVuKG51bGwpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudChzbXQpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGFyZW50ID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHBhcmVudCA9PT0gdGhpcylcblx0XHRcdFx0cmV0dXJuIHBhcmVudC5nZXRDaGlsZHJlbihudWxsKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oPFN0YXRlbWVudD5wYXJlbnQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgY2hpbGQgU3RhdGVtZW50IG9iamVjdHMgb2YgdGhlIHNwZWNpZmllZFxuXHRcdCAqIFN0YXRlbWVudC4gSWYgdGhlIGFyZ3VtZW50IGlzIG51bGwgb3Igb21pdHRlZCwgdGhlIGRvY3VtZW50J3Ncblx0XHQgKiB0b3AtbGV2ZWwgc3RhdGVtZW50cyBhcmUgcmV0dXJuZWQuIElmIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50IFxuXHRcdCAqIGlzIG5vdCBmb3VuZCBpbiB0aGUgZG9jdW1lbnQsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudWxsLlxuXHRcdCAqL1xuXHRcdGdldENoaWxkcmVuKHN0YXRlbWVudDogU3RhdGVtZW50IHwgbnVsbCA9IG51bGwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2hpbGRyZW46IFN0YXRlbWVudFtdID0gW107XG5cdFx0XHRcblx0XHRcdC8vIFN0b3JlcyB0aGUgaW5kZW50IHZhbHVlIHRoYXQgY2F1c2VzIHRoZSBsb29wXG5cdFx0XHQvLyB0byB0ZXJtaW5hdGUgd2hlbiByZWFjaGVkLlxuXHRcdFx0Y29uc3QgYnJlYWtJbmRlbnQgPSBzdGF0ZW1lbnQgPyBzdGF0ZW1lbnQuaW5kZW50IDogLTE7XG5cdFx0XHRsZXQgY2hpbGRJbmRlbnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3RhcnRJZHggPSBzdGF0ZW1lbnQgPyBcblx0XHRcdFx0dGhpcy5nZXRMaW5lTnVtYmVyKHN0YXRlbWVudCkgOlxuXHRcdFx0XHQtMTtcblx0XHRcdFx0XG5cdFx0XHRpZiAoc3RhcnRJZHggPj0gdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpZHggPSBzdGFydElkeDsgKytpZHggPCB0aGlzLnN0YXRlbWVudHMubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlbWVudCA9IHRoaXMuc3RhdGVtZW50c1tpZHhdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaXNOb29wKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgbmVlZCB0byBiYWNrIHVwIHRoZSBpbmRlbnRhdGlvblxuXHRcdFx0XHQvLyBvZiBjaGlsZCBzdGF0ZW1lbnRzLCBpbiBvcmRlciB0byBkZWFsIHdpdGggYml6YXJyZVxuXHRcdFx0XHQvLyAoYnV0IHVuZm9ydHVuYXRlbHksIHZhbGlkKSBpbmRlbnRhdGlvbi5cblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50IDwgY2hpbGRJbmRlbnQpXG5cdFx0XHRcdFx0Y2hpbGRJbmRlbnQgPSBjdXJyZW50U3RhdGVtZW50LmluZGVudDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiBhIHNlcmllcyBvZiBhXG5cdFx0XHRcdC8vIHN0YXRlbWVudCBsb2NhbGl0eS5cblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50IDw9IGJyZWFrSW5kZW50KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50IDw9IGNoaWxkSW5kZW50KVxuXHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goY3VycmVudFN0YXRlbWVudCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjaGlsZHJlbjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0YXRlbWVudCwgb3IgdGhlIHN0YXRlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGhhcyBhbnlcblx0XHQgKiBkZXNjZW5kYW50cy4gSWYgdGhlIGFyZ3VtZW50IGlzIG51bGwsIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhXG5cdFx0ICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBkb2N1bWVudCBoYXMgYW55IG5vbi1ub29wXG5cdFx0ICogc3RhdGVtZW50cy5cblx0XHQgKi9cblx0XHRoYXNEZXNjZW5kYW50cyhzdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bWJlciB8IG51bGwpXG5cdFx0e1xuXHRcdFx0aWYgKHN0YXRlbWVudCA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgaWR4ID0gLTE7ICsraWR4IDwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aDspXG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlbWVudHNbaWR4XS5pc05vb3ApXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc210ID0gc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50ID9cblx0XHRcdFx0XHRzdGF0ZW1lbnQgOiBcblx0XHRcdFx0XHR0aGlzLnN0YXRlbWVudHNbc3RhdGVtZW50XTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzbXQuaXNOb29wKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBpZHggPSBzdGF0ZW1lbnQgaW5zdGFuY2VvZiBTdGF0ZW1lbnQgP1xuXHRcdFx0XHRcdHRoaXMuZ2V0TGluZU51bWJlcihzdGF0ZW1lbnQpIDpcblx0XHRcdFx0XHRzdGF0ZW1lbnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoKytpZHggPCB0aGlzLnN0YXRlbWVudHMubGVuZ3RoKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudFN0YXRlbWVudCA9IHRoaXMuc3RhdGVtZW50c1tpZHhdO1xuXHRcdFx0XHRcdGlmIChjdXJyZW50U3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBjdXJyZW50U3RhdGVtZW50LmluZGVudCA+IHNtdC5pbmRlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQgaW5cblx0XHQgKiB0aGUgZG9jdW1lbnQsIHJlbHlpbmcgb24gY2FjaGluZyB3aGVuIGF2YWlsYWJsZS5cblx0XHQgKiBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBkb2N1bWVudCxcblx0XHQgKiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgLTEuXG5cdFx0ICovXG5cdFx0Z2V0TGluZU51bWJlcihzdGF0ZW1lbnQ6IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZW1lbnRzLmluZGV4T2Yoc3RhdGVtZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyB0aGUgY29udGVudFxuXHRcdCAqIHdyaXR0ZW4gaW4gdGhlIGNvbW1lbnRzIGRpcmVjdGx5IGFib3ZlIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBzdGF0ZW1lbnQuIFdoaXRlc3BhY2UgbGluZXMgYXJlIGlnbm9yZWQuIElmIHRoZSBzcGVjaWZpZWRcblx0XHQgKiBzdGF0ZW1lbnQgaXMgYSBuby1vcCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG5cdFx0ICovXG5cdFx0Z2V0Tm90ZXMoc3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc210ID0gdGhpcy50b1N0YXRlbWVudChzdGF0ZW1lbnQpO1xuXHRcdFx0aWYgKHNtdC5pc05vb3ApXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbGluZU51bSA9IHRoaXMuZ2V0TGluZU51bWJlcihzbXQpO1xuXHRcdFx0aWYgKGxpbmVOdW0gPCAxKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvbW1lbnRMaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHRcdGNvbnN0IHJlcXVpcmVkSW5kZW50ID0gc210LmluZGVudDtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgbnVtID0gbGluZU51bTsgbnVtLS07KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjdXJyZW50U3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzW251bV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlbWVudC5pc1doaXRlc3BhY2UpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjb21tZW50VGV4dCA9IGN1cnJlbnRTdGF0ZW1lbnQuZ2V0Q29tbWVudFRleHQoKTtcblx0XHRcdFx0aWYgKGNvbW1lbnRUZXh0ID09PSBudWxsKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZW1lbnQuaW5kZW50ICE9PSByZXF1aXJlZEluZGVudClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNvbW1lbnRMaW5lcy5wdXNoKGNvbW1lbnRUZXh0KTtcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRyZXR1cm4gY29tbWVudExpbmVzO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBFbnVtZXJhdGVzIHRocm91Z2ggZWFjaCBzdGF0ZW1lbnQgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIFxuXHRcdCAqIHNwZWNpZmllZCBzdGF0ZW1lbnQuIElmIHRoZSBwYXJhbWV0ZXJzIGFyZSBudWxsIG9yIG9taXR0ZWQsIGFsbCBcblx0XHQgKiBzdGF0ZW1lbnRzIGluIHRoaXMgRG9jdW1lbnQgYXJlIHlpZWxkZWQuXG5cdFx0ICogXG5cdFx0ICogVGhlIG1ldGhvZCB5aWVsZHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHlpZWxkZWQgc3RhdGVtZW50LFxuXHRcdCAqIGFzIHdlbGwgYXMgYSBudW1lcmljIGxldmVsIHZhbHVlIHRoYXQgc3BlY2lmaWVzIHRoZSBkaWZmZXJlbmNlIGluIFxuXHRcdCAqIHRoZSBudW1iZXIgb2YgbmVzdGluZyBsZXZlbHMgYmV0d2VlbiB0aGUgc3BlY2lmaWVkIGluaXRpYWxTdGF0ZW1lbnRcblx0XHQgKiBhbmQgdGhlIHlpZWxkZWQgc3RhdGVtZW50LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBpbml0aWFsU3RhdGVtZW50IEEgcmVmZXJlbmNlIHRvIHRoZSBzdGF0ZW1lbnQgb2JqZWN0XG5cdFx0ICogZnJvbSB3aGVyZSB0aGUgZW51bWVyYXRpb24gc2hvdWxkIGJlZ2luLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBpbmNsdWRlSW5pdGlhbCBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yXG5cdFx0ICogbm90IHRoZSBzcGVjaWZpZWQgaW5pdGlhbFN0YXRlbWVudCBzaG91bGQgYWxzbyBiZSByZXR1cm5lZFxuXHRcdCAqIGFzIGFuIGVsZW1lbnQgaW4gdGhlIGVudW1lcmF0aW9uLiBJZiB0cnVlLCBpbml0aWFsU3RhdGVtZW50XG5cdFx0ICogbXVzdCBiZSBub24tbnVsbC5cblx0XHQgKi9cblx0XHQqZWFjaERlc2NlbmRhbnQoXG5cdFx0XHRpbml0aWFsU3RhdGVtZW50OiBTdGF0ZW1lbnQgfCBudWxsID0gbnVsbCwgXG5cdFx0XHRpbmNsdWRlSW5pdGlhbD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0aWYgKGluY2x1ZGVJbml0aWFsKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIWluaXRpYWxTdGF0ZW1lbnQpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRBcmd1bWVudCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0eWllbGQgeyBzdGF0ZW1lbnQ6IGluaXRpYWxTdGF0ZW1lbnQsIGxldmVsOiAwIH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGluaXRpYWxDaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oaW5pdGlhbFN0YXRlbWVudCk7XG5cdFx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGluaXRpYWwgbGV2ZWwgaXMgMCBpZiB0aGUgc3BlY2lmaWVkIGluaXRpYWxTdGF0ZW1lbnQgaXNcblx0XHRcdC8vIG51bGwsIGJlY2F1c2UgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGVudW1lcmF0aW9uIHN0YXJ0c1xuXHRcdFx0Ly8gYXQgdGhlIHJvb3Qgb2YgdGhlIGRvY3VtZW50LlxuXHRcdFx0bGV0IGxldmVsID0gaW5pdGlhbFN0YXRlbWVudCA/IDEgOiAwO1xuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiAqcmVjdXJzZShzdGF0ZW1lbnQ6IFN0YXRlbWVudCk6IEl0ZXJhYmxlSXRlcmF0b3I8e1xuXHRcdFx0XHRzdGF0ZW1lbnQ6IFN0YXRlbWVudDtcblx0XHRcdFx0bGV2ZWw6IG51bWJlcjtcblx0XHRcdH0+XG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkIHsgc3RhdGVtZW50LCBsZXZlbCB9O1xuXHRcdFx0XHRcblx0XHRcdFx0bGV2ZWwrKztcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgY2hpbGRTdGF0ZW1lbnQgb2Ygc2VsZi5nZXRDaGlsZHJlbihzdGF0ZW1lbnQpKVxuXHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlKGNoaWxkU3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldmVsLS07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIGluaXRpYWxDaGlsZHJlbilcblx0XHRcdFx0eWllbGQgKnJlY3Vyc2Uoc3RhdGVtZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKiBFbnVtZXJhdGVzIHRocm91Z2ggZWFjaCB1bmlxdWUgVVJJIGRlZmluZWQgaW4gdGhpcyBkb2N1bWVudCxcblx0XHQgKiB0aGF0IGFyZSByZWZlcmVuY2VkIHdpdGhpbiB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZFxuXHRcdCAqIHN0YXRlbWVudC4gSWYgdGhlIHBhcmFtZXRlcnMgYXJlIG51bGwgb3Igb21pdHRlZCwgYWxsIHVuaXF1ZVxuXHRcdCAqIFVSSXMgcmVmZXJlbmNlZCBpbiB0aGlzIGRvY3VtZW50IGFyZSB5aWVsZGVkLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBpbml0aWFsU3RhdGVtZW50IEEgcmVmZXJlbmNlIHRvIHRoZSBzdGF0ZW1lbnQgb2JqZWN0XG5cdFx0ICogZnJvbSB3aGVyZSB0aGUgZW51bWVyYXRpb24gc2hvdWxkIGJlZ2luLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBpbmNsdWRlSW5pdGlhbCBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yXG5cdFx0ICogbm90IHRoZSBzcGVjaWZpZWQgaW5pdGlhbFN0YXRlbWVudCBzaG91bGQgYWxzbyBiZSByZXR1cm5lZFxuXHRcdCAqIGFzIGFuIGVsZW1lbnQgaW4gdGhlIGVudW1lcmF0aW9uLiBJZiB0cnVlLCBpbml0aWFsU3RhdGVtZW50XG5cdFx0ICogbXVzdCBiZSBub24tbnVsbC5cblx0XHQgKi9cblx0XHQqZWFjaFVyaShcblx0XHRcdGluaXRpYWxTdGF0ZW1lbnQ6IFN0YXRlbWVudCB8IG51bGwgPSBudWxsLFxuXHRcdFx0aW5jbHVkZUluaXRpYWw/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdC8vXG5cdFx0XHQvLyBOT1RFOiBBbHRob3VnaCB0aGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLCBpZiBpdCB3ZXJlXG5cdFx0XHQvLyB0byBiZSByZXZpdmVkLCBpdCB3b3VsZCBuZWVkIHRvIHN1cHBvcnQgXCJjcnVmdFwiLlxuXHRcdFx0Ly9cblx0XHRcdFxuXHRcdFx0Y29uc3QgeWllbGRlZFVyaXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblx0XHRcdGNvbnN0IGl0ZXIgPSB0aGlzLmVhY2hEZXNjZW5kYW50KGluaXRpYWxTdGF0ZW1lbnQsIGluY2x1ZGVJbml0aWFsKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBkZXNjZW5kYW50IG9mIGl0ZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiBkZXNjZW5kYW50LnN0YXRlbWVudC5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNwaW5lIG9mIHNwYW4uZmFjdG9yKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgdXJpID0gVXJpLmNsb25lKHNwaW5lKTtcblx0XHRcdFx0XHRcdGNvbnN0IHVyaVRleHQgPSB1cmkudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCF5aWVsZGVkVXJpcy5oYXModXJpVGV4dCkpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHlpZWxkZWRVcmlzLmFkZCh1cmlUZXh0KTtcblx0XHRcdFx0XHRcdFx0eWllbGQgeyB1cmksIHVyaVRleHQgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRW51bWVyYXRlcyB0aHJvdWdoIGVhY2ggc3RhdGVtZW50IGluIHRoZSBkb2N1bWVudCxcblx0XHQgKiBpbmNsdWRpbmcgY29tbWVudHMgYW5kIHdoaXRlc3BhY2Utb25seSBsaW5lcywgc3RhcnRpbmdcblx0XHQgKiBhdCB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudCBvciBudW1lcmljIHBvc2l0aW9uLlxuXHRcdCAqIFxuXHRcdCAqIEB5aWVsZHMgVGhlIHN0YXRlbWVudHMgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcHBlYXJcblx0XHQgKiBpbiB0aGUgZG9jdW1lbnQsIGV4Y2x1ZGluZyB3aGl0ZXNwYWNlLW9ubHkgc3RhdGVtZW50cy5cblx0XHQgKi9cblx0XHQqZWFjaFN0YXRlbWVudChzdGF0ZW1lbnQ/OiBTdGF0ZW1lbnQgfCBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3RhcnROdW0gPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKCFzdGF0ZW1lbnQpXG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3RhdGVtZW50IGluc3RhbmNlb2YgU3RhdGVtZW50KVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldExpbmVOdW1iZXIoc3RhdGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBzdGF0ZW1lbnQ7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnROdW0gLSAxOyArK2kgPCB0aGlzLnN0YXRlbWVudHMubGVuZ3RoOylcblx0XHRcdFx0eWllbGQgdGhpcy5zdGF0ZW1lbnRzW2ldO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWFkcyB0aGUgU3RhdGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cblx0XHQgKiBOZWdhdGl2ZSBudW1iZXJzIHJlYWQgU3RhdGVtZW50IHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZChsaW5lTnVtYmVyOiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0Y29uc3QgbGluZUJvdW5kZWQgPSBhcHBseUJvdW5kcyhsaW5lTnVtYmVyLCB0aGlzLnN0YXRlbWVudHMubGVuZ3RoKTtcblx0XHRcdHJldHVybiB0aGlzLnN0YXRlbWVudHNbbGluZUJvdW5kZWRdO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjb252ZXJ0cyBhIHN0YXRlbWVudCBvciBpdCdzIGluZGV4XG5cdFx0ICogd2l0aGluIHRoaXMgZG9jdW1lbnQgdG8gYSBzdGF0ZW1lbnQgb2JqZWN0LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgdG9TdGF0ZW1lbnQoc3RhdGVtZW50T3JJbmRleDogU3RhdGVtZW50IHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdHJldHVybiBzdGF0ZW1lbnRPckluZGV4IGluc3RhbmNlb2YgU3RhdGVtZW50ID8gXG5cdFx0XHRcdHN0YXRlbWVudE9ySW5kZXggOlxuXHRcdFx0XHR0aGlzLnJlYWQoc3RhdGVtZW50T3JJbmRleCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBxdWlja2x5IHR1cm4gYSB2YWx1ZSB0aGF0IG1heSBiZVxuXHRcdCAqIGEgc3RhdGVtZW50IG9yIGEgc3RhdGVtZW50IGluZGV4LCBpbnRvIGEgYm91bmRlZCBzdGF0ZW1lbnQgXG5cdFx0ICogaW5kZXguXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB0b0xpbmVOdW1iZXIoc3RhdGVtZW50T3JJbmRleDogU3RhdGVtZW50IHwgbnVtYmVyKVxuXHRcdHtcblx0XHRcdHJldHVybiBzdGF0ZW1lbnRPckluZGV4IGluc3RhbmNlb2YgU3RhdGVtZW50ID9cblx0XHRcdFx0dGhpcy5nZXRMaW5lTnVtYmVyKHN0YXRlbWVudE9ySW5kZXgpIDpcblx0XHRcdFx0YXBwbHlCb3VuZHMoc3RhdGVtZW50T3JJbmRleCwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBTdGFydHMgYW4gZWRpdCB0cmFuc2FjdGlvbiBpbiB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHRcdCAqIEVkaXQgdHJhbnNhY3Rpb25zIGFyZSB1c2VkIHRvIHN5bmNocm9uaXplIGNoYW5nZXMgbWFkZSBpblxuXHRcdCAqIGFuIHVuZGVybHlpbmcgZmlsZSwgdHlwaWNhbGx5IGRvbmUgYnkgYSB1c2VyIGluIGEgdGV4dCBlZGl0aW5nXG5cdFx0ICogZW52aXJvbm1lbnQuIFN5c3RlbS1pbml0aWF0ZWQgY2hhbmdlcyBzdWNoIGFzIGF1dG9tYXRlZFxuXHRcdCAqIGZpeGVzLCByZWZhY3RvcnMsIG9yIHJlbmFtZXMgZG8gbm90IGdvIHRocm91Z2ggdGhpcyBwYXRod2F5LlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBlZGl0Rm4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm1cblx0XHQgKiBkb2N1bWVudCBtdXRhdGlvbiBvcGVyYXRpb25zLlxuXHRcdCAqL1xuXHRcdGVkaXQoZWRpdEZuOiAobXV0YXRvcjogSURvY3VtZW50TXV0YXRvcikgPT4gdm9pZClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5pbkVkaXQpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5kb3VibGVUcmFuc2FjdGlvbigpO1xuXHRcdFx0XG5cdFx0XHRjbGFzcyBJbnNlcnRDYWxsIHsgY29uc3RydWN0b3IocmVhZG9ubHkgc210OiBTdGF0ZW1lbnQsIHJlYWRvbmx5IGF0OiBudW1iZXIpIHsgfSB9XG5cdFx0XHRjbGFzcyBVcGRhdGVDYWxsIHsgY29uc3RydWN0b3IocmVhZG9ubHkgc210OiBTdGF0ZW1lbnQsIHJlYWRvbmx5IGF0OiBudW1iZXIpIHsgfSB9XG5cdFx0XHRjbGFzcyBEZWxldGVDYWxsIHsgY29uc3RydWN0b3IocmVhZG9ubHkgYXQ6IG51bWJlciwgcmVhZG9ubHkgY291bnQ6IG51bWJlcikgeyB9IH1cblx0XHRcdHR5cGUgVENhbGxUeXBlID0gSW5zZXJ0Q2FsbCB8IFVwZGF0ZUNhbGwgfCBEZWxldGVDYWxsO1xuXHRcdFx0Y29uc3QgY2FsbHM6IFRDYWxsVHlwZVtdID0gW107XG5cdFx0XHRcblx0XHRcdGxldCBoYXNEZWxldGUgPSBmYWxzZTtcblx0XHRcdGxldCBoYXNJbnNlcnQgPSBmYWxzZTtcblx0XHRcdGxldCBoYXNVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0dGhpcy5pbkVkaXQgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHRlZGl0Rm4oe1xuXHRcdFx0XHRkZWxldGU6IChhdCA9IC0xLCBjb3VudCA9IDEpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY291bnQgPiAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNhbGxzLnB1c2gobmV3IERlbGV0ZUNhbGwoYXQsIGNvdW50KSk7XG5cdFx0XHRcdFx0XHRoYXNEZWxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0aW5zZXJ0OiAodGV4dDogc3RyaW5nLCBhdCA9IC0xKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2FsbHMucHVzaChuZXcgSW5zZXJ0Q2FsbChuZXcgU3RhdGVtZW50KHRoaXMsIHRleHQpLCBhdCkpO1xuXHRcdFx0XHRcdGhhc0luc2VydCA9IHRydWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwZGF0ZTogKHRleHQ6IHN0cmluZywgYXQgPSAtMSkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGJvdW5kQXQgPSBhcHBseUJvdW5kcyhhdCwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCk7XG5cdFx0XHRcdFx0aWYgKHRoaXMucmVhZChib3VuZEF0KS5zb3VyY2VUZXh0ICE9PSB0ZXh0KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNhbGxzLnB1c2gobmV3IFVwZGF0ZUNhbGwobmV3IFN0YXRlbWVudCh0aGlzLCB0ZXh0KSwgYXQpKTtcblx0XHRcdFx0XHRcdGhhc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGNhbGxzLmxlbmd0aCA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5pbkVkaXQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBCZWdpbiB0aGUgYWxnb3JpdGhtIHRoYXQgZGV0ZXJtaW5lcyB0aGUgY2hhbmdlc2V0LFxuXHRcdFx0Ly8gYW5kIHJ1bnMgdGhlIGFwcHJvcHJpYXRlIGludmFsaWRhdGlvbiBhbmQgcmV2YWxpZGF0aW9uXG5cdFx0XHQvLyBob29rcy4gVGhpcyBpcyB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSB3ZSBuZWVkIHRvXG5cdFx0XHQvLyBwZXJmb3JtIGZpbmFsaXphdGlvbiBhdCB0aGUgYm90dG9tIChhbmQgdGhlcmUgYXJlIGVhcmx5XG5cdFx0XHQvLyByZXR1cm4gcG9pbnRzIHRocm91Z2hvdXQgdGhlIGFsZ29yaXRobS5cblx0XHRcdCgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBoYXNNaXhlZCA9XG5cdFx0XHRcdFx0aGFzSW5zZXJ0ICYmIGhhc1VwZGF0ZSB8fFxuXHRcdFx0XHRcdGhhc0luc2VydCAmJiBoYXNEZWxldGUgfHxcblx0XHRcdFx0XHRoYXNVcGRhdGUgJiYgaGFzRGVsZXRlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYm91bmRBdCA9IChjYWxsOiBUQ2FsbFR5cGUpID0+XG5cdFx0XHRcdFx0YXBwbHlCb3VuZHMoY2FsbC5hdCwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkb0RlbGV0ZSA9IChjYWxsOiBEZWxldGVDYWxsKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYXQgPSBib3VuZEF0KGNhbGwpO1xuXHRcdFx0XHRcdGNvbnN0IHNtdHMgPSB0aGlzLnN0YXRlbWVudHMuc3BsaWNlKGF0LCBjYWxsLmNvdW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBzbXRzKVxuXHRcdFx0XHRcdFx0c210LmRpc3Bvc2UoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gc210cztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRvSW5zZXJ0ID0gKGNhbGw6IEluc2VydENhbGwpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY2FsbC5hdCA+PSB0aGlzLnN0YXRlbWVudHMubGVuZ3RoKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGVtZW50cy5wdXNoKGNhbGwuc210KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGF0ID0gYm91bmRBdChjYWxsKTtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGVtZW50cy5zcGxpY2UoYXQsIDAsIGNhbGwuc210KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkb1VwZGF0ZSA9IChjYWxsOiBVcGRhdGVDYWxsKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYXQgPSBib3VuZEF0KGNhbGwpO1xuXHRcdFx0XHRcdHRoaXMuc3RhdGVtZW50c1thdF0uZGlzcG9zZSgpO1xuXHRcdFx0XHRcdHRoaXMuc3RhdGVtZW50c1thdF0gPSBjYWxsLnNtdDtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghaGFzTWl4ZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBUaGlzIGhhbmRsZXMgdGhlIGZpcnN0IG9wdGltaXphdGlvbiwgd2hpY2ggaXMgdGhlIGNhc2Ugd2hlcmVcblx0XHRcdFx0XHQvLyB0aGUgb25seSBraW5kcyBvZiBtdXRhdGlvbnMgd2hlcmUgdXBkYXRlcywgYW5kIG5vIHN0cnVjdHVyYWxcblx0XHRcdFx0XHQvLyBjaGFuZ2VzIG9jY3VyZWQuIFRoaXMgaGFuZGxlcyB0eXBpY2FsIFwidXNlciBpcyB0eXBpbmdcIiBjYXNlcy5cblx0XHRcdFx0XHQvLyBNb3N0IGVkaXRzIHdpbGwgYmUgY2F1Z2h0IGhlcmUuXG5cdFx0XHRcdFx0aWYgKGhhc1VwZGF0ZSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBTb3J0IHRoZSB1cGRhdGUgY2FsbHMgYnkgdGhlaXIgaW5kZXgsIGFuZCBwcnVuZSB1cGRhdGVzXG5cdFx0XHRcdFx0XHQvLyB0aGF0IHdvdWxkIGJlIG92ZXJyaWRkZW4gaW4gYSBmb2xsb3dpbmcgY2FsbC5cblx0XHRcdFx0XHRcdC8vISBSZW1vdmUgdGhpcyB1bm5lY2Vzc2FyeSB2YXJpYWJsZSBvbmNlIHdlIGNhbiBkbyB0aGF0XG5cdFx0XHRcdFx0XHQvLyEgd2l0aG91dCBFU0xpbnQgY29tcGxhaW5pbmcgKHVubmVjZXNzYXJ5IGJyYWNrZXRzKS5cblx0XHRcdFx0XHRcdGNvbnN0IHVwZGF0ZUNhbGxzVHlwZWQgPSBjYWxscyBhcyBVcGRhdGVDYWxsW107XG5cdFx0XHRcdFx0XHRjb25zdCB1cGRhdGVDYWxscyA9IHVwZGF0ZUNhbGxzVHlwZWRcblx0XHRcdFx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IGEuYXQgLSBiLmF0KVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKChjYWxsLCBpKSA9PiBpID49IGNhbGxzLmxlbmd0aCAtIDEgfHwgY2FsbC5hdCAhPT0gY2FsbHNbaSArIDFdLmF0KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3Qgb2xkU3RhdGVtZW50cyA9IHVwZGF0ZUNhbGxzLm1hcChjID0+IHRoaXMuc3RhdGVtZW50c1tjLmF0XSk7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXdTdGF0ZW1lbnRzID0gdXBkYXRlQ2FsbHMubWFwKGMgPT4gYy5zbXQpO1xuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXhlcyA9IE9iamVjdC5mcmVlemUodXBkYXRlQ2FsbHMubWFwKGMgPT4gYy5hdCkpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBub1N0cnVjdHVyYWxDaGFuZ2VzID0gb2xkU3RhdGVtZW50cy5ldmVyeSgob2xkU210LCBpZHgpID0+XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5ld1NtdCA9IG5ld1N0YXRlbWVudHNbaWR4XTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9sZFNtdC5pbmRlbnQgPT09IG5ld1NtdC5pbmRlbnQgfHxcblx0XHRcdFx0XHRcdFx0XHRvbGRTbXQuaXNOb29wICYmIG5ld1NtdC5pc05vb3A7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKG5vU3RydWN0dXJhbENoYW5nZXMpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGhhc09wU3RhdGVtZW50cyA9XG5cdFx0XHRcdFx0XHRcdFx0b2xkU3RhdGVtZW50cy5zb21lKHNtdCA9PiAhc210LmlzTm9vcCkgfHxcblx0XHRcdFx0XHRcdFx0XHRuZXdTdGF0ZW1lbnRzLnNvbWUoc210ID0+ICFzbXQuaXNOb29wKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChoYXNPcFN0YXRlbWVudHMpXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHQvLyBUZWxsIHN1YnNjcmliZXJzIHRvIGJsb3cgYXdheSBhbGwgdGhlIG9sZCBzdGF0ZW1lbnRzLlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VJbnZhbGlkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdG9sZFN0YXRlbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleGVzKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFJ1biB0aGUgYWN0dWFsIG11dGF0aW9uc1xuXHRcdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHVwZGF0ZUNhbGwgb2YgdXBkYXRlQ2FsbHMpXG5cdFx0XHRcdFx0XHRcdFx0ZG9VcGRhdGUodXBkYXRlQ2FsbCk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzT3BTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGVsbCBzdWJzY3JpYmVycyB3aGF0IGNoYW5nZWRcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlUmV2YWxpZGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsIFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3U3RhdGVtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRcdGluZGV4ZXMpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gVGhpcyBoYW5kbGVzIHRoZSBzZWNvbmQgb3B0aW1pemF0aW9uLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVyZVxuXHRcdFx0XHRcdC8vIG9ubHkgZGVsZXRlcyBvY2N1cmVkLCBhbmQgbm9uZSBvZiB0aGUgZGVsZXRlZCBzdGF0ZW1lbnRzIGhhdmUgYW55XG5cdFx0XHRcdFx0Ly8gZGVzY2VuZGFudHMuIFRoaXMgd2lsbCBoYW5kbGUgdGhlIG1ham9yaXR5IG9mIFwiZGVsZXRlIGEgbGluZVwiIGNhc2VzLlxuXHRcdFx0XHRcdGlmIChoYXNEZWxldGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVsZXRlQ2FsbHMgPSA8RGVsZXRlQ2FsbFtdPmNhbGxzO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGVhZFN0YXRlbWVudHM6IFN0YXRlbWVudFtdID0gW107XG5cdFx0XHRcdFx0XHRjb25zdCBkZWFkSW5kZXhlczogbnVtYmVyW10gPSBbXTtcblx0XHRcdFx0XHRcdGxldCBoYXNPcFN0YXRlbWVudHMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yQ2FsbHM6XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGRlbGV0ZUNhbGwgb2YgZGVsZXRlQ2FsbHMpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgZGVsZXRlQ2FsbC5jb3VudDspXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkZWFkU210ID0gdGhpcy5zdGF0ZW1lbnRzW2RlbGV0ZUNhbGwuYXQgKyBpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5oYXNEZXNjZW5kYW50cyhkZWFkU210KSlcblx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWFkU3RhdGVtZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgZm9yQ2FsbHM7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdGRlYWRTdGF0ZW1lbnRzLnB1c2goZGVhZFNtdCk7XG5cdFx0XHRcdFx0XHRcdFx0ZGVhZEluZGV4ZXMucHVzaChpKTtcblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWRlYWRTbXQuaXNOb29wKVxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzT3BTdGF0ZW1lbnRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoZGVhZFN0YXRlbWVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gVGVsbCBzdWJzY3JpYmVycyB0byBibG93IGF3YXkgYWxsIHRoZSBvbGQgc3RhdGVtZW50cy5cblx0XHRcdFx0XHRcdFx0Ly8gQW4gZWRpdCB0cmFuc2FjdGlvbiBjYW4gYmUgYXZvaWRlZCBjb21wbGV0ZWx5IGluIHRoZSBjYXNlXG5cdFx0XHRcdFx0XHRcdC8vIHdoZW4gdGhlIG9ubHkgc3RhdGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZCB3ZXJlIG5vb3BzLlxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzT3BTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VJbnZhbGlkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdGRlYWRTdGF0ZW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVhZEluZGV4ZXMpKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFJ1biB0aGUgYWN0dWFsIG11dGF0aW9uc1xuXHRcdFx0XHRcdFx0XHRkZWxldGVDYWxscy5mb3JFYWNoKGRvRGVsZXRlKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFJ1biBhbiBlbXB0eSByZXZhbGlkYXRpb24gaG9vaywgdG8gY29tcGx5IHdpdGggdGhlXG5cdFx0XHRcdFx0XHRcdC8vIHJ1bGUgdGhhdCBmb3IgZXZlcnkgaW52YWxpZGF0aW9uIGhvb2ssIHRoZXJlIGlzIGFsd2F5cyBhXG5cdFx0XHRcdFx0XHRcdC8vIGNvcnJlc3BvbmRpbmcgcmV2YWxpZGF0aW9uIGhvb2suXG5cdFx0XHRcdFx0XHRcdGlmIChoYXNPcFN0YXRlbWVudHMpXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZVJldmFsaWRhdGUodGhpcywgW10sIFtdKSk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRoaXMgaGFuZGxlcyB0aGUgdGhpcmQgb3B0aW1pemF0aW9uLCB3aGljaCBpcyB0aGUgY2FzZVxuXHRcdFx0XHRcdC8vIHdoZXJlIHRoZXJlIGFyZSBvbmx5IG5vb3Agc3RhdGVtZW50cyBiZWluZyBpbnNlcnRlZFxuXHRcdFx0XHRcdC8vIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdFx0XHRcdGlmIChoYXNJbnNlcnQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgaW5zZXJ0Q2FsbHMgPSA8SW5zZXJ0Q2FsbFtdPmNhbGxzO1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydENhbGxzLmV2ZXJ5KGNhbGwgPT4gY2FsbC5zbXQuaXNOb29wKSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Q2FsbHMuZm9yRWFjaChkb0luc2VydCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBjaGVja3MgdG8gc2VlIGlmIHdlIGNhbiBnZXQgYXdheSB3aXRoXG5cdFx0XHRcdC8vIHBlcmZvcm1pbmcgc2ltcGxpc3RpYyB1cGRhdGVzIGhhdmUgZmFpbGVkLiBTbyB3ZSBuZWVkXG5cdFx0XHRcdC8vIHRvIHJlc29ydCB0byBpbnZhbGlkYXRpbmcgYW5kIHJldmFsaWRhdGluZyBsYXJnZXIgc3dhdGhzIFxuXHRcdFx0XHQvLyBvZiBzdGF0ZW1lbnRzLlxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gU3RvcmVzIGFuIGFycmF5IG9mIHN0YXRlbWVudHMgd2hvc2UgZGVzY2VuZGFudCBzdGF0ZW1lbnRzXG5cdFx0XHRcdC8vIHNob3VsZCBiZSBpbnZhbGlkYXRlZC4gXG5cdFx0XHRcdC8vY29uc3QgaW52YWxpZGF0ZWRQYXJlbnRzOiB7IGF0OiBudW1iZXI7IHBhcmVudDogU3RhdGVtZW50OyB9W10gPSBbXTtcblx0XHRcdFx0Y29uc3QgaW52YWxpZGF0ZWRQYXJlbnRzID0gbmV3IE1hcDxudW1iZXIsIFN0YXRlbWVudD4oKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFN0b3JlcyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZW50aXJlIGRvY3VtZW50XG5cdFx0XHRcdC8vIG5lZWRzIHRvIGJlIGludmFsaWRhdGVkLlxuXHRcdFx0XHRsZXQgbXVzdEludmFsaWRhdGVEb2MgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZSBmaXJzdCBzdGVwIGlzIHRvIGdvIHRocm91Z2ggYWxsIHRoZSBzdGF0ZW1lbnRzLCBhbmQgY29tcHV0ZSB0aGUgXG5cdFx0XHRcdC8vIHNldCBvZiBwYXJlbnQgc3RhdGVtZW50cyBmcm9tIHdoZXJlIGludmFsaWRhdGlvbiBzaG91bGQgb3JpZ2luYXRlLlxuXHRcdFx0XHQvLyBJbiB0aGUgbWFqb3JpdHkgb2YgY2FzZXMsIHRoaXMgd2lsbCBvbmx5IGJlIG9uZSBzaW5nbGUgc3RhdGVtZW50IG9iamVjdC5cblx0XHRcdFx0Zm9yIChjb25zdCBjYWxsIG9mIGNhbGxzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYXRCb3VuZGVkID0gYXBwbHlCb3VuZHMoY2FsbC5hdCwgdGhpcy5zdGF0ZW1lbnRzLmxlbmd0aCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNhbGwgaW5zdGFuY2VvZiBEZWxldGVDYWxsKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlbGV0ZWRTdGF0ZW1lbnQgPSB0aGlzLnN0YXRlbWVudHNbYXRCb3VuZGVkXTtcblx0XHRcdFx0XHRcdGlmIChkZWxldGVkU3RhdGVtZW50LmlzTm9vcClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KGF0Qm91bmRlZCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGludmFsaWRhdGVkUGFyZW50cy5zZXQoY2FsbC5hdCwgcGFyZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRtdXN0SW52YWxpZGF0ZURvYyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoY2FsbCBpbnN0YW5jZW9mIEluc2VydENhbGwpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChjYWxsLnNtdC5pc05vb3ApXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChjYWxsIGluc3RhbmNlb2YgVXBkYXRlQ2FsbClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgb2xkU3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnRzW2F0Qm91bmRlZF07XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAob2xkU3RhdGVtZW50LmlzTm9vcCAmJiBjYWxsLnNtdC5pc05vb3ApXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50RnJvbVBvc2l0aW9uKFxuXHRcdFx0XHRcdFx0XHRjYWxsLmF0LFxuXHRcdFx0XHRcdFx0XHRjYWxsLnNtdC5pbmRlbnQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgU3RhdGVtZW50KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpbnZhbGlkYXRlZFBhcmVudHMuc2V0KGNhbGwuYXQsIHBhcmVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChwYXJlbnQgPT09IHRoaXMpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG11c3RJbnZhbGlkYXRlRG9jID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBbHRob3VnaCB1bmNsZWFyIGhvdyB0aGlzIGNvdWxkIGhhcHBlbiwgaWYgdGhlcmVcblx0XHRcdFx0Ly8gYXJlIG5vIGludmFsaWRhdGVkIHBhcmVudHMsIHdlIGNhbiBzYWZlbHkgcmV0dXJuLlxuXHRcdFx0XHRpZiAoIW11c3RJbnZhbGlkYXRlRG9jICYmIGludmFsaWRhdGVkUGFyZW50cy5zaXplID09PSAwKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFBydW5lIGFueSByZWR1bmRhbnQgcGFyZW50cy4gQSBwYXJlbnQgaXMgcmVkdW5kYW50XG5cdFx0XHRcdC8vIHdoZW4gaXQncyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlciBwYXJlbnQgaW4gdGhlIFxuXHRcdFx0XHQvLyBpbnZhbGlkYXRpb24gYXJyYXkuIFRoZSBhbGdvcml0aG0gYmVsb3cgY29tcGFyZXMgdGhlXG5cdFx0XHRcdC8vIHN0YXRlbWVudCBhbmNlc3RyaWVzIG9mIGVhY2ggcG9zc2libGUgcGFpcnMgb2YgaW52YWxpZGF0ZWRcblx0XHRcdFx0Ly8gcGFyZW50cywgYW5kIHNwbGljZXMgaW52YWxpZGF0ZWQgcGFyZW50cyBvdXQgb2YgdGhlIFxuXHRcdFx0XHQvLyBhcnJheSBpbiB0aGUgY2FzZSB3aGVuIHRoZSBwYXJlbnQgaXMgcGFyZW50ZWQgYnkgc29tZVxuXHRcdFx0XHQvLyBvdGhlciBpbnZhbGlkYXRlZCBwYXJlbnQgaW4gdGhlIGludmFsaWRhdGVkUGFyZW50cyBhcnJheS5cblx0XHRcdFx0Y29uc3QgaW52YWxpZGF0ZWRBbmNlc3RyaWVzOiBTdGF0ZW1lbnRbXVtdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGF0IG9mIGludmFsaWRhdGVkUGFyZW50cy5rZXlzKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBhbmNlc3RyeSA9IHRoaXMuZ2V0QW5jZXN0cnkoYXQpO1xuXHRcdFx0XHRcdGlmIChhbmNlc3RyeSlcblx0XHRcdFx0XHRcdGludmFsaWRhdGVkQW5jZXN0cmllcy5wdXNoKGFuY2VzdHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGludmFsaWRhdGVkQW5jZXN0cmllcy5sZW5ndGggPiAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGludmFsaWRhdGVkQW5jZXN0cmllcy5sZW5ndGg7IGktLTspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlBID0gaW52YWxpZGF0ZWRBbmNlc3RyaWVzW2ldO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBuID0gaTsgbi0tOylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlCID0gaW52YWxpZGF0ZWRBbmNlc3RyaWVzW25dO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGFuY2VzdHJ5QS5sZW5ndGggPT09IGFuY2VzdHJ5Qi5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjb25zdCBhTGVzc0IgPSBhbmNlc3RyeUEubGVuZ3RoIDwgYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlTaG9ydCA9IGFMZXNzQiA/IGFuY2VzdHJ5QSA6IGFuY2VzdHJ5Qjtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5jZXN0cnlMb25nID0gYUxlc3NCID8gYW5jZXN0cnlCIDogYW5jZXN0cnlBO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKGFuY2VzdHJ5U2hvcnQuZXZlcnkoKHNtdCwgaWR4KSA9PiBzbXQgPT09IGFuY2VzdHJ5TG9uZ1tpZHhdKSlcblx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkYXRlZEFuY2VzdHJpZXMuc3BsaWNlKGFMZXNzQiA/IG4gOiBpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHBhcmVudHMgPSBtdXN0SW52YWxpZGF0ZURvYyA/IFtdIDogQXJyYXkuZnJvbShpbnZhbGlkYXRlZFBhcmVudHMudmFsdWVzKCkpO1xuXHRcdFx0XHRjb25zdCBpbmRleGVzID0gbXVzdEludmFsaWRhdGVEb2MgPyBbXSA6IEFycmF5LmZyb20oaW52YWxpZGF0ZWRQYXJlbnRzLmtleXMoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBOb3RpZnkgb2JzZXJ2ZXJzIG9mIHRoZSBJbnZhbGlkYXRlIGhvb2sgdG8gaW52YWxpZGF0ZSB0aGVcblx0XHRcdFx0Ly8gZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCBzZXQgb2YgcGFyZW50IHN0YXRlbWVudHMuXG5cdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VJbnZhbGlkYXRlKHRoaXMsIHBhcmVudHMsIGluZGV4ZXMpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRlbGV0ZWRTdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gUGVyZm9ybSB0aGUgZG9jdW1lbnQgbXV0YXRpb25zLlxuXHRcdFx0XHRmb3IgKGNvbnN0IGNhbGwgb2YgY2FsbHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY2FsbCBpbnN0YW5jZW9mIERlbGV0ZUNhbGwpXG5cdFx0XHRcdFx0XHRkZWxldGVkU3RhdGVtZW50cy5wdXNoKC4uLmRvRGVsZXRlKGNhbGwpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbHNlIGlmIChjYWxsIGluc3RhbmNlb2YgSW5zZXJ0Q2FsbClcblx0XHRcdFx0XHRcdGRvSW5zZXJ0KGNhbGwpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGVsc2UgaWYgKGNhbGwgaW5zdGFuY2VvZiBVcGRhdGVDYWxsKVxuXHRcdFx0XHRcdFx0ZG9VcGRhdGUoY2FsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgZGVsZXRlZCBzdGF0ZW1lbnRzIGZyb20gdGhlIGludmFsaWRhdGVkUGFyZW50cyBtYXBcblx0XHRcdFx0Zm9yIChjb25zdCBkZWxldGVkU3RhdGVtZW50IG9mIGRlbGV0ZWRTdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgW2F0LCBwYXJlbnRTdGF0ZW1lbnRdIG9mIGludmFsaWRhdGVkUGFyZW50cylcblx0XHRcdFx0XHRcdGlmIChkZWxldGVkU3RhdGVtZW50ID09PSBwYXJlbnRTdGF0ZW1lbnQpXG5cdFx0XHRcdFx0XHRcdGludmFsaWRhdGVkUGFyZW50cy5kZWxldGUoYXQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gTm90aWZ5IG9ic2VydmVycyBvZiB0aGUgUmV2YWxpZGF0ZSBob29rIHRvIHVwZGF0ZSB0aGVcblx0XHRcdFx0Ly8gZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCBzZXQgb2YgcGFyZW50IHN0YXRlbWVudHMuXG5cdFx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VSZXZhbGlkYXRlKFxuXHRcdFx0XHRcdHRoaXMsIFxuXHRcdFx0XHRcdEFycmF5LmZyb20oaW52YWxpZGF0ZWRQYXJlbnRzLnZhbHVlcygpKSxcblx0XHRcdFx0XHRBcnJheS5mcm9tKGludmFsaWRhdGVkUGFyZW50cy5rZXlzKCkpXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0Ly8gUGVyZm9ybSBhIGRlYnVnLXRpbWUgY2hlY2sgdG8gYmUgc3VyZSB0aGF0IHRoZXJlIGFyZVxuXHRcdFx0Ly8gbm8gZGlzcG9zZWQgc3RhdGVtZW50cyBsZWZ0IGhhbmdpbmcgYXJvdW5kIGluIHRoZSBkb2N1bWVudFxuXHRcdFx0Ly8gYWZ0ZXIgdGhlIGVkaXQgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cblx0XHRcdGlmIChcIkRFQlVHXCIpXG5cdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIHRoaXMuc3RhdGVtZW50cylcblx0XHRcdFx0XHRpZiAoc210LmlzRGlzcG9zZWQpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdC8vIENsZWFuIG91dCBhbnkgdHlwZSBjYWNoZVxuXHRcdFx0dGhpcy5fdHlwZXMgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHQvLyBUZWxsIHN1YnNjcmliZXJzIHRoYXQgdGhlIGVkaXQgdHJhbnNhY3Rpb24gY29tcGxldGVkLlxuXHRcdFx0dGhpcy5wcm9ncmFtLmNhdXNlKG5ldyBDYXVzZUVkaXRDb21wbGV0ZSh0aGlzKSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuX3ZlcnNpb24gPSBWZXJzaW9uU3RhbXAubmV4dCgpO1xuXHRcdFx0dGhpcy5pbkVkaXQgPSBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXhlY3V0ZXMgYSBjb21wbGV0ZSBlZGl0IHRyYW5zYWN0aW9uLCBhcHBseWluZyB0aGUgc2VyaWVzXG5cdFx0ICogb2YgZWRpdHMgc3BlY2lmaWVkIGluIHRoZSBgZWRpdHNgIHBhcmFtZXRlci4gXG5cdFx0ICovXG5cdFx0ZWRpdEF0b21pYyhlZGl0czogSURvY3VtZW50RWRpdFtdKVxuXHRcdHtcblx0XHRcdHRoaXMuZWRpdChzdGF0ZW1lbnRzID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgZWRpdEluZm8gb2YgZWRpdHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIWVkaXRJbmZvLnJhbmdlKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIHJhbmdlIGluY2x1ZGVkLlwiKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBzdGFydExpbmUgPSBlZGl0SW5mby5yYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxO1xuXHRcdFx0XHRcdGNvbnN0IGVuZExpbmUgPSBlZGl0SW5mby5yYW5nZS5lbmRMaW5lTnVtYmVyIC0gMTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBzdGFydENoYXIgPSBlZGl0SW5mby5yYW5nZS5zdGFydENvbHVtbiAtIDE7XG5cdFx0XHRcdFx0Y29uc3QgZW5kQ2hhciA9IGVkaXRJbmZvLnJhbmdlLmVuZENvbHVtbiAtIDE7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRMaW5lVGV4dCA9IHRoaXMucmVhZChzdGFydExpbmUpLnNvdXJjZVRleHQ7XG5cdFx0XHRcdFx0Y29uc3QgZW5kTGluZVRleHQgPSB0aGlzLnJlYWQoZW5kTGluZSkuc291cmNlVGV4dDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBwcmVmaXhTZWdtZW50ID0gc3RhcnRMaW5lVGV4dC5zbGljZSgwLCBzdGFydENoYXIpO1xuXHRcdFx0XHRcdGNvbnN0IHN1ZmZpeFNlZ21lbnQgPSBlbmRMaW5lVGV4dC5zbGljZShlbmRDaGFyKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBzZWdtZW50cyA9IGVkaXRJbmZvLnRleHQuc3BsaXQoXCJcXG5cIik7XG5cdFx0XHRcdFx0Y29uc3QgcGFzdENvdW50ID0gZW5kTGluZSAtIHN0YXJ0TGluZSArIDE7XG5cdFx0XHRcdFx0Y29uc3QgcHJlc2VudENvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnN0IGRlbHRhQ291bnQgPSBwcmVzZW50Q291bnQgLSBwYXN0Q291bnQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gRGV0ZWN0IHRoZSBwdXJlIHVwZGF0ZSBjYXNlc1xuXHRcdFx0XHRcdGlmIChkZWx0YUNvdW50ID09PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChwYXN0Q291bnQgPT09IDEpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMudXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRcdHByZWZpeFNlZ21lbnQgKyBlZGl0SW5mby50ZXh0ICsgc3VmZml4U2VnbWVudCwgXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRMaW5lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMudXBkYXRlKHByZWZpeFNlZ21lbnQgKyBzZWdtZW50c1swXSwgc3RhcnRMaW5lKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGVtZW50cy51cGRhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXhTZWdtZW50ICsgc2VnbWVudHNbaV0gKyBzdWZmaXhTZWdtZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRMaW5lKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0c3RhdGVtZW50cy51cGRhdGUoc2VnbWVudHMuc2xpY2UoLTEpWzBdICsgc3VmZml4U2VnbWVudCwgZW5kTGluZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBEZXRlY3QgdGhlIHB1cmUgZGVsZXRlIGNhc2VzXG5cdFx0XHRcdFx0aWYgKGRlbHRhQ291bnQgPCAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlbGV0ZUNvdW50ID0gZGVsdGFDb3VudCAqIC0xO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIERldGVjdCBhIGRlbGV0ZSByYW5naW5nIGZyb20gdGhlIGVuZCBvZiBcblx0XHRcdFx0XHRcdC8vIG9uZSBsaW5lLCB0byB0aGUgZW5kIG9mIGEgc3VjY2Vzc2l2ZSBsaW5lXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRDaGFyID09PSBzdGFydExpbmVUZXh0Lmxlbmd0aClcblx0XHRcdFx0XHRcdFx0aWYgKGVuZENoYXIgPT09IGVuZExpbmVUZXh0Lmxlbmd0aClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMuZGVsZXRlKHN0YXJ0TGluZSArIDEsIGRlbGV0ZUNvdW50KTtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBEZXRlY3QgYSBkZWxldGUgcmFuZ2luZyBmcm9tIHRoZSBzdGFydCBvZlxuXHRcdFx0XHRcdFx0Ly8gb25lIGxpbmUgdG8gdGhlIHN0YXJ0IG9mIGEgc3VjY2Vzc2l2ZSBsaW5lXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRDaGFyICsgZW5kQ2hhciA9PT0gMClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0c3RhdGVtZW50cy5kZWxldGUoc3RhcnRMaW5lLCBkZWxldGVDb3VudCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBEZXRlY3QgdGhlIHB1cmUgaW5zZXJ0IGNhc2VzXG5cdFx0XHRcdFx0aWYgKGRlbHRhQ291bnQgPiAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIEN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLCBhbmQgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIFxuXHRcdFx0XHRcdFx0Ly8gaW5zZXJ0ZWQgY29udGVudCBpcyBlbXB0eSAobW9zdCBsaWtlbHksIGVudGVyIHdhcyBwcmVzc2VkKVx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0Q2hhciA9PT0gc3RhcnRMaW5lVGV4dC5sZW5ndGggJiYgc2VnbWVudHNbMF0gPT09IFwiXCIpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyArK2kgPCBzZWdtZW50cy5sZW5ndGg7KVxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlbWVudHMuaW5zZXJ0KHNlZ21lbnRzW2ldLCBzdGFydExpbmUgKyBpKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBDdXJzb3IgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZSwgYW5kIHRoZVxuXHRcdFx0XHRcdFx0Ly8gbGFzdCBsaW5lIG9mIHRoZSBpbnNlcnRlZCBjb250ZW50IGlzIGVtcHR5LlxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0Q2hhciA9PT0gMCAmJiBzZWdtZW50cy5zbGljZSgtMSlbMF0gPT09IFwiXCIpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgc2VnbWVudHMubGVuZ3RoIC0gMTspXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGVtZW50cy5pbnNlcnQoc2VnbWVudHNbaV0sIHN0YXJ0TGluZSArIGkpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgdGhlIFwiZmFsbGJhY2tcIiBiZWhhdmlvciAtLSBzaW1wbHkgZGVsZXRlIGV2ZXJ5dGhpbmdcblx0XHRcdFx0XHQvLyB0aGF0IGlzIG9sZCwgYW5kIGluc2VydCBldmVyeXRoaW5nIHRoYXQgaXMgbmV3LlxuXHRcdFx0XHRcdGNvbnN0IGRlbGV0ZUNvdW50ID0gZW5kTGluZSAtIHN0YXJ0TGluZSArIDE7XG5cdFx0XHRcdFx0c3RhdGVtZW50cy5kZWxldGUoc3RhcnRMaW5lLCBkZWxldGVDb3VudCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgaW5zZXJ0TGluZXMgPSBzZWdtZW50cy5zbGljZSgpO1xuXHRcdFx0XHRcdGluc2VydExpbmVzWzBdID0gcHJlZml4U2VnbWVudCArIGluc2VydExpbmVzWzBdO1xuXHRcdFx0XHRcdGluc2VydExpbmVzW2luc2VydExpbmVzLmxlbmd0aCAtIDFdICs9IHN1ZmZpeFNlZ21lbnQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBpbnNlcnRMaW5lcy5sZW5ndGg7KVxuXHRcdFx0XHRcdFx0c3RhdGVtZW50cy5pbnNlcnQoaW5zZXJ0TGluZXNbaV0sIHN0YXJ0TGluZSArIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyB0aGUgVVJJIGZyb20gd2hlcmUgdGhpcyBkb2N1bWVudCB3YXMgbG9hZGVkLiAqL1xuXHRcdGdldCBzb3VyY2VVcmkoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9zb3VyY2VVcmk7XG5cdFx0fVxuXHRcdHByaXZhdGUgX3NvdXJjZVVyaTogVXJpO1xuXHRcdFxuXHRcdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgdGhlIENvbXBpbGVyIHRoYXQgb3ducyB0aGlzIERvY3VtZW50LiAqL1xuXHRcdHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBjb21wbGV0ZSBsaXN0IG9mIHRoZSBEb2N1bWVudCdzIHN0YXRlbWVudHMsXG5cdFx0ICogc29ydGVkIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXBwZWFyIGluIHRoZSBmaWxlLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgc3RhdGVtZW50czogU3RhdGVtZW50W10gPSBbXTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIHN0YXRlIHZhcmlhYmxlIHRoYXQgc3RvcmVzIHdoZXRoZXIgYW5cblx0XHQgKiBlZGl0IHRyYW5zYWN0aW9uIGlzIGN1cnJlbnRseSB1bmRlcndheS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGluRWRpdCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEEgcm9sbGluZyB2ZXJzaW9uIHN0YW1wIHRoYXQgaW5jcmVtZW50cyBhZnRlciBlYWNoIGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICovXG5cdFx0Z2V0IHZlcnNpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl92ZXJzaW9uO1xuXHRcdH1cblx0XHRwcml2YXRlIF92ZXJzaW9uID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIERvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKGtlZXBPcmlnaW5hbEZvcm1hdHRpbmc/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRpZiAoa2VlcE9yaWdpbmFsRm9ybWF0dGluZylcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBzdGF0ZW1lbnQgb2YgdGhpcy5zdGF0ZW1lbnRzKVxuXHRcdFx0XHRcdGxpbmVzLnB1c2goc3RhdGVtZW50LnNvdXJjZVRleHQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBmb3IgKGNvbnN0IHsgc3RhdGVtZW50LCBsZXZlbCB9IG9mIHRoaXMuZWFjaERlc2NlbmRhbnQoKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgaW5kZW50ID0gU3ludGF4LnRhYi5yZXBlYXQobGV2ZWwpO1xuXHRcdFx0XHRsaW5lcy5wdXNoKGluZGVudCArIHN0YXRlbWVudC50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhbiBpbnRlcmZhY2UgZm9yIGNyZWF0aW5nIGFcblx0ICogYmF0Y2ggb2YgZG9jdW1lbnQgbXV0YXRpb24gb3BlcmF0aW9ucy5cblx0ICovXG5cdGludGVyZmFjZSBJRG9jdW1lbnRNdXRhdG9yXG5cdHtcblx0XHQvKipcblx0XHQgKiBJbnNlcnRzIGEgZmFjdCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCByZXR1cm5zIHRoZSBpbnNlcnRlZCBGYWN0LiBcblx0XHQgKiBOZWdhdGl2ZSBudW1iZXJzIGluc2VydCBmYWN0cyBzdGFydGluZyBmcm9tIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqIFRoZSBmYWN0VGV4dCBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBvbmUgc2luZ2xlIGNvbXBsZXRlIGxpbmUgb2YgdGV4dC5cblx0XHQgKi9cblx0XHRpbnNlcnQodGV4dDogc3RyaW5nLCBhdDogbnVtYmVyKTogdm9pZDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlcyBhIGZhY3QgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgcmV0dXJucyB0aGUgcmVwbGFjZWQgRmFjdC4gXG5cdFx0ICogTmVnYXRpdmUgbnVtYmVycyBpbnNlcnQgZmFjdHMgc3RhcnRpbmcgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cblx0XHQgKiBUaGUgZmFjdFRleHQgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgb25lIHNpbmdsZSBjb21wbGV0ZSBsaW5lIG9mIHRleHQuXG5cdFx0ICovXG5cdFx0dXBkYXRlKGZhY3RUZXh0OiBzdHJpbmcsIGF0OiBudW1iZXIpOiB2b2lkO1xuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBEZWxldGVzIGEgZmFjdCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCByZXR1cm5zIHRoZSBkZWxldGVkIEZhY3QuIFxuXHRcdCAqIE5lZ2F0aXZlIG51bWJlcnMgZGVsZXRlIGZhY3RzIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0ZGVsZXRlKGF0OiBudW1iZXIsIGNvdW50PzogbnVtYmVyKTogdm9pZDtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0aW50ZXJmYWNlIElEb2N1bWVudEVkaXRcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHJhbmdlIGluIHRoZSBkb2N1bWVudCB0aGF0IHJlcHJlc2VudHMgdGhlXG5cdFx0ICogY29udGVudCB0aGF0IHNob3VsZCBiZSByZXBsYWNlZC5cblx0XHQgKi9cblx0XHRyZWFkb25seSByYW5nZTogSURvY3VtZW50RWRpdFJhbmdlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbmV3IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdGV4dDogc3RyaW5nO1xuXHR9XG5cblxuXHQvKipcblx0ICogQW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyBhIHRleHQgcmFuZ2Ugd2l0aGluIHRoZSBsb2FkZWQgZG9jdW1lbnQuXG5cdCAqIFRoaXMgaW50ZXJmYWNlIGlzIGV4cGxpY2l0bHkgZGVzaWduZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBNb25hY29cblx0ICogdGV4dCBlZGl0b3IgQVBJIChhbmQgbWF5YmUgb3RoZXJzKSB0byBzaW1wbGlmeSBpbnRlZ3JhdGlvbnMuXG5cdCAqL1xuXHRleHBvcnQgaW50ZXJmYWNlIElEb2N1bWVudEVkaXRSYW5nZVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBsaW5lIG51bWJlciBvbiB3aGljaCB0aGUgcmFuZ2Ugc3RhcnRzIChzdGFydHMgYXQgMCkuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgc3RhcnRMaW5lTnVtYmVyOiBudW1iZXI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBjb2x1bW4gb24gd2hpY2ggdGhlIHJhbmdlIHN0YXJ0cyBpbiBsaW5lXG5cdFx0ICogYHN0YXJ0TGluZU51bWJlcmAgKHN0YXJ0cyBhdCAwKS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzdGFydENvbHVtbjogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgbGluZSBudW1iZXIgb24gd2hpY2ggdGhlIHJhbmdlIGVuZHMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZW5kTGluZU51bWJlcjogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgQ29sdW1uIG9uIHdoaWNoIHRoZSByYW5nZSBlbmRzIGluIGxpbmVcblx0XHQgKiBgZW5kTGluZU51bWJlcmAuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZW5kQ29sdW1uOiBudW1iZXI7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCB5aWVsZHMgYWxsIHN0YXRlbWVudHMgKHVucGFyc2VkIGxpbmVzKVxuXHQgKiBvZiB0aGUgZ2l2ZW4gc291cmNlIHRleHQuIFxuXHQgKi9cblx0ZnVuY3Rpb24gKnJlYWRMaW5lcyhzb3VyY2U6IHN0cmluZylcblx0e1xuXHRcdGxldCBjdXJzb3IgPSAtMTtcblx0XHRsZXQgc3RhdGVtZW50U3RhcnQgPSAwO1xuXHRcdGNvbnN0IGNoYXIgPSAoKSA9PiBzb3VyY2VbY3Vyc29yXTtcblx0XHRcblx0XHRmb3IgKDs7KVxuXHRcdHtcblx0XHRcdGlmIChjdXJzb3IgPj0gc291cmNlLmxlbmd0aCAtIDEpXG5cdFx0XHRcdHJldHVybiB5aWVsZCBzb3VyY2Uuc2xpY2Uoc3RhdGVtZW50U3RhcnQpO1xuXHRcdFx0XG5cdFx0XHRjdXJzb3IrKztcblx0XHRcdFxuXHRcdFx0aWYgKGNoYXIoKSA9PT0gU3ludGF4LnRlcm1pbmFsKVxuXHRcdFx0e1xuXHRcdFx0XHR5aWVsZCBzb3VyY2Uuc2xpY2Uoc3RhdGVtZW50U3RhcnQsIGN1cnNvcik7XG5cdFx0XHRcdHN0YXRlbWVudFN0YXJ0ID0gY3Vyc29yICsgMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyB0aGUgaW50ZWdlciBib3VuZGluZyBhbmQgd3JhcHBpbmcgZm9ybXVsYSB0aGF0IGlzXG5cdCAqIGNvbW1vbiBvbiBhbGwgcG9zaXRpb25hbCBhcmd1bWVudHMgZm91bmQgaW4gSmF2YVNjcmlwdCBhcnJheVxuXHQgKiBhbmQgc3RyaW5nIG1ldGhvZHMgKHN1Y2ggYXMgQXJyYXkuc2xpY2UpLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXBwbHlCb3VuZHMoaW5kZXg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpXG5cdHtcblx0XHRpZiAoaW5kZXggPT09IDAgfHwgbGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0XG5cdFx0aWYgKGluZGV4ID4gMClcblx0XHRcdHJldHVybiBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG5cdFx0XG5cdFx0aWYgKGluZGV4IDwgMClcblx0XHRcdHJldHVybiBNYXRoLm1heChsZW5ndGggKyBpbmRleCwgMCk7XG5cdFx0XG5cdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHN0b3JlcyBhbGwgdGhlIGRvY3VtZW50cyBsb2FkZWQgaW50byBhXG5cdCAqIHByb2dyYW0sIGFuZCB0aGUgaW50ZXItZGVwZW5kZW5jaWVzIGJldHdlZW4gdGhlbS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBEb2N1bWVudEdyYXBoXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcm9ncmFtOiBQcm9ncmFtKVxuXHRcdHtcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VEb2N1bWVudFVyaUNoYW5nZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtvbGRVcmlUZXh0LCBkb2NFbnRyeV0gb2YgdGhpcy5kb2N1bWVudHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoZG9jRW50cnkuZG9jdW1lbnQgIT09IGRhdGEuZG9jdW1lbnQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBuZXdVcmlUZXh0ID0gZGF0YS5uZXdVcmkudG9TdG9yZVN0cmluZygpO1xuXHRcdFx0XHRcdGNvbnN0IGVudHJ5ID0gdGhpcy5kb2N1bWVudHMuZ2V0KG9sZFVyaVRleHQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChlbnRyeSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLmRvY3VtZW50cy5kZWxldGUob2xkVXJpVGV4dCk7XG5cdFx0XHRcdFx0XHR0aGlzLmRvY3VtZW50cy5zZXQobmV3VXJpVGV4dCwgZW50cnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlUmV2YWxpZGF0ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBkb2NVcmkgPSBkYXRhLmRvY3VtZW50LnNvdXJjZVVyaS50b1N0cmluZygpO1xuXHRcdFx0XHRjb25zdCBlbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldChkb2NVcmkpO1xuXHRcdFx0XHRjb25zdCBoZWFkZXIgPSBlbnRyeSA/IGVudHJ5LmhlYWRlciA6IG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgaGVhZGVyIGlzIGJlaW5nIHJlLWNvbXB1dGVkIG9uIGV2ZXJ5IGRvY3VtZW50XG5cdFx0XHRcdC8vIG1vZGlmaWNhdGlvbi4gVGhlcmUgbWF5IGJlIHNvbWUgb3B0aW1pemF0aW9ucyBoZXJlXG5cdFx0XHRcdC8vIHRvIGVsaW1pbmF0ZSByZWNvbXB1dGUgaW4gY29tbW9uIGNhc2VzLCBidXQgaXQgd291bGRcblx0XHRcdFx0Ly8gYmUgYSBtaWNyby1vcHRpbWl6YXRpb24gYXQgdGhlIHRpbWUgb2YgdGhpcyB3cml0aW5nLlxuXHRcdFx0XHRpZiAoaGVhZGVyKVxuXHRcdFx0XHRcdGhlYWRlci5yZWNvbXB1dGUoKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlVXJpUmVmZXJlbmNlQWRkLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnVyaS5leHQgIT09IFVyaUV4dGVuc2lvbi50cnV0aClcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBzbXQgPSBkYXRhLnN0YXRlbWVudDtcblx0XHRcdFx0aWYgKHNtdClcblx0XHRcdFx0XHR0aGlzLnRyeUxpbmsoc210LmRvY3VtZW50LCBzbXQsIGRhdGEudXJpKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlVXJpUmVmZXJlbmNlUmVtb3ZlLCBkYXRhID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChkYXRhLnVyaS5leHQgIT09IFVyaUV4dGVuc2lvbi50cnV0aClcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBlbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldChkYXRhLnVyaS50b1N0b3JlU3RyaW5nKCkpO1xuXHRcdFx0XHRpZiAoIWVudHJ5KVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHNtdCA9IGRhdGEuc3RhdGVtZW50O1xuXHRcdFx0XHRpZiAoc210KVxuXHRcdFx0XHRcdHRoaXMudW5saW5rKHNtdC5kb2N1bWVudCwgZW50cnkuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlYWRzIGEgRG9jdW1lbnQgZnJvbSB0aGUgc3BlY2lmaWVkIFVSSS5cblx0XHQgKiBUaGUgZG9jdW1lbnQgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQsIGFzeW5jaHJvbm91c2x5LlxuXHRcdCAqL1xuXHRcdGFzeW5jIHJlYWQodXJpOiBzdHJpbmcgfCBVcmkpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpUGFyc2VkID0gVXJpLnRyeVBhcnNlKHVyaSk7XG5cdFx0XHRpZiAoIXVyaVBhcnNlZClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRVcmkoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdXJpQWJzb2x1dGUgPSB1cmlQYXJzZWQudG9BYnNvbHV0ZSgpO1xuXHRcdFx0aWYgKCF1cmlBYnNvbHV0ZSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByZWFkUmVzdWx0ID0gYXdhaXQgVXJpUmVhZGVyLnRyeVJlYWQodXJpQWJzb2x1dGUpO1xuXHRcdFx0aWYgKHJlYWRSZXN1bHQgaW5zdGFuY2VvZiBFcnJvcilcblx0XHRcdFx0cmV0dXJuIHJlYWRSZXN1bHQ7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZSh1cmlBYnNvbHV0ZSwgcmVhZFJlc3VsdCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSB0ZW1wb3JhcnkgZG9jdW1lbnQgdGhhdCB3aWxsIGV4aXN0IG9ubHkgaW4gbWVtb3J5LlxuXHRcdCAqIFRoZSBkb2N1bWVudCBtYXkgbm90IGJlIGxpbmtlZCB0byBvdGhlciBkb2N1bWVudHMgaW4gdGhlXG5cdFx0ICogZ3JhcGguXG5cdFx0ICovXG5cdFx0Y3JlYXRlKCk6IERvY3VtZW50O1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSB0ZW1wb3JhcnkgZG9jdW1lbnQgdGhhdCB3aWxsIGV4aXN0IG9ubHkgaW4gbWVtb3J5LFxuXHRcdCAqIHdoaWNoIGlzIGluaXRpYWxpemVkIHdpdGggdGhlIHNwZWNpZmllZCBzb3VyY2UgdGV4dC4gVGhlIGRvY3VtZW50XG5cdFx0ICogbWF5IG5vdCBiZSBsaW5rZWQgdG8gb3RoZXIgZG9jdW1lbnRzIGluIHRoZSBncmFwaC5cblx0XHQgKi9cblx0XHRjcmVhdGUoc291cmNlVGV4dDogc3RyaW5nKTogRG9jdW1lbnQ7XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgc3BlY2lmaWVkIFVSSSwgXG5cdFx0ICogd2l0aCB0aGUgc3BlY2lmaWVkIHNvdXJjZVRleHQuIElmIHRoZSBjb250ZW50IHN0aWxsIG5lZWRzIHRvIGJlIFxuXHRcdCAqIHJlYWQgZnJvbSBhIFVSSSwgdXNlIHRoZSAucmVhZCgpIG1ldGhvZC5cblx0XHQgKi9cblx0XHRjcmVhdGUodXJpOiBVcmkgfCBzdHJpbmcsIHNvdXJjZVRleHQ6IHN0cmluZyk6IERvY3VtZW50O1xuXHRcdGNyZWF0ZShwYXJhbTE/OiBVcmkgfCBzdHJpbmcsIHBhcmFtMj86IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCB6ZXJvQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDA7XG5cdFx0XHRjb25zdCBvbmVBcmcgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB1cmkgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHplcm9BcmdzIHx8IG9uZUFyZylcblx0XHRcdFx0XHRyZXR1cm4gVXJpLmNyZWF0ZUludGVybmFsKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXBhcmFtMSlcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJhbTEgaW5zdGFuY2VvZiBVcmkpXG5cdFx0XHRcdFx0cmV0dXJuIHBhcmFtMTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBVcmkudHJ5UGFyc2UocGFyYW0xKTtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGlmICghdXJpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZFVyaSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzb3VyY2VUZXh0ID0gXG5cdFx0XHRcdHplcm9BcmdzID8gXCJcIiA6XG5cdFx0XHRcdG9uZUFyZyA/IChwYXJhbTEgfHwgXCJcIikudG9TdHJpbmcoKSA6XG5cdFx0XHRcdHBhcmFtMiB8fCBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkb2N1bWVudCA9IG5ldyBEb2N1bWVudCh0aGlzLnByb2dyYW0sIHVyaSwgc291cmNlVGV4dCk7XG5cdFx0XHRjb25zdCBoZWFkZXIgPSBuZXcgRG9jdW1lbnRIZWFkZXIoZG9jdW1lbnQpO1xuXHRcdFx0Y29uc3QgZW50cnk6IElEb2N1bWVudEVudHJ5ID0geyBkb2N1bWVudCwgaGVhZGVyIH07XG5cdFx0XHR0aGlzLmRvY3VtZW50cy5zZXQodXJpLnRvU3RvcmVTdHJpbmcoKSwgZW50cnkpO1xuXHRcdFx0aGVhZGVyLnJlY29tcHV0ZSgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByb2dyYW0uY2F1c2UobmV3IENhdXNlRG9jdW1lbnRDcmVhdGUoZG9jdW1lbnQpKTtcblx0XHRcdHJldHVybiBkb2N1bWVudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQmxvY2tzIGV4ZWN1dGlvbiB1bnRpbCBhbGwgcXVldWVkIElPIG9wZXJhdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG5cdFx0ICovXG5cdFx0YXdhaXQoKVxuXHRcdHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmFzeW5jQ291bnQgPT09IDApXG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dGhpcy53YWl0Rm5zLnB1c2gocmVzb2x2ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgVGhlIGRvY3VtZW50IGxvYWRlZCBpbnRvIHRoaXMgZ3JhcGhcblx0XHQgKiB3aXRoIHRoZSBzcGVjaWZpZWQgVVJJLlxuXHRcdCAqL1xuXHRcdGdldCh1cmk6IHN0cmluZyB8IFVyaSlcblx0XHR7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIiA/IHVyaSA6IHVyaS50b1N0b3JlU3RyaW5nKCk7XG5cdFx0XHRjb25zdCBlbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldCh1cmlUZXh0KTtcblx0XHRcdHJldHVybiBlbnRyeSA/IGVudHJ5LmRvY3VtZW50IDogbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXJcblx0XHQgKiB0aGUgc3BlY2lmaWVkIERvY3VtZW50IGhhcyBiZWVuIGxvYWRlZCBpbnRvXG5cdFx0ICogdGhpcyBEb2N1bWVudEdyYXBoLlxuXHRcdCAqL1xuXHRcdGhhcyhwYXJhbTogVXJpIHwgRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0aWYgKHBhcmFtIGluc3RhbmNlb2YgRG9jdW1lbnQpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5kb2N1bWVudHMudmFsdWVzKCkpXG5cdFx0XHRcdFx0aWYgKGVudHJ5LmRvY3VtZW50ID09PSBwYXJhbSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gISF0aGlzLmdldChwYXJhbSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGRvY3VtZW50cyBsb2FkZWQgaW50byB0aGlzXG5cdFx0ICogRG9jdW1lbnRHcmFwaC4gVGhlIGFycmF5IHJldHVybmVkIGlzIHNvcnRlZCB0b3BvbG9naWNhbGx5IFxuXHRcdCAqIGZyb20gbGVmdCB0byByaWdodCwgc28gdGhhdCBmb3J3YXJkIHRyYXZlcnNhbHMgYXJlIGd1YXJhbnRlZWQgXG5cdFx0ICogdG8gbm90IGNhdXNlIGRlcGVuZGVuY3kgY29uZmxpY3RzLlxuXHRcdCAqL1xuXHRcdGVhY2goKVxuXHRcdHtcblx0XHRcdC8vIFRoZSB0b3BvbG9naWNhbCBzb3J0aW5nIG1lY2hhbmlzbSB1c2VzIGEgdmFyaWFudCBvZiBkZXB0aC1maXJzdCBzZWFyY2guXG5cdFx0XHQvLyBBbGdvcml0aG0gaXMgZGVzY3JpYmVkIGhlcmU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvcG9sb2dpY2FsX3NvcnRpbmdcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc29ydGVkUmVzdWx0OiBEb2N1bWVudFtdID0gW107XG5cdFx0XHRjb25zdCBkb2NzRmluYWxpemVkID0gbmV3IFNldDxEb2N1bWVudD4oKTtcblx0XHRcdGNvbnN0IGRvY3NJblN0YWNrID0gbmV3IFNldDxEb2N1bWVudD4oKTtcblx0XHRcdGNvbnN0IGFsbERvY3MgPSBBcnJheS5mcm9tKHRoaXMuZG9jdW1lbnRzLnZhbHVlcygpKVxuXHRcdFx0XHQubWFwKGVudHJ5ID0+IGVudHJ5LmRvY3VtZW50KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVjdXJzZSA9IChjdXJyZW50RG9jOiBEb2N1bWVudCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGRvY3NGaW5hbGl6ZWQuaGFzKGN1cnJlbnREb2MpKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEN5Y2xlIGRldGVjdGVkLiBUaGlzIGNvbmRpdGlvbiBzaG91bGQgbmV2ZXIgcGFzcyBiZWNhdXNlXG5cdFx0XHRcdC8vIERvY3VtZW50R3JhcGggaXMgc3VwcG9zZWQgdG8gcHJldmVudCBjeWNsZXMuXG5cdFx0XHRcdGlmIChkb2NzSW5TdGFjay5oYXMoY3VycmVudERvYykpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0ZG9jc0luU3RhY2suYWRkKGN1cnJlbnREb2MpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZGVwcyA9IHRoaXMuZGVwZW5kZW5jaWVzLmdldChjdXJyZW50RG9jKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChkZXBzKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgZGVwIG9mIGRlcHMpXG5cdFx0XHRcdFx0XHRyZWN1cnNlKGRlcC50YXJnZXQpO1xuXHRcdFx0XHRcblx0XHRcdFx0ZG9jc0ZpbmFsaXplZC5hZGQoY3VycmVudERvYyk7XG5cdFx0XHRcdHNvcnRlZFJlc3VsdC51bnNoaWZ0KGN1cnJlbnREb2MpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGRvY3NGaW5hbGl6ZWQuc2l6ZSA8IGFsbERvY3MubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBuZXh0VW52aXNpdGVkID0gYWxsRG9jcy5maW5kKGQgPT4gIWRvY3NGaW5hbGl6ZWQuaGFzKGQpKTtcblx0XHRcdFx0aWYgKCFuZXh0VW52aXNpdGVkKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJlY3Vyc2UobmV4dFVudmlzaXRlZCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBzb3J0ZWRSZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERlbGV0ZXMgYSBkb2N1bWVudCB0aGF0IHdhcyBwcmV2aW91c2x5IGxvYWRlZCBpbnRvIHRoZSBjb21waWxlci5cblx0XHQgKiBJbnRlbmRlZCB0byBiZSBjYWxsZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQgd2hlbiBhIGZpbGUgY2hhbmdlcy5cblx0XHQgKi9cblx0XHRkZWxldGUodGFyZ2V0OiBEb2N1bWVudCB8IFVyaSlcblx0XHR7XG5cdFx0XHRjb25zdCBkb2MgPSB0YXJnZXQgaW5zdGFuY2VvZiBEb2N1bWVudCA/IHRhcmdldCA6ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBlbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldCh0YXJnZXQudG9TdHJpbmcoKSk7XG5cdFx0XHRcdHJldHVybiBlbnRyeSA/IGVudHJ5LmRvY3VtZW50IDogbnVsbDtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGlmICghZG9jKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VEb2N1bWVudENyZWF0ZShkb2MpKTtcblx0XHRcdFxuXHRcdFx0Ly8gR28gdGhyb3VnaCB0aGUgZW50aXJlIG1hcCBvZiBkZXBlbmRlbnQgZG9jdW1lbnRzLCBcblx0XHRcdC8vIGFuZCBmaW5kIGRvY3VtZW50cyB0aGF0IGhhdmUgdGhlIGRlbGV0ZWQgZG9jdW1lbnQgXG5cdFx0XHQvLyBsaXN0ZWQgYXMgb25lIG9mIGl0J3MgZGVwZW5kZW50cy4gVGhlc2UgZG9jdW1lbnRzIGFyZVxuXHRcdFx0Ly8gdGhlbiByZW1vdmVkIGZyb20gdGhlIGFycmF5IG9mIGRlcGVuZGVudHMuXG5cdFx0XHRmb3IgKGNvbnN0IFtyZWZEb2MsIGRlcGVuZGVudHNdIG9mIHRoaXMuZGVwZW5kZW50cylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZG9jSWR4ID0gZGVwZW5kZW50cy5pbmRleE9mKGRvYyk7XG5cdFx0XHRcdGlmIChkb2NJZHggPiAtMSlcblx0XHRcdFx0XHRkZXBlbmRlbnRzLnNwbGljZShkb2NJZHgsIDEpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGRlcGVuZGVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHRoaXMuZGVwZW5kZW50cy5kZWxldGUocmVmRG9jKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRGVsZXRlIHRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIGRvY3VtZW50XG5cdFx0XHQvLyBhZnRlciB3ZSdyZSBkb25lIGNsZWFyaW5nIG91dCB0aGUgZGVwZW5kZW50cy5cblx0XHRcdHRoaXMuZGVwZW5kZW5jaWVzLmRlbGV0ZShkb2MpO1xuXHRcdFx0XG5cdFx0XHQvLyBEZWxldGUgdGhlIGRlbGV0ZWQgZG9jdW1lbnQgbGFzdFxuXHRcdFx0dGhpcy5kb2N1bWVudHMuZGVsZXRlKGRvYy5zb3VyY2VVcmkudG9TdHJpbmcoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYWxsIGRvY3VtZW50cyBmcm9tIHRoaXMgZ3JhcGguXG5cdFx0ICovXG5cdFx0Y2xlYXIoKVxuXHRcdHtcblx0XHRcdHRoaXMuZG9jdW1lbnRzLmNsZWFyKCk7XG5cdFx0XHR0aGlzLmRlcGVuZGVuY2llcy5jbGVhcigpO1xuXHRcdFx0dGhpcy5kZXBlbmRlbnRzLmNsZWFyKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlcGVuZGVuY2llc1xuXHRcdCAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGRvY3VtZW50LiBUaGUgcmV0dXJuZWRcblx0XHQgKiBhcnJheSBpcyBzb3J0ZWQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBkZXBlbmRlbmNpZXNcblx0XHQgKiBhcmUgZGVmaW5lZCBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0RGVwZW5kZW5jaWVzKGRvYzogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBlbmRlbmNpZXMuZ2V0KGRvYyk7XG5cdFx0XHRpZiAoIWRlcGVuZGVuY2llcylcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB1cmlzU29ydGVkOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0Y29uc3QgZG9jRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLm1hcChkID0+IGQudGFyZ2V0KTtcblx0XHRcdGNvbnN0IGVudHJ5ID0gdGhpcy5kb2N1bWVudHMuZ2V0KGRvYy5zb3VyY2VVcmkudG9TdHJpbmcoKSk7XG5cdFx0XHRcblx0XHRcdGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIGRvYy5lYWNoU3RhdGVtZW50KCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChzdGF0ZW1lbnQuaXNOb29wKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgYSBub24tbm9vcCBzdGF0ZW1lbnQgaXMgcmVhY2hlZCB0aGF0IGlzbid0IGEgcGFydFxuXHRcdFx0XHQvLyBvZiB0aGUgaGVhZGVyLCB0aGUgZW5kIG9mIHRoZSBoZWFkZXIgaGFzIGJlZW4gcmVhY2hlZC5cblx0XHRcdFx0Y29uc3QgcmVmVXJpID0gZW50cnkuaGVhZGVyLmdldEhlYWRlclVyaShzdGF0ZW1lbnQpO1xuXHRcdFx0XHRpZiAoIXJlZlVyaSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdHVyaXNTb3J0ZWQucHVzaChyZWZVcmkudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlcHNTb3J0ZWQgPSB1cmlzU29ydGVkLm1hcCh1cmlUZXh0ID0+IFxuXHRcdFx0XHROb3QudW5kZWZpbmVkKGRvY0RlcGVuZGVuY2llcy5maW5kKGRvY0RlcCA9PiBcblx0XHRcdFx0XHRkb2NEZXAuc291cmNlVXJpLnRvU3RyaW5nKCkgPT09IHVyaVRleHQpKSk7XG5cdFx0XHRcblx0XHRcdGlmIChkZXBzU29ydGVkLnNvbWUoZCA9PiBkID09PSB1bmRlZmluZWQpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBkZXBzU29ydGVkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBkZXBlbmRlbnRzXG5cdFx0ICogYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0RGVwZW5kZW50cyhkb2M6IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlcGVuZGVudHMgPSB0aGlzLmRlcGVuZGVudHMuZ2V0KGRvYyk7XG5cdFx0XHRyZXR1cm4gZGVwZW5kZW50cyA/XG5cdFx0XHRcdGRlcGVuZGVudHMuc2xpY2UoKSA6XG5cdFx0XHRcdFtdO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byBhZGQgYSBsaW5rIGZyb20gb25lIGRvY3VtZW50IHRvIGFub3RoZXIsXG5cdFx0ICogdmlhIHRoZSBzcGVjaWZpZWQgVVJJLiBJZiB0aGVyZSBpcyBzb21lIHJlYXNvbiB3aHkgdGhlXG5cdFx0ICogbGluayBjYW5ub3QgYmUgZXN0YWJsaXNoZWQsIChjaXJjdWxhciByZWZlcmVuY2VzLCBiYWRcblx0XHQgKiBVUklzKSwgbm8gbGluayBpcyBhZGRlZCwgYW5kIGEgZmF1bHQgaXMgcmVwb3J0ZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB0cnlMaW5rKFxuXHRcdFx0Y29udGFpbmluZ0RvY3VtZW50OiBEb2N1bWVudCwgXG5cdFx0XHRjb250YWluaW5nU3RhdGVtZW50OiBTdGF0ZW1lbnQsIFxuXHRcdFx0dXJpOiBVcmkpXG5cdFx0e1xuXHRcdFx0dGhpcy5hc3luY0NvdW50Kys7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4gKGFzeW5jICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJlZkRvY3VtZW50ID0gYXdhaXQgKGFzeW5jICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBJcyB0aGUgZG9jdW1lbnQgYWxyZWFkeSBsb2FkZWQgaW50byB0aGUgZ3JhcGg/XG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMuZG9jdW1lbnRzLmdldCh1cmlUZXh0KTtcblx0XHRcdFx0XHRpZiAoZXhpc3RpbmdFbnRyeSlcblx0XHRcdFx0XHRcdHJldHVybiBleGlzdGluZ0VudHJ5LmRvY3VtZW50O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFJlYWQgdGhlIGRvY3VtZW50IGlmIGl0IHdhc24ndCBsb2FkZWRcblx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWQodXJpKTtcblx0XHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgZmF1bHQgPSBGYXVsdHMuVW5yZXNvbHZlZFJlc291cmNlLmNyZWF0ZShjb250YWluaW5nU3RhdGVtZW50KTtcblx0XHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5mYXVsdHMucmVwb3J0QXN5bmMoZmF1bHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IG5ld0VudHJ5ID0gdGhpcy5kb2N1bWVudHMuZ2V0KHVyaVRleHQpO1xuXHRcdFx0XHRcdGlmICghbmV3RW50cnkpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG5ld0VudHJ5LmRvY3VtZW50O1xuXHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFyZWZEb2N1bWVudClcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBCYWlsIGlmIGEgZG9jdW1lbnQgbG9hZGVkIGZyb20gSFRUUCBpcyB0cnlpbmcgdG8gcmVmZXJlbmNlXG5cdFx0XHRcdC8vIGEgZG9jdW1lbnQgbG9jYXRlZCBvbiB0aGUgZmlsZSBzeXN0ZW0uXG5cdFx0XHRcdGNvbnN0IHNyY1Byb3RvID0gY29udGFpbmluZ0RvY3VtZW50LnNvdXJjZVVyaS5wcm90b2NvbDtcblx0XHRcdFx0Y29uc3QgZHN0UHJvdG8gPSByZWZEb2N1bWVudC5zb3VyY2VVcmkucHJvdG9jb2w7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKHNyY1Byb3RvID09PSBVcmlQcm90b2NvbC5odHRwIHx8IHNyY1Byb3RvID09PSBVcmlQcm90b2NvbC5odHRwcykgJiYgXG5cdFx0XHRcdFx0ZHN0UHJvdG8gPT09IFVyaVByb3RvY29sLmZpbGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBwYXJhbSA9IEZhdWx0cy5JbnNlY3VyZVJlc291cmNlUmVmZXJlbmNlLmNyZWF0ZShjb250YWluaW5nU3RhdGVtZW50KTtcblx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydEFzeW5jKHBhcmFtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQmFpbCBpZiB0aGUgYWRkaXRpb24gb2YgdGhlIHJlZmVyZW5jZSBpcyBnb2luZyB0byByZXN1bHQgaW4gYSBjaXJjdWxhciByZWZlcmVuY2UuXG5cdFx0XHRcdGlmICh0aGlzLndvdWxkQ3JlYXRlQ3ljbGVzKGNvbnRhaW5pbmdEb2N1bWVudCwgcmVmRG9jdW1lbnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcGFyYW0gPSBGYXVsdHMuQ2lyY3VsYXJSZXNvdXJjZVJlZmVyZW5jZS5jcmVhdGUoY29udGFpbmluZ1N0YXRlbWVudCk7XG5cdFx0XHRcdFx0dGhpcy5wcm9ncmFtLmZhdWx0cy5yZXBvcnRBc3luYyhwYXJhbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5saW5rKGNvbnRhaW5pbmdEb2N1bWVudCwgcmVmRG9jdW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmFzeW5jQ291bnQtLTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLmFzeW5jQ291bnQgPCAwKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0aGlzLmFzeW5jQ291bnQgPT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB3YWl0Rm5zID0gdGhpcy53YWl0Rm5zLnNsaWNlKCk7XG5cdFx0XHRcdFx0dGhpcy53YWl0Rm5zLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0d2FpdEZucy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSgpLFxuXHRcdFx0MCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCB3aGVuXG5cdFx0ICogYWxsIG91dHN0YW5kaW5nIGFzeW5jIG9wZXJhdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB3YWl0Rm5zOiAoKCkgPT4gdm9pZClbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgaW4gcHJvZ3Jlc3MuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBhc3luY0NvdW50ID0gMDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBhZGRpdGlvbiBvZiBhIHJlZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d29cblx0XHQgKiBzcGVjaWZpZWQgZG9jdW1lbnRzIHdvdWxkIHJlc3VsdCBpbiBhIGRvY3VtZW50IGdyYXBoIHdpdGhcblx0XHQgKiBjaXJjdWxhciByZWxhdGlvbnNoaXBzLlxuXHRcdCAqIFxuXHRcdCAqIFRoZSBhbGdvcml0aG0gdXNlZCBwZXJmb3JtcyBhIGRlcHRoLWZpcnN0IGRlcGVuZGVuY3kgc2VhcmNoLFxuXHRcdCAqIHN0YXJ0aW5nIGF0IHRoZSBjYW5kaWRhdGVUby4gSWYgdGhlIHRyYXZlcnNhbCBwYXR0ZXJuIGlzIGFibGUgdG9cblx0XHQgKiBtYWtlIGl0cyB3YXkgdG8gY2FuZGlkYXRlRnJvbSwgaXQgY2FuIGJlIGNvbmNsdWRlZCB0aGF0IHRoZVxuXHRcdCAqIGFkZGl0aW9uIG9mIHRoZSBwcm9wb3NlZCByZWZlcmVuY2Ugd291bGQgcmVzdWx0IGluIGEgY3ljbGljYWxcblx0XHQgKiByZWxhdGlvbnNoaXAuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB3b3VsZENyZWF0ZUN5Y2xlcyhwcm9wb3NlZEZyb206IERvY3VtZW50LCBwcm9wb3NlZFRvOiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCBjaGVja0ZvckN5Y2xlc1JlY3Vyc2l2ZSA9IChjdXJyZW50OiBEb2N1bWVudCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGN1cnJlbnQgPT09IHByb3Bvc2VkRnJvbSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRlcGVuZGVuY2llcyA9ICh0aGlzLmRlcGVuZGVuY2llcy5nZXQoY3VycmVudCkgfHwgW10pLm1hcChkID0+IGQudGFyZ2V0KTtcblx0XHRcdFx0aWYgKGRlcGVuZGVuY2llcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGN1cnJlbnQgPT09IHByb3Bvc2VkRnJvbSlcblx0XHRcdFx0XHRkZXBlbmRlbmNpZXMudW5zaGlmdChwcm9wb3NlZFRvKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChkZXBlbmRlbmNpZXMuc29tZShkID0+IGNoZWNrRm9yQ3ljbGVzUmVjdXJzaXZlKGQpKSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBjaGVja0ZvckN5Y2xlc1JlY3Vyc2l2ZShwcm9wb3NlZFRvKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhIGRlcGVuZGVuY3kgYmV0d2VlbiB0d28gZG9jdW1lbnRzIGluIHRoZSBncmFwaC5cblx0XHQgKiBJZiBhIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgdHdvIGRvY3VtZW50cyBhbHJlYWR5IGV4aXN0cyxcblx0XHQgKiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBkZXBlbmRlbmN5IGlzIGluY3JlbWVudGVkLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGV4ZWN1dGVkIG9ubHkgYWZ0ZXIgb3RoZXIgbWV0aG9kcyBoYXZlXG5cdFx0ICogaW5kaWNhdGVkIHRoYXQgdGhlIGFkZGl0aW9uIG9mIHRoZSBsaW5rIHdpbGwgbm90IGNhdXNlIGNvbmZsaWN0LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgbGluayhmcm9tOiBEb2N1bWVudCwgdG86IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IGRlcGVuZGVuY3lBcnJheSA9IHRoaXMuZGVwZW5kZW5jaWVzLmdldChmcm9tKTtcblx0XHRcdGlmIChkZXBlbmRlbmN5QXJyYXkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5QXJyYXkuZmluZChkID0+IGQudGFyZ2V0ID09PSB0byk7XG5cdFx0XHRcdGlmIChkZXBlbmRlbmN5KVxuXHRcdFx0XHRcdGRlcGVuZGVuY3kucmVmZXJlbmNlQ291bnQrKztcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGRlcGVuZGVuY3lBcnJheS5wdXNoKG5ldyBEZXBlbmRlbmN5KHRvKSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZGVwZW5kZW5jaWVzLnNldChmcm9tLCBbbmV3IERlcGVuZGVuY3kodG8pXSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlcGVuZGVudEFycmF5ID0gdGhpcy5kZXBlbmRlbnRzLmdldCh0byk7XG5cdFx0XHRpZiAoZGVwZW5kZW50QXJyYXkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghZGVwZW5kZW50QXJyYXkuaW5jbHVkZXMoZnJvbSkpXG5cdFx0XHRcdFx0ZGVwZW5kZW50QXJyYXkucHVzaChmcm9tKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5kZXBlbmRlbnRzLnNldCh0bywgW2Zyb21dKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhIGRlcGVuZGVuY3kgYmV0d2VlbiB0d28gZG9jdW1lbnRzIGluIHRoZSBncmFwaC5cblx0XHQgKiBJZiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBkZXBlbmRlbmN5IGlzIGdyZWF0ZXIgdGhhbiAxLCB0aGVcblx0XHQgKiB0aGUgcmVmZXJlbmNlIGNvdW50IGlzIGRlY3JlbWVudGVkIGluc3RlYWQgb2YgdGhlIGRlcGVuZGVuY3lcblx0XHQgKiBiZWluZyByZW1vdmVkIGNvbXBsZXRlbHkuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSB1bmxpbmsoZnJvbTogRG9jdW1lbnQsIHRvOiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCBkZXBlbmRlbmN5QXJyYXkgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQoZnJvbSk7XG5cdFx0XHRpZiAoIWRlcGVuZGVuY3lBcnJheSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkZXBlbmRlbmN5SWR4ID0gZGVwZW5kZW5jeUFycmF5LmZpbmRJbmRleChkID0+IGQudGFyZ2V0ID09PSB0byk7XG5cdFx0XHRpZiAoZGVwZW5kZW5jeUlkeCA8IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3lBcnJheVtkZXBlbmRlbmN5SWR4XTtcblx0XHRcdFxuXHRcdFx0aWYgKGRlcGVuZGVuY3kucmVmZXJlbmNlQ291bnQgPiAxKVxuXHRcdFx0e1xuXHRcdFx0XHRkZXBlbmRlbmN5LnJlZmVyZW5jZUNvdW50LS07XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGRlcGVuZGVuY3lBcnJheS5zcGxpY2UoZGVwZW5kZW5jeUlkeCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBHZXQgcmlkIG9mIHRoZSBlbnRyeSBpbiB0aGUgZGVwZW5kZW5jaWVzIG1hcFxuXHRcdFx0XHQvLyBjb21wbGV0ZWx5IGlmIHRoZSBkZXBlbmRlbmN5IGFycmF5IGlzIG5vdyBlbXB0eS5cblx0XHRcdFx0aWYgKGRlcGVuZGVuY3lBcnJheS5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0dGhpcy5kZXBlbmRlbmNpZXMuZGVsZXRlKGZyb20pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBkZXBlbmRlbnRBcnJheSA9IHRoaXMuZGVwZW5kZW50cy5nZXQodG8pO1xuXHRcdFx0aWYgKGRlcGVuZGVudEFycmF5KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBkZXBJZHggPSBkZXBlbmRlbnRBcnJheS5pbmRleE9mKGZyb20pO1xuXHRcdFx0XHRpZiAoZGVwSWR4ID4gLTEpXG5cdFx0XHRcdFx0ZGVwZW5kZW50QXJyYXkuc3BsaWNlKGRlcElkeCwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBBIG1hcCBvZiBkb2N1bWVudHMgbG9hZGVkIGludG8gdGhlIGdyYXBoLFxuXHRcdCAqIGluZGV4ZWQgYnkgdGhlaXIgVVJJcy5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGRvY3VtZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBJRG9jdW1lbnRFbnRyeT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIG1hcCBvZiBlYWNoIGRvY3VtZW50J3MgZGVwZW5kZW5jaWVzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZGVwZW5kZW5jaWVzID0gbmV3IE1hcDxEb2N1bWVudCwgRGVwZW5kZW5jeVtdPigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgbWFwIG9mIHRoZSBkb2N1bWVudHMgdGhhdCBkZXBlbmQgb24gZWFjaCBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGRlcGVuZGVudHMgPSBuZXcgTWFwPERvY3VtZW50LCBEb2N1bWVudFtdPigpO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGUgY29udGVudHMgb2YgdGhpcyBEb2N1bWVudEdyYXBoIHRvIGEgXG5cdFx0ICogc3RyaW5nIHJlcHJlc2VudGF0aW9uLCB1c2VmdWwgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFt1cmlUZXh0LCBlbnRyeV0gb2YgdGhpcy5kb2N1bWVudHMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHVyaSA9IFVyaS50cnlQYXJzZSh1cmlUZXh0KTtcblx0XHRcdFx0Y29uc3QgZG9jID0gZW50cnkuZG9jdW1lbnQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXVyaSlcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRsaW5lcy5wdXNoKHVyaS50b1N0cmluZygpKTtcblx0XHRcdFx0bGluZXMucHVzaChcIlxcdERlcGVuZGVuY2llc1wiKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRvY0RlcGVuZGVuY2llcyA9IHRoaXMuZGVwZW5kZW5jaWVzLmdldChkb2MpO1xuXHRcdFx0XHRpZiAoZG9jRGVwZW5kZW5jaWVzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGRvY0RlcGVuZGVuY2llcy5sZW5ndGgpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGRvY0RlcGVuZGVuY2llcylcblx0XHRcdFx0XHRcdFx0bGluZXMucHVzaChcIlxcdFxcdFwiICsgZGVwZW5kZW5jeS50YXJnZXQuc291cmNlVXJpLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGxpbmVzLnB1c2goXCJcXHRcXHQobm9uZSlcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBsaW5lcy5wdXNoKFwiXFx0XFx0KHVuZGVmaW5lZClcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRsaW5lcy5wdXNoKFwiXFx0RGVwZW5kZW50c1wiKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRvY0RlcGVuZGVudHMgPSB0aGlzLmRlcGVuZGVudHMuZ2V0KGRvYyk7XG5cdFx0XHRcdGlmIChkb2NEZXBlbmRlbnRzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGRvY0RlcGVuZGVudHMubGVuZ3RoKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgZG9jRGVwZW5kZW50IG9mIGRvY0RlcGVuZGVudHMpXG5cdFx0XHRcdFx0XHRcdGxpbmVzLnB1c2goXCJcXHRcXHRcIiArIGRvY0RlcGVuZGVudC5zb3VyY2VVcmkudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgbGluZXMucHVzaChcIlxcdFxcdChub25lKVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGxpbmVzLnB1c2goXCJcXHRcXHQodW5kZWZpbmVkKVwiKTtcblx0XHRcdFx0XG5cdFx0XHRcdGxpbmVzLnB1c2goXCJcIik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBsaW5lcy5zbGljZSgwLCAtMSkuam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGludGVyZmFjZSBJRG9jdW1lbnRFbnRyeVxuXHR7XG5cdFx0aGVhZGVyOiBEb2N1bWVudEhlYWRlcjtcblx0XHRkb2N1bWVudDogRG9jdW1lbnQ7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgZGVwZW5kZW5jeSBcblx0ICogYmV0d2VlbiBkb2N1bWVudHMuXG5cdCAqL1xuXHRjbGFzcyBEZXBlbmRlbmN5XG5cdHtcblx0XHRjb25zdHJ1Y3RvcihyZWFkb25seSB0YXJnZXQ6IERvY3VtZW50KSB7IH1cblx0XHRcblx0XHRyZWZlcmVuY2VDb3VudCA9IDA7XG5cdH1cbn1cbiIsIlxuXG5cbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIGRvY3VtZW50J3MgaGVhZGVyLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIERvY3VtZW50SGVhZGVyXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihkb2N1bWVudDogRG9jdW1lbnQpXG5cdFx0e1xuXHRcdFx0dGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBGb3JjZXMgdGhlIGhlYWRlciB0byBiZSByZWNvbXB1dGVkLCBieSBzY2FubmluZ1xuXHRcdCAqIHRoZSBzdGF0ZW1lbnRzIGluIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxuXHRcdCAqIFxuXHRcdCAqIElmIHRoZSBoZWFkZXIgaGFzIGNoYW5nZWQsIHRoZSBtZXRob2QgcnVucyB0aGVcblx0XHQgKiBuZWNlc3NhcnkgaG9va3MgdG8gbm90aWZ5IHN1YnNjcmliZXJzIG9mIGhvb2tzIFxuXHRcdCAqIGFueSBhZGRlZCBvciByZW1vdmVkLlxuXHRcdCAqL1xuXHRcdHJlY29tcHV0ZSgpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb2xkVXJpTWFwID0gdGhpcy51cmlNYXA7XG5cdFx0XHRjb25zdCBuZXdVcmlNYXAgPSBuZXcgTWFwPFN0YXRlbWVudCwgVXJpPigpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgc3RhdGVtZW50IH0gb2YgdGhpcy5kb2N1bWVudC5lYWNoRGVzY2VuZGFudCgpKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBDdXJyZW50bHksIGFueSBzdGF0ZW1lbnQgd2l0aCBhbiBhbm5vdGF0aW9uIGlzXG5cdFx0XHRcdC8vIGNvbnNpZGVyZWQgdG8gYmUgYSBub24taGVhZGVyIHN0YXRlbWVudC4gVGhpc1xuXHRcdFx0XHQvLyB3aWxsIGNoYW5nZSBpZiBzY29wZWQgcmVmZXJlbmNlcyBiZWNvbWUgc3VwcG9ydGVkLlxuXHRcdFx0XHQvLyBBbHNvLCBvbmx5IG9uZSBVUkkgcmVmZXJlbmNlIHN0YXRlbWVudCBwZXIgbGluZSBpc1xuXHRcdFx0XHQvLyBhY2NlcHRlZC4gVmFjY3VvdXMgc3RhdGVtZW50cyBicmVhayB0aGUgaGVhZGVyLlxuXHRcdFx0XHRpZiAoc3RhdGVtZW50LmFsbEFubm90YXRpb25zLmxlbmd0aCA+IDAgfHwgc3RhdGVtZW50LmFsbERlY2xhcmF0aW9ucy5sZW5ndGggIT09IDEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBkZWNsID0gc3RhdGVtZW50LmFsbERlY2xhcmF0aW9uc1swXTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICh0eXBlb2YgZGVjbC5ib3VuZGFyeS5zdWJqZWN0ID09PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghKGRlY2wuYm91bmRhcnkuc3ViamVjdCBpbnN0YW5jZW9mIFVyaSkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCByZWZVcmkgPSBkZWNsLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHRcdGNvbnN0IGRvY1VyaSA9IHRoaXMuZG9jdW1lbnQuc291cmNlVXJpO1xuXHRcdFx0XHRjb25zdCB1cmlBYnNvbHV0ZSA9IE5vdC5udWxsKFVyaS50cnlQYXJzZShyZWZVcmksIGRvY1VyaSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0bmV3VXJpTWFwLnNldChzdGF0ZW1lbnQsIHVyaUFic29sdXRlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG9sZFVyaU1hcC5zaXplICsgbmV3VXJpTWFwLnNpemUgPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcmVtb3ZlZFVyaU1hcCA9IG5ldyBNYXA8VXJpLCBTdGF0ZW1lbnQ+KCk7XG5cdFx0XHRjb25zdCBhZGRlZFVyaU1hcCA9IG5ldyBNYXA8VXJpLCBTdGF0ZW1lbnQ+KCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3N0YXRlbWVudCwgb2xkVXJpXSBvZiBvbGRVcmlNYXApXG5cdFx0XHRcdGlmICghbmV3VXJpTWFwLmhhcyhzdGF0ZW1lbnQpKVxuXHRcdFx0XHRcdHJlbW92ZWRVcmlNYXAuc2V0KG9sZFVyaSwgc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbc3RhdGVtZW50LCBuZXdVcmldIG9mIG5ld1VyaU1hcClcblx0XHRcdFx0aWYgKCFvbGRVcmlNYXAuaGFzKHN0YXRlbWVudCkpXG5cdFx0XHRcdFx0YWRkZWRVcmlNYXAuc2V0KG5ld1VyaSwgc3RhdGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMuZG9jdW1lbnQucHJvZ3JhbTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbdXJpLCBzdGF0ZW1lbnRdIG9mIHJlbW92ZWRVcmlNYXApXG5cdFx0XHRcdHByb2dyYW0uY2F1c2UobmV3IENhdXNlVXJpUmVmZXJlbmNlUmVtb3ZlKHN0YXRlbWVudCwgdXJpKSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW3VyaSwgc3RhdGVtZW50XSBvZiBhZGRlZFVyaU1hcClcblx0XHRcdFx0cHJvZ3JhbS5jYXVzZShuZXcgQ2F1c2VVcmlSZWZlcmVuY2VBZGQoc3RhdGVtZW50LCB1cmkpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy51cmlNYXAuY2xlYXIoKTtcblx0XHRcdG5ld1VyaU1hcC5mb3JFYWNoKCh1cmksIHN0YXRlbWVudCkgPT4gdGhpcy51cmlNYXAuc2V0KHN0YXRlbWVudCwgdXJpKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIFRoZSBkb2N1bWVudCByZWZlcmVuY2UgVVJJIHRoYXQgY29ycmVzcG9uZHMgXG5cdFx0ICogdG8gdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQuIFJldHVybnMgbnVsbCBpbiB0aGUgY2FzZSB3aGVuXG5cdFx0ICogdGhlIHNwZWNpZmllZCBzdGF0ZW1lbnQgaXMgbm90IGEgcGFydCBvZiB0aGUgaGVhZGVyLlxuXHRcdCAqL1xuXHRcdGdldEhlYWRlclVyaShzdGF0ZW1lbnQ6IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy51cmlNYXAuZ2V0KHN0YXRlbWVudCkgfHwgbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIG9mIHRoZSBVUklzIHJlZmVyZW5jZWQgaW4gdGhlIGhlYWRlciBvZiB0aGlzIFxuXHRcdCAqIGRvY3VtZW50LCB3aGljaCBhcmUgaW5kZXhlZCBieSB0aGUgc3RhdGVtZW50IGluIHdoaWNoXG5cdFx0ICogdGhlIFVSSSBpcyBmb3VuZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHVyaU1hcCA9IG5ldyBNYXA8U3RhdGVtZW50LCBVcmk+KCk7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQ7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBMb2NhbCBtYXJrZXIgdmFsdWVzIHVzZWQgYXMgcmV0dXJuIHZhbHVlcyB0b1xuXHQgKiBpbmRpY2F0ZSB0aGF0IGEgcGF0dGVybiBmYWlsZWQgdG8gcGFyc2UuXG5cdCAqL1xuXHR0eXBlIFRQYXJzZUZhdWx0ID0gUmVhZG9ubHk8RmF1bHRUeXBlPFN0YXRlbWVudD4+O1xuXG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgb3B0aW9ucyBmb3IgdGhlIGxpbmUgcGFyc2VyLlxuXHQgKi9cblx0ZXhwb3J0IGludGVyZmFjZSBJTGluZVBhcnNlck9wdGlvbnNcblx0e1xuXHRcdHJlYWRvbmx5IHJlYWRQYXR0ZXJucz86IGJvb2xlYW47XG5cdFx0cmVhZG9ubHkgcmVhZFVyaXM/OiBib29sZWFuO1xuXHR9XG5cblxuXHQvKipcblx0ICogUGFyc2VzIGEgc2luZ2xlIGxpbmUgb2YgVHJ1dGggY29kZSwgYW5kIHJldHVybnNcblx0ICogYSBMaW5lIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIHdoYXQgd2FzIHJlYWQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTGluZVBhcnNlclxuXHR7XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgeWllbGRzIGFsbCBzdGF0ZW1lbnRzXG5cdFx0ICogKHVucGFyc2VkIGxpbmVzKSBvZiB0aGUgZ2l2ZW4gc291cmNlIHRleHQuIFxuXHRcdCAqL1xuXHRcdHN0YXRpYyAqcmVhZChmdWxsU291cmNlOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0aWYgKGZ1bGxTb3VyY2UubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGxldCBjdXJzb3IgPSAwO1xuXHRcdFx0bGV0IHN0YXRlbWVudFN0YXJ0ID0gMDtcblx0XHRcdFxuXHRcdFx0Zm9yICg7IGN1cnNvciA8IGZ1bGxTb3VyY2UubGVuZ3RoOyBjdXJzb3IrKylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGZ1bGxTb3VyY2VbY3Vyc29yXSA9PT0gU3ludGF4LnRlcm1pbmFsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWllbGQgZnVsbFNvdXJjZS5zbGljZShzdGF0ZW1lbnRTdGFydCwgY3Vyc29yKTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRTdGFydCA9IGN1cnNvciArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHN0YXRlbWVudFN0YXJ0IDwgY3Vyc29yKVxuXHRcdFx0XHR5aWVsZCBmdWxsU291cmNlLnNsaWNlKHN0YXRlbWVudFN0YXJ0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogTWFpbiBlbnRyeSBwb2ludCBmb3IgcGFyc2luZyBhIHNpbmdsZSBsaW5lIGFuZCBwcm9kdWNpbmcgYVxuXHRcdCAqIFJhd1N0YXRlbWVudCBvYmplY3QuXG5cdFx0ICogXG5cdFx0ICogVGhlIHBhcnNpbmcgYWxnb3JpdGhtIGlzIHNvbWUga2luZCBvZiBxdWFzaS1yZWN1c2l2ZSBkZXNjZW50IHdpdGhcblx0XHQgKiBsb29raGVhZHMgYW5kIGJhY2t0cmFja2luZyBpbiBzb21lIHBsYWNlcyB0byBtYWtlIHRoZSBsb2dpYyBlYXNpZXJcblx0XHQgKiB0byBmb2xsb3cuIFRlY2huaWNhbGx5LCBpdCdzIHByb2JhYmx5IHNvbWUgbWFzaC11cCBvZiBMTChrKSAmIExBTFIuXG5cdFx0ICogTWF5YmUgaWYgSSBibGV3IDQgeWVhcnMgb2YgbXkgbGlmZSBpbiBzb21lIHNpbGx5IENvbXAgU2NpIHByb2dyYW1cblx0XHQgKiBpbnN0ZWFkIG9mIGRyb3BwaW5nIG91dCBvZiBoaWdoIHNjaG9vbCBJIGNvdWxkIHNheSBmb3Igc3VyZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgcGFyc2UobGluZVRleHQ6IHN0cmluZywgb3B0aW9ucz86IElMaW5lUGFyc2VyT3B0aW9ucylcblx0XHR7XG5cdFx0XHRjb25zdCBwYXJzZXJPcHRpb25zID0gb3B0aW9ucyB8fCB7XG5cdFx0XHRcdHJlYWRQYXR0ZXJuczogdHJ1ZSxcblx0XHRcdFx0cmVhZFVyaXM6IHRydWVcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZVRleHQpO1xuXHRcdFx0Y29uc3Qgc291cmNlVGV4dCA9IGxpbmVUZXh0O1xuXHRcdFx0Y29uc3QgaW5kZW50ID0gcGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRjb25zdCBkZWNsYXJhdGlvbkVudHJpZXM6IEJvdW5kYXJ5PERlY2xhcmF0aW9uU3ViamVjdD5bXSA9IFtdO1xuXHRcdFx0Y29uc3QgYW5ub3RhdGlvbkVudHJpZXM6IEJvdW5kYXJ5PEFubm90YXRpb25TdWJqZWN0PltdID0gW107XG5cdFx0XHRjb25zdCBlc2MgPSBTeW50YXguZXNjYXBlQ2hhcjtcblx0XHRcdGxldCBmbGFncyA9IExpbmVGbGFncy5ub25lO1xuXHRcdFx0bGV0IGpvaW50UG9zaXRpb24gPSAtMTtcblx0XHRcdGxldCBzdW0gPSBcIlwiO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFVuaXZlcnNhbCBmdW5jdGlvbiBmb3IgcXVpY2tseSBwcm9kdWNpbmcgYSBSYXdTdGF0ZW1lbnRcblx0XHRcdCAqIGluc3RhbmNlIHVzaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIGNvbnN0cnVjdGVkIGxvY2FsIHZhcmlhYmxlcy5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgcmV0ID0gKGZhdWx0OiBUUGFyc2VGYXVsdCB8IG51bGwgPSBudWxsKSA9PiBuZXcgTGluZShcblx0XHRcdFx0c291cmNlVGV4dCxcblx0XHRcdFx0aW5kZW50LFxuXHRcdFx0XHRuZXcgQm91bmRhcnlHcm91cChkZWNsYXJhdGlvbkVudHJpZXMpLFxuXHRcdFx0XHRuZXcgQm91bmRhcnlHcm91cChhbm5vdGF0aW9uRW50cmllcyksXG5cdFx0XHRcdHN1bSxcblx0XHRcdFx0am9pbnRQb3NpdGlvbixcblx0XHRcdFx0ZmxhZ3MsXG5cdFx0XHRcdGZhdWx0KTtcblx0XHRcdFxuXHRcdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlbiB0aGUgbGluZSBjb250YWlucyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycyxcblx0XHRcdC8vIHRoaXMgY29uZGl0aW9uIHdpbGwgcGFzcywgYnlwYXNzaW5nIHRoZSBlbnRpcmUgcGFyc2luZyBwcm9jZXNzXG5cdFx0XHQvLyBhbmQgcmV0dXJuaW5nIGFuIChiYXNpY2FsbHkpIGZyZXNoIFJhd1N0YXRlbWVudCBvYmplY3QuXG5cdFx0XHRpZiAoIXBhcnNlci5tb3JlKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5pc1doaXRlc3BhY2U7XG5cdFx0XHRcdHJldHVybiByZXQoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5jb21tZW50KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICghcGFyc2VyLm1vcmUoKSB8fCBwYXJzZXIucmVhZChTeW50YXguc3BhY2UpIHx8IHBhcnNlci5yZWFkKFN5bnRheC50YWIpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5pc0NvbW1lbnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbiA9IG1hcms7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1bnBhcnNhYmxlRmF1bHRUeXBlID0gKCgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoU3ludGF4LmNvbWJpbmF0b3IpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5TdGF0ZW1lbnRCZWdpbnNXaXRoQ29tbWE7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5saXN0KSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50QmVnaW5zV2l0aEVsbGlwc2lzO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChlc2MgKyBTeW50YXguc3BhY2UpIHx8IHBhcnNlci5yZWFkKGVzYyArIFN5bnRheC50YWIpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5TdGF0ZW1lbnRCZWdpbnNXaXRoRXNjYXBlZFNwYWNlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZFRoZW5UZXJtaW5hbChlc2MpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5TdGF0ZW1lbnRDb250YWluc09ubHlFc2NhcGVDaGFyYWN0ZXI7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodW5wYXJzYWJsZUZhdWx0VHlwZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5pc0NydWZ0O1xuXHRcdFx0XHRcdHJldHVybiByZXQodW5wYXJzYWJsZUZhdWx0VHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBtYXJrQmVmb3JlVXJpID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCB1cmkgPSBtYXliZVJlYWRVcmkoKTtcblx0XHRcdFx0aWYgKHVyaSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5oYXNVcmk7XG5cdFx0XHRcdFx0ZGVjbGFyYXRpb25FbnRyaWVzLnB1c2gobmV3IEJvdW5kYXJ5KFxuXHRcdFx0XHRcdFx0bWFya0JlZm9yZVVyaSxcblx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdHVyaSkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiB0aGVuKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmtCZWZvcmVQYXR0ZXJuID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbWF5YmVSZWFkUGF0dGVybigpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdChwYXR0ZXJuKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5pc0NydWZ0O1xuXHRcdFx0XHRcdHJldHVybiByZXQocGF0dGVybik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXR0ZXJuKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZmxhZ3MgfD0gTGluZUZsYWdzLmhhc1BhdHRlcm47XG5cdFx0XHRcdFx0ZmxhZ3MgfD0gcGF0dGVybi5pc1RvdGFsID9cblx0XHRcdFx0XHRcdExpbmVGbGFncy5oYXNUb3RhbFBhdHRlcm4gOlxuXHRcdFx0XHRcdFx0TGluZUZsYWdzLmhhc1BhcnRpYWxQYXR0ZXJuO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGRlY2xhcmF0aW9uRW50cmllcy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdG1hcmtCZWZvcmVQYXR0ZXJuLFxuXHRcdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0cGF0dGVybikpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiB0aGVuKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgYm91bmRzRW50cnkgb2YgcmVhZERlY2xhcmF0aW9ucyhbXSkpXG5cdFx0XHRcdFx0ZGVjbGFyYXRpb25FbnRyaWVzLnB1c2goYm91bmRzRW50cnkpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHRoZW4oKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gdGhlbigpXG5cdFx0XHR7XG5cdFx0XHRcdGpvaW50UG9zaXRpb24gPSBtYXliZVJlYWRKb2ludCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmVhZFJlc3VsdCA9IHJlYWRBbm5vdGF0aW9ucyhbXSk7XG5cdFx0XHRcdHN1bSA9IHJlYWRSZXN1bHQucmF3LnRyaW0oKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgYm91bmRzRW50cnkgb2YgcmVhZFJlc3VsdC5hbm5vdGF0aW9ucylcblx0XHRcdFx0XHRhbm5vdGF0aW9uRW50cmllcy5wdXNoKGJvdW5kc0VudHJ5KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChqb2ludFBvc2l0aW9uID4gLTEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBkTGVuID0gZGVjbGFyYXRpb25FbnRyaWVzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBhTGVuID0gcmVhZFJlc3VsdC5hbm5vdGF0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGRMZW4gPT09IDApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGVjbGFyYXRpb25FbnRyaWVzLnVuc2hpZnQobmV3IEJvdW5kYXJ5KFxuXHRcdFx0XHRcdFx0XHRqb2ludFBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0XHRqb2ludFBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0XHRuZXcgQW5vbigpKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChhTGVuID09PSAwKVxuXHRcdFx0XHRcdFx0XHRmbGFncyB8PSBMaW5lRmxhZ3MuaXNWYWN1b3VzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChhTGVuID09PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZsYWdzIHw9IExpbmVGbGFncy5pc1JlZnJlc2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcmV0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZHMgdGhlIGZvbGxvd2luZyBzZXJpZXMgb2YgZGVjbGFyYXRpb25zLCB3aGljaCBtYXkgYmVcblx0XHRcdCAqIGVpdGhlciBkaXJlY3RseSBjb250YWluZWQgYnkgYSBzdGF0ZW1lbnQsIG9yIGluc2lkZSBhbiBpbmZpeC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcmVhZERlY2xhcmF0aW9ucyhxdWl0VG9rZW5zOiBzdHJpbmdbXSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZW50cmllczogQm91bmRhcnk8SWRlbnRpZmllcj5bXSA9IFtdO1xuXHRcdFx0XHRjb25zdCB1bnRpbCA9IHF1aXRUb2tlbnMuY29uY2F0KFN5bnRheC5qb2ludCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHJlYWRSZXN1bHQgPSBtYXliZVJlYWRJZGVudGlmaWVyKHVudGlsKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVhZFJlc3VsdCAhPT0gbnVsbClcblx0XHRcdFx0XHRcdGVudHJpZXMucHVzaChuZXcgQm91bmRhcnk8SWRlbnRpZmllcj4oXG5cdFx0XHRcdFx0XHRcdHJlYWRSZXN1bHQuYXQsIFxuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0XHRcdHJlYWRSZXN1bHQuaWRlbnRpZmllcikpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRoZSBmb2xsb3dpbmcgY29tYmluYXRvciBtdXN0IGJlIGVhdGVuIGJlZm9yZVxuXHRcdFx0XHRcdC8vIG1vdmluZyBvbiB0byBhbm90aGVyIGRlY2xhcmF0aW9uLiBJZiB0aGlzIGZhaWxzLFxuXHRcdFx0XHRcdC8vIGl0J3MgYmVjYXVzZSB0aGUgcGFyc2Ugc3RyZWFtIGhhcyBlbmRlZC5cblx0XHRcdFx0XHRpZiAoIXBhcnNlci5yZWFkKFN5bnRheC5jb21iaW5hdG9yKSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwZWVrSm9pbnQoKSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZW50cmllcztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIHRoZSBqb2ludCB0b2tlbiBmcm9tIHRoZSBwYXJzZSBzdHJlYW0uXG5cdFx0XHQgKiBDb25zdW1lcyBhbGwgc3Vycm91bmRpbmcgd2hpdGVzcGFjZS5cblx0XHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGpvaW50XG5cdFx0XHQgKiB0b2tlbiB3YXMgcmVhZC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkSm9pbnQoKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBtYXJrQmVmb3JlV3MgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRjb25zdCBtYXJrQWZ0ZXJXcyA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0bGV0IGZvdW5kSm9pbnRQb3NpdGlvbiA9IC0xO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSkgfHxcblx0XHRcdFx0XHRwYXJzZXIucmVhZChTeW50YXguam9pbnQgKyBTeW50YXgudGFiKSB8fFxuXHRcdFx0XHRcdHBhcnNlci5yZWFkVGhlblRlcm1pbmFsKFN5bnRheC5qb2ludCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3VuZEpvaW50UG9zaXRpb24gPSBtYXJrQWZ0ZXJXcztcblx0XHRcdFx0XHRwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrQmVmb3JlV3M7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBmb3VuZEpvaW50UG9zaXRpb247XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGpvaW50XG5cdFx0XHQgKiBpcyB0aGUgbmV4dCBsb2dpY2FsIHRva2VuIHRvIGJlIGNvbnN1bWVkLiBUcnVlIGlzIHJldHVybmVkXG5cdFx0XHQgKiBpbiB0aGUgY2FzZSB3aGVuIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBzaXQgYmV0d2VlbiB0aGVcblx0XHRcdCAqIGN1cnNvciBhbmQgdGhlIGpvaW50IG9wZXJhdG9yLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwZWVrSm9pbnQoKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBpbm5lclBlZWtKb2ludCA9ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VyLnBlZWsoU3ludGF4LmpvaW50ICsgU3ludGF4LnNwYWNlKSB8fFxuXHRcdFx0XHRcdFx0cGFyc2VyLnBlZWsoU3ludGF4LmpvaW50ICsgU3ludGF4LnRhYikgfHxcblx0XHRcdFx0XHRcdHBhcnNlci5wZWVrVGhlblRlcm1pbmFsKFN5bnRheC5qb2ludCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaW5uZXJQZWVrSm9pbnQoKSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghcGFyc2VyLnBlZWsoU3ludGF4LnNwYWNlKSAmJiAhcGFyc2VyLnBlZWsoU3ludGF4LnRhYikpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGNvbnN0IGF0Sm9pbnQgPSBpbm5lclBlZWtKb2ludCgpO1xuXHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGF0Sm9pbnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHJlYWRBbm5vdGF0aW9ucyhxdWl0VG9rZW5zOiBzdHJpbmdbXSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYW5ub3RhdGlvbnM6IEJvdW5kYXJ5PEFubm90YXRpb25TdWJqZWN0PltdID0gW107XG5cdFx0XHRcdGxldCByYXcgPSBcIlwiO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCByZWFkUmVzdWx0ID0gbWF5YmVSZWFkSWRlbnRpZmllcihxdWl0VG9rZW5zKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVhZFJlc3VsdCAhPT0gbnVsbClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhbm5vdGF0aW9ucy5wdXNoKG5ldyBCb3VuZGFyeShcblx0XHRcdFx0XHRcdFx0cmVhZFJlc3VsdC5hdCwgXG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0cmVhZFJlc3VsdC5pZGVudGlmaWVyKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJhdyArPSByZWFkUmVzdWx0LnJhdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5leHQgdG9rZW4gaXMgbm90IGEgY29tYmluYXRvciwgXG5cdFx0XHRcdFx0Ly8gdGhlIHBhcnNlIHN0cmVhbSBoYXMgZW5kZWQuXG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChTeW50YXguY29tYmluYXRvcikpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRhbm5vdGF0aW9ucyxcblx0XHRcdFx0XHRyYXdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgcmF3IGFubm90YXRpb24gZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdFx0ICogSWYgZm91bmQsIHRoZSByYXcgc3RyaW5nIGZvdW5kIGlzIHJldHVybmVkLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRJZGVudGlmaWVyKHF1aXRUb2tlbnM6IHN0cmluZ1tdKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1bnRpbCA9IHF1aXRUb2tlbnNcblx0XHRcdFx0XHQuY29uY2F0KFN5bnRheC5jb21iaW5hdG9yKVxuXHRcdFx0XHRcdC5maWx0ZXIodG9rID0+IHRvayAhPT0gU3ludGF4LmpvaW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHNob3VsZFF1aXRPbkpvaW50ID0gcXVpdFRva2Vucy5pbmNsdWRlcyhTeW50YXguam9pbnQpO1xuXHRcdFx0XHRjb25zdCBhdCA9IHBhcnNlci5wb3NpdGlvbiArIHBhcnNlci5yZWFkV2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRsZXQgdG9rZW4gPSBcIlwiO1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHBhcnNlci5tb3JlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodW50aWwuc29tZSh0b2sgPT4gcGFyc2VyLnBlZWsodG9rKSkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoc2hvdWxkUXVpdE9uSm9pbnQgJiYgcGVla0pvaW50KCkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBnMSA9IHBhcnNlci5yZWFkR3JhcGhlbWUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBUaGUgb25seSBvcGVyYXRvcnMgdGhhdCBjYW4gYmUgbWVhbmluZ2Z1bGx5IGVzY2FwZWQgYXRcblx0XHRcdFx0XHRcdC8vIHRoZSBpZGVudGlmaWVyIGxldmVsIGFyZSB0aGUgam9pbnQsIHRoZSBjb21iaW5hdG9yLCBhbmQgdGhlXG5cdFx0XHRcdFx0XHQvLyBwYXR0ZXJuIGRlbGltaXRlci4gT3RoZXIgb2NjdXJlbmNlcyBvZiB0aGUgZXNjYXBlIGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0Ly8gYXBwZW5kIHRoaXMgY2hhcmFjdGVyIHRvIHRoZSBpZGVudGlmaWVyLlxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoZzEgPT09IGVzYylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZzIgPSBwYXJzZXIucmVhZEdyYXBoZW1lKCk7XG5cdFx0XHRcdFx0XHRcdHRva2VuICs9IGcyO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dG9rZW4gKz0gZzE7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHRva2VuVHJpbW1lZCA9IHRva2VuLnRyaW0oKTtcblx0XHRcdFx0aWYgKCF0b2tlblRyaW1tZWQubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRhdCxcblx0XHRcdFx0XHRpZGVudGlmaWVyOiBuZXcgSWRlbnRpZmllcih0b2tlblRyaW1tZWQpLFxuXHRcdFx0XHRcdHJhdzogdG9rZW5cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgVVJJIHN0YXJ0aW5nIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cdFx0XHQgKiBvZiB0aGUgY3Vyc29yLiBUaGUgcG9zaXRpb24gb2YgdGhlIGN1cnNvciBpcyBub3QgY2hhbmdlZFxuXHRcdFx0ICogaW4gdGhlIGNhc2Ugd2hlbiBhIHZhbGlkIFVSSSB3YXMgbm90IHJlYWQuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFVyaSgpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghcGFyc2VyT3B0aW9ucy5yZWFkVXJpcylcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IG1hcmsgPSBwYXJzZXIucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IHVyaSA9IFVyaS50cnlQYXJzZShwYXJzZXIucmVhZFVudGlsKCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHVyaSA9PT0gbnVsbClcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHVyaTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGEgcGF0dGVybiBmcm9tIHRoZSBzdGVhbS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUGF0dGVybihuZXN0ZWQgPSBmYWxzZSk6IFBhdHRlcm4gfCBUUGFyc2VGYXVsdCB8IG51bGxcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFuZXN0ZWQgJiYgIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW4pKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFwYXJzZXJPcHRpb25zLnJlYWRQYXR0ZXJucylcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZXNlIGFyZSByZXNlcnZlZCBzdGFydGluZyBzZXF1ZW5jZXMuIFRoZXkncmUgaW52YWxpZFxuXHRcdFx0XHQvLyByZWdleCBzeW50YXgsIGFuZCB3ZSBtYXkgdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZSB0byBwYWNrXG5cdFx0XHRcdC8vIGluIG90aGVyIGxhbmd1YWdlIGZlYXR1cmVzLlxuXHRcdFx0XHRpZiAocGFyc2VyLnBlZWsoUmVnZXhTeW50YXhNaXNjLnBsdXMpIHx8XG5cdFx0XHRcdFx0cGFyc2VyLnBlZWsoUmVnZXhTeW50YXhNaXNjLnN0YXIpIHx8XG5cdFx0XHRcdFx0cGFyc2VyLnBlZWsoUmVnZXhTeW50YXhNaXNjLnJlc3RyYWluZWQpKVxuXHRcdFx0XHRcdHJldHVybiBGYXVsdHMuU3RhdGVtZW50QmVnaW5zV2l0aEludmFsaWRTZXF1ZW5jZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFR5cGVTY3JpcHQgaXNuJ3QgcGVyZmVjdC5cblx0XHRcdFx0Y29uc3QgdW5pdHMgPSBuZXN0ZWQgP1xuXHRcdFx0XHRcdHJlYWRSZWdleFVuaXRzKHRydWUpIDpcblx0XHRcdFx0XHRyZWFkUmVnZXhVbml0cyhmYWxzZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaXNQYXJzZUZhdWx0KHVuaXRzKSlcblx0XHRcdFx0XHRyZXR1cm4gdW5pdHM7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBSaWdodC10cmltIGFueSB0cmFpbGluZyB3aGl0ZXNwYWNlXG5cdFx0XHRcdHdoaWxlICh1bml0cy5sZW5ndGgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBsYXN0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCEobGFzdCBpbnN0YW5jZW9mIFJlZ2V4R3JhcGhlbWUpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGxhc3QuZ3JhcGhlbWUgIT09IFN5bnRheC5zcGFjZSAmJiBsYXN0LmdyYXBoZW1lICE9PSBTeW50YXgudGFiKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dW5pdHMucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmICh1bml0cy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5FbXB0eVBhdHRlcm47XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBsYXN0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGNvbnN0IGlzVG90YWwgPSBcblx0XHRcdFx0XHRsYXN0IGluc3RhbmNlb2YgUmVnZXhHcmFwaGVtZSAmJlxuXHRcdFx0XHRcdGxhc3QucXVhbnRpZmllciA9PT0gbnVsbCAmJlxuXHRcdFx0XHRcdGxhc3QuZ3JhcGhlbWUgPT09IFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW47XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBOZWVkIHRvIHBvcCBvZmYgdGhlIFxuXHRcdFx0XHRpZiAoaXNUb3RhbClcblx0XHRcdFx0XHR1bml0cy5wb3AoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE5vdyByZWFkIHRoZSBhbm5vdGF0aW9ucywgaW4gb3JkZXIgdG8gY29tcHV0ZSB0aGUgUGF0dGVybidzIGhhc2hcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgZm91bmRKb2ludFBvc2l0aW9uID0gbWF5YmVSZWFkSm9pbnQoKTtcblx0XHRcdFx0aWYgKGZvdW5kSm9pbnRQb3NpdGlvbiA8IDApXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQYXR0ZXJuKE9iamVjdC5mcmVlemUodW5pdHMpLCBpc1RvdGFsLCBcIlwiKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGFubm9zID0gcmVhZEFubm90YXRpb25zKFtdKS5hbm5vdGF0aW9ucztcblx0XHRcdFx0Y29uc3QgYW5ub3NBcnJheUpvaW5lZCA9IEFycmF5LmZyb20oYW5ub3MudmFsdWVzKCkpXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IHYuc3ViamVjdC50b1N0cmluZygpKVxuXHRcdFx0XHRcdC5qb2luKFN5bnRheC50ZXJtaW5hbCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBoYXNoID0gSGFzaC5jYWxjdWxhdGUoYW5ub3NBcnJheUpvaW5lZCk7XG5cdFx0XHRcdHBhcnNlci5wb3NpdGlvbiA9IG1hcms7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IFBhdHRlcm4oT2JqZWN0LmZyZWV6ZSh1bml0cyksIGlzVG90YWwsIGhhc2gpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiByZWFkUmVnZXhVbml0cyhuZXN0ZWQ6IHRydWUpOiBUUGFyc2VGYXVsdCB8IChSZWdleFVuaXQpW107XG5cdFx0XHRmdW5jdGlvbiByZWFkUmVnZXhVbml0cyhuZXN0ZWQ6IGZhbHNlKTogVFBhcnNlRmF1bHQgfCAoUmVnZXhVbml0IHwgSW5maXgpW107XG5cdFx0XHRmdW5jdGlvbiByZWFkUmVnZXhVbml0cyhuZXN0ZWQ6IGJvb2xlYW4pOiBUUGFyc2VGYXVsdCB8IChSZWdleFVuaXQgfCBJbmZpeClbXVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1bml0czogKFJlZ2V4VW5pdCB8IEluZml4KVtdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHNldE9yR3JvdXAgPSBtYXliZVJlYWRSZWdleFNldCgpIHx8IG1heWJlUmVhZFJlZ2V4R3JvdXAoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaXNQYXJzZUZhdWx0KHNldE9yR3JvdXApKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHNldE9yR3JvdXA7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNldE9yR3JvdXAgIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdChxdWFudGlmaWVyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHF1YW50aWZpZXI7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHVuaXRzLnB1c2goYXBwZW5kUXVhbnRpZmllcihzZXRPckdyb3VwLCBxdWFudGlmaWVyKSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5lc3RlZClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAocGFyc2VyLnBlZWsoUmVnZXhTeW50YXhEZWxpbWl0ZXIuYWx0ZXJuYXRvcikpXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAocGFyc2VyLnBlZWsoUmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBFbmQpKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIEluZml4ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYW55d2hlcmUgb3RoZXIgXG5cdFx0XHRcdFx0XHQvLyB0aGFuIGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHBhdHRlcm4uXG5cdFx0XHRcdFx0XHRjb25zdCBpbmZpeCA9IG1heWJlUmVhZEluZml4KCk7XG5cdFx0XHRcdFx0XHRpZiAoaXNQYXJzZUZhdWx0KGluZml4KSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGluZml4O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoaW5maXggIT09IG51bGwpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHF1YW50aWZpZXIgPSBtYXliZVJlYWRSZWdleFF1YW50aWZpZXIoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHF1YW50aWZpZXIgIT09IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5JbmZpeEhhc1F1YW50aWZpZXI7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR1bml0cy5wdXNoKGluZml4KTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChwZWVrSm9pbnQoKSlcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGdyYXBoZW1lID0gbWF5YmVSZWFkUmVnZXhHcmFwaGVtZSgpO1xuXHRcdFx0XHRcdGlmICghZ3JhcGhlbWUpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJZiB0aGUgZ3JhcGhlbWUgcmVhZCBpcyBpbiB0aGUgUmVnZXhTeW50YXhLbm93blNldFxuXHRcdFx0XHRcdC8vIGVudW1lcmF0aW9uLCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIGdyYXBoZW1lIHRvIGFcblx0XHRcdFx0XHQvLyBSZWdleFNldCBpbnN0YW5jZSwgYW5kIHB1c2ggdGhhdCBvbiB0byB0aGUgdW5pdHMgYXJyYXlcblx0XHRcdFx0XHQvLyBpbnN0ZWFkLlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHJlZ2V4S25vd25TZXQgPSAoKCkgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoZ3JhcGhlbWUuY2hhcmFjdGVyID09PSBSZWdleFN5bnRheEtub3duU2V0LndpbGQgJiYgIWdyYXBoZW1lLmVzY2FwZWQpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBSZWdleFN5bnRheEtub3duU2V0LndpbGQ7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChncmFwaGVtZS5lc2NhcGVkKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjaGFyYWN0ZXJXaXRoRXNjYXBlID0gZXNjICsgZ3JhcGhlbWUuY2hhcmFjdGVyO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBrbm93blNldCA9IFJlZ2V4U3ludGF4S25vd25TZXQucmVzb2x2ZShjaGFyYWN0ZXJXaXRoRXNjYXBlKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChrbm93blNldCAhPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4ga25vd25TZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpc1BhcnNlRmF1bHQocXVhbnRpZmllcikpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcXVhbnRpZmllcjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocmVnZXhLbm93blNldCAhPT0gbnVsbClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR1bml0cy5wdXNoKG5ldyBSZWdleFNldChbcmVnZXhLbm93blNldF0sIFtdLCBbXSwgW10sIGZhbHNlLCBxdWFudGlmaWVyKSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGdyYXBoZW1lLnVuaWNvZGVCbG9ja05hbWUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgdWJuID0gZ3JhcGhlbWUudW5pY29kZUJsb2NrTmFtZTtcblx0XHRcdFx0XHRcdHVuaXRzLnB1c2gobmV3IFJlZ2V4U2V0KFtdLCBbXSwgW3Vibl0sIFtdLCBmYWxzZSwgcXVhbnRpZmllcikpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChncmFwaGVtZS5lc2NhcGVkKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHNpZ24gPSBSZWdleFN5bnRheFNpZ24ucmVzb2x2ZShlc2MgKyBncmFwaGVtZS5jaGFyYWN0ZXIpO1xuXHRcdFx0XHRcdFx0aWYgKHNpZ24gIT09IG51bGwpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHVuaXRzLnB1c2gobmV3IFJlZ2V4U2lnbihzaWduLCBxdWFudGlmaWVyKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGlzIHBvaW50IGlzIHJlYWNoZWQsIGl0J3MgYmVjYXVzZSB0aGVyZSB3YXMgYSB1bm5lY2Nlc2FyaWx5XG5cdFx0XHRcdFx0XHQvLyBlc2NhcGVkIGNoYXJhY3RlciBmb3VuZCBpbiB0aGUgcGFyc2Ugc3RyZWFtLCBzdWNoIGFzIFwiXFxhXCIuIEluXG5cdFx0XHRcdFx0XHQvLyB0aGlzIGNhc2UsIHRoZSByYXcgY2hhcmFjdGVyIGNhbiBqdXN0IGJlIGFkZGVkIGFzIGEgcmVnZXggdW5pdC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dW5pdHMucHVzaChuZXcgUmVnZXhHcmFwaGVtZShcblx0XHRcdFx0XHRcdGdyYXBoZW1lLmNoYXJhY3Rlcixcblx0XHRcdFx0XHRcdHF1YW50aWZpZXIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHVuaXRzO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgYSBjaGFyYWN0ZXIgc2V0IGZyb20gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqIEV4YW1wbGU6IFthLXowLTldXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIG1heWJlUmVhZFJlZ2V4U2V0KCk6IFJlZ2V4U2V0IHwgVFBhcnNlRmF1bHQgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghcGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0U3RhcnQpKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgcm5nID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIucmFuZ2U7XG5cdFx0XHRcdGNvbnN0IGtub3duczogUmVnZXhTeW50YXhLbm93blNldFtdID0gW107XG5cdFx0XHRcdGNvbnN0IHJhbmdlczogUmVnZXhDaGFyUmFuZ2VbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBibG9ja3M6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdGNvbnN0IHNpbmdsZXM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdGNvbnN0IGlzTmVnYXRlZCA9ICEhcGFyc2VyLnJlYWQoUmVnZXhTeW50YXhNaXNjLm5lZ2F0ZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgY2xvc2VkID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogU3RvcmVzIGFsbCBHcmFwaGVtZXMgcmVhZC5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGNvbnN0IGdyYXBoZW1lczogKEdyYXBoZW1lIHwgbnVsbClbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFN0b3JlcyBib29sZWFucyB0aGF0IGFsaWduIHdpdGggdGhlIGl0ZW1zIGluIFwicXVldWVcIixcblx0XHRcdFx0ICogdGhhdCBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgcXVldWVkIEdyYXBoZW1lXG5cdFx0XHRcdCAqIGNhbiBwYXJ0aWNpcGF0ZSBpbiBhIHJhbmdlLlxuXHRcdFx0XHQgKi9cblx0XHRcdFx0Y29uc3QgcmFuZ2FibGVRdWV1ZTogYm9vbGVhbltdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKDs7KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZyA9IG1heWJlUmVhZFJlZ2V4R3JhcGhlbWUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZyA9PT0gbnVsbClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghZy5lc2NhcGVkICYmIGcuY2hhcmFjdGVyID09PSBSZWdleFN5bnRheERlbGltaXRlci5zZXRFbmQpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZy51bmljb2RlQmxvY2tOYW1lKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGJsb2Nrcy5wdXNoKGcudW5pY29kZUJsb2NrTmFtZSk7XG5cdFx0XHRcdFx0XHRyYW5nYWJsZVF1ZXVlLnB1c2goZmFsc2UpO1xuXHRcdFx0XHRcdFx0Z3JhcGhlbWVzLnB1c2gobnVsbCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZ0Z1bGwgPSBnLmVzY2FwZWQgPyBlc2MgKyBnLmNoYXJhY3RlciA6IGcuY2hhcmFjdGVyO1xuXHRcdFx0XHRcdGNvbnN0IGtub3duID0gUmVnZXhTeW50YXhLbm93blNldC5yZXNvbHZlKGdGdWxsKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoa25vd24gIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0a25vd25zLnB1c2goa25vd24pO1xuXHRcdFx0XHRcdFx0cmFuZ2FibGVRdWV1ZS5wdXNoKGZhbHNlKTtcblx0XHRcdFx0XHRcdGdyYXBoZW1lcy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGdyYXBoZW1lcy5wdXNoKGcpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJhbmdhYmxlUXVldWUucHVzaChcblx0XHRcdFx0XHRcdGcuY2hhcmFjdGVyLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHRcdGcuY2hhcmFjdGVyICE9PSBSZWdleFN5bnRheE1pc2MuYm91bmRhcnkgJiZcblx0XHRcdFx0XHRcdGcuY2hhcmFjdGVyICE9PSBSZWdleFN5bnRheE1pc2MuYm91bmRhcnlOb24pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChnLnVuaWNvZGVCbG9ja05hbWUpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBsZW4gPSBncmFwaGVtZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChsZW4gPCAzKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbWF5YmVSbmcgPSBncmFwaGVtZXNbbGVuIC0gMl07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1heWJlUm5nICE9PSBudWxsICYmIG1heWJlUm5nLmNoYXJhY3RlciAhPT0gcm5nKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFyYW5nYWJsZVF1ZXVlW2xlbiAtIDNdKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbWF5YmVGcm9tID0gZ3JhcGhlbWVzW2xlbiAtIDNdO1xuXHRcdFx0XHRcdGlmIChtYXliZUZyb20gPT09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBQZWVsIGJhY2sgc3ltYm9sIHF1ZXVlLCBhbmQgYWRkIGEgcmFuZ2Vcblx0XHRcdFx0XHQvLyB0byB0aGUgYWxwaGFiZXQgYnVpbGRlciBpZiB0aGUgcXVldWUgZ2V0cyBpbnRvXG5cdFx0XHRcdFx0Ly8gYSBzdGF0ZSB3aGVyZSBpdCdzIGVuZGluZyB3aXRoIHNvbWV0aGluZ1xuXHRcdFx0XHRcdC8vIGxvb2tpbmcgbGlrZTogPy0/XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZnJvbSA9IG1heWJlRnJvbS5jaGFyYWN0ZXIuY29kZVBvaW50QXQoMCkgfHwgMDtcblx0XHRcdFx0XHRjb25zdCB0byA9IGcuY2hhcmFjdGVyLmNvZGVQb2ludEF0KDApIHx8IDA7XG5cdFx0XHRcdFx0cmFuZ2VzLnB1c2gobmV3IFJlZ2V4Q2hhclJhbmdlKGZyb20sIHRvKSk7XG5cdFx0XHRcdFx0Z3JhcGhlbWVzLmxlbmd0aCAtPSAzO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWNsb3NlZClcblx0XHRcdFx0XHRyZXR1cm4gRmF1bHRzLlVudGVybWluYXRlZENoYXJhY3RlclNldDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgZyBvZiBncmFwaGVtZXMpXG5cdFx0XHRcdFx0aWYgKGcgIT09IG51bGwpXG5cdFx0XHRcdFx0XHRzaW5nbGVzLnB1c2goZy5jaGFyYWN0ZXIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFJlZ2V4UXVhbnRpZmllcigpO1xuXHRcdFx0XHRpZiAoaXNQYXJzZUZhdWx0KHF1YW50aWZpZXIpKVxuXHRcdFx0XHRcdHJldHVybiBxdWFudGlmaWVyO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFNldChcblx0XHRcdFx0XHRrbm93bnMsXG5cdFx0XHRcdFx0cmFuZ2VzLFxuXHRcdFx0XHRcdGJsb2Nrcyxcblx0XHRcdFx0XHRzaW5nbGVzLFxuXHRcdFx0XHRcdGlzTmVnYXRlZCxcblx0XHRcdFx0XHRxdWFudGlmaWVyKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBdHRlbXB0cyB0byByZWFkIGFuIGFsdGVybmF0aW9uIGdyb3VwIGZyb20gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqIEV4YW1wbGU6IChBfEJ8Qylcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUmVnZXhHcm91cCgpOiBSZWdleEdyb3VwIHwgVFBhcnNlRmF1bHQgfCBudWxsXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghcGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBTdGFydCkpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjYXNlczogKHJlYWRvbmx5IFJlZ2V4VW5pdFtdKVtdID0gW107XG5cdFx0XHRcdGxldCBjbG9zZWQgPSBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmFsdGVybmF0b3IpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHN1YlVuaXRzID0gcmVhZFJlZ2V4VW5pdHModHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKGlzUGFyc2VGYXVsdChzdWJVbml0cykpXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3ViVW5pdHM7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGNhbGwgdG8gbWF5YmVSZWFkUGF0dGVybiBjYXVzZXMgdGhlIGN1cnNvclxuXHRcdFx0XHRcdC8vIHRvIHJlYWNoIHRoZSBlbmQgb2YgdGUgcGFyc2Ugc3RyZWFtLCB0aGUgZXhwcmVzc2lvblxuXHRcdFx0XHRcdC8vIGlzIGludmFsaWQgYmVjYXVzZSBpdCB3b3VsZCBtZWFuIHRoZSBpbnB1dCBsb29rc1xuXHRcdFx0XHRcdC8vIHNvbWV0aGluZyBsaWtlOiAvKGFhfGJiXG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5VbnRlcm1pbmF0ZWRHcm91cDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBBIG51bGwgc3ViUGF0dGVybiBjb3VsZCBjb21lIGJhY2sgaW4gdGhlIGNhc2Ugd2hlbiBzb21lXG5cdFx0XHRcdFx0Ly8gYml6YXJyZSBzeW50YXggaXMgZm91bmQgaW4gdGhlIHBhdHRlcm4gc3VjaCBhczogKGF8fGIpXG5cdFx0XHRcdFx0aWYgKHN1YlVuaXRzID09PSBudWxsKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZXMucHVzaChPYmplY3QuZnJlZXplKHN1YlVuaXRzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmICghY2xvc2VkKVxuXHRcdFx0XHRcdHJldHVybiBGYXVsdHMuVW50ZXJtaW5hdGVkR3JvdXA7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBxdWFudGlmaWVyID0gbWF5YmVSZWFkUmVnZXhRdWFudGlmaWVyKCk7XG5cdFx0XHRcdGlmIChpc1BhcnNlRmF1bHQocXVhbnRpZmllcikpXG5cdFx0XHRcdFx0cmV0dXJuIHF1YW50aWZpZXI7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4R3JvdXAoT2JqZWN0LmZyZWV6ZShjYXNlcyksIHF1YW50aWZpZXIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEF0dGVtcHRzIHRvIHJlYWQgYSBwYXR0ZXJuIHF1YW50aWZpZXIgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtLlxuXHRcdFx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGVzLCB3aGljaCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgSmF2YVNjcmlwdFxuXHRcdFx0ICogcmVndWxhciBleHByZXNzaW9uIGZsYXZvciAoYW5kIG90aGVycz8pIGNhbm5vdCBwYXJzZSBhbiBleHByZXNzaW9uXG5cdFx0XHQgKiB3aXRoIHR3byBjb25zZWN1dGl2ZSBxdWFudGlmaWVycy5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUmVnZXhRdWFudGlmaWVyKCk6IFJlZ2V4UXVhbnRpZmllciB8IFRQYXJzZUZhdWx0IHwgbnVsbFxuXHRcdFx0e1xuXHRcdFx0XHQvKiogKi9cblx0XHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUXVhbnRpZmllcigpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2Muc3RhcikpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcigwLCBJbmZpbml0eSwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2MucGx1cykpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcigxLCBJbmZpbml0eSwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheE1pc2MucmVzdHJhaW5lZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcigwLCAxLCBmYWxzZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyU3RhcnQpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbWluID0gbWF5YmVSZWFkSW50ZWdlcigpO1xuXHRcdFx0XHRcdGlmIChtaW4gIT09IG51bGwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcXVhbnRFbmQgPSBSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyRW5kO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyB7Mn1cblx0XHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChxdWFudEVuZCkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgUmVnZXhRdWFudGlmaWVyKG1pbiwgbWluLCBpc1Jlc3RyYWluZWQoKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIHsyLH0gb3IgezIsM30gb3IgezIsPz8/XG5cdFx0XHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoUmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclNlcGFyYXRvcikpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChxdWFudEVuZCkpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBSZWdleFF1YW50aWZpZXIobWluLCBJbmZpbml0eSwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF4ID0gbWF5YmVSZWFkSW50ZWdlcigpO1xuXHRcdFx0XHRcdFx0XHRpZiAobWF4ICE9PSBudWxsICYmIHBhcnNlci5yZWFkKHF1YW50RW5kKSlcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ2V4UXVhbnRpZmllcihtaW4sIG1heCwgaXNSZXN0cmFpbmVkKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvKiogKi9cblx0XHRcdFx0ZnVuY3Rpb24gaXNSZXN0cmFpbmVkKClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiAhIXBhcnNlci5yZWFkKFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcXVhbnRpZmllciA9IG1heWJlUmVhZFF1YW50aWZpZXIoKTtcblx0XHRcdFx0aWYgKHF1YW50aWZpZXIpXG5cdFx0XHRcdFx0aWYgKG1heWJlUmVhZFF1YW50aWZpZXIoKSlcblx0XHRcdFx0XHRcdHJldHVybiBGYXVsdHMuRHVwbGljYXRlUXVhbnRpZmllcjtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBxdWFudGlmaWVyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRJbnRlZ2VyKClcblx0XHRcdHtcblx0XHRcdFx0bGV0IGludGVnZXJUZXh0ID0gXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMTYgJiYgcGFyc2VyLm1vcmUoKTsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZGlnaXQgPSAoKCkgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBkaWdpdCA9IDA7IGRpZ2l0IDw9IDk7IGRpZ2l0KyspXG5cdFx0XHRcdFx0XHRcdGlmIChwYXJzZXIucmVhZChkaWdpdC50b1N0cmluZygpKSlcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZGlnaXQudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWRpZ2l0KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aW50ZWdlclRleHQgKz0gZGlnaXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBpbnRlZ2VyVGV4dC5sZW5ndGggPiAwID9cblx0XHRcdFx0XHRwYXJzZUludChpbnRlZ2VyVGV4dCwgMTApIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBtYXliZVJlYWRJbmZpeCgpOiBJbmZpeCB8IFRQYXJzZUZhdWx0IHwgbnVsbFxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBtYXJrID0gcGFyc2VyLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBsaHNFbnRyaWVzOiBCb3VuZGFyeTxJZGVudGlmaWVyPltdID0gW107XG5cdFx0XHRcdGNvbnN0IHJoc0VudHJpZXM6IEJvdW5kYXJ5PElkZW50aWZpZXI+W10gPSBbXTtcblx0XHRcdFx0Y29uc3QgaW5maXhTdGFydCA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0bGV0IGluZml4RmxhZ3M6IEluZml4RmxhZ3MgPSBJbmZpeEZsYWdzLm5vbmU7XG5cdFx0XHRcdGxldCBxdWl0VG9rZW4gPSBJbmZpeFN5bnRheC5lbmQ7XG5cdFx0XHRcdGxldCBoYXNKb2ludCA9IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhcnNlci5yZWFkKEluZml4U3ludGF4Lm5vbWluYWxTdGFydCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbmZpeEZsYWdzIHw9IEluZml4RmxhZ3Mubm9taW5hbDtcblx0XHRcdFx0XHRxdWl0VG9rZW4gPSBJbmZpeFN5bnRheC5ub21pbmFsRW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHBhcnNlci5yZWFkKEluZml4U3ludGF4LnBhdHRlcm5TdGFydCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbmZpeEZsYWdzIHw9IEluZml4RmxhZ3MucGF0dGVybjtcblx0XHRcdFx0XHRxdWl0VG9rZW4gPSBJbmZpeFN5bnRheC5wYXR0ZXJuRW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHBhcnNlci5yZWFkKEluZml4U3ludGF4LnN0YXJ0KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGluZml4RmxhZ3MgfD0gSW5maXhGbGFncy5wb3B1bGF0aW9uO1xuXHRcdFx0XHRcdHF1aXRUb2tlbiA9IEluZml4U3ludGF4LmVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFyc2VyLnJlYWQoU3ludGF4LmpvaW50KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGluZml4RmxhZ3MgfD0gSW5maXhGbGFncy5wb3J0YWJpbGl0eTtcblx0XHRcdFx0XHRwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGJvdW5kc0VudHJ5IG9mIHJlYWRBbm5vdGF0aW9ucyhbcXVpdFRva2VuXSkuYW5ub3RhdGlvbnMpXG5cdFx0XHRcdFx0XHRyaHNFbnRyaWVzLnB1c2gobmV3IEJvdW5kYXJ5KFxuXHRcdFx0XHRcdFx0XHRib3VuZHNFbnRyeS5vZmZzZXRTdGFydCxcblx0XHRcdFx0XHRcdFx0cGFyc2VyLnBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0XHRib3VuZHNFbnRyeS5zdWJqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBib3VuZHNFbnRyeSBvZiByZWFkRGVjbGFyYXRpb25zKFtxdWl0VG9rZW5dKSlcblx0XHRcdFx0XHRcdGxoc0VudHJpZXMucHVzaChib3VuZHNFbnRyeSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1heWJlUmVhZEpvaW50KCkgPiAtMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRoYXNKb2ludCA9IHRydWU7XG5cdFx0XHRcdFx0XHRwYXJzZXIucmVhZFdoaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBib3VuZHNFbnRyeSBvZiByZWFkQW5ub3RhdGlvbnMoW3F1aXRUb2tlbl0pLmFubm90YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRyaHNFbnRyaWVzLnB1c2gobmV3IEJvdW5kYXJ5KFxuXHRcdFx0XHRcdFx0XHRcdGJvdW5kc0VudHJ5Lm9mZnNldFN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbixcblx0XHRcdFx0XHRcdFx0XHRib3VuZHNFbnRyeS5zdWJqZWN0KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBdm9pZCBwcm9kdWNpbmcgYW4gaW5maXggaW4gd2VpcmQgY2FzZXMgc3VjaCBhczpcblx0XHRcdFx0Ly8gPCA6ID4gIDwvICAvPiAgPDw6Pj5cblx0XHRcdFx0aWYgKGxoc0VudHJpZXMubGVuZ3RoICsgcmhzRW50cmllcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24gPSBtYXJrO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaGFzSm9pbnQpXG5cdFx0XHRcdFx0aW5maXhGbGFncyB8PSBJbmZpeEZsYWdzLmhhc0pvaW50O1xuXHRcdFx0XHRcblx0XHRcdFx0cGFyc2VyLnJlYWRXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXBhcnNlci5yZWFkKHF1aXRUb2tlbikpXG5cdFx0XHRcdFx0cmV0dXJuIEZhdWx0cy5VbnRlcm1pbmF0ZWRJbmZpeDtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXcgSW5maXgoXG5cdFx0XHRcdFx0aW5maXhTdGFydCxcblx0XHRcdFx0XHRwYXJzZXIucG9zaXRpb24sXG5cdFx0XHRcdFx0bmV3IEJvdW5kYXJ5R3JvdXAobGhzRW50cmllcyksXG5cdFx0XHRcdFx0bmV3IEJvdW5kYXJ5R3JvdXAocmhzRW50cmllcyksXG5cdFx0XHRcdFx0aW5maXhGbGFncyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQXR0ZW1wdHMgdG8gcmVhZCBvbmUgc2luZ2xlIHN5bWJvbCBmcm9tIHRoZSBwYXJzZSBzdHJlYW0sXG5cdFx0XHQgKiB3aGlsZSByZXNwZWN0aW5nIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlcywgYW5kIGVzY2FwZWRcblx0XHRcdCAqIGNoYXJhY3RlcnMuXG5cdFx0XHQgKiBcblx0XHRcdCAqIEByZXR1cm5zIFRoZSByZWFkIHN0cmluZywgb3IgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBjYXNlIHdoZW5cblx0XHRcdCAqIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgaW4gdGhlIHBhcnNlIHN0cmVhbS5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gbWF5YmVSZWFkUmVnZXhHcmFwaGVtZSgpOiBHcmFwaGVtZSB8IG51bGxcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFwYXJzZXIubW9yZSgpKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbWFyayA9IHBhcnNlci5wb3NpdGlvbjtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChSZWdleFN5bnRheERlbGltaXRlci51dGYxNkdyb3VwU3RhcnQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZGVsaW0gPSBSZWdleFN5bnRheERlbGltaXRlci51dGYxNkdyb3VwRW5kO1xuXHRcdFx0XHRcdGNvbnN0IHVuaWNvZGVSZWYgPSBwYXJzZXIucmVhZFVudGlsKGRlbGltKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHJlYWRVbnRpbCBtZXRob2Qgc3RvcHBlZCBiZWNhdXNlIGl0XG5cdFx0XHRcdFx0Ly8gYWN0dWFsbHkgaGl0IHRoZSBkZWxpbWl0ZXIsIGFuZCBub3QgYmVjYXVzZSBpdCByYW4gb3V0XG5cdFx0XHRcdFx0Ly8gb2YgY2hhcmFjdGVycy5cblx0XHRcdFx0XHRpZiAocGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwYXJzZXIucmVhZChkZWxpbSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChVbmljb2RlQmxvY2tzLmhhcyh1bmljb2RlUmVmLnRvTG93ZXJDYXNlKCkpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEdyYXBoZW1lKFwiXCIsIHVuaWNvZGVSZWYsIHRydWUpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBsZW4gPSB1bmljb2RlUmVmLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlmIChsZW4gPj0gMSAmJiBsZW4gPD0gNSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbnVtID0gcGFyc2VJbnQodW5pY29kZVJlZiwgMTYpO1xuXHRcdFx0XHRcdFx0XHRpZiAobnVtID09PSBudW0pXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBjaGFyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEdyYXBoZW1lKGNoYXIsIFwiXCIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFNvbWV0aGluZyBjYW1lIGluIHRoYXQgbG9va2VkIGxpa2UgYSB1bmljb2RlIGVzY2FwZVxuXHRcdFx0XHRcdC8vIHNlcXVlbmNlLCBidXQgdHVybmVkIG91dCBub3QgdG8gYmUsIGxpa2U6IFxcdVxuXHRcdFx0XHRcdHBhcnNlci5wb3NpdGlvbiA9IG1hcms7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwYXJzZXIucmVhZChlc2MpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHBhcnNlIHN0cmVhbSBlbmRzIHdpdGggYSBiYWNrc2xhc2gsIHdlIGp1c3Rcblx0XHRcdFx0XHQvLyByZXR1cm4gdGhlIGFjdHVhbCBiYWNrc2xhc2ggY2hhcmFjdGVyIGFzIGEgY2hhcmFjdGVyLlxuXHRcdFx0XHRcdC8vIFRoaXMgY292ZXJzIHJpZGljdWxvdXMgYnV0IHBvc3NpYmxlIGNhc2VzIHdoZXJlIGFcblx0XHRcdFx0XHQvLyBhbiB1bmFubm90YXRlZCB0eXBlIGlzIG5hbWVkIHNvbWV0aGluZyBsaWtlIFwiVGhpbmdcXFwiLlxuXHRcdFx0XHRcdGlmICghcGFyc2VyLm1vcmUoKSlcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgR3JhcGhlbWUoZXNjLCBcIlwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgZyA9IHBhcnNlci5yZWFkR3JhcGhlbWUoKTtcblx0XHRcdFx0XHRjb25zdCBkZWNvZGVkID0gUmVnZXhTeW50YXhTaWduLnVuZXNjYXBlKGVzYyArIGcpIHx8IGc7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcmFwaGVtZShkZWNvZGVkLCBcIlwiLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ldyBHcmFwaGVtZShwYXJzZXIucmVhZEdyYXBoZW1lKCksIFwiXCIsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyoqICovXG5cdFx0XHRmdW5jdGlvbiBpc1BhcnNlRmF1bHQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBSZWFkb25seTxGYXVsdFR5cGU8U3RhdGVtZW50Pj5cblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRmF1bHRUeXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGNvbnN0cnVjdG9yKCkgeyB9XG5cdH1cblxuXG5cdC8qKiAqL1xuXHRjbGFzcyBHcmFwaGVtZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgY2hhcmFjdGVyIGZvdW5kIGluIHRoZSBwYXJzZSBzdHJlYW0gaW5cblx0XHRcdCAqIHRoZWlyIHVuZXNjYXBlZCBmb3JtYXQuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuXHRcdFx0ICogd2hlbiB0aGUgZmllbGQgaXMgcmVmZXJyaW5nIHRvIGEgdW5pY29kZSBjaGFyYWN0ZXIsXG5cdFx0XHQgKiB0aGUgZmllbGQgd291bGQgc3RvcmUgXCLwn5CHXCIgLi4uIG5vdCBcIlxcdTFGNDA3XCIuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGNoYXJhY3Rlcjogc3RyaW5nLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIG5hbWUgb2YgdGhlIHVuaWNvZGUgYmxvY2sgc3BlY2lmaWVkLFxuXHRcdFx0ICogb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBncmFwaGVtZSBkb2VzIG5vdCByZWZlclxuXHRcdFx0ICogdG8gYSB1bmljb2RlIGJsb2NrLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSB1bmljb2RlQmxvY2tOYW1lOiBzdHJpbmcsXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoZSBkaXNjb3ZlcmVkIGdyYXBoZW1lIHdhc1xuXHRcdFx0ICogZXNjYXBlZCBpbiB0aGUgcGFyc2Ugc3RyZWFtLiBOb3RlIHRoYXQgaWYgdGhlXG5cdFx0XHQgKiBncmFwaGVtZSByZWZlcnMgdG8gYSBzcGVjaWFsIGNoYXJhY3Rlciwgc3VjaFxuXHRcdFx0ICogYXMgXCJcXGRcIiBmb3IgYWxsIGRpZ2l0cywgdGhpcyB3aWxsIGJlIHRydWUuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGVzY2FwZWQ6IGJvb2xlYW4pXG5cdFx0eyB9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTbGlnaHRseSBhd2t3YXJkIGhhY2sgZnVuY3Rpb24gdG8gYXR0YWNoIGEgUGF0dGVyblF1YW50aWZpZXJcblx0ICogdG8gYW4gYWxyZWFkeSBleGlzdGluZyBQYXR0ZXJuVW5pdCAod2l0aG91dCByZXNvcnRpbmcgdG8gbWFraW5nXG5cdCAqIHF1YW50aWZpZXIgYSBtdXRhYmxlIHByb3BlcnR5LlxuXHQgKi9cblx0ZnVuY3Rpb24gYXBwZW5kUXVhbnRpZmllcih1bml0OiBSZWdleFVuaXQsIHF1YW50aWZpZXI6IFJlZ2V4UXVhbnRpZmllciB8IG51bGwgPSBudWxsKVxuXHR7XG5cdFx0aWYgKHF1YW50aWZpZXIgPT09IG51bGwpXG5cdFx0XHRyZXR1cm4gdW5pdDtcblx0XHRcblx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4U2V0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWdleFNldChcblx0XHRcdFx0dW5pdC5rbm93bnMsXG5cdFx0XHRcdHVuaXQucmFuZ2VzLFxuXHRcdFx0XHR1bml0LnVuaWNvZGVCbG9ja3MsXG5cdFx0XHRcdHVuaXQuc2luZ2xlcyxcblx0XHRcdFx0dW5pdC5pc05lZ2F0ZWQsXG5cdFx0XHRcdHF1YW50aWZpZXIpO1xuXHRcdFxuXHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcm91cClcblx0XHRcdHJldHVybiBuZXcgUmVnZXhHcm91cCh1bml0LmNhc2VzLCBxdWFudGlmaWVyKTtcblx0XHRcblx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIFJlZ2V4R3JhcGhlbWUpXG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2V4R3JhcGhlbWUodW5pdC5ncmFwaGVtZSwgcXVhbnRpZmllcik7XG5cdFx0XG5cdFx0dGhyb3cgRXhjZXB0aW9uLm5vdEltcGxlbWVudGVkKCk7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBQbGFjZWhvbGRlciBvYmplY3QgdG8gbWFyayB0aGUgcG9zaXRpb24gb2Zcblx0ICogYW4gYW5vbnltb3VzIHR5cGUgd2l0aGluIGEgc3RhdGVtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEFub25cblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIE5vLW9wIHByb3BlcnR5IHVzZWQgZm9yIGRlYnVnZ2luZ1xuXHRcdCAqIHB1cnBvc2VzLCBhbmQgYWxzbyB0byBkb2RnZSBzdHJ1Y3R1cmFsXG5cdFx0ICogdHlwZSBjb21wYXRpYmlsaXR5IGJ1Z3MgaW4gVHlwZVNjcmlwdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpZCA9ICsrbmV4dElkO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gYF9fQU5PTiR7dGhpcy5pZH1fX2A7XG5cdFx0fVxuXHR9XG5cblx0bGV0IG5leHRJZCA9IDA7XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogU3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgbGluZSwgYWZ0ZXIgYmVpbmcgcGFyc2VkLlxuXHQgKiBBIExpbmUgaXMgZGlmZmVyZW50IGZyb20gYSBTdGF0ZW1lbnQgaW4gdGhhdCBpdCBoYXMgbm9cblx0ICogcmVsYXRpb25zaGlwIHRvIGEgRG9jdW1lbnQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgTGluZVxuXHR7XG5cdFx0LyoqKiAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgc291cmNlVGV4dDogc3RyaW5nLFxuXHRcdFx0cmVhZG9ubHkgaW5kZW50OiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSBkZWNsYXJhdGlvbnM6IEJvdW5kYXJ5R3JvdXA8RGVjbGFyYXRpb25TdWJqZWN0Pixcblx0XHRcdHJlYWRvbmx5IGFubm90YXRpb25zOiBCb3VuZGFyeUdyb3VwPEFubm90YXRpb25TdWJqZWN0Pixcblx0XHRcdHJlYWRvbmx5IHN1bTogc3RyaW5nLFxuXHRcdFx0cmVhZG9ubHkgam9pbnRQb3NpdGlvbjogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgZmxhZ3M6IExpbmVGbGFncyxcblx0XHRcdHJlYWRvbmx5IGZhdWx0VHlwZTogUmVhZG9ubHk8RmF1bHRUeXBlPFN0YXRlbWVudD4+IHwgbnVsbClcblx0XHR7IH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEEgYml0IGZpZWxkIGVudW1lcmF0aW9uIHVzZWQgdG8gZWZmaWNpZW50bHkgc3RvcmVcblx0ICogbWV0YSBkYXRhIGFib3V0IGEgTGluZSAob3IgYSBTdGF0ZW1lbnQpIG9iamVjdC5cblx0ICovXG5cdGV4cG9ydCBlbnVtIExpbmVGbGFnc1xuXHR7XG5cdFx0bm9uZSA9IDAsXG5cdFx0aXNSZWZyZXNoID0gMSxcblx0XHRpc1ZhY3VvdXMgPSAyLFxuXHRcdGlzQ29tbWVudCA9IDQsXG5cdFx0aXNXaGl0ZXNwYWNlID0gOCxcblx0XHRpc0Rpc3Bvc2VkID0gMTYsXG5cdFx0aXNDcnVmdCA9IDMyLFxuXHRcdGhhc1VyaSA9IDY0LFxuXHRcdGhhc1RvdGFsUGF0dGVybiA9IDEyOCxcblx0XHRoYXNQYXJ0aWFsUGF0dGVybiA9IDI1Nixcblx0XHRoYXNQYXR0ZXJuID0gNTEyXG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBTdGFrZXMgb3V0IHN0YXJ0aW5nIGFuZCBlbmRpbmcgY2hhcmFjdGVyIHBvc2l0aW9uc1xuXHQgKiBvZiBzdWJqZWN0cyB3aXRoaW4gYSBnaXZlbiByZWdpb24uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQm91bmRhcnlHcm91cDxUU3ViamVjdD5cblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKGJvdW5kYXJpZXM6IEJvdW5kYXJ5PFRTdWJqZWN0PltdKVxuXHRcdHtcblx0XHRcdHRoaXMuZW50cmllcyA9IE9iamVjdC5mcmVlemUoYm91bmRhcmllcy5zbGljZSgpLnNvcnQoKGVudHJ5QSwgZW50cnlCKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZW50cnlBLm9mZnNldFN0YXJ0IC0gZW50cnlCLm9mZnNldFN0YXJ0O1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHQqW1N5bWJvbC5pdGVyYXRvcl0oKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKVxuXHRcdFx0XHR5aWVsZCBlbnRyeTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVhY2hTdWJqZWN0KClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcylcblx0XHRcdFx0eWllbGQgZW50cnkuc3ViamVjdDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aW5zcGVjdChvZmZzZXQ6IG51bWJlcik6IFRTdWJqZWN0IHwgbnVsbFxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKVxuXHRcdFx0XHRpZiAob2Zmc2V0ID49IGVudHJ5Lm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBlbnRyeS5vZmZzZXRFbmQpXG5cdFx0XHRcdFx0cmV0dXJuIGVudHJ5LnN1YmplY3Q7XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRmaXJzdCgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiB0aGlzKVxuXHRcdFx0XHRyZXR1cm4gZW50cnk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKiogR2V0cyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgZGVmaW5lZCBpbiB0aGUgYm91bmRzLiAqL1xuXHRcdGdldCBsZW5ndGgoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGVudHJpZXM6IHJlYWRvbmx5IEJvdW5kYXJ5PFRTdWJqZWN0PltdO1xuXHR9XG5cblxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIEJvdW5kYXJ5PFRTdWJqZWN0PlxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBvZmZzZXRTdGFydDogbnVtYmVyLFxuXHRcdFx0cmVhZG9ubHkgb2Zmc2V0RW5kOiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSBzdWJqZWN0OiBUU3ViamVjdClcblx0XHR7IH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgU3RhdGVtZW50XG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBMb2dpY2FsIGNsb2NrIHZhbHVlIHVzZWQgdG8gbWFrZSBjaHJvbm9sb2dpY2FsIFxuXHRcdCAqIGNyZWF0aW9uLXRpbWUgY29tcGFyaXNvbnMgYmV0d2VlbiBTdGF0ZW1lbnRzLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHN0YW1wID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihkb2N1bWVudDogRG9jdW1lbnQsIHRleHQ6IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCBsaW5lID0gTGluZVBhcnNlci5wYXJzZSh0ZXh0KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcblx0XHRcdHRoaXMuc291cmNlVGV4dCA9IGxpbmUuc291cmNlVGV4dDtcblx0XHRcdHRoaXMuc3VtID0gbGluZS5zdW07XG5cdFx0XHR0aGlzLmluZGVudCA9IGxpbmUuaW5kZW50O1xuXHRcdFx0dGhpcy5mbGFncyA9IGxpbmUuZmxhZ3M7XG5cdFx0XHR0aGlzLmpvaW50UG9zaXRpb24gPSBsaW5lLmpvaW50UG9zaXRpb247XG5cdFx0XHRcblx0XHRcdHRoaXMuYWxsRGVjbGFyYXRpb25zID0gT2JqZWN0LmZyZWV6ZShBcnJheS5mcm9tKGxpbmUuZGVjbGFyYXRpb25zKVxuXHRcdFx0XHQubWFwKGJvdW5kYXJ5ID0+IG5ldyBTcGFuKHRoaXMsIGJvdW5kYXJ5KSkpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFsbEFubm90YXRpb25zID0gT2JqZWN0LmZyZWV6ZShBcnJheS5mcm9tKGxpbmUuYW5ub3RhdGlvbnMpXG5cdFx0XHRcdC5tYXAoYm91bmRhcnkgPT4gbmV3IFNwYW4odGhpcywgYm91bmRhcnkpKSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZhdWx0czogRmF1bHRbXSA9IFtdO1xuXHRcdFx0Y29uc3QgY3J1ZnRPYmplY3RzID0gbmV3IFNldDxTdGF0ZW1lbnQgfCBTcGFuIHwgSW5maXhTcGFuPigpO1xuXHRcdFx0XG5cdFx0XHRpZiAobGluZS5mYXVsdFR5cGUgIT09IG51bGwpXG5cdFx0XHRcdGZhdWx0cy5wdXNoKG5ldyBGYXVsdChsaW5lLmZhdWx0VHlwZSwgdGhpcykpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0IG9mIHRoaXMuZWFjaFBhcnNlRmF1bHQoKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGZhdWx0LnR5cGUuc2V2ZXJpdHkgPT09IEZhdWx0U2V2ZXJpdHkuZXJyb3IpXG5cdFx0XHRcdFx0Y3J1ZnRPYmplY3RzLmFkZChmYXVsdC5zb3VyY2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0ZmF1bHRzLnB1c2goZmF1bHQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZhdWx0IG9mIGZhdWx0cylcblx0XHRcdFx0Ly8gQ2hlY2sgbmVlZGVkIHRvIHN1cHBvcnQgdGhlIHVuaXQgdGVzdHMsIHRoZSBmZWVkXG5cdFx0XHRcdC8vIGZha2UgZG9jdW1lbnQgb2JqZWN0cyBpbnRvIHRoZSBzdGF0ZW1lbnQgY29uc3RydWN0b3IuXG5cdFx0XHRcdGlmIChkb2N1bWVudC5wcm9ncmFtICYmIGRvY3VtZW50LnByb2dyYW0uZmF1bHRzKVxuXHRcdFx0XHRcdGRvY3VtZW50LnByb2dyYW0uZmF1bHRzLnJlcG9ydChmYXVsdCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuY3J1ZnRPYmplY3RzID0gY3J1ZnRPYmplY3RzO1xuXHRcdFx0dGhpcy5mYXVsdHMgPSBPYmplY3QuZnJlZXplKGZhdWx0cyk7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvZ3JhbVN0YW1wID0gZG9jdW1lbnQucHJvZ3JhbSA/XG5cdFx0XHRcdGRvY3VtZW50LnByb2dyYW0udmVyc2lvbiA6XG5cdFx0XHRcdFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0fVxuXHRcdFxuXHRcdHJlYWRvbmx5IHByb2dyYW1TdGFtcDogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgKmVhY2hQYXJzZUZhdWx0KCk6IEl0ZXJhYmxlSXRlcmF0b3I8UmVhZG9ubHk8RmF1bHQ8VEZhdWx0U291cmNlPj4+XG5cdFx0e1xuXHRcdFx0Ly8gQ2hlY2sgZm9yIHRhYnMgYW5kIHNwYWNlcyBtaXh0dXJlXG5cdFx0XHRpZiAodGhpcy5pbmRlbnQgPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgaGFzVGFicyA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgaGFzU3BhY2VzID0gZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHRoaXMuaW5kZW50Oylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGNociA9IHRoaXMuc291cmNlVGV4dFtpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY2hyID09PSBTeW50YXgudGFiKVxuXHRcdFx0XHRcdFx0aGFzVGFicyA9IHRydWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNociA9PT0gU3ludGF4LnNwYWNlKVxuXHRcdFx0XHRcdFx0aGFzU3BhY2VzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGhhc1RhYnMgJiYgaGFzU3BhY2VzKVxuXHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuVGFic0FuZFNwYWNlcywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmFsbERlY2xhcmF0aW9ucy5sZW5ndGggPiAxKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdWJqZWN0czogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbERlY2xhcmF0aW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN1YlRleHQgPSBzcGFuLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0aWYgKHN1YmplY3RzLmluY2x1ZGVzKHN1YlRleHQpKVxuXHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5EdXBsaWNhdGVEZWNsYXJhdGlvbiwgc3Bhbik7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c3ViamVjdHMucHVzaChzdWJUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5hbGxBbm5vdGF0aW9ucy5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBUaGlzIHBlcmZvcm1zIGFuIGV4cGVkaWVudCBjaGVjayBmb3IgXCJMaXN0SW50cmluc2ljRXh0ZW5kaW5nTGlzdFwiLFxuXHRcdFx0XHQvLyBob3dldmVyLCBmdWxsIHR5cGUgYW5hbHlzaXMgaXMgcmVxdWlyZWQgdG8gY292ZXIgYWxsIGNhc2VzIHdoZXJlXG5cdFx0XHRcdC8vIHRoaXMgZmF1bHQgbWF5IGJlIHJlcG9ydGVkLlxuXHRcdFx0XHRjb25zdCBnZXRMaXN0U3BhbnMgPSAoc3BhbnM6IHJlYWRvbmx5IFNwYW5bXSkgPT4gc3BhbnMuZmlsdGVyKHNwYW4gPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN1YiA9IHNwYW4uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdFx0XHRyZXR1cm4gc3ViIGluc3RhbmNlb2YgSWRlbnRpZmllciAmJiBzdWIuaXNMaXN0O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGxoc0xpc3RTcGFucyA9IGdldExpc3RTcGFucyh0aGlzLmFsbERlY2xhcmF0aW9ucyk7XG5cdFx0XHRcdGNvbnN0IHJoc0xpc3RTcGFucyA9IGdldExpc3RTcGFucyh0aGlzLmFsbEFubm90YXRpb25zKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChsaHNMaXN0U3BhbnMubGVuZ3RoID4gMCAmJiByaHNMaXN0U3BhbnMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgcmhzTGlzdFNwYW5zKVxuXHRcdFx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5MaXN0SW50cmluc2ljRXh0ZW5kaW5nTGlzdCwgc3Bhbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhdHRlcm4gPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuYWxsRGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGhwID0gTGluZUZsYWdzLmhhc1BhdHRlcm47XG5cdFx0XHRcdGlmICgodGhpcy5mbGFncyAmIGhwKSAhPT0gaHApXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBzdWJqZWN0ID0gdGhpcy5hbGxEZWNsYXJhdGlvbnNbMF0uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdFx0cmV0dXJuIHN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuID9cblx0XHRcdFx0XHRzdWJqZWN0IDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhdHRlcm4gPT09IG51bGwpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWYgKCFwYXR0ZXJuLmlzVmFsaWQpXG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuUGF0dGVybkludmFsaWQsIHRoaXMpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmFsbEFubm90YXRpb25zLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5QYXR0ZXJuV2l0aG91dEFubm90YXRpb24sIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGF0dGVybi50ZXN0KFwiXCIpKVxuXHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLlBhdHRlcm5DYW5NYXRjaEVtcHR5LCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFwYXR0ZXJuLmlzVG90YWwpXG5cdFx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiBwYXR0ZXJuLmVhY2hVbml0KCkpXG5cdFx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lKVxuXHRcdFx0XHRcdFx0aWYgKHVuaXQuZ3JhcGhlbWUgPT09IFN5bnRheC5jb21iaW5hdG9yKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLlBhdHRlcm5QYXJ0aWFsV2l0aENvbWJpbmF0b3IsIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgcGF0dGVyblNwYW4gPSB0aGlzLmFsbERlY2xhcmF0aW9uc1swXTtcblx0XHRcdGlmIChwYXR0ZXJuU3Bhbi5pbmZpeGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpbmZpeFNwYW5zOiBJbmZpeFNwYW5bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4IG9mIHBhdHRlcm5TcGFuLmluZml4ZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGxocyA9IEFycmF5LmZyb20ocGF0dGVyblNwYW4uZWFjaERlY2xhcmF0aW9uRm9ySW5maXgoaW5maXgpKTtcblx0XHRcdFx0Y29uc3QgcmhzID0gQXJyYXkuZnJvbShwYXR0ZXJuU3Bhbi5lYWNoQW5ub3RhdGlvbkZvckluZml4KGluZml4KSk7XG5cdFx0XHRcdGNvbnN0IGFsbCA9IGxocy5jb25jYXQocmhzKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoaXMgaXMgYSBiaXQgb3V0IG9mIHBsYWNlIC4uLiBidXQgd2UgbmVlZCB0byBwb3B1bGF0ZSB0aGVcblx0XHRcdFx0Ly8gaW5maXhTcGFucyBhcnJheSBhbmQgdGhpcyBpcyBwcm9iYWJseSB0aGUgbW9zdCBlZmZpY2llbnRcblx0XHRcdFx0Ly8gcGxhY2UgdG8gZG8gdGhhdC5cblx0XHRcdFx0aW5maXhTcGFucy5wdXNoKC4uLmFsbCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiBhbGwpXG5cdFx0XHRcdFx0aWYgKGluZml4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LmlzTGlzdClcblx0XHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuSW5maXhVc2luZ0xpc3RPcGVyYXRvciwgaW5maXhTcGFuKTtcblx0XHRcdFx0XG5cdFx0XHRcdHlpZWxkICpkZWR1cEluZml4U3ViamVjdHMobGhzKTtcblx0XHRcdFx0eWllbGQgKmRlZHVwSW5maXhTdWJqZWN0cyhyaHMpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgbGhzSWRlbnRpZmllcnMgPSBsaHMubWFwKG5meFNwYW4gPT4gXG5cdFx0XHRcdFx0bmZ4U3Bhbi5ib3VuZGFyeS5zdWJqZWN0LnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgcmhzKVxuXHRcdFx0XHRcdGlmIChsaHNJZGVudGlmaWVycy5pbmNsdWRlcyhpbmZpeFNwYW4uYm91bmRhcnkuc3ViamVjdC50b1N0cmluZygpKSlcblx0XHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuSW5maXhIYXNTZWxmUmVmZXJlbnRpYWxUeXBlLCBpbmZpeFNwYW4pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGluZml4LmlzUG9wdWxhdGlvbilcblx0XHRcdFx0XHRmb3IgKGxldCBpZHggPSAxOyBpZHggPCBsaHMubGVuZ3RoOyBpZHgrKylcblx0XHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChGYXVsdHMuSW5maXhQb3B1bGF0aW9uQ2hhaW5pbmcsIGxoc1tpZHhdKTtcblx0XHRcdFx0XG5cdFx0XHRcdHlpZWxkICpleHBlZGllbnRMaXN0Q2hlY2sobGhzKTtcblx0XHRcdFx0eWllbGQgKmV4cGVkaWVudExpc3RDaGVjayhyaHMpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiBkZWR1cEluZml4ZXNBY3Jvc3NJbmZpeGVzKFxuXHRcdFx0XHRwYXR0ZXJuU3Bhbixcblx0XHRcdFx0aW5maXggPT4gcGF0dGVyblNwYW4uZWFjaERlY2xhcmF0aW9uRm9ySW5maXgoaW5maXgpKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGluZml4U3Bhbi5jb250YWluaW5nSW5maXguaXNQb3B1bGF0aW9uKVxuXHRcdFx0XHRcdHlpZWxkIG5ldyBGYXVsdChcblx0XHRcdFx0XHRcdEZhdWx0cy5Qb3B1bGF0aW9uSW5maXhIYXNNdWx0aXBsZURlZmluaXRpb25zLFxuXHRcdFx0XHRcdFx0aW5maXhTcGFuKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgZGVkdXBJbmZpeGVzQWNyb3NzSW5maXhlcyhcblx0XHRcdFx0cGF0dGVyblNwYW4sXG5cdFx0XHRcdGluZml4ID0+IHBhdHRlcm5TcGFuLmVhY2hBbm5vdGF0aW9uRm9ySW5maXgoaW5maXgpKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGluZml4U3Bhbi5jb250YWluaW5nSW5maXguaXNQb3J0YWJpbGl0eSlcblx0XHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoXG5cdFx0XHRcdFx0XHRGYXVsdHMuUG9ydGFiaWxpdHlJbmZpeEhhc011bHRpcGxlRGVmaW5pdGlvbnMsIFxuXHRcdFx0XHRcdFx0aW5maXhTcGFuKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5faW5maXhTcGFucyA9IE9iamVjdC5mcmVlemUoaW5maXhTcGFucyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGUgam9pbnQgb3BlcmF0b3IgZXhpc3RzIGF0IHRoZVxuXHRcdCAqIGVuZCBvZiB0aGUgc3RhdGVtZW50LCBmb3JjaW5nIHRoZSBzdGF0ZW1lbnQnc1xuXHRcdCAqIGRlY2xhcmF0aW9ucyB0byBiZSBcInJlZnJlc2ggdHlwZXNcIi5cblx0XHQgKi9cblx0XHRnZXQgaXNSZWZyZXNoKClcblx0XHR7XG5cdFx0XHRjb25zdCBmID0gTGluZUZsYWdzLmlzUmVmcmVzaDtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIGYpID09PSBmO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhlIHN0YXRlbWVudCBjb250YWlucyBub3RoaW5nXG5cdFx0ICogb3RoZXIgdGhhbiBhIHNpbmdsZSBqb2ludCBvcGVyYXRvci5cblx0XHQgKi9cblx0XHRnZXQgaXNWYWN1b3VzKClcblx0XHR7XG5cdFx0XHRjb25zdCBmID0gTGluZUZsYWdzLmlzVmFjdW91cztcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIGYpID09PSBmO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhlIHN0YXRlbWVudCBpcyBhIGNvbW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0IGlzQ29tbWVudCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc0NvbW1lbnQ7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBmKSA9PT0gZjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoZSBzdGF0ZW1lbnQgY29udGFpbnNcblx0XHQgKiBubyBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuXHRcdCAqL1xuXHRcdGdldCBpc1doaXRlc3BhY2UoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGYgPSBMaW5lRmxhZ3MuaXNXaGl0ZXNwYWNlO1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgZikgPT09IGY7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGUgc3RhdGVtZW50IGlzIGEgY29tbWVudCBvciB3aGl0ZXNwYWNlLlxuXHRcdCAqL1xuXHRcdGdldCBpc05vb3AoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmlzQ29tbWVudCB8fCB0aGlzLmlzV2hpdGVzcGFjZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoZSBzdGF0ZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0J3Ncblx0XHQgKiBjb250YWluaW5nIGRvY3VtZW50LiBSZW1vdmFsIG9jY3VycyBhZnRlciB0aGUgc3RhdGVtZW50XG5cdFx0ICogaGFzIGJlZW4gaW52YWxpZGF0ZWQuIFRoZXJlZm9yZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGZhbHNlXG5cdFx0ICogYmVmb3JlIHRoZSBpbnZhbGlkYXRpb24gcGhhc2UgaGFzIG9jY3VyZWQsIGV2ZW4gaWYgaXQgd2lsbCBiZVxuXHRcdCAqIGRpc3Bvc2VkIGluIHRoZSBjdXJyZW50IGVkaXQgdHJhbnNhY3Rpb24uXG5cdFx0ICovXG5cdFx0Z2V0IGlzRGlzcG9zZWQoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGYgPSBMaW5lRmxhZ3MuaXNEaXNwb3NlZDtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIGYpID09PSBmO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRnZXQgaXNDcnVmdCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZiA9IExpbmVGbGFncy5pc0NydWZ0O1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgZikgPT09IGY7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRwcml2YXRlIGZsYWdzID0gTGluZUZsYWdzLm5vbmU7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgZmF1bHRzOiByZWFkb25seSBGYXVsdFtdO1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRoYXQgY29udGFpbnMgdGhpcyBzdGF0ZW1lbnQuICovXG5cdFx0cmVhZG9ubHkgZG9jdW1lbnQ6IERvY3VtZW50O1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgdGhlIGluZGVudCBsZXZlbCBvZiB0aGUgc3RhdGVtZW50LiAqL1xuXHRcdHJlYWRvbmx5IGluZGVudDogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc2V0IG9mIG9iamVjdHMgdGhhdCBhcmUgY29udGFpbmVkIGJ5IHRoaXMgU3RhdGVtZW50LCBcblx0XHQgKiBhbmQgYXJlIG1hcmtlZCBhcyBjcnVmdC4gTm90ZSB0aGF0IHRoZSBvbmx5IFN0YXRlbWVudCBvYmplY3Rcblx0XHQgKiB0aGF0IG1heSBiZSBsb2NhdGVkIGluIHRoaXMgc2V0IGlzIHRoaXMgU3RhdGVtZW50IG9iamVjdCBpdHNlbGYuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgY3J1ZnRPYmplY3RzOiBSZWFkb25seVNldDxTdGF0ZW1lbnQgfCBTcGFuIHwgSW5maXhTcGFuPjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBsaW5lIG51bWJlciBvZiB0aGlzIHN0YXRlbWVudCBpbiBpdCdzIGNvbnRhaW5pbmdcblx0XHQgKiBkb2N1bWVudCwgb3IgLTEgaWYgdGhlIHN0YXRlbWVudCBpcyBkaXNwb3NlZCBhbmQvb3IgaXMgbm90XG5cdFx0ICogaW4gdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGdldCBpbmRleCgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaXNEaXNwb3NlZClcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50ID9cblx0XHRcdFx0dGhpcy5kb2N1bWVudC5nZXRMaW5lTnVtYmVyKHRoaXMpIDpcblx0XHRcdFx0LTE7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgb2Ygc3BhbnMgaW4gdGhhdCByZXByZXNlbnQgdGhlIGRlY2xhcmF0aW9uc1xuXHRcdCAqIG9mIHRoaXMgc3RhdGVtZW50LCBleGNsdWRpbmcgdGhvc2UgdGhhdCBoYXZlIGJlZW4gbWFya2VkXG5cdFx0ICogYXMgb2JqZWN0LWxldmVsIGNydWZ0LlxuXHRcdCAqL1xuXHRcdGdldCBkZWNsYXJhdGlvbnMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNydWZ0T2JqZWN0cy5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hbGxEZWNsYXJhdGlvbnM7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dDogU3BhbltdID0gW107XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc3BhbiBvZiB0aGlzLmFsbERlY2xhcmF0aW9ucylcblx0XHRcdFx0aWYgKCF0aGlzLmNydWZ0T2JqZWN0cy5oYXMoc3BhbikpXG5cdFx0XHRcdFx0b3V0LnB1c2goc3Bhbik7XG5cdFx0XHRcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKG91dCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgYXJyYXkgb2Ygc3BhbnMgdGhhdCByZXByZXNlbnQgdGhlIGRlY2xhcmF0aW9uc1xuXHRcdCAqIG9mIHRoaXMgc3RhdGVtZW50LCBpbmNsdWRpbmcgdGhvc2UgdGhhdCBoYXZlIGJlZW4gbWFya2VkXG5cdFx0ICogYXMgb2JqZWN0LWxldmVsIGNydWZ0LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGFsbERlY2xhcmF0aW9uczogcmVhZG9ubHkgU3BhbltdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSBsaXN0IG9mIGFsbCBpbmZpeGVzIGRlZmluZWQgaW4gdGhlIHBhdHRlcm4gb2YgdGhpcyBzdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0Z2V0IGluZml4U3BhbnMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9pbmZpeFNwYW5zO1xuXHRcdH1cblx0XHRwcml2YXRlIF9pbmZpeFNwYW5zOiByZWFkb25seSBJbmZpeFNwYW5bXSA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgb2Ygc3BhbnMgaW4gdGhhdCByZXByZXNlbnQgdGhlIGFubm90YXRpb25zXG5cdFx0ICogb2YgdGhpcyBzdGF0ZW1lbnQsIGZyb20gbGVmdCB0byByaWdodCwgZXhjbHVkaW5nIHRob3NlIHRoYXRcblx0XHQgKiBoYXZlIGJlZW4gbWFya2VkIGFzIG9iamVjdC1sZXZlbCBjcnVmdC5cblx0XHQgKi9cblx0XHRnZXQgYW5ub3RhdGlvbnMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNydWZ0T2JqZWN0cy5zaXplID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hbGxBbm5vdGF0aW9ucztcblx0XHRcdFxuXHRcdFx0Y29uc3Qgb3V0OiBTcGFuW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuYWxsQW5ub3RhdGlvbnMpXG5cdFx0XHRcdGlmICghdGhpcy5jcnVmdE9iamVjdHMuaGFzKHNwYW4pKVxuXHRcdFx0XHRcdG91dC5wdXNoKHNwYW4pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHNwYW5zIHRoYXQgcmVwcmVzZW50IHRoZSBhbm5vdGF0aW9uc1xuXHRcdCAqIG9mIHRoaXMgc3RhdGVtZW50LCBpbmNsdWRpbmcgdGhvc2UgdGhhdCBoYXZlIGJlZW4gbWFya2VkXG5cdFx0ICogYXMgb2JqZWN0LWxldmVsIGNydWZ0LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGFsbEFubm90YXRpb25zOiByZWFkb25seSBTcGFuW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSBvZiBzcGFucyBpbiB0aGF0IHJlcHJlc2VudCBib3RoIHRoZSBkZWNsYXJhdGlvbnNcblx0XHQgKiBhbmQgdGhlIGFubm90YXRpb25zIG9mIHRoaXMgc3RhdGVtZW50LCBleGNsdWRpbmcgdGhvc2UgdGhhdCBoYXZlXG5cdFx0ICogYmVlbiBtYXJrZWQgYXMgb2JqZWN0LWxldmVsIGNydWZ0LlxuXHRcdCAqL1xuXHRcdGdldCBzcGFucygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNDcnVmdCA/XG5cdFx0XHRcdFtdIDpcblx0XHRcdFx0dGhpcy5kZWNsYXJhdGlvbnMuY29uY2F0KHRoaXMuYW5ub3RhdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRnZXQgYWxsU3BhbnMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmRlY2xhcmF0aW9ucy5jb25jYXQodGhpcy5hbm5vdGF0aW9ucyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGpvaW50IG9wZXJhdG9yIGV4aXN0c1xuXHRcdCAqIGluIHRoZSBzdGF0ZW1lbnQuIEEgbmVnYXRpdmUgbnVtYmVyIGluZGljYXRlcyB0aGF0XG5cdFx0ICogdGhlIGpvaW50IG9wZXJhdG9yIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzdGF0ZW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgam9pbnRQb3NpdGlvbjogbnVtYmVyO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgdW5wcm9jZXNzZWQgdGV4dCBjb250ZW50IG9mIHRoZSBzdGF0ZW1lbnQsIFxuXHRcdCAqIGFzIGl0IGFwcGVhcnMgaW4gdGhlIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHNvdXJjZVRleHQ6IHN0cmluZztcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHN0YXRlbWVudCdzIHRleHR1YWwgKnN1bSosIHdoaWNoIGlzIHRoZVxuXHRcdCAqIHJhdyB0ZXh0IG9mIHRoZSBzdGF0ZW1lbnQncyBhbm5vdGF0aW9ucywgd2l0aCB3aGl0ZXNwYWNlXG5cdFx0ICogdHJpbW1lZC4gVGhlIHN1bSBpcyBzdWl0YWJsZSBhcyBhbiBpbnB1dCB0byBhIHRvdGFsXG5cdFx0ICogcGF0dGVybi5cblx0XHQgKi9cblx0XHRyZWFkb25seSBzdW06IHN0cmluZztcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZVxuXHRcdCAqIHN0YXRlbWVudCBjb250YWlucyBhIGRlY2xhcmF0aW9uIG9mIGEgcGF0dGVybi5cblx0XHQgKi9cblx0XHRnZXQgaGFzUGF0dGVybigpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZCA9IHRoaXMuYWxsRGVjbGFyYXRpb25zO1xuXHRcdFx0cmV0dXJuIGQubGVuZ3RoID09PSAxICYmIGRbMF0uYm91bmRhcnkuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIE1hcmtzIHRoZSBzdGF0ZW1lbnQgYXMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0J3MgY29udGFpbmluZyBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRkaXNwb3NlKClcblx0XHR7XG5cdFx0XHR0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8IExpbmVGbGFncy5pc0Rpc3Bvc2VkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBUaGUga2luZCBvZiBTdGF0ZW1lbnRSZWdpb24gdGhhdCBleGlzdHNcblx0XHQgKiBhdCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIG9mZnNldCB3aXRoaW4gdGhlIFN0YXRlbWVudC5cblx0XHQgKi9cblx0XHRnZXRSZWdpb24ob2Zmc2V0OiBudW1iZXIpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaXNDb21tZW50IHx8IG9mZnNldCA8IHRoaXMuaW5kZW50IHx8IHRoaXMuaXNDcnVmdClcblx0XHRcdFx0cmV0dXJuIFN0YXRlbWVudFJlZ2lvbi52b2lkO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc1doaXRlc3BhY2UpXG5cdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRSZWdpb24ud2hpdGVzcGFjZTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFzUGF0dGVybilcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYm5kID0gdGhpcy5hbGxEZWNsYXJhdGlvbnNbMF0uYm91bmRhcnk7XG5cdFx0XHRcdGlmIChvZmZzZXQgPj0gYm5kLm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBibmQub2Zmc2V0RW5kKVxuXHRcdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRSZWdpb24ucGF0dGVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG9mZnNldCA8PSB0aGlzLmpvaW50UG9zaXRpb24gfHwgdGhpcy5qb2ludFBvc2l0aW9uIDwgMClcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBzcGFuIG9mIHRoaXMuYWxsRGVjbGFyYXRpb25zKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgYm5kID0gc3Bhbi5ib3VuZGFyeTtcblx0XHRcdFx0XHRpZiAob2Zmc2V0ID49IGJuZC5vZmZzZXRTdGFydCAmJiBvZmZzZXQgPD0gYm5kLm9mZnNldEVuZClcblx0XHRcdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRSZWdpb24uZGVjbGFyYXRpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBTdGF0ZW1lbnRSZWdpb24uZGVjbGFyYXRpb25Wb2lkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgdGhpcy5hbGxBbm5vdGF0aW9ucylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYm5kID0gc3Bhbi5ib3VuZGFyeTtcblx0XHRcdFx0aWYgKG9mZnNldCA+PSBibmQub2Zmc2V0U3RhcnQgJiYgb2Zmc2V0IDw9IGJuZC5vZmZzZXRFbmQpXG5cdFx0XHRcdFx0cmV0dXJuIFN0YXRlbWVudFJlZ2lvbi5hbm5vdGF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gU3RhdGVtZW50UmVnaW9uLmFubm90YXRpb25Wb2lkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRnZXRTdWJqZWN0KG9mZnNldDogbnVtYmVyKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmdldERlY2xhcmF0aW9uKG9mZnNldCkgfHwgdGhpcy5nZXRBbm5vdGF0aW9uKG9mZnNldCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc3BhbiB0byB0aGUgZGVjbGFyYXRpb24gc3ViamVjdCBhdCB0aGUgXG5cdFx0ICogc3BlY2lmaWVkIG9mZnNldCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lIHdhcyBmb3VuZC5cblx0XHQgKi9cblx0XHRnZXREZWNsYXJhdGlvbihvZmZzZXQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgdGhpcy5kZWNsYXJhdGlvbnMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGJuZCA9IHNwYW4uYm91bmRhcnk7XG5cdFx0XHRcdGlmIChvZmZzZXQgPj0gYm5kLm9mZnNldFN0YXJ0ICYmIG9mZnNldCA8PSBibmQub2Zmc2V0RW5kKVxuXHRcdFx0XHRcdHJldHVybiBzcGFuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQSBzcGFuIHRvIHRoZSBhbm5vdGF0aW9uIHN1YmplY3QgYXQgdGhlIFxuXHRcdCAqIHNwZWNpZmllZCBvZmZzZXQsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZSB3YXMgZm91bmQuXG5cdFx0ICovXG5cdFx0Z2V0QW5ub3RhdGlvbihvZmZzZXQ6IG51bWJlcilcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2YgdGhpcy5hbm5vdGF0aW9ucylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYm5kID0gc3Bhbi5ib3VuZGFyeTtcblx0XHRcdFx0aWYgKG9mZnNldCA+PSBibmQub2Zmc2V0U3RhcnQgJiYgb2Zmc2V0IDw9IGJuZC5vZmZzZXRFbmQpXG5cdFx0XHRcdFx0cmV0dXJuIHNwYW47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBpbm5lciBjb21tZW50IHRleHQgb2Zcblx0XHQgKiB0aGlzIHN0YXRlbWVudCwgZXhjbHVkaW5nIHRoZSBjb21tZW50IHN5bnRheCB0b2tlbi5cblx0XHQgKiBJZiB0aGUgc3RhdGVtZW50IGlzbid0IGEgY29tbWVudCwgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdGdldENvbW1lbnRUZXh0KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0NvbW1lbnQgP1xuXHRcdFx0XHR0aGlzLnNvdXJjZVRleHQuc2xpY2UodGhpcy5pbmRlbnQgKyBTeW50YXguY29tbWVudC5sZW5ndGgpLnRyaW0oKSA6XG5cdFx0XHRcdFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoZSBzdGF0ZW1lbnQgdG8gYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKGluY2x1ZGVJbmRlbnQgPSBmYWxzZSlcblx0XHR7XG5cdFx0XHRjb25zdCBzZXJpYWxpemVTcGFucyA9IChcblx0XHRcdFx0c3BhbnM6IHJlYWRvbmx5IFNwYW5bXSxcblx0XHRcdFx0ZXNjU3R5bGU6IElkZW50aWZpZXJFc2NhcGVLaW5kKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gc3BhbnNcblx0XHRcdFx0XHQuZmlsdGVyKHNwID0+ICEoc3AuYm91bmRhcnkuc3ViamVjdCBpbnN0YW5jZW9mIEFub24pKVxuXHRcdFx0XHRcdC5tYXAoc3AgPT4gU3ViamVjdFNlcmlhbGl6ZXIuZm9yRXh0ZXJuYWwoc3AsIGVzY1N0eWxlKSlcblx0XHRcdFx0XHQuam9pbihTeW50YXguY29tYmluYXRvciArIFN5bnRheC5zcGFjZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpbmRlbnQgPSBpbmNsdWRlSW5kZW50ID8gU3ludGF4LnRhYi5yZXBlYXQodGhpcy5pbmRlbnQpIDogXCJcIjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNDcnVmdClcblx0XHRcdFx0cmV0dXJuIGluZGVudCArIFwiKGNydWZ0KVwiO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc1doaXRlc3BhY2UpXG5cdFx0XHRcdHJldHVybiBpbmRlbnQ7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzVmFjdW91cylcblx0XHRcdFx0cmV0dXJuIGluZGVudCArIFN5bnRheC5qb2ludDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVjbHMgPSBzZXJpYWxpemVTcGFucyh0aGlzLmFsbERlY2xhcmF0aW9ucywgSWRlbnRpZmllckVzY2FwZUtpbmQuZGVjbGFyYXRpb24pO1xuXHRcdFx0Y29uc3QgYW5ub3MgPSBzZXJpYWxpemVTcGFucyh0aGlzLmFsbEFubm90YXRpb25zLCBJZGVudGlmaWVyRXNjYXBlS2luZC5hbm5vdGF0aW9uKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgam9pbnQgPSBhbm5vcy5sZW5ndGggPiAwIHx8IHRoaXMuaXNSZWZyZXNoID8gU3ludGF4LmpvaW50IDogXCJcIjtcblx0XHRcdGNvbnN0IGpvaW50TCA9IGRlY2xzLmxlbmd0aCA+IDAgJiYgam9pbnQgIT09IFwiXCIgPyBTeW50YXguc3BhY2UgOiBcIlwiO1xuXHRcdFx0Y29uc3Qgam9pbnRSID0gYW5ub3MubGVuZ3RoID4gMCA/IFN5bnRheC5zcGFjZSA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBpbmRlbnQgKyBkZWNscyArIGpvaW50TCArIGpvaW50ICsgam9pbnRSICsgYW5ub3M7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogRGVmaW5lcyB0aGUgYXJlYXMgb2YgYSBzdGF0ZW1lbnQgdGhhdCBhcmUgc2lnbmlmaWNhbnRseVxuXHQgKiBkaWZmZXJlbnQgd2hlbiBwZXJmb3JtaW5nIGluc3BlY3Rpb24uXG5cdCAqL1xuXHRleHBvcnQgZW51bSBTdGF0ZW1lbnRSZWdpb25cblx0e1xuXHRcdC8qKlxuXHRcdCAqIFJlZmVycyB0byB0aGUgYXJlYSB3aXRoaW4gYSBjb21tZW50IHN0YXRlbWVudCxcblx0XHQgKiBvciB0aGUgd2hpdGVzcGFjZSBwcmVjZWVkaW5nIGEgbm9uLW5vLW9wLlxuXHRcdCAqL1xuXHRcdHZvaWQsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVmZXJzIHRvIHRoZSBhcmVhIGluIHRoZSBpbmRlbnRhdGlvbiBhcmVhLlxuXHRcdCAqL1xuXHRcdHdoaXRlc3BhY2UsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVmZXJzIHRvIHRoZSBcblx0XHQgKi9cblx0XHRwYXR0ZXJuLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGRlY2xhcmF0aW9uLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFubm90YXRpb24sXG5cdFx0XG5cdFx0LyoqICovXG5cdFx0ZGVjbGFyYXRpb25Wb2lkLFxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGFubm90YXRpb25Wb2lkXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBZaWVsZHMgZmF1bHRzIG9uIGluZml4IHNwYW5zIGluIHRoZSBjYXNlIHdoZW4gYW4gaWRlbnRpZmllclxuXHQgKiBoYXMgYmVlbiByZS1kZWNsYXJlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gdGhlIHNhbWUgaW5maXguXG5cdCAqL1xuXHRmdW5jdGlvbiAqZGVkdXBJbmZpeFN1YmplY3RzKHNpZGU6IEluZml4U3BhbltdKVxuXHR7XG5cdFx0aWYgKHNpZGUubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdFxuXHRcdGNvbnN0IHN1YmplY3RzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgbmZ4U3BhbiBvZiBzaWRlKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN1YlRleHQgPSBuZnhTcGFuLmJvdW5kYXJ5LnN1YmplY3QudG9TdHJpbmcoKTtcblx0XHRcdGlmIChzdWJqZWN0cy5pbmNsdWRlcyhzdWJUZXh0KSlcblx0XHRcdHtcblx0XHRcdFx0eWllbGQgbmV3IEZhdWx0KEZhdWx0cy5JbmZpeEhhc0R1cGxpY2F0ZUlkZW50aWZpZXIsIG5meFNwYW4pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBzdWJqZWN0cy5wdXNoKHN1YlRleHQpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFlpZWxkcyBmYXVsdHMgb24gaW5maXggc3BhbnMgaW4gdGhlIGNhc2Ugd2hlbiBhbiBpZGVudGlmaWVyXG5cdCAqIGhhcyBiZWVuIHJlLWRlY2xhcmVkIG11bHRpcGxlIHRpbWVzIGFjcm9zcyB0aGUgaW5maXhlcy5cblx0ICovXG5cdGZ1bmN0aW9uICpkZWR1cEluZml4ZXNBY3Jvc3NJbmZpeGVzKFxuXHRcdHNwYW46IFNwYW4sXG5cdFx0aW5maXhGbjogKG5meDogSW5maXgpID0+IEl0ZXJhYmxlSXRlcmF0b3I8SW5maXhTcGFuPilcblx0e1xuXHRcdGNvbnN0IGlkZW50aWZpZXJzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0Zm9yIChjb25zdCBpbmZpeCBvZiBzcGFuLmluZml4ZXMpXG5cdFx0e1xuXHRcdFx0Y29uc3QgaW5maXhTcGFucyA9IEFycmF5LmZyb20oaW5maXhGbihpbmZpeCkpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiBpbmZpeFNwYW5zKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB0ZXh0ID0gaW5maXhTcGFuLmJvdW5kYXJ5LnN1YmplY3QudG9TdHJpbmcoKTtcblx0XHRcdFx0aWYgKGlkZW50aWZpZXJzLmluY2x1ZGVzKHRleHQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0eWllbGQgaW5maXhTcGFuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWRlbnRpZmllcnMucHVzaCh0ZXh0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBZaWVsZHMgd2hlbiBzdWNjZXNzaXZlIGVxdWl2YWxlbnQgaW5zdGFuY2VzIGFyZSBkaXNjb3ZlcmVkXG5cdCAqIGluIHRoZSBzcGVjaWZpZWQgaXRlcmF0b3IuXG5cdCAqL1xuXHRmdW5jdGlvbiAqZGVkdXA8VD4oXG5cdFx0aXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8VD4sXG5cdFx0ZXF1YWxpdHlGbjogKGE6IFQsIGI6IFQpID0+IGJvb2xlYW4pXG5cdHtcblx0XHRjb25zdCB5aWVsZGVkOiBUW10gPSBbXTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmF0b3IpXG5cdFx0e1xuXHRcdFx0aWYgKHlpZWxkZWQuaW5jbHVkZXMoaXRlbSkpXG5cdFx0XHRcdHlpZWxkIGl0ZW07XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHlpZWxkZWQucHVzaChpdGVtKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIHF1aWNrIGFuZCBkaXJ0eSBjaGVjayB0byBzZWUgaWYgdGhlIGluZml4IGlzIHJlZmVyZW5jaW5nXG5cdCAqIGEgbGlzdCwgYnkgbG9va2luZyB0byBzZWUgaWYgaXQgaGFzIHRoZSBsaXN0IG9wZXJhdG9yLiBBIGZ1bGwgY2hlY2sgbmVlZHNcblx0ICogdG8gcGVyZm9ybSB0eXBlIGluc3BlY3Rpb24gdG8gc2VlIGlmIGFueSBvZiB0aGUgdHlwZXMgdGhhdCBjb3JyZXNwb25kXG5cdCAqIHRvIHRoZSBpZGVudGlmaWVycyBzcGVjaWZpZWQgYXJlIGFjdHVhbGx5IGxpc3RzLlxuXHQgKi9cblx0ZnVuY3Rpb24gKmV4cGVkaWVudExpc3RDaGVjayhzaWRlOiBJbmZpeFNwYW5bXSlcblx0e1xuXHRcdGlmIChzaWRlLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblx0XHRcblx0XHRmb3IgKGNvbnN0IG5meFNwYW4gb2Ygc2lkZSlcblx0XHRcdGlmIChuZnhTcGFuLmJvdW5kYXJ5LnN1YmplY3QuaXNMaXN0KVxuXHRcdFx0XHR5aWVsZCBuZXcgRmF1bHQoRmF1bHRzLkluZml4VXNpbmdMaXN0T3BlcmF0b3IsIG5meFNwYW4pO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUGF0dGVyblxuXHR7XG5cdFx0LyoqIEBpbnRlcm5hbCAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgdW5pdHM6IHJlYWRvbmx5IChSZWdleFVuaXQgfCBJbmZpeClbXSxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhlIHBhdHRlcm4gaXMgY29uc2lkZXJlZCB0byBiZSBcIlRvdGFsXCJcblx0XHRcdCAqIG9yIFwiUGFydGlhbFwiLiBUb3RhbCBwYXR0ZXJucyBtdXN0IG1hdGNoIGFuIGVudGlyZSBhbm5vdGF0aW9uXG5cdFx0XHQgKiBzZXQgKHRoZSBlbnRpcmUgc3RyaXAgb2YgY29udGVudCB0byB0aGUgcmlnaHQgb2YgYSBqb2ludCwgYWZ0ZXJcblx0XHRcdCAqIGJlaW5nIHRyaW1tZWQpLiBQYXJ0aWFsIHBhdHRlcm5zIG1hdGNoIGluZGl2aWR1YWxseSBcblx0XHRcdCAqIHNwZWNpZmllZCBzdWJqZWN0cyAoc2VwYXJhdGVkIGJ5IGNvbW1hcykuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGlzVG90YWw6IGJvb2xlYW4sXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyBhIGhhc2ggd2hpY2ggaXMgY29tcHV0ZWQgZnJvbSB0aGUgc2V0IG9mXG5cdFx0XHQgKiBhbm5vdGF0aW9ucyBzcGVjaWZpZWQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwYXR0ZXJuLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBoYXNoOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0dGhpcy5jb21waWxlZFJlZ0V4cCA9IFBhdHRlcm5QcmVjb21waWxlci5leGVjKHRoaXMpO1xuXHRcdFx0dGhpcy5pc1ZhbGlkID0gdGhpcy5jb21waWxlZFJlZ0V4cCBpbnN0YW5jZW9mIFJlZ0V4cDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhlIGludGVybmFsIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHRcdCAqIHdhcyBjb21waWxlZCBzdWNjZXNzZnVsbHkuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaXNWYWxpZDogYm9vbGVhbjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWN1cnNpdmVseSBlbnVtZXJhdGVzIHRocm91Z2ggdGhpcyBQYXR0ZXJuJ3MgdW5pdCBzdHJ1Y3R1cmUuXG5cdFx0ICovXG5cdFx0KmVhY2hVbml0KClcblx0XHR7XG5cdFx0XHRmdW5jdGlvbiAqcmVjdXJzZSh1bml0czogcmVhZG9ubHkgKFJlZ2V4VW5pdCB8IEluZml4KVtdKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHVuaXQgb2YgdW5pdHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aWVsZCB1bml0O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh1bml0IGluc3RhbmNlb2YgUmVnZXhHcm91cClcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgdW5pdENhc2Ugb2YgdW5pdC5jYXNlcylcblx0XHRcdFx0XHRcdFx0cmVjdXJzZSh1bml0Q2FzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0eWllbGQgKnJlY3Vyc2UodGhpcy51bml0cyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyXG5cdFx0ICogdGhpcyBQYXR0ZXJuIGhhcyBhdCBsZWFzdCBvbmUgaW5maXgsIG9mIGFueSB0eXBlLlxuXHRcdCAqL1xuXHRcdGhhc0luZml4ZXMoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnVuaXRzLnNvbWUodSA9PiB1IGluc3RhbmNlb2YgSW5maXgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmZpeGVzIG9mIHRoZVxuXHRcdCAqIHNwZWNpZmllZCB0eXBlIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhpcyBQYXR0ZXJuLlxuXHRcdCAqIElmIHRoZSBhcmd1bWVudCBpcyBvbWl0dGVkLCBhbGwgaW5maXhlcyBvZiBhbnkgdHlwZVxuXHRcdCAqIGRlZmluZWQgb24gdGhpcyBQYXR0ZXJuIGFyZSByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRnZXRJbmZpeGVzKHR5cGUgPSBJbmZpeEZsYWdzLm5vbmUpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMudW5pdHNcblx0XHRcdFx0LmZpbHRlcigodSk6IHUgaXMgSW5maXggPT4gdSBpbnN0YW5jZW9mIEluZml4KVxuXHRcdFx0XHQuZmlsdGVyKG5meCA9PiAobmZ4LmZsYWdzICYgdHlwZSkgPT09IHR5cGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhbiBcImV4cGVkaWVudFwiIHRlc3QgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlXG5cdFx0ICogc3BlY2lmaWVkIGlucHV0IGhhcyBhIGNoYW5jZSBvZiBiZWluZyBtYXRjaGVkIGJ5IHRoaXMgcGF0dGVybi5cblx0XHQgKiBUaGUgY2hlY2sgaXMgY29uc2lkZXJlZCBleHBlZGllbnQsIHJhdGhlciB0aGFuIHRob3JvdWdoLFxuXHRcdCAqIGJlY2F1c2UgYW55IGluZml4ZXMgdGhhdCBleGlzdCBpbiB0aGlzIHBhdHRlcm4gYXJlIHJlcGxhY2VkXG5cdFx0ICogd2l0aCBcImNhdGNoIGFsbFwiIHJlZ3VsYXIgZXhwcmVzc2lvbiBzZXF1ZW5jZSwgcmF0aGVyIHRoYW5cblx0XHQgKiBlbWJlZGRpbmcgdGhlIHBhdHRlcm4gYXNzb2NpYXRlZCB3aXRoIHRoZSB0eXBlIHNwZWNpZmllZFxuXHRcdCAqIGluIHRoZSBpbmZpeC5cblx0XHQgKi9cblx0XHR0ZXN0KGlucHV0OiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVnRXhwID0gdGhpcy5jb21waWxlZFJlZ0V4cDtcblx0XHRcdGlmIChyZWdFeHAgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5wdXRUcmltbWVkID0gaW5wdXQudHJpbSgpO1xuXHRcdFx0aWYgKGlucHV0VHJpbW1lZCA9PT0gXCJcIilcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcmVnRXhwLnRlc3QoaW5wdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBFeGVjdXRlcyB0aGUgcGF0dGVybiAobGlrZSBhIGZ1bmN0aW9uKSB1c2luZyB0aGUgc3BlY2lmaWVkXG5cdFx0ICogc3RyaW5nIGFzIHRoZSBpbnB1dC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBIFJlYWRvbmx5TWFwIHdob3NlIGtleXMgYWxpZ24gd2l0aCB0aGUgaW5maXhlc1xuXHRcdCAqIGNvbnRhaW5lZCBpbiB0aGlzIFBhdHRlcm4sIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHN0cmluZ3MgdGhhdFxuXHRcdCAqIGFyZSB0aGUgZXh0cmFjdGVkIFwiaW5wdXRzXCIsIGZvdW5kIGluIHRoZSBwbGFjZSBvZiBlYWNoIGluZml4LiBcblx0XHQgKiBJZiB0aGlzIFBhdHRlcm4gaGFzIG5vIGluZml4ZXMsIGFuIGVtcHR5IG1hcCBpcyByZXR1cm5lZC5cblx0XHQgKi9cblx0XHRleGVjKHBhdHRlcm5QYXJhbWV0ZXI6IHN0cmluZyk6IFJlYWRvbmx5TWFwPEluZml4LCBzdHJpbmc+XG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVnRXhwID0gdGhpcy5jb21waWxlZFJlZ0V4cDtcblx0XHRcdGlmIChyZWdFeHAgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiBuZXcgTWFwKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBNYXA8SW5maXgsIHN0cmluZz4oKTtcblx0XHRcdGNvbnN0IGluZml4ZXMgPSB0aGlzLmdldEluZml4ZXMoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZ2V0SW5maXhlcygpLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaW5maXhDYXB0dXJlR3JvdXBJbmRleGVzID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGlkeEFycmF5OiBudW1iZXJbXSA9IFtdO1xuXHRcdFx0XHRsZXQgaWR4ID0gMDtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgdW5pdCBvZiB0aGlzLmVhY2hVbml0KCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodW5pdCBpbnN0YW5jZW9mIEluZml4KVxuXHRcdFx0XHRcdFx0aWR4QXJyYXkucHVzaCgrK2lkeCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyb3VwKVxuXHRcdFx0XHRcdFx0aWR4Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vL01ha2Ugc3VyZSB0aGUgYWJvdmUgcHJvZHVjZXMgdGhlIHNhbWUgYmVoYXZpb3IgYmVmb3JlIGRlbGV0aW5nXG5cdFx0XHRcdC8vL2NvbnN0IHJlY3Vyc2VVbml0cyA9ICh1bml0czogcmVhZG9ubHkgKFJlZ2V4VW5pdCB8IEluZml4PilbXSkgPT5cblx0XHRcdFx0Ly8ve1xuXHRcdFx0XHQvLy9cdGZvciAoY29uc3QgdW5pdCBvZiB1bml0cylcblx0XHRcdFx0Ly8vXHR7XG5cdFx0XHRcdC8vL1x0XHRpZiAodW5pdCBpbnN0YW5jZW9mIEluZml4KVxuXHRcdFx0XHQvLy9cdFx0e1xuXHRcdFx0XHQvLy9cdFx0XHRpZHhBcnJheS5wdXNoKCsraWR4KTtcblx0XHRcdFx0Ly8vXHRcdH1cblx0XHRcdFx0Ly8vXHRcdGVsc2UgaWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyb3VwKVxuXHRcdFx0XHQvLy9cdFx0e1xuXHRcdFx0XHQvLy9cdFx0XHQrK2lkeDtcblx0XHRcdFx0Ly8vXHRcdFx0Zm9yIChjb25zdCB1bml0Q2FzZSBvZiB1bml0LmNhc2VzKVxuXHRcdFx0XHQvLy9cdFx0XHRcdHJlY3Vyc2VVbml0cyh1bml0Q2FzZSk7XG5cdFx0XHRcdC8vL1x0XHR9XG5cdFx0XHRcdC8vL1x0fVxuXHRcdFx0XHQvLy99XG5cdFx0XHRcdC8vL3JlY3Vyc2VVbml0cyh0aGlzLnVuaXRzKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBpZHhBcnJheTtcblx0XHRcdH0pKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAocmVnRXhwLnNvdXJjZSwgcmVnRXhwLmZsYWdzKTtcblx0XHRcdGNvbnN0IG1hdGNoZXMgPSByZWcuZXhlYyhwYXR0ZXJuUGFyYW1ldGVyKTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoZXMgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgW2lkeCwgaW5maXhdIG9mIGluZml4ZXMuZW50cmllcygpKVxuXHRcdFx0XHRyZXN1bHQuc2V0KGluZml4LCBtYXRjaGVzW2luZml4Q2FwdHVyZUdyb3VwSW5kZXhlc1tpZHhdXSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgY29tcGlsZWRSZWdFeHA6IFJlZ0V4cCB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoaXMgUGF0dGVybiB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cblx0XHQgKiAoTm90ZSB0aGF0IHRoZSBzZXJpYWxpemVkIHBhdHRlcm4gY2Fubm90IGJlIHVzZWRcblx0XHQgKiBhcyBhIHBhcmFtZXRlciB0byBhIEphdmFTY3JpcHQgUmVnRXhwIG9iamVjdC4pXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGluY2x1ZGVIYXNoUHJlZml4IElmIHRydWUsIHRoZSBQYXR0ZXJuJ3MgaGFzaFxuXHRcdCAqIHByZWZpeCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgc2VyaWFsaXplZCByZXN1bHQuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoaW5jbHVkZUhhc2hQcmVmaXg/OiBib29sZWFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IHByZWZpeCA9IGluY2x1ZGVIYXNoUHJlZml4ID8gZXNjYXBlKHRoaXMuaGFzaCkgOiBcIlwiO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBkZWxpbSA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLm1haW4udG9TdHJpbmcoKTtcblx0XHRcdHJldHVybiBkZWxpbSArIHByZWZpeCArXG5cdFx0XHRcdHRoaXMudW5pdHMubWFwKHUgPT4gdS50b1N0cmluZygpKS5qb2luKFwiXCIpICsgXG5cdFx0XHRcdCh0aGlzLmlzVG90YWwgPyBkZWxpbSA6IFwiXCIpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqICovXG5cdGV4cG9ydCBjbGFzcyBQYXR0ZXJuUHJlY29tcGlsZXJcblx0e1xuXHRcdC8qKlxuXHRcdCAqIENvbXBpbGVzIHRoZSBzcGVjaWZpZWQgcGF0dGVybiBpbnRvIGEgSlMtbmF0aXZlXG5cdFx0ICogUmVnRXhwIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgcmVndWxhclxuXHRcdCAqIGV4cHJlc3Npb24gcHJlLW1hdGNoaW5nIChpLmUuIGNoZWNrcyB0aGF0IGVzc2VudGlhbGx5XG5cdFx0ICogaWdub3JlIGFueSBpbmZpeGVzIHRoYXQgdGhlIHBhdHRlcm4gbWF5IGhhdmUpLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBleGVjKHBhdHRlcm46IFBhdHRlcm4pXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHVuaXQgb2YgcGF0dGVybi51bml0cylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHVuaXQgaW5zdGFuY2VvZiBSZWdleEdyYXBoZW1lKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKE11c3RFc2NhcGVDaGFycy5pbmNsdWRlcyh1bml0LmdyYXBoZW1lKSlcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKFN5bnRheC5lc2NhcGVDaGFyICsgdW5pdC5ncmFwaGVtZSk7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2godW5pdC5ncmFwaGVtZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVuaXQucXVhbnRpZmllcilcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKHVuaXQucXVhbnRpZmllci50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh1bml0IGluc3RhbmNlb2YgSW5maXgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChFeHBlZGllbnRJbmZpeFBhdHRlcm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHVuaXQudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmVzdWx0LnVuc2hpZnQoXCJeXCIpO1xuXHRcdFx0cmVzdWx0LnB1c2goXCIkXCIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByZWdUZXh0ID0gcmVzdWx0LmpvaW4oXCJcIik7XG5cdFx0XHRcblx0XHRcdHRyeVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cChyZWdUZXh0LCBcInVcIik7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSlcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogU3RvcmVzIHRoZSBsaXN0IG9mIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIGVzY2FwZWRcblx0ICogaW4gb3JkZXIgZm9yIHRoZSBUcnV0aCByZWd1bGFyIGV4cHJlc3Npb24gZmxhdm9yIHRvXG5cdCAqIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgZW5naW5lIGJ1aWxkIGludG8gSmF2YVNjcmlwdC5cblx0ICovXG5cdGNvbnN0IE11c3RFc2NhcGVDaGFycyA9IFtcIiRcIiwgXCJeXCIsIFwie1wiLCBcIn1cIl07XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgcGF0dGVybiB0aGF0IGlzIGZlZCBpbnRvIGEgcGF0dGVybiBpblxuXHQgKiBwbGFjZSBvZiB3aGVyZSBpbmZpeGVzIGFyZSwgaW4gb3JkZXIgdG8gYmUgYWJsZSB0b1xuXHQgKiBkbyBlYXJseSB0ZXN0cyBvbiB0aGUgcmVndWxhciBleHByZXNzaW9uIHdpdGhvdXRcblx0ICogZG9pbmcgYSBmdWxsIHJlc29sdXRpb24gb2YgdGhlIHR5cGVzIHRoYXQgdGhlIGluZml4ZXNcblx0ICogcmVmZXJlbmNlLiBUaGUgcGF0dGVybiBlc3NlbnRpYWxseSBtZWFuczpcblx0ICogXG5cdCAqIFwiTWF0Y2ggb25lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlciwgb3IgYSBzZXJpZXNcblx0ICogb2YgY2hhcmFjdGVycywgcHJvdmlkZWQgdGhhdCB0aGUgc3RyaW5nIG9mIGNoYXJhY3RlcnNcblx0ICogZG9uJ3QgYmVnaW4gb3IgZW5kIHdpdGggd2hpdGVzcGFjZS5cIlxuXHQgKi9cblx0Y29uc3QgRXhwZWRpZW50SW5maXhQYXR0ZXJuID0gXCIoXFxcXFMrKFxcXFxzK1xcXFxTKykqKVwiO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEFtYmllbnQgdW5pZmllciBmb3IgYWxsIFBhdHRlcm5Vbml0IGluc3RhbmNlc1xuXHQgKi9cblx0ZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlZ2V4VW5pdFxuXHR7XG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbCkgeyB9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWJzdHJhY3QgdG9TdHJpbmcoKTogc3RyaW5nO1xuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhTZXQgZXh0ZW5kcyBSZWdleFVuaXRcblx0e1xuXHRcdC8qKiAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkga25vd25zOiByZWFkb25seSBSZWdleFN5bnRheEtub3duU2V0W10sXG5cdFx0XHRyZWFkb25seSByYW5nZXM6IHJlYWRvbmx5IFJlZ2V4Q2hhclJhbmdlW10sXG5cdFx0XHRyZWFkb25seSB1bmljb2RlQmxvY2tzOiByZWFkb25seSBzdHJpbmdbXSxcblx0XHRcdHJlYWRvbmx5IHNpbmdsZXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuXHRcdFx0cmVhZG9ubHkgaXNOZWdhdGVkOiBib29sZWFuLFxuXHRcdFx0cmVhZG9ubHkgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbClcblx0XHR7XG5cdFx0XHRzdXBlcihxdWFudGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGNvbnN0IGtMZW4gPSB0aGlzLmtub3ducy5sZW5ndGg7XG5cdFx0XHRjb25zdCByTGVuID0gdGhpcy5yYW5nZXMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgdUxlbiA9IHRoaXMudW5pY29kZUJsb2Nrcy5sZW5ndGg7XG5cdFx0XHRjb25zdCBjTGVuID0gdGhpcy5zaW5nbGVzLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc2V0VGV4dCA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoa0xlbiA9PT0gMSAmJiByTGVuICsgdUxlbiArIGNMZW4gPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMua25vd25zWzBdLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodUxlbiA9PT0gMSAmJiBrTGVuICsgckxlbiArIGNMZW4gPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLnNldFN0YXJ0ICsgXG5cdFx0XHRcdFx0XHRzZXJpYWxpemVVbmljb2RlQmxvY2sodGhpcy51bmljb2RlQmxvY2tzWzBdKSArXG5cdFx0XHRcdFx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRFbmRcblx0XHRcdFx0XHRdLmpvaW4oXCJcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY0xlbiA9PT0gMSAmJiBrTGVuICsgckxlbiArIHVMZW4gPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2luZ2xlc1swXTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuc2V0U3RhcnQsXG5cdFx0XHRcdFx0Li4udGhpcy5rbm93bnMsXG5cdFx0XHRcdFx0Li4udGhpcy5yYW5nZXMubWFwKHIgPT4gZXNjKHIuZnJvbSkgKyBcIi1cIiArIGVzYyhyLnRvKSksXG5cdFx0XHRcdFx0Li4udGhpcy51bmljb2RlQmxvY2tzLm1hcChzZXJpYWxpemVVbmljb2RlQmxvY2spLFxuXHRcdFx0XHRcdC4uLmVzY01hbnkodGhpcy5zaW5nbGVzKSxcblx0XHRcdFx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRFbmRcblx0XHRcdFx0XS5qb2luKFwiXCIpO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNldFRleHQgKyAodGhpcy5xdWFudGlmaWVyID8gdGhpcy5xdWFudGlmaWVyLnRvU3RyaW5nKCkgOiBcIlwiKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICovXG5cdFx0dG9BbHBoYWJldCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgYWxwaGFiZXRCdWlsZGVyID0gbmV3IEFscGhhYmV0QnVpbGRlcigpO1xuXHRcdFx0Y29uc3QgZ3QgPSAoY2hhcjogc3RyaW5nKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkgKyAxO1xuXHRcdFx0Y29uc3QgbHQgPSAoY2hhcjogc3RyaW5nKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkgLSAxO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGtub3duIG9mIHRoaXMua25vd25zKVxuXHRcdFx0e1xuXHRcdFx0XHRzd2l0Y2ggKGtub3duKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheEtub3duU2V0LmRpZ2l0OlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZChcIjBcIiwgXCI5XCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheEtub3duU2V0LmRpZ2l0Tm9uOlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgwLCBsdChcIjBcIikpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZChndChcIjlcIiksIFVuaWNvZGVNYXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheEtub3duU2V0LmFscGhhbnVtZXJpYzpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoXCIwXCIsIFwiOVwiKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoXCJBXCIsIFwiWlwiKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoXCJhXCIsIFwielwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC5hbHBoYW51bWVyaWNOb246XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDAsIGx0KFwiMFwiKSk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKGd0KFwiOVwiKSwgbHQoXCJBXCIpKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoZ3QoXCJaXCIpLCBsdChcImFcIikpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZChndChcInpcIiksIFVuaWNvZGVNYXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBSZWdleFN5bnRheEtub3duU2V0LndoaXRlc3BhY2U6XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDksIDEzKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMTYwKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoNTc2MCk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgxOTIsIDgyMDIpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjMyKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIzMyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMzkpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4Mjg3KTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMTIyODgpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg2NTI3OSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIFJlZ2V4U3ludGF4S25vd25TZXQud2hpdGVzcGFjZU5vbjpcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoMCwgOCk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDE0LCAxNTkpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCgxNjEsIDU3NTkpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg1NzYxLCA4MTkxKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIwMywgODIzMSk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyMzIpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4MjMzKTtcblx0XHRcdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoODIzNCwgODIzOCk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDgyNDAsIDgyODYpO1xuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZCg4Mjg4LCAxMjI4Nyk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDEyMjg5LCA2NTI3OCk7XG5cdFx0XHRcdFx0XHRhbHBoYWJldEJ1aWxkZXIuYWRkKDY1MjgwLCBVbmljb2RlTWF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgUmVnZXhTeW50YXhLbm93blNldC53aWxkOlxuXHRcdFx0XHRcdFx0YWxwaGFiZXRCdWlsZGVyLmFkZFdpbGQoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG5cdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNpbmdsZSBvZiB0aGlzLnNpbmdsZXMpXG5cdFx0XHRcdGFscGhhYmV0QnVpbGRlci5hZGQoc2luZ2xlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGFscGhhYmV0QnVpbGRlci50b0FscGhhYmV0KHRoaXMuaXNOZWdhdGVkKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBSZWdleENoYXJSYW5nZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBmcm9tOiBudW1iZXIsXG5cdFx0XHRyZWFkb25seSB0bzogbnVtYmVyKVxuXHRcdHsgfVxuXHR9XG5cblxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgUmVnZXhHcm91cCBleHRlbmRzIFJlZ2V4VW5pdFxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBjYXNlczogcmVhZG9ubHkgKHJlYWRvbmx5IFJlZ2V4VW5pdFtdKVtdLFxuXHRcdFx0cmVhZG9ubHkgcXVhbnRpZmllcjogUmVnZXhRdWFudGlmaWVyIHwgbnVsbClcblx0XHR7XG5cdFx0XHRzdXBlcihxdWFudGlmaWVyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0dG9TdHJpbmcoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNhc2VzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHN0YXJ0ID0gUmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBTdGFydDtcblx0XHRcdGNvbnN0IG1pZCA9IHRoaXMuY2FzZXNcblx0XHRcdFx0Lm1hcChjYSA9PiBjYS5tYXAodW5pdCA9PiBlc2ModW5pdC50b1N0cmluZygpKSkuam9pbihcIlwiKSlcblx0XHRcdFx0LmpvaW4oUmVnZXhTeW50YXhEZWxpbWl0ZXIuYWx0ZXJuYXRvcik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGVuZCA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwRW5kO1xuXHRcdFx0Y29uc3QgcXVhbnQgPSB0aGlzLnF1YW50aWZpZXIgPyB0aGlzLnF1YW50aWZpZXIudG9TdHJpbmcoKSA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzdGFydCArIG1pZCArIGVuZCArIHF1YW50O1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIEEgcGF0dGVybiBcImdyYXBoZW1lXCIgaXMgYSBwYXR0ZXJuIHVuaXQgY2xhc3MgdGhhdFxuXHQgKiByZXByZXNlbnRzOlxuXHQgKiBcblx0ICogYSkgQSBcIkxpdGVyYWxcIiwgd2hpY2ggaXMgYSBzaW5nbGUgdW5pY29kZS1hd2FyZSBjaGFyYWN0ZXIsXG5cdCAqIHdpdGggcG9zc2libGUgcmVwcmVzZW50YXRpb25zIGJlaW5nIGFuIGFzY2lpIGNoYXJhY3Rlcixcblx0ICogYSB1bmljb2RlIGNoYXJhY3Rlciwgb3IgYW4gYXNjaWkgb3IgdW5pY29kZSBlc2NhcGVcblx0ICogc2VxdWVuY2UuXG5cdCAqIFxuXHQgKiBvciBiKSBBIFwiU3BlY2lhbFwiLCB3aGljaCBpcyBhIHNlcXVlbmNlIHRoYXQgbWF0Y2hlc1xuXHQgKiBzb21ldGhpbmcgb3RoZXIgdGhhbiB0aGUgY2hhcmFjdGVyIHNwZWNpZmllZCxcblx0ICogc3VjaCBhcyAuIFxcYiBcXHNcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBSZWdleEdyYXBoZW1lIGV4dGVuZHMgUmVnZXhVbml0XG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IGdyYXBoZW1lOiBzdHJpbmcsXG5cdFx0XHRyZWFkb25seSBxdWFudGlmaWVyOiBSZWdleFF1YW50aWZpZXIgfCBudWxsKVxuXHRcdHtcblx0XHRcdHN1cGVyKHF1YW50aWZpZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcSA9IHRoaXMucXVhbnRpZmllcjtcblx0XHRcdGNvbnN0IHFFc2MgPSBxID09PSBudWxsID8gXCJcIiA6IGVzYyhxLnRvU3RyaW5nKCkpO1xuXHRcdFx0Y29uc3QgZyA9IHRoaXMuZ3JhcGhlbWUudG9TdHJpbmcoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGVzY2FwYWJsZUdyYXBoZW1lcy5pbmNsdWRlcyhnKSA/XG5cdFx0XHRcdFwiXFxcXFwiICsgZyArIHFFc2MgOlxuXHRcdFx0XHRnICsgcUVzYztcblx0XHR9XG5cdH1cblxuXHQvKiogKi9cblx0Y29uc3QgZXNjYXBhYmxlR3JhcGhlbWVzOiBzdHJpbmdbXSA9IFtcblx0XHRSZWdleFN5bnRheE1pc2Muc3Rhcixcblx0XHRSZWdleFN5bnRheE1pc2MucGx1cyxcblx0XHRSZWdleFN5bnRheE1pc2MubmVnYXRlLFxuXHRcdFJlZ2V4U3ludGF4TWlzYy5yZXN0cmFpbmVkLFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLmdyb3VwU3RhcnQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuZ3JvdXBFbmQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIuYWx0ZXJuYXRvcixcblx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRTdGFydCxcblx0XHRSZWdleFN5bnRheERlbGltaXRlci5zZXRFbmQsXG5cdFx0UmVnZXhTeW50YXhEZWxpbWl0ZXIucXVhbnRpZmllclN0YXJ0LFxuXHRcdFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJFbmRcblx0XTtcblxuXHQvKipcblx0ICogQSBSZWdleCBcIlNpZ25cIiByZWZlcnMgdG8gYW4gZXNjYXBlIHNlcXVlbmNlIHRoYXQgcmVmZXJzXG5cdCAqIHRvIG9uZSBvdGhlciBjaGFyYWN0ZXIsIGFzIG9wcG9zZWQgdG8gdGhhdCBjaGFyYWN0ZXJcblx0ICogYmVpbmcgd3JpdHRlbiBkaXJlY3RseSBpbiB0aGUgcGFyc2Ugc3RyZWFtLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlZ2V4U2lnbiBleHRlbmRzIFJlZ2V4VW5pdFxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRyZWFkb25seSBzaWduOiBSZWdleFN5bnRheFNpZ24sXG5cdFx0XHRyZWFkb25seSBxdWFudGlmaWVyOiBSZWdleFF1YW50aWZpZXIgfCBudWxsKVxuXHRcdHtcblx0XHRcdHN1cGVyKHF1YW50aWZpZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcSA9IHRoaXMucXVhbnRpZmllcjtcblx0XHRcdHJldHVybiB0aGlzLnNpZ24udG9TdHJpbmcoKSArIChxID09PSBudWxsID8gXCJcIiA6IGVzYyhxLnRvU3RyaW5nKCkpKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBIHBhdHRlcm4gdW5pdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgKywgKiwgXG5cdCAqIGFuZCBleHBsaWNpdCBxdWFudGlmaWVycyBzdWNoIGFzIHsxLDJ9LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlZ2V4UXVhbnRpZmllclxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgbG93ZXIgYm91bmQgb2YgdGhlIHF1YW50aWZpZXIsIFxuXHRcdFx0ICogb3IgdGhlIGZld2VzdCBudW1iZXIgb2YgZ3JhcGhlbWVzIHRvIGJlIG1hdGNoZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IG1pbjogbnVtYmVyID0gMCxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSB1cHBlciBib3VuZCBvZiB0aGUgcXVhbnRpZmllciwgXG5cdFx0XHQgKiBvciB0aGUgbW9zdCBudW1iZXIgb2YgZ3JhcGhlbWVzIHRvIGJlIG1hdGNoZWQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IG1heDogbnVtYmVyID0gSW5maW5pdHksXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoZSB0aGUgcXVhbnRpZmllciBpcyByZXN0cmFpbmVkLFxuXHRcdFx0ICogaW4gdGhhdCBpdCBtYXRjaGVzIHRoZSBmZXdlc3QgcG9zc2libGUgbnVtYmVyXG5cdFx0XHQgKiBvZiBjaGFyYWN0ZXJzLlxuXHRcdFx0ICogXG5cdFx0XHQgKiAoU29tZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhdm91cnMgYXdrd2FyZGx5XG5cdFx0XHQgKiByZWZlciB0byB0aGlzIGFzIFwibm9uLWdyZWVkeVwiLilcblx0XHRcdCAqL1xuXHRcdFx0cmVhZG9ubHkgcmVzdHJhaW5lZDogYm9vbGVhbilcblx0XHR7IH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGUgcmVnZXggcXVhbnRpZmllciB0byBhbiBvcHRpbWl6ZWQgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCByc3QgPSB0aGlzLnJlc3RyYWluZWQgPyBSZWdleFN5bnRheE1pc2MucmVzdHJhaW5lZCA6IFwiXCI7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLm1pbiA9PT0gMCAmJiB0aGlzLm1heCA9PT0gSW5maW5pdHkpXG5cdFx0XHRcdHJldHVybiBSZWdleFN5bnRheE1pc2Muc3RhciArIHJzdDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubWluID09PSAxICYmIHRoaXMubWF4ID09PSBJbmZpbml0eSlcblx0XHRcdFx0cmV0dXJuIFJlZ2V4U3ludGF4TWlzYy5wbHVzICsgcnN0O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5taW4gPT09IDAgJiYgdGhpcy5tYXggPT09IDEpXG5cdFx0XHRcdHJldHVybiBSZWdleFN5bnRheE1pc2MucmVzdHJhaW5lZDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcXMgPSBSZWdleFN5bnRheERlbGltaXRlci5xdWFudGlmaWVyU3RhcnQ7XG5cdFx0XHRjb25zdCBxcCA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJTZXBhcmF0b3I7XG5cdFx0XHRjb25zdCBxZSA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLnF1YW50aWZpZXJFbmQ7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLm1pbiA9PT0gdGhpcy5tYXggP1xuXHRcdFx0XHRxcyArIHRoaXMubWluICsgcWUgOlxuXHRcdFx0XHRxcyArIHRoaXMubWluICsgcXAgKyAodGhpcy5tYXggPT09IEluZmluaXR5ID8gXCJcIiA6IHRoaXMubWF4LnRvU3RyaW5nKCkpICsgcWU7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkb3VibGUgZXNjYXBlXG5cdCAqIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBiYWNrc2xhc2guXG5cdCAqL1xuXHRmdW5jdGlvbiBlc2MobWF5YmVCYWNrc2xhc2g6IHN0cmluZyB8IG51bWJlcilcblx0e1xuXHRcdGlmIChtYXliZUJhY2tzbGFzaCA9PT0gOTIgfHwgbWF5YmVCYWNrc2xhc2ggPT09IFwiXFxcXFwiKVxuXHRcdFx0cmV0dXJuIFwiXFxcXFxcXFxcIjtcblx0XHRcblx0XHRpZiAodHlwZW9mIG1heWJlQmFja3NsYXNoID09PSBcIm51bWJlclwiKVxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG1heWJlQmFja3NsYXNoKTtcblx0XHRcblx0XHRyZXR1cm4gbWF5YmVCYWNrc2xhc2g7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGZ1bmN0aW9uIGVzY01hbnkoYXJyYXk6IHJlYWRvbmx5IChzdHJpbmcgfCBudW1iZXIpW10pXG5cdHtcblx0XHRyZXR1cm4gYXJyYXkubWFwKGVzYykuam9pbihcIlwiKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZnVuY3Rpb24gc2VyaWFsaXplVW5pY29kZUJsb2NrKGJsb2NrTmFtZTogc3RyaW5nKVxuXHR7XG5cdFx0Y29uc3QgYmxvY2sgPSBVbmljb2RlQmxvY2tzLmdldChibG9ja05hbWUudG9Mb3dlckNhc2UoKSk7IFxuXHRcdGlmIChibG9jayA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFxuXHRcdGNvbnN0IHJuZyA9IFJlZ2V4U3ludGF4RGVsaW1pdGVyLnJhbmdlO1xuXHRcdGNvbnN0IGZyb20gPSBibG9ja1swXS50b1N0cmluZygxNik7XG5cdFx0Y29uc3QgdG8gPSBibG9ja1sxXS50b1N0cmluZygxNik7XG5cdFx0cmV0dXJuIGBcXFxcdXske2Zyb219fSR7cm5nfVxcXFx1eyR7dG99fWA7XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvcnRpb24gb2YgdGhlIGNvbnRlbnQgXG5cdCAqIHdpdGhpbiBhbiBJbmZpeCB0aGF0IHNwYW5zIGEgdHlwZSByZWZlcmVuY2UuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgSW5maXhcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9yZXMgdGhlIGxlZnQtbW9zdCBjaGFyYWN0ZXIgcG9zaXRpb24gb2YgdGhlIEluZml4XG5cdFx0XHQgKiAoYmVmb3JlIHRoZSBkZWxpbWl0ZXIpLCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyBzdGF0ZW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IG9mZnNldFN0YXJ0OiBudW1iZXIsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBsZWZ0LW1vc3QgY2hhcmFjdGVyIHBvc2l0aW9uIG9mIHRoZSBJbmZpeFxuXHRcdFx0ICogKGFmdGVyIHRoZSBkZWxpbWl0ZXIpLCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyBzdGF0ZW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IG9mZnNldEVuZDogbnVtYmVyLFxuXHRcdFx0XG5cdFx0XHQvKiogXG5cdFx0XHQgKiBTdG9yZXMgdGhlIEJvdW5kcyBvYmplY3QgdGhhdCBtYXJrcyBvdXQgdGhlIHBvc2l0aW9uc1xuXHRcdFx0ICogb2YgdGhlIGlkZW50aWZpZXJzIGluIHRoZSBJbmZpeCB0aGF0IGFyZSBsb2NhdGVkIGJlZm9yZVxuXHRcdFx0ICogYW55IEpvaW50IG9wZXJhdG9yLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSBsaHM6IEJvdW5kYXJ5R3JvdXA8SWRlbnRpZmllcj4sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIHRoZSBCb3VuZHMgb2JqZWN0IHRoYXQgbWFya3Mgb3V0IHRoZSBwb3NpdGlvbnNcblx0XHRcdCAqIG9mIHRoZSBpZGVudGlmaWVycyBpbiB0aGUgSW5maXggdGhhdCBhcmUgbG9jYXRlZCBhZnRlclxuXHRcdFx0ICogYW55IEpvaW50IG9wZXJhdG9yLlxuXHRcdFx0ICovXG5cdFx0XHRyZWFkb25seSByaHM6IEJvdW5kYXJ5R3JvdXA8SWRlbnRpZmllcj4sXG5cdFx0XHRcblx0XHRcdC8qKiAqL1xuXHRcdFx0cmVhZG9ubHkgZmxhZ3M6IEluZml4RmxhZ3MpXG5cdFx0eyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB3aGV0aGVyIHRoaXMgSW5maXggaXMgb2YgdGhlIFwicGF0dGVyblwiIHZhcmlldHkuXG5cdFx0ICovXG5cdFx0Z2V0IGlzUGF0dGVybigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICh0aGlzLmZsYWdzICYgSW5maXhGbGFncy5wYXR0ZXJuKSA9PT0gSW5maXhGbGFncy5wYXR0ZXJuO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBJbmZpeCBpcyBvZiB0aGUgXCJwb3J0YWJpbGl0eVwiIHZhcmlldHkuXG5cdFx0ICovXG5cdFx0Z2V0IGlzUG9ydGFiaWxpdHkoKVxuXHRcdHtcblx0XHRcdHJldHVybiAodGhpcy5mbGFncyAmIEluZml4RmxhZ3MucG9ydGFiaWxpdHkpID09PSBJbmZpeEZsYWdzLnBvcnRhYmlsaXR5O1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBJbmZpeCBpcyBvZiB0aGUgXCJwb3B1bGF0aW9uXCIgdmFyaWV0eS5cblx0XHQgKi9cblx0XHRnZXQgaXNQb3B1bGF0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBJbmZpeEZsYWdzLnBvcHVsYXRpb24pID09PSBJbmZpeEZsYWdzLnBvcHVsYXRpb247XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGlzIEluZml4IGhhcyB0aGUgXCJub21pbmFsXCIgb3B0aW9uIHNldC5cblx0XHQgKi9cblx0XHRnZXQgaXNOb21pbmFsKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gKHRoaXMuZmxhZ3MgJiBJbmZpeEZsYWdzLm5vbWluYWwpID09PSBJbmZpeEZsYWdzLm5vbWluYWw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRjb25zdCBkZWxpbUwgPVxuXHRcdFx0XHR0aGlzLmlzUGF0dGVybiA/IEluZml4U3ludGF4LnBhdHRlcm5TdGFydCA6XG5cdFx0XHRcdHRoaXMuaXNOb21pbmFsID8gSW5maXhTeW50YXgubm9taW5hbFN0YXJ0IDpcblx0XHRcdFx0dGhpcy5pc1BvcnRhYmlsaXR5ID8gSW5maXhTeW50YXguc3RhcnQgKyBTeW50YXguc3BhY2UgKyBTeW50YXguam9pbnQgKyBTeW50YXguc3BhY2UgOlxuXHRcdFx0XHRJbmZpeFN5bnRheC5zdGFydDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVsaW1SID0gXG5cdFx0XHRcdHRoaXMuaXNQYXR0ZXJuID8gSW5maXhTeW50YXgucGF0dGVybkVuZCA6XG5cdFx0XHRcdHRoaXMuaXNOb21pbmFsID8gSW5maXhTeW50YXgubm9taW5hbEVuZCA6XG5cdFx0XHRcdEluZml4U3ludGF4LmVuZDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgam9pbiA9IChzcGFuczogQm91bmRhcnlHcm91cDxJZGVudGlmaWVyPikgPT5cblx0XHRcdFx0QXJyYXkuZnJvbShzcGFucylcblx0XHRcdFx0XHQubWFwKGVudHJ5ID0+IGVudHJ5LnN1YmplY3QpXG5cdFx0XHRcdFx0LmpvaW4oU3ludGF4LmNvbWJpbmF0b3IgKyBTeW50YXguc3BhY2UpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc1BvcnRhYmlsaXR5KVxuXHRcdFx0XHRyZXR1cm4gam9pbih0aGlzLnJocyk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzUGF0dGVybilcblx0XHRcdFx0cmV0dXJuIGpvaW4odGhpcy5saHMpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBqb2ludCA9IHRoaXMucmhzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHRTeW50YXguc3BhY2UgKyBTeW50YXguam9pbnQgKyBTeW50YXguc3BhY2UgOlxuXHRcdFx0XHRcIlwiO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZGVsaW1MICsgam9pbih0aGlzLmxocykgKyBqb2ludCArIGpvaW4odGhpcy5yaHMpICsgZGVsaW1SO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGVudW0gSW5maXhGbGFnc1xuXHR7XG5cdFx0bm9uZSA9IDAsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgdGhlIGpvaW50IHdhcyBzcGVjaWZpZWQgd2l0aGluXG5cdFx0ICogdGhlIGluZml4LiBDYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGluZml4XG5cdFx0ICogY29udGFpbnMgc29tZSAoZXJyb25lb3VzKSBzeW50YXggcmVzZW1iaW5nXG5cdFx0ICogYSByZWZyZXNoIHR5cGUsIGVnIC0gLzxUeXBlIDogPi9cblx0XHQgKi9cblx0XHRoYXNKb2ludCA9IDEsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoYXQgdGhlIDwvUGF0dGVybi8+IHN5bnRheCB3YXNcblx0XHQgKiB1c2VkIHRvIGVtYmVkIHRoZSBwYXR0ZXJucyBhc3NvY2lhdGVkXG5cdFx0ICogd2l0aCBhIHNwZWNpZmllZCB0eXBlLlxuXHRcdCAqL1xuXHRcdHBhdHRlcm4gPSAyLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IHRoZSBpbmZpeCBpcyBvZiB0aGUgXCJwb3J0YWJpaXR5XCJcblx0XHQgKiB2YXJpZXR5LCB1c2luZyB0aGUgc3ludGF4IDwgOiBUeXBlPlxuXHRcdCAqL1xuXHRcdHBvcnRhYmlsaXR5ID0gNCxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgaW5maXggaXMgb2YgdGhlIFwicG9wdWF0aW9uXCJcblx0XHQgKiB2YXJpZXR5LCB1c2luZyB0aGUgc3ludGF4IDxEZWNsYXJhdGlvbiA6IEFubm90YXRpb24+XG5cdFx0ICogb3IgPERlY2xhcmF0aW9uPlxuXHRcdCAqL1xuXHRcdHBvcHVsYXRpb24gPSA4LFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IHRoZSA8PERvdWJsZT4+IGFuZ2xlIGJyYWNrZXRcblx0XHQgKiBzeW50YXggd2FzIHVzZWQgdG8gb25seSBtYXRjaCBuYW1lZCB0eXBlcyxcblx0XHQgKiByYXRoZXIgdGhhbiBhbGlhc2VzLlxuXHRcdCAqL1xuXHRcdG5vbWluYWwgPSAxNlxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzaW5nbGUgc3ViamVjdCBpbiBhIFN0YXRlbWVudC5cblx0ICogQ29uc3VtZXJzIG9mIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBleHBlY3QgU3ViamVjdCBvYmplY3RzXG5cdCAqIHRvIGJlIGxvbmctbGl2ZWQsIGFzIHRoZXkgYXJlIGRpc2NhcmRlZCByZWd1bGFybHkgYWZ0ZXIgZWRpdFxuXHQgKiB0cmFuc2FjdGlvbnMgY29tcGxldGUuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgSWRlbnRpZmllclxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IodGV4dDogc3RyaW5nKVxuXHRcdHtcblx0XHRcdGNvbnN0IGxpc3RUb2sgPSBTeW50YXgubGlzdDtcblx0XHRcdGNvbnN0IHRva0xlbiA9IGxpc3RUb2subGVuZ3RoO1xuXHRcdFx0dGhpcy5pc0xpc3QgPSB0ZXh0Lmxlbmd0aCA+IHRva0xlbiArIDEgJiYgdGV4dC5zbGljZSgtdG9rTGVuKSA9PT0gbGlzdFRvaztcblx0XHRcdHRoaXMuZnVsbE5hbWUgPSB0ZXh0O1xuXHRcdFx0dGhpcy50eXBlTmFtZSA9IHRoaXMuaXNMaXN0ID8gdGV4dC5zbGljZSgwLCAtdG9rTGVuKSA6IHRleHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIGZ1bGwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdWJqZWN0LCBcblx0XHQgKiBhcyBpdCBhcHBlYXJzIGluIHRoZSBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBmdWxsTmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbmFtZSBvZiB0aGVcblx0XHQgKiB0eXBlIHRvIHdoaWNoIHRoZSBzdWJqZWN0IHJlZmVycywgd2l0aG91dCBhbnkgTGlzdFxuXHRcdCAqIG9wZXJhdG9yIHN1ZmZpeC5cblx0XHQgKi9cblx0XHRyZWFkb25seSB0eXBlTmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGlzTGlzdDogYm9vbGVhbjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyB0aGlzIFN1YmplY3QgdG8gaXQncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFxuXHRcdCAqIEBwYXJhbSBlc2NhcGUgSWYgdHJ1ZSwgcHJlc2VydmVzIGFueSBuZWNlc3Nhcnlcblx0XHQgKiBlc2NhcGluZyByZXF1aXJlZCB0byBlbnN1cmUgdGhlIGlkZW50aWZpZXIgc3RyaW5nXG5cdFx0ICogaXMgaW4gYSBwYXJzYWJsZSBmb3JtYXQuXG5cdFx0ICovXG5cdFx0dG9TdHJpbmcoZXNjYXBlID0gSWRlbnRpZmllckVzY2FwZUtpbmQubm9uZSlcblx0XHR7XG5cdFx0XHRjb25zdCB2YWwgPSAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0c3dpdGNoIChlc2NhcGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjYXNlIElkZW50aWZpZXJFc2NhcGVLaW5kLm5vbmU6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy50eXBlTmFtZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjYXNlIElkZW50aWZpZXJFc2NhcGVLaW5kLmRlY2xhcmF0aW9uOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIFJlZ2V4IGRlbGltaXRlcnMgYXJlIGVzY2FwZWQgaWYgYW5kIG9ubHkgaWYgXG5cdFx0XHRcdFx0XHQvLyB0aGV5J3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYW4gSWRlbnRpZmllci5cblx0XHRcdFx0XHRcdGNvbnN0IGRsbVJlZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBSZWdleFN5bnRheERlbGltaXRlci5tYWluKTtcblx0XHRcdFx0XHRcdGNvbnN0IGpudFJlZ1MgPSBuZXcgUmVnRXhwKFN5bnRheC5qb2ludCArIFN5bnRheC5zcGFjZSk7XG5cdFx0XHRcdFx0XHRjb25zdCBqbnRSZWdUID0gbmV3IFJlZ0V4cChTeW50YXguam9pbnQgKyBTeW50YXgudGFiKTtcblx0XHRcdFx0XHRcdGNvbnN0IGNtYlJlZyA9IG5ldyBSZWdFeHAoU3ludGF4LmNvbWJpbmF0b3IpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy50eXBlTmFtZVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZShkbG1SZWcsIFN5bnRheC5lc2NhcGVDaGFyICsgUmVnZXhTeW50YXhEZWxpbWl0ZXIubWFpbilcblx0XHRcdFx0XHRcdFx0LnJlcGxhY2Uoam50UmVnUywgU3ludGF4LmVzY2FwZUNoYXIgKyBTeW50YXguam9pbnQgKyBTeW50YXguc3BhY2UpXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKGpudFJlZ1QsIFN5bnRheC5lc2NhcGVDaGFyICsgU3ludGF4LmpvaW50ICsgU3ludGF4LnRhYilcblx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoY21iUmVnLCBTeW50YXguZXNjYXBlQ2hhciArIFN5bnRheC5jb21iaW5hdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBJZGVudGlmaWVyRXNjYXBlS2luZC5hbm5vdGF0aW9uOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoU3ludGF4LmNvbWJpbmF0b3IpO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVwID0gU3ludGF4LmVzY2FwZUNoYXIgKyBTeW50YXguY29tYmluYXRvcjtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnR5cGVOYW1lLnJlcGxhY2UocmVnLCByZXApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHZhbCArICh0aGlzLmlzTGlzdCA/IFN5bnRheC5saXN0IDogXCJcIik7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogQW4gZW51bWVyYXRpb24gdGhhdCBkZXNjcmliZXMgdGhlIHZhcmlvdXMgd2F5c1xuXHQgKiB0byBoYW5kbGUgZXNjYXBpbmcgd2hlbiBzZXJpYWxpemluZyBhbiBpZGVudGlmaWVyLlxuXHQgKiBUaGlzIGVudW1lcmF0aW9uIGlzIHVzZWQgdG8gYWRkcmVzcyB0aGUgZGlmZmVyZW5jZXNcblx0ICogaW4gdGhlIHdheSBpZGVudGlmaWVycyBjYW4gYmUgc2VyaWFsaXplZCwgd2hpY2ggY2FuIFxuXHQgKiBkZXBlbmQgb24gd2hldGhlciB0aGUgaWRlbnRpZmllciBpcyBhIGRlY2xhcmF0aW9uIG9yXG5cdCAqIGFuIGFubm90YXRpb24uXG5cdCAqL1xuXHRleHBvcnQgY29uc3QgZW51bSBJZGVudGlmaWVyRXNjYXBlS2luZFxuXHR7XG5cdFx0bm9uZSA9IDAsXG5cdFx0ZGVjbGFyYXRpb24gPSAxLFxuXHRcdGFubm90YXRpb24gPSAyXG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIGEgc3RhdGVtZW50LlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFNwYW5cblx0e1xuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIExvZ2ljYWwgY2xvY2sgdmFsdWUgdXNlZCB0byBtYWtlIGNocm9ub2xvZ2ljYWwgXG5cdFx0ICogY3JlYXRpb24tdGltZSBjb21wYXJpc29ucyBiZXR3ZWVuIFNwYW5zLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IHN0YW1wID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBTdGF0ZW1lbnQgdGhhdCBjb250YWlucyB0aGlzIFNwYW4uXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHN0YXRlbWVudDogU3RhdGVtZW50LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0b3JlcyB0aGUgc3ViamVjdCwgYW5kIHRoZSBsb2NhdGlvbiBvZiBpdCBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGJvdW5kYXJ5OiBCb3VuZGFyeTxTdWJqZWN0Pilcblx0XHR7XG5cdFx0XHR0aGlzLm5hbWUgPSBcblx0XHRcdFx0U3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwoYm91bmRhcnkpICsgXG5cdFx0XHRcdGAgKCR7Ym91bmRhcnkub2Zmc2V0U3RhcnR9LCAke2JvdW5kYXJ5Lm9mZnNldEVuZH0pYDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgU3BhbiwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgSW5maXhlcyBzdG9yZWQgd2l0aGluIHRoaXMgU3BhbiwgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdCAqIHRoZSBTcGFuIGNvcnJlc3BvbmRzIHRvIGEgUGF0dGVybi4gSW4gb3RoZXIgY2FzZXMsIGFuZFxuXHRcdCAqIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuXHRcdCAqL1xuXHRcdGdldCBpbmZpeGVzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5faW5maXhlcyB8fCAodGhpcy5faW5maXhlcyA9IE9iamVjdC5mcmVlemUoKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuID9cblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaXMuYm91bmRhcnkuc3ViamVjdC5nZXRJbmZpeGVzKCkpIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH0pKCkpKTtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfaW5maXhlczogcmVhZG9ubHkgSW5maXhbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdCplYWNoRGVjbGFyYXRpb25Gb3JJbmZpeChpbmZpeDogSW5maXgpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLmluZml4ZXMuaW5jbHVkZXMoaW5maXgpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZENhbGwoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgeyBsaHMgfSA9IHRoaXMucXVlcnlJbmZpeFNwYW5UYWJsZShpbmZpeCk7XG5cdFx0XHRmb3IgKGNvbnN0IGluZml4U3BhbiBvZiBsaHMpXG5cdFx0XHRcdHlpZWxkIGluZml4U3Bhbjtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0KmVhY2hBbm5vdGF0aW9uRm9ySW5maXgoaW5maXg6IEluZml4KVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5pbmZpeGVzLmluY2x1ZGVzKGluZml4KSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLmludmFsaWRDYWxsKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHsgcmhzIH0gPSB0aGlzLnF1ZXJ5SW5maXhTcGFuVGFibGUoaW5maXgpO1xuXHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgcmhzKVxuXHRcdFx0XHR5aWVsZCBpbmZpeFNwYW47XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcXVlcnlJbmZpeFNwYW5UYWJsZShpbmZpeDogSW5maXgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5maXhTcGFuVGFibGUuZ2V0KGluZml4KSB8fCAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbGhzOiBJbmZpeFNwYW5bXSA9IFtdO1xuXHRcdFx0XHRjb25zdCByaHM6IEluZml4U3BhbltdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGJvdW5kYXJ5IG9mIGluZml4Lmxocylcblx0XHRcdFx0XHRsaHMucHVzaChuZXcgSW5maXhTcGFuKHRoaXMsIGluZml4LCBib3VuZGFyeSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBib3VuZGFyeSBvZiBpbmZpeC5yaHMpXG5cdFx0XHRcdFx0cmhzLnB1c2gobmV3IEluZml4U3Bhbih0aGlzLCBpbmZpeCwgYm91bmRhcnkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7IGxocywgcmhzIH07XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGluZml4U3BhblRhYmxlID0gbmV3IE1hcDxJbmZpeCwgeyBsaHM6IEluZml4U3BhbltdOyByaHM6IEluZml4U3BhbltdIH0+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHRoYXQgcmVwcmVzZW50IHRoZSBzdGF0ZW1lbnRcblx0XHQgKiBjb250YWlubWVudCBwcm9ncmVzc2lvbiwgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgY29udGFpbmluZ1xuXHRcdCAqIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdGdldCBhbmNlc3RyeSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2FuY2VzdHJ5KVxuXHRcdFx0XHRpZiAodGhpcy5fYW5jZXN0cnkuZXZlcnkoc210ID0+ICFzbXQuaXNEaXNwb3NlZCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FuY2VzdHJ5O1xuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgYW5jZXN0cnkgaGFzIG5vIHlldCBiZWVuIGNvbXB1dGVkLCBvciBpdCBoYXMsIGJ1dCBhdCBsZWFzdCBvZlxuXHRcdFx0Ly8gaXQncyBzdGF0ZW1lbnRzIGhhdmUgYmVlbiBkaXNwb3NlZCwgdGhlbiBpdCBtdXN0IGJlIHJlY29tcHV0ZWQuXG5cdFx0XHR0aGlzLl9hbmNlc3RyeSA9IHRoaXMuc3RhdGVtZW50LmRvY3VtZW50LmdldEFuY2VzdHJ5KHRoaXMuc3RhdGVtZW50KTtcblx0XHRcdGlmICghdGhpcy5fYW5jZXN0cnkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2FuY2VzdHJ5O1xuXHRcdH1cblx0XHRwcml2YXRlIF9hbmNlc3RyeTogcmVhZG9ubHkgU3RhdGVtZW50W10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTcGxpdHMgYXBhcnQgdGhlIGdyb3VwcyBzdWJqZWN0cyBzcGVjaWZpZWQgaW4gdGhlIGNvbnRhaW5pbmdcblx0XHQgKiBzdGF0ZW1lbnQncyBhbmNlc3RyeSwgYW5kIGdlbmVyYXRlcyBhIHNlcmllcyBvZiBzcGluZXMsIFxuXHRcdCAqIGVhY2ggaW5kaWNhdGluZyBhIHNlcGFyYXRlIHBhdGh3YXkgb2YgZGVjbGFyYXRpb25zIHRocm91Z2hcblx0XHQgKiB0aGUgYW5jZXN0cnkgdGhhdCByZWFjaCB0aGUgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50XG5cdFx0ICogcmVmZXJlbmNlZCBieSB0aGlzIGdsb2JhbCBzcGFuIG9iamVjdC5cblx0XHQgKiBcblx0XHQgKiBUaGUgZ2VuZXJhdGVkIHNwaW5lcyBhcmUgcmVmZXJlbnRpYWxseSBvcGFxdWUuIFJ1bm5pbmcgdGhpc1xuXHRcdCAqIG1ldGhvZCBvbiB0aGUgc2FtZSBTcGFuIG9iamVjdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZVxuXHRcdCAqIFNwaW5lIGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdGZhY3RvcigpOiByZWFkb25seSBTcGluZVtdXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuZmFjdG9yZWRTcGluZXMpXG5cdFx0XHRcdHJldHVybiB0aGlzLmZhY3RvcmVkU3BpbmVzO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5pc0NydWZ0IHx8IHRoaXMuc3RhdGVtZW50LmlzQ3J1ZnQpXG5cdFx0XHRcdHJldHVybiB0aGlzLmZhY3RvcmVkU3BpbmVzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmFuY2VzdHJ5Lmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHRoaXMuZmFjdG9yZWRTcGluZXMgPSBPYmplY3QuZnJlZXplKFtuZXcgU3BpbmUoW3RoaXNdKV0pO1xuXHRcdFx0XG5cdFx0XHQvLyBXZSBuZWVkIHRvIGZhY3RvciB0aGUgYW5jZXN0cnkuIFRoaXMgbWVhbnMgd2UncmUgdGFraW5nIHRoZVxuXHRcdFx0Ly8gc3BlY2lmaWVkIGFuY2VzdHJ5IHBhdGgsIGFuZCBzcGxpdHRpbmcgd2hlcmUgYW55IGhhcy1hIHNpZGUgdW5pb25zXG5cdFx0XHQvLyBleGlzdCwgaW4gZWZmZWN0IGNyZWF0aW5nIGFsbCBwb3NzaWJsZSBwYXRocyB0byB0aGUgc3BlY2lmaWVkIHRpcC5cblx0XHRcdC8vIEl0J3MgcG9zc2libGUgdG8gaGF2ZSBzdGF0ZW1lbnRzIGluIHRoZSBzcGFuIHBhdGggaW4gdGhlIGNhc2Vcblx0XHRcdC8vIHdoZW4gdGhlIHN0YXRlbWVudCBoYXMgYmVlbiBkZWVtZWQgYXMgY3J1ZnQsIGFuZCB0aGVyZWZvcmUsXG5cdFx0XHQvLyBpcyBpbXBvc3NpYmxlIHRvIGV4dHJhY3QgYW55IHNwYW5zIGZyb20gaXQuXG5cdFx0XHRjb25zdCBmYWN0b3JlZFNwYW5QYXRoczogKFNwYW4gfCBTdGF0ZW1lbnQpW11bXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBBbiBhcnJheSBvZiBhcnJheXMuIFRoZSBmaXJzdCBkaW1lbnNpb24gY29ycmVzcG9uZHMgdG8gYSBzdGF0ZW1lbnQuIFxuXHRcdFx0Ly8gVGhlIHNlY29uZCBkaW1lbnNpb24gc3RvcmVzIHRoZSBkZWNsYXJhdGlvbiBzcGFucyB0aGVtc2VsdmVzLlxuXHRcdFx0Y29uc3QgYW5jZXN0cnlNYXRyaXggPSB0aGlzLmFuY2VzdHJ5Lm1hcChzbXQgPT4gQXJyYXkuZnJvbShzbXQuZGVjbGFyYXRpb25zKSk7XG5cdFx0XHRcblx0XHRcdC8vIEFuIGFycmF5IHRoYXQgc3RvcmVzIHRoZSBudW1iZXIgb2YgZGVjbGFyYXRpb24gc3BhbnMgaW4gZWFjaCBzdGF0ZW1lbnQuXG5cdFx0XHRjb25zdCBhbmNlc3RyeUxlbmd0aHMgPSBhbmNlc3RyeU1hdHJpeC5tYXAoc3BhbiA9PiBzcGFuLmxlbmd0aCk7XG5cdFx0XHRcblx0XHRcdC8vIE11bHRpcGx5aW5nIHRvZ2V0aGVyIHRoZSBudW1iZXIgb2Ygc3BhbnMgaW4gZWFjaCBzdGF0ZW1lbnQgd2lsbFxuXHRcdFx0Ly8gZ2l2ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHVuaXF1ZSBzcGluZXMgdGhhdCB3aWxsIGJlIHByb2R1Y2VkLlxuXHRcdFx0Y29uc3QgbnVtU3BpbmVzID0gYW5jZXN0cnlMZW5ndGhzLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuXHRcdFx0XG5cdFx0XHQvLyBTdGFydCB3aXRoIGFuIGFycmF5IG9mIDAncywgd2hvc2UgbGVuZ3RoIG1hdGNoZXMgdGhlIG51bWJlclxuXHRcdFx0Ly8gb2Ygc3RhdGVtZW50cyBpbiB0aGUgYW5jZXN0cnkuIEVhY2ggbnVtYmVyIGluIHRoaXMgYXJyYXkgd2lsbCBiZSBcblx0XHRcdC8vIGluY3JlbWVudGVkIGJ5IDEsIGZyb20gcmlnaHQgdG8gbGVmdCwgZWFjaCBudW1iZXIgbWF4aW5nIG91dCBhdFxuXHRcdFx0Ly8gdGhlIG51bWJlciBvZiBkZWNsYXJhdGlvbnMgaW4gdGhlIGFuY2VzdG9yLiBBZnRlciBlYWNoIGluY3JlbWVudGF0aW9uLFxuXHRcdFx0Ly8gdGhlIHByb2dyZXNzaW9uIG9mIG51bWJlcnMgd2lsbCBydW4gdGhyb3VnaCBhbGwgaW5kZXhlcyByZXF1aXJlZCB0b1xuXHRcdFx0Ly8gcGVyZm9ybSBhIGZ1bGwgZmFjdG9yaXphdGlvbiBvZiB0aGUgdGVybXMgaW4gdGhlIGFuY2VzdHJ5LiBUaGlzIGFycmF5XG5cdFx0XHQvLyB0ZWxscyB0aGUgYWxnb3JpdGhtIHdoaWNoIGluZGV4ZXMgaW4gYW5jZXN0cnlNYXRyaXggdG8gcHVsbCB3aGVuXG5cdFx0XHQvLyBjb25zdHJ1Y3RpbmcgYSBzcGluZS5cblx0XHRcdGNvbnN0IGNoZXJyeVBpY2tJbmRleGVzID0gYW5jZXN0cnlMZW5ndGhzLm1hcCgoKSA9PiAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIHRoZSBwb3NpdGlvbiBpbiBjaGVycnlQaWNrSW5kZXhlcyB0aGF0IHdlJ3JlIGN1cnJlbnRseVxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nLiBNb3ZlcyBiYWNrd2FyZCB3aGVuIHRoZSBudW1iZXIgYXQgXG5cdFx0XHQvLyB0aGUgdGFyZ2V0IHBvc2l0aW9uIGlzID49IHRoZSBudW1iZXIgb2YgdGVybXMgYXQgdGhhdCBwb3NpdGlvbi5cblx0XHRcdGxldCB0YXJnZXRJbmNMZXZlbCA9IDA7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgbnVtU3BpbmVzOylcblx0XHRcdHtcblx0XHRcdFx0Ly8gRG8gYW4gaW5zZXJ0aW9uIGF0IHRoZSBpbmRleGVzIHNwZWNpZmllZCBieSBpbnNlcnRpb25JbmRleGVzXG5cdFx0XHRcdGNvbnN0IHNwYW5QYXRoOiAoU3BhbiB8IFN0YXRlbWVudClbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlcnJ5IHBpY2sgYSBzZXJpZXMgb2YgdGVybXMgZnJvbSB0aGUgYW5jZXN0cnkgdGVybXMsXG5cdFx0XHRcdC8vIGFjY29yZGluZyB0byB0aGUgaW5kZXggc2V0IHdlJ3JlIGN1cnJlbnRseSBvbi5cblx0XHRcdFx0Zm9yIChsZXQgbGV2ZWwgPSAtMTsgKytsZXZlbCA8IHRoaXMuYW5jZXN0cnkubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlbWVudCA9IHRoaXMuYW5jZXN0cnlbbGV2ZWxdO1xuXHRcdFx0XHRcdGlmIChzdGF0ZW1lbnQuaXNDcnVmdClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzcGFuUGF0aC5wdXNoKHN0YXRlbWVudCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3Qgc3BhbnNGb3JTdGF0ZW1lbnQgPSBhbmNlc3RyeU1hdHJpeFtsZXZlbF07XG5cdFx0XHRcdFx0Y29uc3Qgc3BhbkluZGV4ID0gY2hlcnJ5UGlja0luZGV4ZXNbbGV2ZWxdO1xuXHRcdFx0XHRcdGNvbnN0IHNwYW4gPSBzcGFuc0ZvclN0YXRlbWVudFtzcGFuSW5kZXhdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghc3Bhbilcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzcGFuUGF0aC5wdXNoKHNwYW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgdGlwIHNwYW4gc3BlY2lmaWVkIGluIHRoZSBtZXRob2QgYXJndW1lbnRzXG5cdFx0XHRcdC8vIGlzIGFkZGVkIGF0IHRoZSBlbmQgb2YgYWxsIGdlbmVyYXRlZCBzcGFuIHBhdGhzLlxuXHRcdFx0XHRzcGFuUGF0aC5wdXNoKHRoaXMpO1xuXHRcdFx0XHRmYWN0b3JlZFNwYW5QYXRocy5wdXNoKHNwYW5QYXRoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEJ1bXAgdXAgdGhlIGN1cnJlbnQgY2hlcnJ5IHBpY2sgaW5kZXgsIFxuXHRcdFx0XHQvLyBvciBpZiB3ZSBoaXQgdGhlIHJvb2YsIG1vdmUgdG8gdGhlIG5leHQgbGV2ZWwsXG5cdFx0XHRcdC8vIGFuZCBrZWVwIGRvaW5nIHRoaXMgdW50aWwgd2UgZmluZCBhIG51bWJlclxuXHRcdFx0XHQvLyB0byBpbmNyZW1lbnQuXG5cdFx0XHRcdHdoaWxlIChjaGVycnlQaWNrSW5kZXhlc1t0YXJnZXRJbmNMZXZlbF0gPj0gYW5jZXN0cnlMZW5ndGhzW3RhcmdldEluY0xldmVsXSAtIDEpXG5cdFx0XHRcdFx0dGFyZ2V0SW5jTGV2ZWwrKztcblx0XHRcdFx0XG5cdFx0XHRcdGNoZXJyeVBpY2tJbmRleGVzW3RhcmdldEluY0xldmVsXSsrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mYWN0b3JlZFNwaW5lcyA9IFxuXHRcdFx0XHRPYmplY3QuZnJlZXplKGZhY3RvcmVkU3BhblBhdGhzLm1hcChzcGFuUGF0aCA9PiBcblx0XHRcdFx0XHRuZXcgU3BpbmUoc3BhblBhdGgpKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAgKi9cblx0XHRwcml2YXRlIGZhY3RvcmVkU3BpbmVzOiByZWFkb25seSBTcGluZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIFNwYW4gaXMgY29uc2lkZXJlZFxuXHRcdCAqIG9iamVjdC1sZXZlbCBjcnVmdCwgYW5kIHNob3VsZCB0aGVyZWZvcmUgYmUgaWdub3JlZCBkdXJpbmcgdHlwZSBhbmFseXNpcy5cblx0XHQgKi9cblx0XHRnZXQgaXNDcnVmdCgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50LmNydWZ0T2JqZWN0cy5oYXModGhpcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoaXMgU3BhbiB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gaW5jbHVkZUhhc2hQcmVmaXggSWYgdGhlIHN1YmplY3QgaW5zaWRlIHRoaXMgU3BhbiBpcyBhXG5cdFx0ICogUGF0dGVybiwgYW5kIHRoaXMgYXJndW1lbnQgaXMgdHJ1ZSwgdGhlIFBhdHRlcm4ncyBoYXNoIHByZWZpeFxuXHRcdCAqIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBzZXJpYWxpemVkIHJlc3VsdC5cblx0XHQgKi9cblx0XHR0b1N0cmluZyhpbmNsdWRlSGFzaFByZWZpeD86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3Qgc3ViID0gdGhpcy5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0cmV0dXJuIHN1YiBpbnN0YW5jZW9mIFBhdHRlcm4gP1xuXHRcdFx0XHRzdWIudG9TdHJpbmcoISFpbmNsdWRlSGFzaFByZWZpeCkgOlxuXHRcdFx0XHRzdWIudG9TdHJpbmcoKTtcblx0XHR9XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgbWFuYWdlcyBhbiBhcnJheSBvZiBTcGFuIG9iamVjdHMgdGhhdFxuXHQgKiByZXByZXNlbnQgYSBzcGVjaWZpYyBzcGluZSBvZiBkZWNsYXJhdGlvbnMsIHN0YXJ0aW5nIGF0XG5cdCAqIGEgZG9jdW1lbnQsIHBhc3NpbmcgdGhyb3VnaCBhIHNlcmllcyBvZiBzcGFucyxcblx0ICogYW5kIGVuZGluZyBhdCBhIHRpcCBzcGFuLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFNwaW5lXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcih2ZXJ0ZWJyYWU6IChTcGFuIHwgU3RhdGVtZW50KVtdKVxuXHRcdHtcblx0XHRcdGlmICh2ZXJ0ZWJyYWUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24uaW52YWxpZENhbGwoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy52ZXJ0ZWJyYWUgPSB2ZXJ0ZWJyYWUubWFwKHYgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHYgaW5zdGFuY2VvZiBTcGFuKVxuXHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgZXhpc3RDcnVmdE1hcmtlciA9IENydWZ0TWFya2Vycy5nZXQodik7XG5cdFx0XHRcdGlmIChleGlzdENydWZ0TWFya2VyICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGV4aXN0Q3J1ZnRNYXJrZXI7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBuZXdDcnVmdE1hcmtlciA9IG5ldyBDcnVmdE1hcmtlcih2KTtcblx0XHRcdFx0Q3J1ZnRNYXJrZXJzLnNldCh2LCBuZXdDcnVmdE1hcmtlcik7XG5cdFx0XHRcdHJldHVybiBuZXdDcnVmdE1hcmtlcjtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB0aXAgPSB0aGlzLnZlcnRlYnJhZVt2ZXJ0ZWJyYWUubGVuZ3RoIC0gMV07XG5cdFx0XHRpZiAodGlwIGluc3RhbmNlb2YgQ3J1ZnRNYXJrZXIpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQ2FsbCgpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnRpcCA9IHRpcDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyB0aGUgbGFzdCBzcGFuIGluIHRoZSBhcnJheSBvZiBzZWdtZW50cy4gKi9cblx0XHRyZWFkb25seSB0aXA6IFNwYW47XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IHN0YXRlbWVudCgpIHsgcmV0dXJuIHRoaXMudGlwLnN0YXRlbWVudDsgfVxuXHRcdFxuXHRcdC8qKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0aGF0IHNpdHMgYXQgdGhlIHRvcCBvZiB0aGUgc3BpbmUuICovXG5cdFx0Z2V0IGRvY3VtZW50KCkgeyByZXR1cm4gdGhpcy5zdGF0ZW1lbnQuZG9jdW1lbnQ7IH1cblx0XHRcblx0XHQvKiogU3RvcmVzIGFuIGFycmF5IG9mIHRoZSBTcGFucyB0aGF0IGNvbXBvc2UgdGhlIFNwaW5lLiAqL1xuXHRcdHJlYWRvbmx5IHZlcnRlYnJhZTogcmVhZG9ubHkgKFNwYW4gfCBDcnVmdE1hcmtlcilbXSA9IFtdO1xuXHR9XG5cblxuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IGFjdHMgYXMgYSBzdGFuZC1pbiBmb3IgYSBzdGF0ZW1lbnQgdGhhdCBoYXMgYmVlblxuXHQgKiBtYXJrZWQgYXMgY3J1ZnQsIHN1aXRhYmxlIGZvciB1c2FnZSBpbiBhIFNwaW5lLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIENydWZ0TWFya2VyXG5cdHtcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0Y29uc3RydWN0b3IocmVhZG9ubHkgc3RhdGVtZW50OiBTdGF0ZW1lbnQpIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIHRoaXMgY3J1ZnQgbWFya2VyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLFxuXHRcdCAqIHdoaWNoIGlzIGRlcml2ZWQgZnJvbSBhIGhhc2ggY2FsY3VsYXRlZCBmcm9tIHRoaXNcblx0XHQgKiBtYXJrZXIncyB1bmRlcmx5aW5nIHN0YXRlbWVudC5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFwi4omIXCIgKyBIYXNoLmNhbGN1bGF0ZSh0aGlzLnN0YXRlbWVudC5zb3VyY2VUZXh0KTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBDcnVmdE1hcmtlcnMgPSBuZXcgV2Vha01hcDxTdGF0ZW1lbnQsIENydWZ0TWFya2VyPigpO1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqICovXG5cdGV4cG9ydCB0eXBlIFN1YmplY3QgPSBEZWNsYXJhdGlvblN1YmplY3QgfCBBbm5vdGF0aW9uU3ViamVjdDtcblxuXHQvKipcblx0ICogU3RvcmVzIGEgbWFwIG9mIHRoZSBjaGFyYWN0ZXIgb2Zmc2V0cyB3aXRoaW4gYSBTdGF0ZW1lbnRcblx0ICogdGhhdCByZXByZXNlbnQgdGhlIHN0YXJ0aW5nIHBvc2l0aW9ucyBvZiB0aGUgc3RhdGVtZW50J3Ncblx0ICogZGVjbGFyYXJ0aW9ucy5cblx0ICovXG5cdGV4cG9ydCB0eXBlIERlY2xhcmF0aW9uU3ViamVjdCA9IElkZW50aWZpZXIgfCBQYXR0ZXJuIHwgVXJpIHwgQW5vbjtcblxuXHQvKipcblx0ICogU3RvcmVzIGEgbWFwIG9mIHRoZSBjaGFyYWN0ZXIgb2Zmc2V0cyB3aXRoaW4gYSBTdGF0ZW1lbnRcblx0ICogdGhhdCByZXByZXNlbnQgdGhlIHN0YXJ0aW5nIHBvc2l0aW9ucyBvZiB0aGUgc3RhdGVtZW50J3Ncblx0ICogYW5ub3RhdGlvbnMuXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBBbm5vdGF0aW9uU3ViamVjdCA9IElkZW50aWZpZXI7XG5cblxuXHQvKiogKi9cblx0ZXhwb3J0IGNsYXNzIFN1YmplY3RTZXJpYWxpemVyXG5cdHtcblx0XHQvKipcblx0XHQgKiBVbml2ZXJzYWwgbWV0aG9kIGZvciBzZXJpYWxpemluZyBhIHN1YmplY3QgdG8gYSBzdHJpbmcsXG5cdFx0ICogdXNlZnVsIGZvciBkZWJ1Z2dpbmcgYW5kIHN1cHBvcnRpbmcgdGVzdHMuXG5cdFx0ICovXG5cdFx0c3RhdGljIGZvckV4dGVybmFsKFxuXHRcdFx0dGFyZ2V0OiBTdWJqZWN0Q29udGFpbmVyLFxuXHRcdFx0ZXNjYXBlU3R5bGU6IElkZW50aWZpZXJFc2NhcGVLaW5kID0gSWRlbnRpZmllckVzY2FwZUtpbmQubm9uZSlcblx0XHR7XG5cdFx0XHRjb25zdCBzdWJqZWN0ID0gdGhpcy5yZXNvbHZlU3ViamVjdCh0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VyaWFsaXplKHN1YmplY3QsIGVzY2FwZVN0eWxlLCBmYWxzZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNlcmlhbGl6ZXMgYSBzdWJqZWN0LCBvciBhIGtub3duIHN1YmplY3QgY29udGFpbmluZyBvYmplY3QgZm9yIGludGVybmFsIHVzZS5cblx0XHQgKi9cblx0XHRzdGF0aWMgZm9ySW50ZXJuYWwodGFyZ2V0OiBTdWJqZWN0Q29udGFpbmVyKVxuXHRcdHtcblx0XHRcdGNvbnN0IHN1YmplY3QgPSB0aGlzLnJlc29sdmVTdWJqZWN0KHRhcmdldCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXJpYWxpemUoc3ViamVjdCwgSWRlbnRpZmllckVzY2FwZUtpbmQubm9uZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHJlc29sdmVTdWJqZWN0KHRhcmdldDogU3ViamVjdENvbnRhaW5lcik6IFN1YmplY3Rcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgQm91bmRhcnkgPyB0YXJnZXQuc3ViamVjdCA6XG5cdFx0XHRcdHRhcmdldCBpbnN0YW5jZW9mIFNwYW4gPyB0YXJnZXQuYm91bmRhcnkuc3ViamVjdCA6XG5cdFx0XHRcdHRhcmdldCBpbnN0YW5jZW9mIEluZml4U3BhbiA/IHRhcmdldC5ib3VuZGFyeS5zdWJqZWN0IDpcblx0XHRcdFx0dGFyZ2V0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyBzZXJpYWxpemUoXG5cdFx0XHRzdWJqZWN0OiBTdWJqZWN0Q29udGFpbmVyLFxuXHRcdFx0ZXNjYXBlU3R5bGU6IElkZW50aWZpZXJFc2NhcGVLaW5kLFxuXHRcdFx0aW5jbHVkZUhhc2g6IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0aWYgKHN1YmplY3QgaW5zdGFuY2VvZiBJZGVudGlmaWVyKVxuXHRcdFx0XHRyZXR1cm4gc3ViamVjdC50b1N0cmluZyhlc2NhcGVTdHlsZSk7XG5cdFx0XHRcblx0XHRcdGVsc2UgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuKVxuXHRcdFx0XHRyZXR1cm4gc3ViamVjdC50b1N0cmluZyhpbmNsdWRlSGFzaCk7XG5cdFx0XHRcblx0XHRcdGVsc2UgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBVcmkpXG5cdFx0XHRcdHJldHVybiBzdWJqZWN0LnRvU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdGVsc2UgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBBbm9uKVxuXHRcdFx0XHRyZXR1cm4gc3ViamVjdC50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIElkZW50aWZpZXMgYSBUeXBlIHRoYXQgaXMgb3IgY29udGFpbnMgYSBTdWJqZWN0LiAqL1xuXHRleHBvcnQgdHlwZSBTdWJqZWN0Q29udGFpbmVyID0gU3ViamVjdCB8IEJvdW5kYXJ5PFN1YmplY3Q+IHwgU3BhbiB8IEluZml4U3Bhbjtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBIeXBlckdyYXBoXG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBUZXN0LW9ubHkgZmllbGQgdXNlZCB0byBkaXNhYmxlIHRoZSBmdW5jdGlvbnMgb2YgdGhlIEdyYXBoLlxuXHRcdCAqL1xuXHRcdHN0YXRpYyBkaXNhYmxlZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblx0XHRcblx0XHQvKiogQGludGVybmFsICovXG5cdFx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtKVxuXHRcdHtcblx0XHRcdHRoaXMubm9kZUluZGV4ID0gbmV3IE5vZGVJbmRleCh0aGlzLnByb2dyYW0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoSHlwZXJHcmFwaC5kaXNhYmxlZClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLmRvY3VtZW50cy5lYWNoKClcblx0XHRcdFx0LmZvckVhY2godGhpcy5pbmNsdWRlLmJpbmQodGhpcykpO1xuXHRcdFx0XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlRG9jdW1lbnRDcmVhdGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5pbmNsdWRlKGRhdGEuZG9jdW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHByb2dyYW0ub24oQ2F1c2VEb2N1bWVudERlbGV0ZSwgZGF0YSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmV4Y2x1ZGUoZGF0YS5kb2N1bWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZUludmFsaWRhdGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGRhdGEucGFyZW50cy5sZW5ndGggPiAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgZGF0YS5wYXJlbnRzKVxuXHRcdFx0XHRcdFx0dGhpcy5leGNsdWRlKHNtdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB0aGlzLmV4Y2x1ZGUoZGF0YS5kb2N1bWVudCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cHJvZ3JhbS5vbihDYXVzZVJldmFsaWRhdGUsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKGRhdGEucGFyZW50cy5sZW5ndGggPiAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzbXQgb2YgZGF0YS5wYXJlbnRzKVxuXHRcdFx0XHRcdFx0dGhpcy5pbmNsdWRlKHNtdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB0aGlzLmluY2x1ZGUoZGF0YS5kb2N1bWVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVhZHMgYSByb290IE5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkXG5cdFx0ICogbmFtZSBvdXQgb2YgdGhlIHNwZWNpZmllZCBkb2N1bWVudC5cblx0XHQgKi9cblx0XHRyZWFkKGRvY3VtZW50OiBEb2N1bWVudCwgbmFtZTogc3RyaW5nKTogTm9kZSB8IG51bGxcblx0XHR7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gZG9jdW1lbnQuc291cmNlVXJpXG5cdFx0XHRcdC5leHRlbmRUeXBlKG5hbWUpXG5cdFx0XHRcdC50b1N0cmluZygpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlSW5kZXguZ2V0Tm9kZUJ5VXJpKHVyaVRleHQpIHx8IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGUgb2JqZWN0c1xuXHRcdCAqIHRoYXQgYXJlIGRlZmluZWQgYXQgdGhlIHJvb3QgbGV2ZWwgb2YgdGhlIHNwZWNpZmllZFxuXHRcdCAqIGRvY3VtZW50LlxuXHRcdCAqL1xuXHRcdCpyZWFkUm9vdHMoZG9jdW1lbnQ6IERvY3VtZW50KVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVJbmRleC5lYWNoTm9kZSgpKVxuXHRcdFx0XHRpZiAobm9kZS5jb250YWluZXIgPT09IG51bGwpXG5cdFx0XHRcdFx0aWYgKG5vZGUuZG9jdW1lbnQgPT09IGRvY3VtZW50KVxuXHRcdFx0XHRcdFx0eWllbGQgbm9kZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBhIGRvY3VtZW50LWxldmVsIGV4Y2x1c2lvbiwgd2hpY2ggaXMgdGhlIHJlbW92YWwgXG5cdFx0ICogb2YgYSBzZWN0aW9uIG9mIFNwYW5zIHdpdGhpbiBhIGRvY3VtZW50LCBvciBwb3NzaWJseSB0aGVcblx0XHQgKiBlbnRpcmUgZG9jdW1lbnQgaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgZXhjbHVkZShyb290OiBEb2N1bWVudCB8IFN0YXRlbWVudClcblx0XHR7XG5cdFx0XHRjb25zdCB7IGRvY3VtZW50LCBpdGVyYXRvciB9ID0gdGhpcy5tZXRob2RTZXR1cChyb290KTtcblx0XHRcdGNvbnN0IHR4biA9IG5ldyBHcmFwaFRyYW5zYWN0aW9uKCk7XG5cdFx0XHQvLy9jb25zdCBtYXliZURlc3RhYmlsaXplZEVkZ2VzOiBIeXBlckVkZ2VbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgc3RhdGVtZW50IH0gb2YgaXRlcmF0b3IpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2Ygc3RhdGVtZW50LmRlY2xhcmF0aW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGFzc29jaWF0ZWROb2RlcyA9IG5ldyBTZXQoZGVjbGFyYXRpb25cblx0XHRcdFx0XHRcdC5mYWN0b3IoKVxuXHRcdFx0XHRcdFx0Lm1hcChzcGluZSA9PiBVcmkuY2xvbmUoc3BpbmUpKVxuXHRcdFx0XHRcdFx0Lm1hcCh1cmkgPT4gdGhpcy5ub2RlSW5kZXguZ2V0Tm9kZUJ5VXJpKHVyaSkpXG5cdFx0XHRcdFx0XHQuZmlsdGVyKChuKTogbiBpcyBOb2RlID0+IG4gaW5zdGFuY2VvZiBOb2RlKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBhc3NvY2lhdGVkTm9kZSBvZiBhc3NvY2lhdGVkTm9kZXMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YXNzb2NpYXRlZE5vZGUucmVtb3ZlRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoYXNzb2NpYXRlZE5vZGUuZGVjbGFyYXRpb25zLnNpemUgPT09IDApXG5cdFx0XHRcdFx0XHRcdHR4bi5kZXN0YWJpbGl6ZWROb2Rlcy5wdXNoKGFzc29jaWF0ZWROb2RlKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBvYiBvZiBhc3NvY2lhdGVkTm9kZS5vdXRib3VuZHMpXG5cdFx0XHRcdFx0XHRcdGlmIChvYi5mcmFnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0XHRcdHR4bi5kZXN0YWJsaXplZEVkZ2VzLnB1c2gob2IpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLy9mb3IgKGNvbnN0IGliIG9mIGFzc29jaWF0ZWROb2RlLmluYm91bmRzKVxuXHRcdFx0XHRcdFx0Ly8vXHRtYXliZURlc3RhYmlsaXplZEVkZ2VzLnB1c2goaWIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLy9mb3IgKGNvbnN0IGVkZ2Ugb2YgbWF5YmVEZXN0YWJpbGl6ZWRFZGdlcylcblx0XHRcdC8vL1x0aWYgKGVkZ2Uuc3VjY2Vzc29ycy5ldmVyeShzY3NyID0+IHR4bi5kZXN0YWJpbGl6ZWROb2Rlcy5pbmNsdWRlcyhzY3NyLm5vZGUpKSlcblx0XHRcdC8vL1x0XHR0eG4uZGVzdGFibGl6ZWRFZGdlcy5wdXNoKGVkZ2UpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFjdGl2ZVRyYW5zYWN0aW9ucy5zZXQoZG9jdW1lbnQsIHR4bik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgcmV2YWxpZGF0aW9uIG9mIHRoZSBOb2RlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG5cdFx0ICogaW5wdXQgYXJndW1lbnQuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHJvb3QgVGhlIHJvb3Qgb2JqZWN0IHVuZGVyIHdoaWNoIHdoaWNoIHJldmFsaWRhdGlvblxuXHRcdCAqIHNob3VsZCBvY2N1ci4gSW4gdGhlIGNhc2Ugd2hlbiBhIERvY3VtZW50IGluc3RhbmNlIGlzIHBhc3NlZCxcblx0XHQgKiBhbGwgTm9kZXMgcHJlc2VudCB3aXRoaW4gdGhlIGRvY3VtZW50IGFyZSByZXZhbGlkYXRlZC4gSW4gdGhlIFxuXHRcdCAqIGNhc2Ugd2hlbiBhIFN0YXRlbWVudCBpbnN0YW5jZSBpcyBwYXNzZWQsIHRoZSBOb2RlcyB0aGF0XG5cdFx0ICogY29ycmVzcG9uZCB0byB0aGUgU3RhdGVtZW50LCBhbmQgYWxsIG9mIGl0J3MgY29udGVudHMgYXJlXG5cdFx0ICogcmV2YWxpZGF0ZWQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBpbmNsdWRlKHJvb3Q6IERvY3VtZW50IHwgU3RhdGVtZW50KVxuXHRcdHtcblx0XHRcdGNvbnN0IHsgZG9jdW1lbnQsIGl0ZXJhdG9yIH0gPSB0aGlzLm1ldGhvZFNldHVwKHJvb3QpO1xuXHRcdFx0Y29uc3QgdHhuID0gdGhpcy5hY3RpdmVUcmFuc2FjdGlvbnMuZ2V0KGRvY3VtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIGFsbCB0aGUgbm9kZXMgdGhhdCBoYXZlIGJlZW4gYWZmZWN0ZWQgYnkgYSBuZXdcblx0XHRcdC8vIGZyYWdtZW50IGVpdGhlciBiZWluZyBhZGRlZCBvciByZW1vdmVkIGZyb20gaXQuXG5cdFx0XHRjb25zdCBhZmZlY3RlZE5vZGVzOiBOb2RlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RvcmVzIGEgc3Vic2V0IG9mIHRoZSBhZmZlY3RlZE5vZGVzIGFycmF5LiBDb250YWluc1xuXHRcdFx0Ly8gb25seSB0aGUgbm9kZXMgdGhhdCBhcmUgYXQgdGhlIGhpZ2hlc3QgbGV2ZWwgb2YgZGVwdGhcblx0XHRcdC8vIHdpdGhpbiB0aGUgbm9kZSBzZXQgKG5vdCBuZWNlc3NhcmlseSB0aGUgZG9jdW1lbnQgcm9vdCkuXG5cdFx0XHRjb25zdCBhZmZlY3RlZE5vZGVzQXBleGVzOiBOb2RlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcmV0dXJucyBUaGUgY29udGFpbmluZyBub2RlIHRoYXRcblx0XHRcdCAqIGNvcnJlc3BvbmRzIHRvIHRoZSBzcGVjaWZpZWQgVVJJLlxuXHRcdFx0ICovIFxuXHRcdFx0Y29uc3QgZmluZE5vZGUgPSAodXJpOiBVcmkpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh1cmkudHlwZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nTm9kZSA9IGFmZmVjdGVkTm9kZXMuZmluZChub2RlID0+IFxuXHRcdFx0XHRcdG5vZGUudXJpLmVxdWFscyh1cmksIHRydWUpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChleGlzdGluZ05vZGUpXG5cdFx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nTm9kZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNhY2hlZE5vZGUgPSB0aGlzLm5vZGVJbmRleC5nZXROb2RlQnlVcmkodXJpKTtcblx0XHRcdFx0aWYgKGNhY2hlZE5vZGUpXG5cdFx0XHRcdFx0cmV0dXJuIGNhY2hlZE5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgdGhlc2UgZGVjbGFyYXRpb25zIGFyZSBlbnVtZXJhdGVkXG5cdFx0XHQvLyBpbiBicmVhZHRoLWZpcnN0IG9yZGVyLCBzbyB0aGF0IGRlZXBlciBub2RlcyBoYXZlIGEgXG5cdFx0XHQvLyBjb250YWluZXIgdGhhdCB0aGV5IGNhbiByZWZlcmVuY2UgZHVyaW5nIGNvbnN0cnVjdGlvblxuXHRcdFx0Ly8gdGltZS4gQmVmb3JlIG5vZGUgY29uc3RydWN0aW9uIGNhbiBoYXBwZW4sIHRoZSBuZXcgXG5cdFx0XHQvLyBTcGFucyBuZWVkIHRvIGJlIG9yZ2FuaXplZCBpbiBhIGRhdGEgc3RydWN0dXJlIHRoYXQgXG5cdFx0XHQvLyBtYWtlcyBicmVhZHRoLWZpcnN0IHRyYXZlcnNhbCBlYXN5LlxuXHRcdFx0Ly8gXG5cdFx0XHQvLyBUaGUgYnJlYWR0aEZpcnN0T3JnYW5pemVyIGhhcyAzIGxldmVscyBvZiBvcmdhbml6YXRpb246XG5cdFx0XHQvL1xuXHRcdFx0Ly8gKDEpIEFuIGFycmF5IG9mIG11bHRpLW1hcHMgd2hpY2ggY29ycmVzcG9uZCB0byBhIHNpbmdsZVxuXHRcdFx0Ly8gbGV2ZWwgb2YgZGVwdGggaW4gdGhlIGhpZXJhcmNoeSBiZWluZyB0cmF2ZXJzZWQgKHdoaWNoXG5cdFx0XHQvLyBjb3VsZCBwb3NzaWJseSBleHRlbmQgYWNyb3NzIG11bHRpcGxlIGxvY2FsaXRpZXMgaW4gdGhlXG5cdFx0XHQvLyBkb2N1bWVudCkuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gKDIpIEEgbXVsdGktbWFwLCB0aGF0IGlzIGtleWVkIGJ5IGEgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvblxuXHRcdFx0Ly8gb2Ygb25lIHNpbmdsZSBzcGluZSBmb3VuZCBpbiB0aGUgaGllcmFyY2h5LCBhbmQgd2hvc2Vcblx0XHRcdC8vIHZhbHVlcyBhcmUuLi5cblx0XHRcdC8vXG5cdFx0XHQvLyAoMykgQSB1bmlxdWUgU3BhbiBvYmplY3QgdGhhdCBjb3JyZXNwb25kcyB0byBhIHVucWl1ZVxuXHRcdFx0Ly8gb2NjdXJlbmNlIG9mIGEgc3ViamVjdCBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpbnRlcmZhY2UgSUJyZWFkdGhGaXJzdEVudHJ5IHsgdXJpOiBVcmk7IGRlY2xhcmF0aW9uOiBTcGFuIHwgSW5maXhTcGFuIH1cblx0XHRcdGNvbnN0IGJyZWFkdGhGaXJzdE9yZ2FuaXplcjogQXJyYXk8TXVsdGlNYXA8c3RyaW5nLCBJQnJlYWR0aEZpcnN0RW50cnk+PiA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgbGV2ZWwsIHN0YXRlbWVudCB9IG9mIGl0ZXJhdG9yKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBQb3NzaWJseSBhcHBlbmQgYSBidW5jaCBvZiBlbXB0eSBtdWx0aS1tYXBzXG5cdFx0XHRcdC8vIGF0IHRoZSBlbmQgb2YgdGhlIG9yZ2FuaXplciwgc28gdGhhdCB3ZSBkb24ndFxuXHRcdFx0XHQvLyBhY2Nlc3MgYW4gdW5pbml0aWFsaXplZCBpbmRleCBkb3duIGJlbG93LlxuXHRcdFx0XHR3aGlsZSAoYnJlYWR0aEZpcnN0T3JnYW5pemVyLmxlbmd0aCA8IGxldmVsICsgMSlcblx0XHRcdFx0XHRicmVhZHRoRmlyc3RPcmdhbml6ZXIucHVzaChuZXcgTXVsdGlNYXA8c3RyaW5nLCBJQnJlYWR0aEZpcnN0RW50cnk+KCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlbiB0aGUgY3VycmVudCBzdGF0ZW1lbnQgaGFzIGJlZW4gZGVlbWVkXG5cdFx0XHRcdC8vIGFzIGNydWZ0LCBpdCdzIE9LIHRvIGp1c3QgY29udGludWUsIGJlY2F1c2UgdGhlIGJyZWFkdGgtZmlyc3Rcblx0XHRcdFx0Ly8gb3JnYW5pemVyIHdpbGwgZW5kIHVwIHdpdGggYW4gZW1wdHkgbXVsdGktbWFwIGluIHRoZSBjYXNlXG5cdFx0XHRcdC8vIHdoZW4gdGhlIHBvcnRpb24gb2YgdGhlIGhpZXJhcmNoeSBiZWluZyB0cmF2ZXJzZWQgbG9va3MgXG5cdFx0XHRcdC8vIGxpa2U6XG5cdFx0XHRcdC8vIFxuXHRcdFx0XHQvLyBGb29cblx0XHRcdFx0Ly8gXHRbQ3J1ZnRdICAgIDw9PT0gV2lsbCBjb3JyZXNwb25kIHRvIGFuIGVtcHR5IG11bHRpLW1hcFxuXHRcdFx0XHQvLyBcdFx0QmFyXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIE9yLCBpdCB3aWxsIGVuZCB1cCB3aXRoIGEgcG9wdWxhdGVkIG11bHRpLW1hcCBpbiB0aGUgY2FzZVxuXHRcdFx0XHQvLyB3aGVuIHRoZXJlIGlzIGFub3RoZXIgc3RhdGVtZW50IGF0IFtDcnVmdF0ncyBsZXZlbCBvZiBkZXB0aC5cblx0XHRcdFx0Ly8gRWl0aGVyIHdheSwgdGhlcmUgYXJlIG5vIHNwYW5zIHRoYXQgbmVlZCB0byBiZSBhZGRlZCBmcm9tXG5cdFx0XHRcdC8vIHN0YXRlbWVudHMgbWFya2VkIGFzIGNydWZ0LiBUaGUgdHJhdmVyc2FsIHdpbGwgc3RpbGwgcmVhY2hcblx0XHRcdFx0Ly8gdGhlIGNydWZ0eSBzdGF0ZW1lbnQncyBjb250ZW50cywgY2F1c2luZyB0aGUgc3BpbmVzIHRvIHN0aWxsXG5cdFx0XHRcdC8vIGJlIGNvbXB1dGVkLlxuXHRcdFx0XHRpZiAoc3RhdGVtZW50LmlzQ3J1ZnQpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBtdWx0aU1hcCA9IGJyZWFkdGhGaXJzdE9yZ2FuaXplcltsZXZlbF07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGRlY2wgb2Ygc3RhdGVtZW50LmRlY2xhcmF0aW9ucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc3BpbmUgb2YgZGVjbC5mYWN0b3IoKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB1cmkgPSBVcmkuY2xvbmUoc3BpbmUpO1xuXHRcdFx0XHRcdFx0Y29uc3QgdHlwZU5hbWVzID0gc3BpbmUudmVydGVicmFlLm1hcCh2ID0+IHYudG9TdHJpbmcodHJ1ZSkpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRtdWx0aU1hcC5hZGQoXG5cdFx0XHRcdFx0XHRcdHR5cGVOYW1lcy5qb2luKFN5bnRheC50ZXJtaW5hbCksXG5cdFx0XHRcdFx0XHRcdHsgdXJpLCBkZWNsYXJhdGlvbjogZGVjbCB9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGRlY2xhcmF0aW9uIGhhcyBwb3B1bGF0aW9uIGluZml4ZXMsIHRoZXNlXG5cdFx0XHRcdFx0XHQvLyBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAgYXMgdGhvdWdoIHRoZXlcblx0XHRcdFx0XHRcdC8vIHdlcmUgcmVndWxhciBkZWNsYXJhdGlvbnMuXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IHBvcEluZml4ZXMgPSBkZWNsLmluZml4ZXMuZmlsdGVyKG5meCA9PiBuZnguaXNQb3B1bGF0aW9uKTtcblx0XHRcdFx0XHRcdGlmIChwb3BJbmZpeGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgaW5maXggb2YgcG9wSW5maXhlcylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBpbmZpeFNwYW4gb2YgZGVjbC5lYWNoRGVjbGFyYXRpb25Gb3JJbmZpeChpbmZpeCkpXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBuZnhUZXh0ID0gU3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwoaW5maXhTcGFuKTtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBpbmZpeFNwaW5lUGFydHMgPSB0eXBlTmFtZXMuY29uY2F0KG5meFRleHQpO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdG11bHRpTWFwLmFkZChcblx0XHRcdFx0XHRcdFx0XHRcdGluZml4U3BpbmVQYXJ0cy5qb2luKFN5bnRheC50ZXJtaW5hbCksXG5cdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVyaTogdXJpLmV4dGVuZFR5cGUobmZ4VGV4dCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlY2xhcmF0aW9uOiBpbmZpeFNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBmb2xsb3dpbmcgYmxvY2sgcG9wdWxhdGVzIHRoZSBhcHByb3ByaWF0ZSBOb2Rlc1xuXHRcdFx0Ly8gaW4gdGhlIGdyYXBoIHdpdGggdGhlIG5ldyBTcGFuIG9iamVjdHMgdGhhdCB3ZXJlIHNlbnRcblx0XHRcdC8vIGluIHRocm91Z2ggdGhlIFwicm9vdFwiIHBhcmFtZXRlci4gTmV3IE5vZGUgb2JqZWN0c1xuXHRcdFx0Ly8gYXJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0Zm9yIChjb25zdCBtdWx0aU1hcCBvZiBicmVhZHRoRmlyc3RPcmdhbml6ZXIpXG5cdFx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgbXVsdGlNYXAudmFsdWVzKCkpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB7IHVyaSwgZGVjbGFyYXRpb24gfSBvZiBlbnRyeSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBub2RlQXRVcmkgPSBmaW5kTm9kZSh1cmkpO1xuXHRcdFx0XHRcdFx0aWYgKG5vZGVBdFVyaSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlcy5wdXNoKG5vZGVBdFVyaSk7XG5cdFx0XHRcdFx0XHRcdG5vZGVBdFVyaS5hZGREZWNsYXJhdGlvbihkZWNsYXJhdGlvbik7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRjb25zdCBjb250YWluZXIgPSB1cmkudHlwZXMubGVuZ3RoID4gMSA/XG5cdFx0XHRcdFx0XHRcdGZpbmROb2RlKHVyaS5yZXRyYWN0VHlwZSgxKSkgOlxuXHRcdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAodXJpLnR5cGVzLmxlbmd0aCA+IDEgJiYgY29udGFpbmVyID09PSBudWxsKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIE5vdGUgdGhhdCB3aGVuIGNyZWF0aW5nIGEgTm9kZSwgaXQnc1xuXHRcdFx0XHRcdFx0Ly8gYXV0b21hdGljYWxseSBib3VuZCB0byBpdCdzIGNvbnRhaW5lci5cblx0XHRcdFx0XHRcdGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZShjb250YWluZXIsIGRlY2xhcmF0aW9uKTtcblx0XHRcdFx0XHRcdGFmZmVjdGVkTm9kZXMucHVzaChuZXdOb2RlKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gUG9wdWxhdGUgdGhlIHRvcE1vc3RBZmZlY3RlZE5vZGVzIGFycmF5LCBcblx0XHRcdFx0XHRcdC8vIHdoaWNoIGlzIG5lZWRlZCB0byBmaW5kIHRoZSBub2RlcyB0aGF0IGFyZVxuXHRcdFx0XHRcdFx0Ly8gYWZmZWN0ZWQgYnkgdGhlIGNoYW5nZSwgYnV0IGFyZSBub3QgbG9jYXRlZFxuXHRcdFx0XHRcdFx0Ly8gZGlyZWN0bHkgd2l0aGluIHRoZSBwYXRjaC5cblx0XHRcdFx0XHRcdGlmIChhZmZlY3RlZE5vZGVzQXBleGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlc0FwZXhlcy5wdXNoKG5ld05vZGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSd2ZSBlbmNvdW50ZXJlZCBhIG5vZGUgdGhhdCBpcyBoaWdoZXJcblx0XHRcdFx0XHRcdFx0Ly8gdGhhbiB0aGUgbGV2ZWwgb2YgZGVwdGggZGVmaW5lZCBpbiB0aGUgbm9kZXMgY3VycmVudGx5XG5cdFx0XHRcdFx0XHRcdC8vIGluIHRoZSBhZmZlY3RlZE5vZGVzQXBleGVzIGFycmF5LlxuXHRcdFx0XHRcdFx0XHRjb25zdCBoaWdoZXN0RGVwdGggPSBhZmZlY3RlZE5vZGVzWzBdLnVyaS50eXBlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5vZGVEZXB0aCA9IG5ld05vZGUudXJpLnR5cGVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChub2RlRGVwdGggPCBoaWdoZXN0RGVwdGgpXG5cdFx0XHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlc0FwZXhlcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKG5vZGVEZXB0aCA8PSBoaWdoZXN0RGVwdGgpXG5cdFx0XHRcdFx0XHRcdFx0YWZmZWN0ZWROb2Rlc0FwZXhlcy5wdXNoKG5ld05vZGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbGwgbmV3IEh5cGVyRWRnZXMgYnkgZmVlZGluZyBpbiBhbGxcblx0XHRcdC8vIGFubm90YXRpb24gc3BhbnMgZm9yIGVhY2ggZGVjbGFyYXRpb24gc3Bhbi5cblx0XHRcdC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGluIGEgc2Vjb25kIHBhc3MgYmVjYXVzZVxuXHRcdFx0Ly8gYWxsIG5ldyBub2RlcyBuZWVkIHRvIGJlIGNyZWF0ZWQgYW5kIHBvc2l0aW9uZWRcblx0XHRcdC8vIGluIHRoZSBncmFwaCBiZWZvcmUgbmV3IFwiSHlwZXJFZGdlIHNwYW5zXCIgY2FuIGJlIGFkZGVkLFxuXHRcdFx0Ly8gYmVjYXVzZSBkb2luZyB0aGlzIGNhdXNlcyByZXNvbHV0aW9uIHRvIG9jY3VyLlxuXHRcdFx0Zm9yIChjb25zdCBub2RlIG9mIGFmZmVjdGVkTm9kZXMpXG5cdFx0XHRcdGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2Ygbm9kZS5kZWNsYXJhdGlvbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBTcGFuKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBkZWNsYXJhdGlvbi5zdGF0ZW1lbnQuYW5ub3RhdGlvbnMpXG5cdFx0XHRcdFx0XHRcdG5vZGUuYWRkRWRnZUZyYWdtZW50KGFubm90YXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgbmZ4ID0gZGVjbGFyYXRpb24uY29udGFpbmluZ0luZml4O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGJvdW5kYXJ5IG9mIG5meC5yaHMpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG5vZGUuYWRkRWRnZUZyYWdtZW50KG5ldyBJbmZpeFNwYW4oXG5cdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb24uY29udGFpbmluZ1NwYW4sXG5cdFx0XHRcdFx0XHRcdFx0bmZ4LFxuXHRcdFx0XHRcdFx0XHRcdGJvdW5kYXJ5KSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRoaXMgaXMgZG9pbmcgdGhlIHJldmVyc2Ugb2Ygd2hhdCB0aGUgYWJvdmUgYWZmZWN0ZWROb2Rlc1xuXHRcdFx0Ly8gbG9vcCBpcyBkb2luZyAuLi4gdGhpcyBpcyBjb25uZWN0aW5nIG90aGVyIG5vZGVzIHRvIHRoZSBhZmZlY3RlZFxuXHRcdFx0Ly8gbm9kZXMsIHdoZXJlYXMgdGhlIGxvb3AgYWJvdmUgaXMgY29ubmVjdGluZyBhZmZlY3RlZE5vZGVzXG5cdFx0XHQvLyB0byBvdGhlcnMuXG5cdFx0XHRpZiAoYWZmZWN0ZWROb2Rlc0FwZXhlcy5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBTdG9yZXMgdGhlIHNlcmllcyBvZiBjb250YWluZXJzIHRoYXQgYW55IG9mIHRoZSBuZXdseSBkaXNjb3ZlcmVkXG5cdFx0XHRcdC8vIHBvc3NpYmx5IGFmZmVjdGVkIG5vZGVzIG11c3QgaGF2ZSBpbiB0aGVpciBjb250YWlubWVudCBsaXN0XG5cdFx0XHRcdC8vIGluIG9yZGVyIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBcImFmZmVjdGVkTm9kZXNcIiBhcnJheS5cblx0XHRcdFx0Y29uc3QgYXBleENvbnRhaW5lcnMgPSBhZmZlY3RlZE5vZGVzQXBleGVzXG5cdFx0XHRcdFx0Lm1hcChub2RlID0+IG5vZGUuY29udGFpbmVyKVxuXHRcdFx0XHRcdC5maWx0ZXIoKG5vZGUpOiBub2RlIGlzIE5vZGUgPT4gbm9kZSAhPT0gbnVsbClcblx0XHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY2hlY2tSb290ID0gYXBleENvbnRhaW5lcnMubGVuZ3RoID09PSAwO1xuXHRcdFx0XHRjb25zdCBpc0JlbG93QW5BcGV4Q29udGFpbmVyID0gKG5vZGU6IE5vZGUpID0+XG5cdFx0XHRcdFx0bm9kZS5jb250YWlubWVudC5zb21lKG4gPT4gYXBleENvbnRhaW5lcnMuaW5jbHVkZXMobikpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBzY3NyTm9kZSBvZiBhZmZlY3RlZE5vZGVzQXBleGVzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gUGF0dGVybiBhbmQgVVJJIHJlc29sdXRpb24gZG9lc24ndCBvY2N1ciBpbiB0aGVcblx0XHRcdFx0XHQvLyBOb2RlIGdyYXBoLCBzbyB3aGVuIHRoZSBub2RlJ3Mgc3ViamVjdCBpc24ndCBcblx0XHRcdFx0XHQvLyBhbiBpZGVudGlmaWVyLCB3ZSBkb24ndCBhZGQgYW55IGVkZ2VzIHRvIGl0LlxuXHRcdFx0XHRcdGlmICghKHNjc3JOb2RlLnN1YmplY3QgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IGlkZW50cyA9IHRoaXMubm9kZUluZGV4LmdldEFzc29jaWF0ZWRJZGVudGlmaWVycyhzY3NyTm9kZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBpZGVudCBvZiBpZGVudHMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcHJlZGVjZXNzb3JzID0gdGhpcy5ub2RlSW5kZXguZ2V0Tm9kZXNCeUlkZW50aWZpZXIoaWRlbnQpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHByZWRlY2Vzc29yIG9mIHByZWRlY2Vzc29ycylcblx0XHRcdFx0XHRcdFx0aWYgKGNoZWNrUm9vdCB8fCBpc0JlbG93QW5BcGV4Q29udGFpbmVyKHByZWRlY2Vzc29yKSlcblx0XHRcdFx0XHRcdFx0XHRwcmVkZWNlc3Nvci5hZGRFZGdlU3VjY2Vzc29yKHNjc3JOb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlcmUncyBubyBhY3RpdmUgdHJhbnNhY3Rpb24gdGhlIGNvcnJlc3BvbmRzIHRvIHRoZSBpbnB1dFxuXHRcdFx0Ly8gZG9jdW1lbnQsIHRoZSBtb3N0IGxpa2VseSByZWFzb24gaXMgdGhhdCBhbiBlbnRpcmUgZG9jdW1lbnRcblx0XHRcdC8vIGlzIGJlaW5nIGluY2x1ZGVkIGZvciB0aGUgZmlyc3QgdGltZS5cblx0XHRcdGlmICh0eG4pXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgbWF5YmVEZWFkRWRnZSBvZiB0eG4uZGVzdGFibGl6ZWRFZGdlcylcblx0XHRcdFx0XHRpZiAobWF5YmVEZWFkRWRnZS5mcmFnbWVudHMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRcdG1heWJlRGVhZEVkZ2UucHJlZGVjZXNzb3IuZGlzcG9zZUVkZ2UobWF5YmVEZWFkRWRnZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IG1heWJlRGVhZE5vZGUgb2YgdHhuLmRlc3RhYmlsaXplZE5vZGVzKVxuXHRcdFx0XHRcdGlmIChtYXliZURlYWROb2RlLmRlY2xhcmF0aW9ucy5zaXplID09PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG1heWJlRGVhZE5vZGUuZGlzcG9zZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5ub2RlSW5kZXguZGVsZXRlKG1heWJlRGVhZE5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gUG9wdWxhdGUgbm9kZUNhY2hlIHdpdGggYW55IG5ld2x5IGNyZWF0ZWQgbm9kZXMuXG5cdFx0XHRmb3IgKGNvbnN0IGFmZmVjdGVkTm9kZSBvZiBhZmZlY3RlZE5vZGVzKVxuXHRcdFx0e1xuXHRcdFx0XHRhZmZlY3RlZE5vZGUuc29ydE91dGJvdW5kcygpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYWZmZWN0ZWRVcmkgPSBhZmZlY3RlZE5vZGUudXJpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdGNvbnN0IGNhY2hlZE5vZGUgPSB0aGlzLm5vZGVJbmRleC5nZXROb2RlQnlVcmkoYWZmZWN0ZWRVcmkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNhY2hlZE5vZGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoY2FjaGVkTm9kZSAhPT0gYWZmZWN0ZWROb2RlKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMubm9kZUluZGV4LnVwZGF0ZShhZmZlY3RlZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMubm9kZUluZGV4LnNldChhZmZlY3RlZFVyaSwgYWZmZWN0ZWROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5zYW5pdGl6ZShhZmZlY3RlZE5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGxvZygpXG5cdFx0e1xuXHRcdFx0Y29uc29sZS5sb2coXCItLS0tIElOVEVSTkFMIEdSQVBIIFJFUFJFU0VOVEFUSU9OIC0tLS1cIik7XG5cdFx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2RlSW5kZXguZWFjaE5vZGUoKSlcblx0XHRcdFx0Y29uc29sZS5sb2cobm9kZS50b1N0cmluZyh0cnVlKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIHNldHVwIGZvciB0aGUgaW52YWxpZGF0ZSBhbmQgcmV2YWxpZGF0ZSBtZXRob2RzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgbWV0aG9kU2V0dXAocm9vdDogRG9jdW1lbnQgfCBTdGF0ZW1lbnQpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZG9jdW1lbnQgPSByb290IGluc3RhbmNlb2YgRG9jdW1lbnQgP1xuXHRcdFx0XHRyb290IDpcblx0XHRcdFx0cm9vdC5kb2N1bWVudDtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSByb290IGluc3RhbmNlb2YgRG9jdW1lbnQgP1xuXHRcdFx0XHRkb2N1bWVudC5lYWNoRGVzY2VuZGFudCgpIDpcblx0XHRcdFx0ZG9jdW1lbnQuZWFjaERlc2NlbmRhbnQocm9vdCwgdHJ1ZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB7IGRvY3VtZW50LCBpdGVyYXRvciB9O1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBSZXBvcnRzIGFueSBOb2RlLWxldmVsIGZhdWx0cyBkZXRlY3RlZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHNhbml0aXplKG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Ly8gQ2hlY2sgZm9yIGZhdWx0eSByZWZyZXNoIHR5cGVzXG5cdFx0XHQvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBvbiBub24taW5maXggc3BhbnNcblx0XHRcdGlmICghKG5vZGUuZGVjbGFyYXRpb25zLnZhbHVlcygpLm5leHQoKS52YWx1ZSBpbnN0YW5jZW9mIFNwYW4pKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNtdHMgPSBub2RlLnN0YXRlbWVudHM7XG5cdFx0XHRjb25zdCBzbXRzUmVmcmVzaCA9IHNtdHMuZmlsdGVyKHNtdCA9PiBzbXQuaXNSZWZyZXNoKTtcblx0XHRcdGNvbnN0IHNtdHNBbm5vdGF0ZWQgPSBzbXRzLmZpbHRlcihzbXQgPT4gc210LmFsbEFubm90YXRpb25zLmxlbmd0aCA+IDApO1xuXHRcdFx0XG5cdFx0XHRpZiAoc210c1JlZnJlc2gubGVuZ3RoID4gMCAmJiBzbXRzQW5ub3RhdGVkLmxlbmd0aCA+IDApXG5cdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIHNtdHNSZWZyZXNoKVxuXHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5mYXVsdHMucmVwb3J0KG5ldyBGYXVsdChcblx0XHRcdFx0XHRcdEZhdWx0cy5UeXBlQ2Fubm90QmVSZWZyZXNoZWQsXG5cdFx0XHRcdFx0XHRzbXQpKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIG9mIGFsbCBub2RlcyB0aGF0XG5cdFx0ICogaGF2ZSBiZWVuIGxvYWRlZCBpbnRvIHRoZSBwcm9ncmFtLCBpbmRleGVkXG5cdFx0ICogYnkgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaXQncyBVUkkuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBub2RlSW5kZXg6IE5vZGVJbmRleDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBHcmFwaFRyYW5zYWN0aW9uIGluc3RhbmNlIGluIHRoZSBjYXNlXG5cdFx0ICogd2hlbiBhbiBlZGl0IHRyYW5zYWN0aW9uIGlzIHVuZGVyd2F5LlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgYWN0aXZlVHJhbnNhY3Rpb25zID0gbmV3IE1hcDxEb2N1bWVudCwgR3JhcGhUcmFuc2FjdGlvbj4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTZXJpYWxpemVzIHRoZSBHcmFwaCBpbnRvIGEgZm9ybWF0IHN1aXRhYmxlXG5cdFx0ICogZm9yIGRlYnVnZ2luZyBhbmQgY29tcGFyaW5nIGFnYWluc3QgYmFzZWxpbmVzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlSW5kZXgudG9TdHJpbmcoKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGNsYXNzIEdyYXBoVHJhbnNhY3Rpb25cblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhbiBhcnJheSBvZiBOb2RlcyB0aGF0IG5vIGxvbmdlciBoYXZlIGFueVxuXHRcdCAqIHVuZGVybHlpbmcgU3BhbiBvYmplY3RzLCBkdWUgdG8gdGhlaXIgcmVtb3ZhbCBpblxuXHRcdCAqIHRoZSBpbnZhbGlkYXRpb24gcGhhc2UuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgZGVzdGFiaWxpemVkTm9kZXM6IE5vZGVbXSA9IFtdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhbiBhcnJheSBvZiBGYW5zIHRoYXQgbm8gbG9uZ2VyIGhhdmUgYW55XG5cdFx0ICogdW5kZXJseWluZyBTcGFuIG9iamVjdHMsIGR1ZSB0byB0aGVpciByZW1vdmFsIGluXG5cdFx0ICogdGhlIGludmFsaWRhdGlvbiBwaGFzZS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBkZXN0YWJsaXplZEVkZ2VzOiBIeXBlckVkZ2VbXSA9IFtdO1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIERlYnVnIHV0aWxpdHkuXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXJpYWxpemVOb2Rlcyhub2RlczogTm9kZVtdKVxuXHR7XG5cdFx0cmV0dXJuIFwiXFxuXCIgKyBub2Rlcy5tYXAobm9kZSA9PiBub2RlLnRvU3RyaW5nKHRydWUpKS5qb2luKFwiXFxuXCIpO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBzaW5nbGUgTm9kZSBjb250YWluZWQgd2l0aGluXG5cdCAqIHRoZSBQcm9ncmFtJ3MgR3JhcGguIE5vZGVzIGFyZSBsb25nLWxpdmVkLCByZWZlcmVudGlhbGx5XG5cdCAqIHNpZ25pZmljYW50IG9iamVjdHMgdGhhdCBwZXJzaXN0IGJldHdlZW4gZWRpdCBmcmFtZXMuXG5cdCAqIFxuXHQgKiBOb2RlcyBhcmUgY29ubmVjdGVkIGluIGEgZ3JhcGggbm90IGJ5IGVkZ2VzLCBidXQgYnlcblx0ICogSHlwZXJFZGdlcy4gQSBIeXBlckVkZ2UgKGZyb20gZ3JhcGggdGhlb3J5KSBpcyBzaW1pbGFyIFxuXHQgKiB0byBhIGRpcmVjdGVkIGVkZ2UgaW4gdGhhdCBpdCBoYXMgYSBzaW5nbGUgcHJlZGVjZXNzb3IsXG5cdCAqIGJ1dCBkaWZmZXJzIGluIHRoYXQgaXQgaGFzIG11bHRpcGxlIHN1Y2Nlc3NvcnMuXG5cdCAqIFxuXHQgKiBJdCBpcyBuZWNlc3NhcnkgZm9yIE5vZGVzIHRvIGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyXG5cdCAqIGluIHRoaXMgd2F5LCBpbiBvcmRlciBmb3IgZnVydGhlciBwaGFzZXMgaW4gdGhlIHBpcGVsaW5lXG5cdCAqIHRvIGV4ZWN1dGUgdGhlIHZhcmlvdXMga2luZHMgb2YgcG9seW1vcnBoaWMgdHlwZVxuXHQgKiByZXNvbHV0aW9uLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIE5vZGVcblx0e1xuXHRcdC8qKiBAaW50ZXJuYWwgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdGNvbnRhaW5lcjogTm9kZSB8IG51bGwsXG5cdFx0XHRkZWNsYXJhdGlvbjogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHRjb25zdCBzcGFuID0gZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBTcGFuID9cblx0XHRcdFx0ZGVjbGFyYXRpb24gOiBcblx0XHRcdFx0ZGVjbGFyYXRpb24uY29udGFpbmluZ1NwYW47XG5cdFx0XHRcblx0XHRcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdFx0dGhpcy5kb2N1bWVudCA9IHNwYW4uc3RhdGVtZW50LmRvY3VtZW50O1xuXHRcdFx0dGhpcy5zdGFtcCA9IHRoaXMuZG9jdW1lbnQudmVyc2lvbjtcblx0XHRcdHRoaXMuX2RlY2xhcmF0aW9ucyA9IG5ldyBTZXQoW2RlY2xhcmF0aW9uXSk7XG5cdFx0XHR0aGlzLnN1YmplY3QgPSBkZWNsYXJhdGlvbi5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0dGhpcy5uYW1lID0gU3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwodGhpcy5zdWJqZWN0KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5pc0xpc3RJbnRyaW5zaWMgPSBcblx0XHRcdFx0dGhpcy5zdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllciAmJlxuXHRcdFx0XHR0aGlzLnN1YmplY3QuaXNMaXN0O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb250YWluZXJUeXBlUGF0aCA9IGNvbnRhaW5lciAhPT0gbnVsbCA/XG5cdFx0XHRcdHRoaXMuY29udGFpbm1lbnQuc2xpY2UoKS5yZXZlcnNlKCkubWFwKG4gPT4gbi5uYW1lKSA6XG5cdFx0XHRcdFtdO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnR5cGVQYXRoID0gY29udGFpbmVyVHlwZVBhdGguY29uY2F0KHRoaXMubmFtZSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmRlY2xhcmF0aW9ucy5zaXplID09PSAwKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGlmICghdGhpcy5jb250YWluZXIpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYWRkUm9vdE5vZGUodGhpcyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5fY29udGVudHMuc2V0KHRoaXMubmFtZSwgdGhpcyk7XG5cdFx0XHRcblx0XHRcdC8vL2lmICghKGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgU3BhbikpXG5cdFx0XHQvLy9cdHJldHVybiB0aGlzO1xuXHRcdFx0Ly8vXG5cdFx0XHQvLy9jb25zdCBpZGVudGlmaWVyID0gZGVjbGFyYXRpb24uYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdC8vL1xuXHRcdFx0Ly8vaWYgKCEoaWRlbnRpZmllciBpbnN0YW5jZW9mIElkZW50aWZpZXIpKVxuXHRcdFx0Ly8vXHRyZXR1cm4gdGhpcztcblx0XHRcdC8vL1xuXHRcdFx0Ly8vY29uc3QgY29udGFpbmVyUGF0dGVybiA9ICgoKSA9PlxuXHRcdFx0Ly8ve1xuXHRcdFx0Ly8vXHRmb3IgKGNvbnN0IGRlY2wgb2YgdGhpcy5jb250YWluZXIuZGVjbGFyYXRpb25zKVxuXHRcdFx0Ly8vXHRcdGlmIChkZWNsLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuKVxuXHRcdFx0Ly8vXHRcdFx0cmV0dXJuIGRlY2wuYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdC8vL30pKCk7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2lmICghY29udGFpbmVyUGF0dGVybilcblx0XHRcdC8vL1x0cmV0dXJuIHRoaXM7XG5cdFx0XHQvLy9cblx0XHRcdC8vL2ZvciAoY29uc3QgbmZ4IG9mIGNvbnRhaW5lclBhdHRlcm4uZ2V0SW5maXhlcyhJbmZpeEZsYWdzLnBvcHVsYXRpb24pKVxuXHRcdFx0Ly8vXHRmb3IgKGNvbnN0IGlkZW50IG9mIG5meC5saHMuZWFjaFN1YmplY3QoKSlcblx0XHRcdC8vL1x0XHRpZiAoaWRlbnQuZnVsbE5hbWUgPT09IGlkZW50aWZpZXIuZnVsbE5hbWUpXG5cdFx0XHQvLy9cdFx0XHQvL3JldHVybiAodGhpcy5jb250YWluZXJJbmZpeCA9IG5meCksIHRoaXM7XG5cdFx0XHQvLy9cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyB0aGlzIE5vZGUsIGFuZCBhbGwgaXRzIGNvbnRlbnRzIGZyb20gdGhlIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGRpc3Bvc2UoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbnRhaW5lciA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwID0gTm9kZS5yb290Tm9kZXMuZ2V0KHRoaXMuZG9jdW1lbnQpO1xuXHRcdFx0XHRpZiAobWFwKVxuXHRcdFx0XHRcdG1hcC5kZWxldGUodGhpcy5uYW1lKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgdGhpcy5jb250YWluZXIuX2NvbnRlbnRzLmRlbGV0ZSh0aGlzLm5hbWUpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGliIG9mIHRoaXMuX2luYm91bmRzKVxuXHRcdFx0XHRpYi5yZW1vdmVTdWNjZXNzb3IodGhpcyk7XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZTogTm9kZSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCBlZGdlIG9mIG5vZGUuX291dGJvdW5kcylcblx0XHRcdFx0XHRub2RlLmRpc3Bvc2VFZGdlKGVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBjb250YWluZWROb2RlIG9mIG5vZGUuX2NvbnRlbnRzLnZhbHVlcygpKVxuXHRcdFx0XHRcdHJlY3Vyc2UoY29udGFpbmVkTm9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBNYW51YWwgbWVtb3J5IG1hbmFnZW1lbnQgZ29pbmcgb24gaGVyZS5cblx0XHRcdFx0Ly8gQ2xlYXJpbmcgb3V0IHRoZSBTZXRzIGlzIHByb2JhYmx5IHVubmVjZXNzYXJ5XG5cdFx0XHRcdC8vIGJlY2F1c2UgdGhlIEdDIHdvdWxkIGNhdGNoIGl0IGFueXdheXMsIGJ1dFxuXHRcdFx0XHQvLyB0aGVzZSBjYWxscyBhcmUgaGVyZSBqdXN0IHRvIGJlIHNhZmUuXG5cdFx0XHRcdC8vIEl0J3Mgc3RpbGwgcmVxdWlyZWQgdGhhdCB3ZSBjbGVhciBvdXQgdGhlIGluYm91bmRzXG5cdFx0XHRcdC8vIGZyb20gdGhlIG5vZGVzIHRvIHdoaWNoIHRoaXMgb25lIGlzIGNvbm5lY3RlZC5cblx0XHRcdFx0bm9kZS5fZGVjbGFyYXRpb25zLmNsZWFyKCk7XG5cdFx0XHRcdG5vZGUuX2luYm91bmRzLmNsZWFyKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJlY3Vyc2UodGhpcyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBIeXBlckVkZ2UgZnJvbSB0aGlzIE5vZGUnc1xuXHRcdCAqIHNldCBvZiBvdXRib3VuZHMuXG5cdFx0ICogXG5cdFx0ICogQHRocm93cyBJbiB0aGUgY2FzZSB3aGVuIHRoZSBzcGVjaWZpZWQgSHlwZXJFZGdlIGlzXG5cdFx0ICogbm90IG93bmVkIGJ5IHRoaXMgTm9kZS5cblx0XHQgKi9cblx0XHRkaXNwb3NlRWRnZShlZGdlOiBIeXBlckVkZ2UpXG5cdFx0e1xuXHRcdFx0aWYgKGVkZ2UucHJlZGVjZXNzb3IgIT09IHRoaXMpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWR4ID0gdGhpcy5fb3V0Ym91bmRzLmluZGV4T2YoZWRnZSk7XG5cdFx0XHR0aGlzLl9vdXRib3VuZHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3Qgc2NzciBvZiBlZGdlLnN1Y2Nlc3NvcnMpXG5cdFx0XHRcdHNjc3Iubm9kZS5faW5ib3VuZHMuZGVsZXRlKGVkZ2UpO1xuXHRcdFx0XG5cdFx0XHRlZGdlLmNsZWFyRnJhZ21lbnRzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGNvbnRhaW5lcjogTm9kZSB8IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW4gdGhlIGNhc2Ugd2hlbiB0aGlzIG5vZGUgaXMgYSBkaXJlY3QgZGVzY2VuZGVudCBvZiBhXG5cdFx0ICogcGF0dGVybiBub2RlLCBhbmQgdGhhdCBwYXR0ZXJuIGhhcyBwb3B1bGF0aW9uIGluZml4ZXMsXG5cdFx0ICogYW5kIHRoaXMgbm9kZSBkaXJlY3RseSBjb3JyZXNwb25kcyB0byBvbmUgb2YgdGhvc2UgaW5maXhlcyxcblx0XHQgKiB0aGlzIHByb3BlcnR5IGdldHMgYSByZWZlcmVuY2UgdG8gc2FpZCBjb3JyZXNwb25kaW5nIGluZml4LlxuXHRcdCAqL1xuXHRcdGdldCBjb250YWluZXJJbmZpeCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZmxhZyA9IEluZml4RmxhZ3MucG9wdWxhdGlvbjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuY29udGFpbmVyICE9PSBudWxsKVxuXHRcdFx0XHRpZiAodGhpcy5jb250YWluZXIuc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBuZnggb2YgdGhpcy5jb250YWluZXIuc3ViamVjdC5nZXRJbmZpeGVzKGZsYWcpKVxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBpZGVudCBvZiBuZngubGhzLmVhY2hTdWJqZWN0KCkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZng7XG5cdFx0XHRcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgc3ViamVjdDogU3ViamVjdDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgdXJpKClcblx0XHR7XG5cdFx0XHQvLyBCZWNhdXNlIHRoZSBVUkkgb2YgdGhlIGRvY3VtZW50IGNhbiBjaGFuZ2UsIHdlIG5lZWQgdG8gXG5cdFx0XHQvLyBtYWtlIHN1cmUgaXQncyBub3QgaGFyZCBjb2RlZCBpbnRvIHRoZSBub2RlIGluc3RhbmNlLlxuXHRcdFx0Y29uc3Qgb3V0VXJpID0gdGhpcy5kb2N1bWVudC5zb3VyY2VVcmkuZXh0ZW5kVHlwZSh0aGlzLnR5cGVQYXRoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubGFzdFVyaSAhPT0gbnVsbClcblx0XHRcdFx0aWYgKG91dFVyaS5lcXVhbHModGhpcy5sYXN0VXJpKSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5sYXN0VXJpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5sYXN0VXJpID0gb3V0VXJpO1xuXHRcdH1cblx0XHRcblx0XHRwcml2YXRlIGxhc3RVcmk6IFVyaSB8IG51bGwgPSBudWxsO1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgdHlwZVBhdGg6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXHRcdFxuXHRcdC8qKiBTdG9yZXMgdGhlIGRvY3VtZW50IHRoYXQgY29udGFpbnMgdGhpcyBOb2RlLiAqL1xuXHRcdHJlYWRvbmx5IGRvY3VtZW50OiBEb2N1bWVudDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBzdGFtcDogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoaXMgTm9kZSBoYXMgYmVlbiBleHBsaWNpdGx5IGRlZmluZWQgYXNcblx0XHQgKiBhIGxpc3QgaW50cmluc2ljLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlzTGlzdEludHJpbnNpYzogYm9vbGVhbjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHdoZXRoZXIgdGhpcyBOb2RlIGhhcyBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZCBhcyBhIGxpc3Rcblx0XHQgKiBleHRyaW5zaWMuIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHRoaXMgcHJvcGVydHkgaW4gYW5kIG9mIGl0c2VsZiBpc1xuXHRcdCAqIG5vdCBzdWZmaWNpZW50IHRvIGRldGVybWluZSB3aGV0aGVyIGFueSBjb3JyZXNwb25kaW5nIHR5cGUgaXNcblx0XHQgKiBhY3R1YWxseSBhIGxpc3QgKGZ1bGwgdHlwZSBhbmFseXNpcyBpcyByZXF1aXJlZCB0byBtYWtlIHRoaXMgY29uY2x1c2lvbikuXG5cdFx0ICovXG5cdFx0Z2V0IGlzTGlzdEV4dHJpbnNpYygpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBvYiBvZiB0aGlzLm91dGJvdW5kcylcblx0XHRcdFx0Zm9yIChjb25zdCBzb3VyY2Ugb2Ygb2IuZnJhZ21lbnRzKVxuXHRcdFx0XHRcdGlmIChzb3VyY2UuYm91bmRhcnkuc3ViamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIpXG5cdFx0XHRcdFx0XHRpZiAoc291cmNlLmJvdW5kYXJ5LnN1YmplY3QuaXNMaXN0KVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBcIm9wcG9zaXRlIHNpZGUgb2YgdGhlIGxpc3RcIi5cblx0XHQgKiBcblx0XHQgKiBJZiB0aGlzIE5vZGUgcmVwcmVzZW50cyBhIGxpc3QgaW50cmluc2ljIHR5cGUsIHRoaXMgcHJvcGVydHkgZ2V0c1xuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBOb2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29ycmVzcG9uZGluZ1xuXHRcdCAqIGV4dHJpbnNpYyBzaWRlLlxuXHRcdCAqIFxuXHRcdCAqIElmIHRoaXMgTm9kZSByZXByZXNlbnRzIGFueXRoaW5nIHRoYXQgKmlzbid0KiBhIGxpc3QgaW50cmluc2ljIHR5cGUsXG5cdFx0ICogdGhlIHByb3BlcnR5IGdldHMgYSByZWZlcmVuY2UgdG8gdGhlIE5vZGUgdGhhdCByZXByZXNlbnRzIHRoZVxuXHRcdCAqIGNvcnJlc3BvbmRpbmcgaW50cmluc2ljIHNpZGUgKHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBsaXN0IG9yIG5vdCkuXG5cdFx0ICogXG5cdFx0ICogR2V0cyBudWxsIGluIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBsaXN0IGludHJpbnNpY1xuXHRcdCAqIG9yIGV4dHJpbnNpYyBOb2RlIHRvIGNvbm5lY3QuXG5cdFx0ICovXG5cdFx0Z2V0IGludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSgpOiBOb2RlIHwgbnVsbFxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnN1YmplY3QgaW5zdGFuY2VvZiBJZGVudGlmaWVyKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGFkamFjZW50IG9mIHRoaXMuYWRqYWNlbnRzLnZhbHVlcygpKVxuXHRcdFx0XHRcdGlmIChhZGphY2VudC5zdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcilcblx0XHRcdFx0XHRcdGlmIChhZGphY2VudC5zdWJqZWN0LnR5cGVOYW1lID09PSB0aGlzLnN1YmplY3QudHlwZU5hbWUpXG5cdFx0XHRcdFx0XHRcdGlmIChhZGphY2VudC5zdWJqZWN0LmlzTGlzdCAhPT0gdGhpcy5pc0xpc3RJbnRyaW5zaWMpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGFkamFjZW50O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHRoZSBzZXQgb2YgZGVjbGFyYXRpb24tc2lkZSBTcGFuIGluc3RhbmNlcyB0aGF0XG5cdFx0ICogY29tcG9zZSB0aGlzIE5vZGUuIElmIHRoaXMgdGhlIHNpemUgb2YgdGhpcyBzZXQgd2VyZSB0b1xuXHRcdCAqIHJlYWNoIHplcm8sIHRoZSBOb2RlIHdvdWxkIGJlIG1hcmtlZCBmb3IgZGVsZXRpb24uXG5cdFx0ICogKE5vZGUgY2xlYW51cCB1c2VzIGEgcmVmZXJlbmNlIGNvdW50ZWQgY29sbGVjdGlvblxuXHRcdCAqIG1lY2hhbmlzbSB0aGF0IHVzZXMgdGhlIHNpemUgb2YgdGhpcyBzZXQgYXMgaXQncyBndWlkZSkuXG5cdFx0ICogXG5cdFx0ICogTm90ZSB0aGF0IGFsdGhvdWdoIHRoZSB0eXBlIG9mIHRoaXMgZmllbGQgaXMgZGVmaW5lZCBhc1xuXHRcdCAqIFwiU2V0PFNwYW4gfCBJbmZpeFNwYW4+XCIsIGluIHByYWN0aWNlLCBpdCBpcyBlaXRoZXIgYSBzZXRcblx0XHQgKiBvZiBTcGFuIGluc3RhbmNlcywgb3IgYSBzZXQgY29udGFpbmluZyBvbmUgc2luZ2xlXG5cdFx0ICogSW5maXhTcGFuIGluc3RhbmNlLiBUaGlzIGlzIGJlY2F1c2UgaXQncyBwb3NzaWJsZSB0byBoYXZlXG5cdFx0ICogZnJhZ21lbnRzIG9mIGEgdHlwZSBkZWNsYXJlZCBpbiBtdWx0aXBsZSBwbGFjZXMgaW5cblx0XHQgKiBhIGRvY3VtZW50LCBob3dldmVyLCBJbmZpeFNwYW5zIGNhbiBvbmx5IGV4aXN0IGluIG9uZVxuXHRcdCAqIHBsYWNlLlxuXHRcdCAqL1xuXHRcdGdldCBkZWNsYXJhdGlvbnMoKTogUmVhZG9ubHlTZXQ8U3BhbiB8IEluZml4U3Bhbj5cblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGVjbGFyYXRpb25zO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9kZWNsYXJhdGlvbnM6IFNldDxTcGFuIHwgSW5maXhTcGFuPjtcblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGREZWNsYXJhdGlvbihzcGFuOiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdHRoaXMuX2RlY2xhcmF0aW9ucy5hZGQoc3Bhbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlbW92ZURlY2xhcmF0aW9uKHNwYW46IFNwYW4gfCBJbmZpeFNwYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3Qgd2FzRGVsZXRlZCA9IHRoaXMuX2RlY2xhcmF0aW9ucy5kZWxldGUoc3Bhbik7XG5cdFx0XHRpZiAod2FzRGVsZXRlZClcblx0XHRcdHtcblx0XHRcdFx0Ly8gUmVtb3ZlIGFsbCBvZiB0aGUgYW5ub3RhdGlvbnMgdGhhdCBleGlzdCBvbiB0aGUgc2FtZVxuXHRcdFx0XHQvLyBzdGF0ZW1lbnQgYXMgdGhlIG9uZSB0aGF0IGNvbnRhaW5zIHRoZSBkZWNsYXJhdGlvbiB0aGF0XG5cdFx0XHRcdC8vIHdhcyByZW1vdmVkLiBOb3RlIHRoYXQgdGhpcyB3b24ndCBtZXNzIHVwIGZyYWdtZW50ZWRcblx0XHRcdFx0Ly8gdHlwZXMuIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGUgc2l0dWF0aW9uIHdoZW4gdGhlIGZpcnN0XG5cdFx0XHRcdC8vIHN0YXRlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIGZvbGxvd2luZyBkb2N1bWVudDpcblx0XHRcdFx0Ly8gXG5cdFx0XHRcdC8vIEEsIEIgOiBYLCBZXG5cdFx0XHRcdC8vIEEsIEMgOiBYLCBZXG5cdFx0XHRcdC8vIFxuXHRcdFx0XHQvLyBTdGF0ZW1lbnRzIGFyZSByZW1vdmVkIGF0b21pY2FsbHksIHNvIHdoZW4gdGhlIHN0YXRlbWVudFxuXHRcdFx0XHQvLyBpcyByZW1vdmVkLCB0aGlzIHdpbGwgcmVzdWx0IGluIDIgY2FsbHMgdG8gdGhpcyBtZXRob2Q6IG9uZSBmb3Jcblx0XHRcdFx0Ly8gdGhlIGZpcnN0IFwiQVwiLCBhbmQgb25lIGZvciB0aGUgXCJCXCIuIFdoZW4gdGhlIHNlY29uZCBjYWxsIGlzIG1hZGUsXG5cdFx0XHRcdC8vIHRoZSBhc3NvY2lhdGVkIGFubm90YXRpb25zIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gcmVtb3ZlZC5cblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSB0aGlzLl9vdXRib3VuZHMubGVuZ3RoOyBpLS0gPiAwOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IG9iID0gdGhpcy5fb3V0Ym91bmRzW2ldO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgYW5ubyBvZiBzcGFuLnN0YXRlbWVudC5hbGxBbm5vdGF0aW9ucylcblx0XHRcdFx0XHRcdG9iLnJlbW92ZUZyYWdtZW50KGFubm8pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChvYi5mcmFnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0dGhpcy5fb3V0Ym91bmRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN0YXRlbWVudHMgdGhhdFxuXHRcdCAqIGNvbnRhaW4gdGhpcyBOb2RlLlxuXHRcdCAqL1xuXHRcdGdldCBzdGF0ZW1lbnRzKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShcblx0XHRcdFx0QXJyYXkuZnJvbSh0aGlzLmRlY2xhcmF0aW9ucylcblx0XHRcdFx0XHQubWFwKGRlY2wgPT4gZGVjbC5zdGF0ZW1lbnQpXG5cdFx0XHRcdFx0LmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYSByZWFkb25seSBtYXAgb2YgTm9kZXMgdGhhdCBhcmUgY29udGFpbmVkXG5cdFx0ICogYnkgdGhpcyBub2RlIGluIHRoZSBjb250YWlubWVudCBoaWVyYXJjaHkuXG5cdFx0ICovXG5cdFx0Z2V0IGNvbnRlbnRzKCk6IE5vZGVNYXBcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29udGVudHM7XG5cdFx0fVxuXHRcdHByaXZhdGUgcmVhZG9ubHkgX2NvbnRlbnRzID0gbmV3IE1hcDxzdHJpbmcsIE5vZGU+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHJlYWRvbmx5IG5hbWUgb2YgTm9kZXMgdGhhdCBhcmUgYWRqYWNlbnRcblx0XHQgKiB0byB0aGlzIE5vZGUgaW4gdGhlIGNvbnRhaW5tZW50IGhpZXJhcmNoeS5cblx0XHQgKi9cblx0XHRnZXQgYWRqYWNlbnRzKCk6IE5vZGVNYXBcblx0XHR7XG5cdFx0XHRjb25zdCBhZGphY2VudE5vZGVzID0gdGhpcy5jb250YWluZXIgP1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lci5jb250ZW50cyA6XG5cdFx0XHRcdHRoaXMuZ2V0Um9vdE5vZGVzKCk7XG5cdFx0XHRcblx0XHRcdC8vIEZpbHRlciB0aGlzIG5vZGUgb3V0IG9mIHRoZSByZXN1bHQgc2V0LCBiZWNhdXNlXG5cdFx0XHQvLyBOb2RlcyBjYW5ub3QgYmUgYWRqYWNlbnQgdG8gdGhlbXNlbHZlcy5cblx0XHRcdGNvbnN0IG91dCA9IG5ldyBNYXA8c3RyaW5nLCBOb2RlPigpO1xuXHRcdFx0Zm9yIChjb25zdCBbbmFtZSwgbm9kZV0gb2YgYWRqYWNlbnROb2Rlcylcblx0XHRcdFx0aWYgKG5vZGUgIT09IHRoaXMpXG5cdFx0XHRcdFx0b3V0LnNldChuYW1lLCBub2RlKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIDItZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2Zcblx0XHQgKiB0aGUgcG9ydGFiaWxpdHkgaW5maXhlcyB0aGF0IGhhdmUgYmVlbiBkZWZpbmVkIHdpdGhpblxuXHRcdCAqIHRoaXMgbm9kZSwgd2l0aCB0aGUgZmlyc3QgZGltZW5zaW9uIGNvcnJlc3BvbmRpbmcgdG9cblx0XHQgKiBhIHVuaXF1ZSBwb3J0YWJpbGl0eSBpbmZpeCwgYW5kIHRoZSBzZWNvbmQgZGltZW5zaW9uXG5cdFx0ICogY29ycmVzcG9uZGluZyB0byB0aGUgbmFtZXMgZGVmaW5lZCB3aXRoaW4gdGhhdCBpbmZpeC5cblx0XHQgKiBcblx0XHQgKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuXHRcdCAqIC88IDogQSwgQiwgQz48IDogRCwgRSwgRj4gOiA/Pz9cblx0XHQgKiBcblx0XHQgKiBUaGUgZm9sbG93aW5nIHJlc3VsdCB3b3VsZCBiZSBwcm9kdWNlZDpcblx0XHQgKiBbW1wiQVwiLCBcIkJcIiwgXCJDXCJdLCBbXCJEXCIsIFwiRVwiLCBcIkZcIl1dXG5cdFx0ICovXG5cdFx0Z2V0IHBvcnRhYmlsaXR5VGFyZ2V0cygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX3BvcnRhYmlsaXR5VGFyZ2V0cyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BvcnRhYmlsaXR5VGFyZ2V0cztcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybikpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9wb3J0YWJpbGl0eVRhcmdldHMgPSBbXTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWRlbnRpZmllckFycmF5cyA9IHRoaXMuc3ViamVjdFxuXHRcdFx0XHQuZ2V0SW5maXhlcyhJbmZpeEZsYWdzLnBvcnRhYmlsaXR5KVxuXHRcdFx0XHQubWFwKG5meCA9PiBPYmplY3QuZnJlZXplKEFycmF5LmZyb20obmZ4LnJocy5lYWNoU3ViamVjdCgpKVxuXHRcdFx0XHRcdC5tYXAoaWRlbnQgPT4gaWRlbnQudHlwZU5hbWUpKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLl9wb3J0YWJpbGl0eVRhcmdldHMgPSBPYmplY3QuZnJlZXplKGlkZW50aWZpZXJBcnJheXMpO1xuXHRcdH1cblx0XHRwcml2YXRlIF9wb3J0YWJpbGl0eVRhcmdldHM6IHJlYWRvbmx5IChyZWFkb25seSBzdHJpbmdbXSlbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgc2V0IG9mIG5vZGVzIHRoYXQgYXJlIG1hdGNoZWQgYnlcblx0XHQgKiBwYXR0ZXJucyBvZiBhZGphY2VudCBub2Rlcy5cblx0XHQgKiBcblx0XHQgKiAoTm90ZSB0aGF0IHRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBhbm5vdGF0aW9uc1xuXHRcdCAqIHRoYXQgaGF2ZSBiZWVuIGFwcGxpZWQgdG8gYSBwYXR0ZXJuIGNhbm5vdCBiZVxuXHRcdCAqIHBvbHltb3JwaGljKVxuXHRcdCAqL1xuXHRcdGdldFBhdHRlcm5Ob2Rlc01hdGNoaW5nKG5vZGVzOiBOb2RlW10pXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb3V0Tm9kZXM6IE5vZGVbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvL1xuXHRcdFx0Ly8gVGhpcyBkb2Vzbid0IHdvcmsgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGlmXG5cdFx0XHQvLyBhIG5vZGUgaGFzIGJlZW4gbWFya2VkIGFzIGNydWZ0IGF0IHRoaXMgcG9pbnQuXG5cdFx0XHQvLyBUaGlzIG1ldGhvZCBtYXkgcmV0dXJuIGp1bmsgcmVzdWx0cyBpbiB0aGVcblx0XHRcdC8vIGNhc2Ugd2hlbiBvbmUgb2YgdGhlIHJlcXVpcmVkIG5vZGVzIGhhc1xuXHRcdFx0Ly8gYmVlbiBtYXJrZWQgYXMgY3J1ZnQgKGJ1dCB0aGVuLCB3b3VsZG4ndCB0aGVcblx0XHRcdC8vIGluY29taW5nIG5vZGUgYWxzbyBiZSBjcnVmdD8pXG5cdFx0XHQvL1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5hZGphY2VudHMudmFsdWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChub2RlLnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgdW5vcnBoYW5lZCA9IG5vZGUub3V0Ym91bmRzXG5cdFx0XHRcdFx0XHQuZmlsdGVyKG9iID0+IG9iLnN1Y2Nlc3NvcnMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRcdC5tYXAob2IgPT4gb2Iuc3VjY2Vzc29yc1swXS5ub2RlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodW5vcnBoYW5lZC5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodW5vcnBoYW5lZC5sZW5ndGggPT09IG5vZGVzLmxlbmd0aClcblx0XHRcdFx0XHRcdGlmICh1bm9ycGhhbmVkLmV2ZXJ5KG5vZGUgPT4gbm9kZXMuaW5jbHVkZXMobm9kZSkpKVxuXHRcdFx0XHRcdFx0XHRvdXROb2Rlcy5wdXNoKC4uLnVub3JwaGFuZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXROb2Rlcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBpbW11dGFibGUgc2V0IG9mIEh5cGVyRWRnZXMgZnJvbSBhZGphY2VudFxuXHRcdCAqIG9yIGNvbnRhaW5lZCBOb2RlcyB0aGF0IHJlZmVyZW5jZSB0aGlzIE5vZGUuIFxuXHRcdCAqIFxuXHRcdCAqIChUaGUgb3JkZXJpbmcgb2YgaW5ib3VuZHMgaXNuJ3QgaW1wb3J0YW50LCBhc1xuXHRcdCAqIHRoZXkgaGF2ZSBubyBwaHlzaWNhbCByZXByZXNlbnRhdGlvbiBpbiB0aGVcblx0XHQgKiBkb2N1bWVudCwgd2hpY2ggaXMgd2h5IHRoZXkncmUgc3RvcmVkIGluIGEgU2V0XG5cdFx0ICogcmF0aGVyIHRoYW4gYW4gYXJyYXkuKVxuXHRcdCAqL1xuXHRcdGdldCBpbmJvdW5kcygpOiBSZWFkb25seVNldDxIeXBlckVkZ2U+XG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2luYm91bmRzO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9pbmJvdW5kcyA9IG5ldyBTZXQ8SHlwZXJFZGdlPigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgb2YgSHlwZXJFZGdlcyB0aGF0IGNvbm5lY3QgdGhpcyBOb2RlIHRvXG5cdFx0ICogb3RoZXJzLCBiZWluZyBlaXRoZXIgYWRqYWNlbnRzLCBvciBOb2RlcyB0aGF0XG5cdFx0ICogZXhpc3RzIHNvbWV3aGVyZSBpbiB0aGUgY29udGFpbm1lbnQgaGllcmFyY2h5LlxuXHRcdCAqL1xuXHRcdGdldCBvdXRib3VuZHMoKTogcmVhZG9ubHkgSHlwZXJFZGdlW11cblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3V0Ym91bmRzO1xuXHRcdH1cblx0XHRwcml2YXRlIHJlYWRvbmx5IF9vdXRib3VuZHM6IEh5cGVyRWRnZVtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogU29ydHMgdGhlIG91dGJvdW5kIEh5cGVyRWRnZXMsIHNvIHRoYXQgdGhleSdyZSBvcmRlcmluZ1xuXHRcdCAqIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgd2F5IHRoZWlyIGNvcnJlc3BvbmRpbmdcblx0XHQgKiBhbm5vdGF0aW9ucyBhcHBlYXIgaW4gdGhlIHVuZGVybHlpbmcgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0c29ydE91dGJvdW5kcygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX291dGJvdW5kcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX291dGJvdW5kcy5sZW5ndGggPT09IDEpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGVkZ2UgPSB0aGlzLl9vdXRib3VuZHNbMF07XG5cdFx0XHRcdGlmIChlZGdlLmZyYWdtZW50cy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBlZGdlTG9va3VwID0gbmV3IE1hcDxIeXBlckVkZ2UsIFtTdGF0ZW1lbnQsIG51bWJlcl0+KCk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLl9vdXRib3VuZHMpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3JjIG9mIGVkZ2UuZnJhZ21lbnRzLnZhbHVlcygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgc210ID0gc3JjLnN0YXRlbWVudDtcblx0XHRcdFx0XHRjb25zdCBsaW5lTnVtID0gc210LmRvY3VtZW50LmdldExpbmVOdW1iZXIoc210KTtcblx0XHRcdFx0XHRjb25zdCBleGlzdGluZ1R1cGxlID0gZWRnZUxvb2t1cC5nZXQoZWRnZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nVHVwbGUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBleGlzdGluZ1N0bXQgPSBleGlzdGluZ1R1cGxlWzBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdTdG10SWR4ID0gZXhpc3RpbmdUdXBsZVsxXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGxpbmVOdW0gPCBleGlzdGluZ1N0bXRJZHgpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGV4aXN0aW5nVHVwbGVbMF0gPSBleGlzdGluZ1N0bXQ7XG5cdFx0XHRcdFx0XHRcdGV4aXN0aW5nVHVwbGVbMV0gPSBleGlzdGluZ1N0bXRJZHg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGdlTG9va3VwLnNldChlZGdlLCBbc210LCBsaW5lTnVtXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFNvcnQgdGhlIG91dHB1dCBlZGdlcyBpbiB0aGUgYXJyYXksIHNvIHRoYXQgdGhlIHNvcnRpbmcgb2Zcblx0XHRcdC8vIHRoZSBhcnJheSBhbGlnbnMgd2l0aCB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgdW5kZXJseWluZ1xuXHRcdFx0Ly8gc3BhbnMgaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0dGhpcy5fb3V0Ym91bmRzLnNvcnQoKGVkZ2VBLCBlZGdlQikgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdHVwbGVBID0gZWRnZUxvb2t1cC5nZXQoZWRnZUEpO1xuXHRcdFx0XHRjb25zdCB0dXBsZUIgPSBlZGdlTG9va3VwLmdldChlZGdlQik7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBvYnMgPSB0aGlzLl9vdXRib3VuZHM7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodHVwbGVBID09PSB1bmRlZmluZWQgfHwgdHVwbGVCID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgW3NtdEEsIHNtdElkeEFdID0gdHVwbGVBO1xuXHRcdFx0XHRjb25zdCBbc210Qiwgc210SWR4Ql0gPSB0dXBsZUI7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB0aGUgdG9wLW1vc3Qgc3BhbiBvZiB0aGUgcHJlZGVjZXNzb3JzIG9mXG5cdFx0XHRcdC8vIHRoZSBlZGdlcyBhcmUgbG9jYXRlZCBpbiBkaWZmZXJlbnQgc3RhdGVtZW50cyxcblx0XHRcdFx0Ly8gYSBzaW1wbGUgY29tcGFyaXNvbiBvZiB0aGUgc3RhdGVtZW50IGluZGV4ZXNcblx0XHRcdFx0Ly8gaXMgcG9zc2libGUuXG5cdFx0XHRcdGlmIChzbXRJZHhBIDwgc210SWR4Qilcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc210SWR4QiA8IHNtdElkeEEpXG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBzdGF0ZW1lbnQgQSBhbmQgc3RhdGVtZW50IEIgXG5cdFx0XHRcdC8vIGFyZSBhY3R1YWxseSBlcXVhbC5cblx0XHRcdFx0aWYgKHNtdEEgIT09IHNtdEIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGFubm9zID0gc210QS5hbm5vdGF0aW9ucztcblx0XHRcdFx0Y29uc3QgZmluZE1pbkluZGV4ID0gKGVkZ2U6IEh5cGVyRWRnZSkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBtaW5JZHggPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNyYyBvZiBlZGdlLmZyYWdtZW50cylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoc3JjIGluc3RhbmNlb2YgSW5maXhTcGFuKVxuXHRcdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IGlkeCA9IGFubm9zLmluZGV4T2Yoc3JjKTtcblx0XHRcdFx0XHRcdGlmIChpZHggPCBtaW5JZHgpXG5cdFx0XHRcdFx0XHRcdG1pbklkeCA9IGlkeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1pbklkeCA9PT0gSW5maW5pdHkpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIG1pbklkeDtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGVkZ2VBSWR4ID0gZmluZE1pbkluZGV4KGVkZ2VBKTtcblx0XHRcdFx0Y29uc3QgZWRnZUJJZHggPSBmaW5kTWluSW5kZXgoZWRnZUIpO1xuXHRcdFx0XHRyZXR1cm4gZWRnZUFJZHggLSBlZGdlQklkeDtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBBZGRzIGEgbmV3IGVkZ2UgdG8gdGhlIG5vZGUsIG9yIHVwZGF0ZXMgYW4gZXhpc3Rpbmcgb25lIHdpdGhcblx0XHQgKiBhIG5ldyBmcmFnbWVudC5cblx0XHQgKiBcblx0XHQgKiBJZiBubyBlZGdlIGV4aXN0cyBmb3IgdGhlIG5ldyBmcmFnbWVudCwgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG5cdFx0ICovXG5cdFx0YWRkRWRnZUZyYWdtZW50KGZyYWdtZW50OiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IGlkZW50aWZpZXIgPSBmcmFnbWVudC5ib3VuZGFyeS5zdWJqZWN0O1xuXHRcdFx0aWYgKCEoaWRlbnRpZmllciBpbnN0YW5jZW9mIElkZW50aWZpZXIpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBpbnB1dCBzb3VyY2UgaXMgXCJhbG9uZVwiLCBpdCBtZWFucyB0aGF0IGl0IHJlZmVycyB0b1xuXHRcdFx0Ly8gYSBzdGF0ZW1lbnQtbGV2ZWwgYW5ub3RhdGlvbiB0aGF0IGhhcyBubyBvdGhlciBhbm5vdGF0aW9uc1xuXHRcdFx0Ly8gYmVzaWRlIGl0IChlLmcuIGluIGFuIGFubm90YXRpb24gc3RydWN0dXJlIGxvb2tpbmcgbGlrZSBcIkQ6IEExLCBBMlwiKVxuXHRcdFx0Ly8gVGhpcyBpcyByZWxldmFudCwgYmVjYXVzZSBpZiB0aGUgc291cmNlIGlzIGFsb25lLCBpdCBhbHNvIG5lZWRzXG5cdFx0XHQvLyB0byBiZSBjb21wYXJlZCBhZ2FpbnN0IGFueSB2aXNpYmxlIHRvdGFsIHBhdHRlcm5zLlxuXHRcdFx0Y29uc3Qgc291cmNlSXNBbG9uZSA9XG5cdFx0XHRcdGZyYWdtZW50IGluc3RhbmNlb2YgU3BhbiAmJiBcblx0XHRcdFx0ZnJhZ21lbnQuc3RhdGVtZW50LmFubm90YXRpb25zLmxlbmd0aCA9PT0gMTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIGEgZWRnZSB0byBpdCdzIHR3byBhcHBsaWNhYmxlIHN1Y2Nlc3NvciBub2Rlcy5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgYXBwZW5kID0gKGVkZ2U6IEh5cGVyRWRnZSkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fb3V0Ym91bmRzLnB1c2goZWRnZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YyBvZiBlZGdlLnN1Y2Nlc3NvcnMpXG5cdFx0XHRcdFx0c3VjLm5vZGUuX2luYm91bmRzLmFkZChlZGdlKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gZXhpc3Rpbmcgb3V0Ym91bmQgSHlwZXJFZGdlLCB3ZSBjYW5cblx0XHRcdC8vIGFkZCB0aGUgbmV3IFNwYW4gdG8gdGhlIGVkZ2UncyBsaXN0IG9mIFNwYW5zLCBhbmQgcXVpdC5cblx0XHRcdC8vIFRoaXMgd29ya3Mgd2hldGhlciB0aGUgZWRnZSBpcyBmb3IgYSB0eXBlIG9yIHBhdHRlcm4uXG5cdFx0XHRjb25zdCBleGlzdGluZ0VkZ2UgPSB0aGlzLl9vdXRib3VuZHMuZmluZChlZGdlID0+XG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBlZGdlLmlkZW50aWZpZXIudHlwZU5hbWUgPT09IGlkZW50aWZpZXIudHlwZU5hbWU7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGV4aXN0aW5nRWRnZSlcblx0XHRcdHtcblx0XHRcdFx0ZXhpc3RpbmdFZGdlLmFkZEZyYWdtZW50KGZyYWdtZW50KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3VjY2Vzc29yczogU3VjY2Vzc29yW10gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgbGV2ZWwgb2YgdGhpcy5lbnVtZXJhdGVDb250YWlubWVudCgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3Qgc3VjY2Vzc29yTm9kZSA9IFxuXHRcdFx0XHRcdFx0bGV2ZWwuY29udGFpbmVyICE9PSBudWxsICYmIFxuXHRcdFx0XHRcdFx0bGV2ZWwuY29udGFpbmVyICE9PSB0aGlzICYmXG5cdFx0XHRcdFx0XHRsZXZlbC5jb250YWluZXIubmFtZSA9PT0gaWRlbnRpZmllci50eXBlTmFtZSA/XG5cdFx0XHRcdFx0XHRcdGxldmVsLmNvbnRhaW5lciA6XG5cdFx0XHRcdFx0XHRcdGxldmVsLmFkamFjZW50cy5nZXQoaWRlbnRpZmllci50eXBlTmFtZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHN1Y2Nlc3Nvck5vZGUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzdWNjZXNzb3JzLnB1c2gobmV3IFN1Y2Nlc3Nvcihcblx0XHRcdFx0XHRcdFx0c3VjY2Vzc29yTm9kZSxcblx0XHRcdFx0XHRcdFx0bGV2ZWwubG9uZ2l0dWRlRGVsdGEpKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBhIHNpbmdsZSBzdWNjZXNzb3IgaW4gdGhlIGNhc2Ugd2hlblxuXHRcdFx0XHRcdFx0Ly8gdGhlIG5vZGUgaXMgYSBwYXR0ZXJuIG5vZGUsIGJlY2F1c2UgdGhlIGFubm90YXRpb25zICh3aGljaFxuXHRcdFx0XHRcdFx0Ly8gYXJlIGV2ZW50dWFsbHkgYmVjb21lIGJhc2VzKSBvZiB0aGVzZSBub2RlcyBkbyBub3QgaGF2ZVxuXHRcdFx0XHRcdFx0Ly8gcG9seW1vcnBoaWMgYmVoYXZpb3IuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRhcHBlbmQobmV3IEh5cGVyRWRnZSh0aGlzLCBmcmFnbWVudCwgc3VjY2Vzc29ycykpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBcblx0XHRcdC8vIFJlZnJlc2ggdGhlIHN1bXMgYmVmb3JlIHF1aXR0aW5nLlxuXHRcdFx0Ly8gXG5cdFx0XHRcblx0XHRcdC8vL2NvbnN0IHN1bUVkZ2VGb3JJbnB1dFNwYW5JZHggPSB0aGlzLl9vdXRib3VuZHMuZmluZEluZGV4KGVkZ2UgPT4gXG5cdFx0XHQvLy97XG5cdFx0XHQvLy9cdGlmIChlZGdlLmtpbmQgPT09IEh5cGVyRWRnZUtpbmQuc3VtbWF0aW9uKVxuXHRcdFx0Ly8vXHRcdGZvciAoY29uc3Qgc3JjIG9mIGVkZ2Uuc291cmNlcylcblx0XHRcdC8vL1x0XHRcdHJldHVybiBzcmMuc3RhdGVtZW50ID09PSBzbXQ7XG5cdFx0XHQvLy9cdFxuXHRcdFx0Ly8vXHRyZXR1cm4gZmFsc2U7XG5cdFx0XHQvLy99KTtcblx0XHRcdC8vL1xuXHRcdFx0Ly8vaWYgKHN1bUVkZ2VGb3JJbnB1dFNwYW5JZHggPiAtMSlcblx0XHRcdC8vL1x0dGhpcy5fb3V0Ym91bmRzLnNwbGljZShzdW1FZGdlRm9ySW5wdXRTcGFuSWR4LCAxKTtcblx0XHRcdC8vL1xuXHRcdFx0Ly8vaWYgKCFzb3VyY2VJc0Fsb25lKVxuXHRcdFx0Ly8vXHRmb3IgKGNvbnN0IHsgbG9uZ2l0dWRlRGVsdGEsIGFkamFjZW50cyB9IG9mIHRoaXMuZW51bWVyYXRlQ29udGFpbm1lbnQoKSlcblx0XHRcdC8vL1x0XHRmb3IgKGNvbnN0IGFkamFjZW50Tm9kZSBvZiBhZGphY2VudHMudmFsdWVzKCkpXG5cdFx0XHQvLy9cdFx0XHRpZiAoYWRqYWNlbnROb2RlLnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuKVxuXHRcdFx0Ly8vXHRcdFx0XHRpZiAoYWRqYWNlbnROb2RlLnN1YmplY3QuaXNUb3RhbClcblx0XHRcdC8vL1x0XHRcdFx0XHRpZiAoYWRqYWNlbnROb2RlLnN1YmplY3QudGVzdChzbXQuc3VtKSlcblx0XHRcdC8vL1x0XHRcdFx0XHRcdGFwcGVuZChuZXcgSHlwZXJFZGdlKFxuXHRcdFx0Ly8vXHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0Ly8vXHRcdFx0XHRcdFx0XHRzbXQuc3VtLFxuXHRcdFx0Ly8vXHRcdFx0XHRcdFx0XHRbbmV3IFN1Y2Nlc3Nvcihcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0XHRhZGphY2VudE5vZGUsXG5cdFx0XHQvLy9cdFx0XHRcdFx0XHRcdFx0bG9uZ2l0dWRlRGVsdGEpXSxcblx0XHRcdC8vL1x0XHRcdFx0XHRcdFx0SHlwZXJFZGdlS2luZC5zdW1tYXRpb24pKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0YWRkRWRnZVN1Y2Nlc3NvcihzdWNjZXNzb3JOb2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGlkZW50aWZpZXIgPSBzdWNjZXNzb3JOb2RlLnN1YmplY3QgYXMgSWRlbnRpZmllcjtcblx0XHRcdGlmICghKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IG9iIG9mIHRoaXMub3V0Ym91bmRzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAob2IuaWRlbnRpZmllci50eXBlTmFtZSAhPT0gc3VjY2Vzc29yTm9kZS5uYW1lKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc2NzckxvbmcgPSBzdWNjZXNzb3JOb2RlLnVyaS50eXBlcy5sZW5ndGg7XG5cdFx0XHRcdGNvbnN0IHByZWRMb25nID0gb2IucHJlZGVjZXNzb3IudXJpLnR5cGVzLmxlbmd0aDtcblx0XHRcdFx0b2IuYWRkU3VjY2Vzc29yKHN1Y2Nlc3Nvck5vZGUsIHByZWRMb25nIC0gc2NzckxvbmcpO1xuXHRcdFx0XHRzdWNjZXNzb3JOb2RlLl9pbmJvdW5kcy5hZGQob2IpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIGVudW1lcmF0ZU91dGJvdW5kcygpXG5cdFx0e1xuXHRcdFx0Ly8vY29uc3QgcmVjdXJzZSA9IChub2RlOiBOb2RlKSA9PlxuXHRcdFx0Ly8ve1xuXHRcdFx0Ly8vXHRmb3IgKGNvbnN0IGVkZ2Ugb2Ygbm9kZS5vdXRib3VuZHMpXG5cdFx0XHQvLy9cdFx0Zm9yIChjb25zdCBzdWNjZXNzb3Igb2YgZWRnZS5zdWNjZXNzb3JzKVxuXHRcdFx0Ly8vXHRcdFx0Ly95aWVsZCB7IG5vZGU6IFxuXHRcdFx0Ly8vfVxuXHRcdFx0Ly8vXG5cdFx0XHQvLy95aWVsZCAqcmVjdXJzZSh0aGlzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRW51bWVyYXRlcyB1cHdhcmRzIHRocm91Z2ggdGhlIGNvbnRhaW5tZW50XG5cdFx0ICogaGllcmFyY2h5IG9mIHRoZSBOb2RlcyBwcmVzZW50IGluIHRoaXMgTm9kZSdzXG5cdFx0ICogY29udGFpbmluZyBkb2N1bWVudCwgeWllbGRpbmcgdGhlIGFkamFjZW50cyBhdFxuXHRcdCAqIGV2ZXJ5IGxldmVsLCBhbmQgdGhlbiBjb250aW51ZXMgdGhyb3VnaCB0byB0aGVcblx0XHQgKiByb290IGxldmVsIGFkamFjZW50cyBvZiBlYWNoIG9mIHRoZSBkb2N1bWVudCdzXG5cdFx0ICogZGVwZW5kZW5jaWVzLlxuXHRcdCAqL1xuXHRcdCplbnVtZXJhdGVDb250YWlubWVudCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZG9jID0gdGhpcy5kb2N1bWVudDtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBkb2MucHJvZ3JhbTtcblx0XHRcdGNvbnN0IGRlcHMgPSBwcm9ncmFtLmRvY3VtZW50cy5nZXREZXBlbmRlbmNpZXMoZG9jKTtcblx0XHRcdGxldCBjdXJyZW50TGV2ZWw6IE5vZGUgfCBudWxsID0gdGhpcztcblx0XHRcdGxldCBsb25naXR1ZGVDb3VudCA9IDA7XG5cdFx0XHRcblx0XHRcdGRvXG5cdFx0XHR7XG5cdFx0XHRcdHlpZWxkIHtcblx0XHRcdFx0XHRzb3VyY2VEb2N1bWVudDogZG9jLFxuXHRcdFx0XHRcdGNvbnRhaW5lcjogPE5vZGUgfCBudWxsPmN1cnJlbnRMZXZlbCxcblx0XHRcdFx0XHRhZGphY2VudHM6IGN1cnJlbnRMZXZlbC5hZGphY2VudHMsXG5cdFx0XHRcdFx0bG9uZ2l0dWRlRGVsdGE6IGxvbmdpdHVkZUNvdW50Kytcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHdoaWxlICgoY3VycmVudExldmVsID0gY3VycmVudExldmVsLmNvbnRhaW5lcikgIT09IG51bGwpO1xuXHRcdFx0XG5cdFx0XHQvLyBOT1RFOiBUaGlzIGlzIGJyb2tlbi4gSXQgbmVlZHMgdG8gYmUgcmVjdXJzaXZlLlxuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gZGVwcy5sZW5ndGg7IC0taSA+IDA7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzb3VyY2VEb2N1bWVudCA9IGRlcHNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0c291cmNlRG9jdW1lbnQsXG5cdFx0XHRcdFx0Y29udGFpbmVyOiBudWxsLFxuXHRcdFx0XHRcdGFkamFjZW50czogdGhpcy5nZXRSb290Tm9kZXMoc291cmNlRG9jdW1lbnQpLFxuXHRcdFx0XHRcdGxvbmdpdHVkZURlbHRhOiBsb25naXR1ZGVDb3VudFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSB0aGF0IHN0b3JlcyB0aGUgY29udGFpbm1lbnQgaGllcmFyY2h5XG5cdFx0ICogb2YgdGhlIE5vZGVzIHByZXNlbnQgaW4gdGhpcyBOb2RlJ3MgY29udGFpbmluZyBkb2N1bWVudCxcblx0XHQgKiB5aWVsZGluZyBlYWNoIGNvbnRhaW5lcm9mIHRoaXMgTm9kZS5cblx0XHQgKi9cblx0XHRnZXQgY29udGFpbm1lbnQoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9jb250YWlubWVudCAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5tZW50O1xuXHRcdFx0XG5cdFx0XHRjb25zdCBub2RlczogTm9kZVtdID0gW107XG5cdFx0XHRcblx0XHRcdGxldCBjdXJyZW50TGV2ZWw6IE5vZGUgfCBudWxsID0gdGhpcztcblx0XHRcdHdoaWxlICgoY3VycmVudExldmVsID0gY3VycmVudExldmVsLmNvbnRhaW5lcikgIT09IG51bGwpXG5cdFx0XHRcdG5vZGVzLnB1c2goY3VycmVudExldmVsKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5tZW50ID0gT2JqZWN0LmZyZWV6ZShub2Rlcyk7XG5cdFx0fVxuXHRcdHByaXZhdGUgX2NvbnRhaW5tZW50OiByZWFkb25seSBOb2RlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZW1vdmVFZGdlU291cmNlKHNyYzogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5fb3V0Ym91bmRzLmxlbmd0aDsgLS1pID4gMDspXG5cdFx0XHRcdHRoaXMuX291dGJvdW5kc1tpXS5yZW1vdmVGcmFnbWVudChzcmMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHR0b1N0cmluZyhpbmNsdWRlUGF0aCA9IHRydWUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZGVjbHMgPSBBcnJheS5mcm9tKHRoaXMuZGVjbGFyYXRpb25zKTtcblx0XHRcdGNvbnN0IHNwYW5zID0gZGVjbHMuZmlsdGVyKChzKTogcyBpcyBTcGFuID0+IHMgaW5zdGFuY2VvZiBTcGFuKTtcblx0XHRcdGNvbnN0IGFuY2hvcnMgPSBkZWNscy5maWx0ZXIoKGEpOiBhIGlzIEluZml4U3BhbiA9PiBhIGluc3RhbmNlb2YgSW5maXhTcGFuKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3BhbnNUZXh0ID0gc3BhbnMubWFwKHMgPT4gU3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwocykpLmpvaW4oXCIsIFwiKTtcblx0XHRcdGNvbnN0IGFuY2hvclRleHQgPSBhbmNob3JzLm1hcChhID0+IFN1YmplY3RTZXJpYWxpemVyLmZvckludGVybmFsKGEpKS5qb2luKFwiLCBcIik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG9iID0gdGhpcy5vdXRib3VuZHMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgaWIgPSB0aGlzLmluYm91bmRzLnNpemU7XG5cdFx0XHRjb25zdCBwYXRoID0gaW5jbHVkZVBhdGggPyB0aGlzLnVyaS50eXBlcy5qb2luKFwiL1wiKSArIFwiIFwiIDogXCJcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc2ltcGxlID0gW1xuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRzcGFuc1RleHQubGVuZ3RoID8gXCJzcGFucz1cIiArIHNwYW5zVGV4dCA6IFwiXCIsXG5cdFx0XHRcdGFuY2hvclRleHQubGVuZ3RoID8gXCJhbmNob3I9XCIgKyBhbmNob3JUZXh0IDogXCJcIixcblx0XHRcdFx0XCJvdXQ9XCIgKyBvYixcblx0XHRcdFx0XCJpbj1cIiArIGliXG5cdFx0XHRdLmZpbHRlcihzID0+IHMudHJpbSgpKS5qb2luKFwiLCBcIik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZtdCA9IChzdHI6IHN0cmluZykgPT4gc3RyLnNwbGl0KFwiXFxuXCIpLm1hcChzID0+IFwiXFx0XFx0XCIgKyBzKS5qb2luKFwiXFxuXCIpO1xuXHRcdFx0Y29uc3Qgb2JzVmVyYm9zZSA9IHRoaXMub3V0Ym91bmRzXG5cdFx0XHRcdC5tYXAob2IgPT4gZm10KG9iLnRvU3RyaW5nKCkpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWJzVmVyYm9zZSA9IEFycmF5LmZyb20odGhpcy5pbmJvdW5kcy52YWx1ZXMoKSlcblx0XHRcdFx0Lm1hcChpYiA9PiBmbXQoaWIudG9TdHJpbmcoKSkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCB2ZXJib3NlID0gXG5cdFx0XHRcdFwiXFxuXFx0T3V0czpcXG5cIiArIG9ic1ZlcmJvc2Uuam9pbihcIlxcblxcblwiKSArXG5cdFx0XHRcdFwiXFxuXFx0SW5zOlxcblwiICsgaWJzVmVyYm9zZS5qb2luKFwiXFxuXFxuXCIpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2ltcGxlICsgdmVyYm9zZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBhZGRSb290Tm9kZShub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGV4aXN0aW5nU2V0ID0gTm9kZS5yb290Tm9kZXMuZ2V0KG5vZGUuZG9jdW1lbnQpO1xuXHRcdFx0aWYgKGV4aXN0aW5nU2V0KVxuXHRcdFx0e1xuXHRcdFx0XHRleGlzdGluZ1NldC5zZXQobm9kZS5uYW1lLCBub2RlKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbWFwID0gbmV3IE1hcDxzdHJpbmcsIE5vZGU+KCk7XG5cdFx0XHRcdG1hcC5zZXQobm9kZS5uYW1lLCBub2RlKTtcblx0XHRcdFx0Tm9kZS5yb290Tm9kZXMuc2V0KG5vZGUuZG9jdW1lbnQsIG1hcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVtb3ZlUm9vdE5vZGUobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCBleGlzdGluZ1NldCA9IE5vZGUucm9vdE5vZGVzLmdldChub2RlLmRvY3VtZW50KTtcblx0XHRcdGlmIChleGlzdGluZ1NldClcblx0XHRcdHtcblx0XHRcdFx0ZXhpc3RpbmdTZXQuZGVsZXRlKG5vZGUubmFtZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGlzIGlzIHNvbWV3aGF0IHJlZHVuZGFudCBhcyB0aGUgc2V0XG5cdFx0XHRcdC8vIGlzIGxpa2VseSBnb2luZyB0byBiZSBHQydkIGF3YXkgYW55d2F5IGluXG5cdFx0XHRcdC8vIHRoaXMgY2FzZS4gSXQncyBoZXJlIGZvciBjb21wbGV0ZW5lc3Mgc2FrZS5cblx0XHRcdFx0aWYgKGV4aXN0aW5nU2V0LnNpemUgPT09IDApXG5cdFx0XHRcdFx0Tm9kZS5yb290Tm9kZXMuZGVsZXRlKG5vZGUuZG9jdW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGdldFJvb3ROb2Rlcyhmcm9tRG9jdW1lbnQ/OiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCBmcm9tRG9jID0gZnJvbURvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQ7XG5cdFx0XHRjb25zdCBvdXQgPSBOb2RlLnJvb3ROb2Rlcy5nZXQoZnJvbURvYykgfHwgbmV3IE1hcDxzdHJpbmcsIE5vZGU+KCk7XG5cdFx0XHRyZXR1cm4gSGlnaGVyT3JkZXIuY29weShvdXQpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyByb290Tm9kZXMgPSBuZXcgV2Vha01hcDxEb2N1bWVudCwgTWFwPHN0cmluZywgTm9kZT4+KCk7XG5cdH1cblxuXHR0eXBlIE5vZGVNYXAgPSBSZWFkb25seU1hcDxzdHJpbmcsIE5vZGU+O1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIE5vZGVJbmRleFxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IocHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHRwcm9ncmFtLm9uKENhdXNlRG9jdW1lbnRVcmlDaGFuZ2UsIGRhdGEgPT5cblx0XHRcdHtcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBlbnRpcmUgY2FjaGUgd2hlbiB0aGUgVVJJIG9mIGFueSBkb2N1bWVudCBjaGFuZ2VzLlxuXHRcdFx0XHRjb25zdCBuZXdVcmlTdG9yZSA9IGRhdGEubmV3VXJpLnJldHJhY3RUeXBlVG8oMCk7XG5cdFx0XHRcdGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMudXJpVG9Ob2RlTWFwLmVudHJpZXMoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IFtvbGRVcmlUZXh0LCBub2RlXSBvZiBlbnRyaWVzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKG5vZGUuZG9jdW1lbnQgIT09IGRhdGEuZG9jdW1lbnQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBvbGRVcmkgPSBOb3QubnVsbChVcmkudHJ5UGFyc2Uob2xkVXJpVGV4dCkpO1xuXHRcdFx0XHRcdGNvbnN0IG5ld1VyaVRleHQgPSBuZXdVcmlTdG9yZVxuXHRcdFx0XHRcdFx0LmV4dGVuZFR5cGUob2xkVXJpLnR5cGVzLm1hcCh0ID0+IHQudmFsdWUpKVxuXHRcdFx0XHRcdFx0LnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy51cmlUb05vZGVNYXAuZGVsZXRlKG9sZFVyaVRleHQpO1xuXHRcdFx0XHRcdHRoaXMudXJpVG9Ob2RlTWFwLnNldChuZXdVcmlUZXh0LCBub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVudW1lcmF0ZXMgdGhyb3VnaCBhbGwgTm9kZSBpbnN0YW5jZXMgc3RvcmVkXG5cdFx0ICogaW4gdGhlIGluZGV4LlxuXHRcdCAqL1xuXHRcdCplYWNoTm9kZSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBub2RlIG9mIHRoaXMudXJpVG9Ob2RlTWFwLnZhbHVlcygpKVxuXHRcdFx0XHR5aWVsZCBub2RlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBudW1iZXIgb2Ygbm9kZXMgc3RvcmVkIGluIHRoZSBpbmRleC5cblx0XHQgKi9cblx0XHRnZXQgY291bnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnVyaVRvTm9kZU1hcC5zaXplO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBpbmRleCwgZXN0YWJsaXNoaW5nIGEgY2FjaGVkIHJlbGF0aW9uc2hpcFxuXHRcdCAqIGJldHdlZW4gdGhlIHNwZWNpZmllZCB1cmkgYW5kIHRoZSBzcGVjaWZpZWQgbm9kZS5cblx0XHQgKi9cblx0XHRzZXQodXJpOiBVcmkgfCBzdHJpbmcsIG5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpVGV4dCA9IHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIgPyB1cmkgOiB1cmkudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMudXJpVG9Ob2RlTWFwLnNldCh1cmlUZXh0LCBub2RlKTtcblx0XHRcdHRoaXMudXBkYXRlKG5vZGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogXG5cdFx0ICogVXBkYXRlcyB0aGUgaW5kZXggYnkgcmVmcmVzaGluZyBpbiB0aGUgc2V0IG9mIGlkZW50aWZpZXJzXG5cdFx0ICogdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgbm9kZS5cblx0XHQgKi9cblx0XHR1cGRhdGUobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHRjb25zdCBwYXN0SWRlbnRpZmllcnMgPSB0aGlzLm5vZGVzVG9JZGVudGlmaWVyc01hcC5nZXQobm9kZSk7XG5cdFx0XHRjb25zdCBwcmVzZW50SWRlbnRpZmllcnMgPSB0aGlzLmdldEFzc29jaWF0ZWRJZGVudGlmaWVycyhub2RlKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhc3RJZGVudGlmaWVycyAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtpZHgsIGlkZW50XSBvZiBwYXN0SWRlbnRpZmllcnMuZW50cmllcygpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHByZXNlbnRJZGVudGlmaWVycy5pbmNsdWRlcyhpZGVudCkpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwYXN0SWRlbnRpZmllcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgbWFwID0gdGhpcy5pZGVudGlmaWVyVG9Ob2Rlc01hcC5nZXQoaWRlbnQpO1xuXHRcdFx0XHRcdGlmIChtYXAgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG1hcC5kZWxldGUobm9kZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1hcC5zaXplID09PSAwKVxuXHRcdFx0XHRcdFx0dGhpcy5pZGVudGlmaWVyVG9Ob2Rlc01hcC5kZWxldGUoaWRlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaWRlbnRpZmllciBvZiBwcmVzZW50SWRlbnRpZmllcnMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5vZGVzRm9ySWRlbnQgPSB0aGlzLmlkZW50aWZpZXJUb05vZGVzTWFwLmdldChpZGVudGlmaWVyKSB8fCAoKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IG91dCA9IG5ldyBTZXQ8Tm9kZT4oKTtcblx0XHRcdFx0XHR0aGlzLmlkZW50aWZpZXJUb05vZGVzTWFwLnNldChpZGVudGlmaWVyLCBvdXQpO1xuXHRcdFx0XHRcdHJldHVybiBvdXQ7XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRub2Rlc0ZvcklkZW50LmFkZChub2RlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5ub2Rlc1RvSWRlbnRpZmllcnNNYXAuc2V0KG5vZGUsIHByZXNlbnRJZGVudGlmaWVycyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldE5vZGVCeVVyaSh1cmk6IFVyaSB8IHN0cmluZylcblx0XHR7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIiA/IHVyaSA6IHVyaS50b1N0cmluZygpO1xuXHRcdFx0cmV0dXJuIHRoaXMudXJpVG9Ob2RlTWFwLmdldCh1cmlUZXh0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgbm9kZXMgdGhhdCBhcmUgYXNzb2NpYXRlZFxuXHRcdCAqIHdpdGggdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyIHRoYXQgZXhpc3QgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZFxuXHRcdCAqIGRlcHRoLiBcIkFzc29jaWF0ZWRcIiBtZWFucyB0aGF0IHRoZSBpZGVudGlmaWVyIGlzIGVpdGhlciBlcXVpdmFsZW50XG5cdFx0ICogdG8gdGhlIE5vZGUncyBtYWluIHN1YmplY3QsIG9yIGl0IGlzIHJlZmVyZW5jZWQgaW4gb25lIG9mIGl0J3MgZWRnZXMuXG5cdFx0ICovXG5cdFx0Z2V0Tm9kZXNCeUlkZW50aWZpZXIoaWRlbnRpZmVyOiBzdHJpbmcpXG5cdFx0e1xuXHRcdFx0Y29uc3Qgb3V0ID0gdGhpcy5pZGVudGlmaWVyVG9Ob2Rlc01hcC5nZXQoaWRlbnRpZmVyKTtcblx0XHRcdHJldHVybiBvdXQgPyBBcnJheS5mcm9tKG91dCkgOiBbXTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIG5vZGUgZnJvbSB0aGUgaW5kZXgsIGlmIGl0IGV4aXN0cy5cblx0XHQgKi9cblx0XHRkZWxldGUoZGVhZE5vZGU6IE5vZGUpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBbdXJpLCBub2RlXSBvZiB0aGlzLnVyaVRvTm9kZU1hcClcblx0XHRcdFx0aWYgKG5vZGUgPT09IGRlYWROb2RlKVxuXHRcdFx0XHRcdHRoaXMudXJpVG9Ob2RlTWFwLmRlbGV0ZSh1cmkpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBleGlzdGluZ0lkZW50aWZpZXJzID0gdGhpcy5ub2Rlc1RvSWRlbnRpZmllcnNNYXAuZ2V0KGRlYWROb2RlKTtcblx0XHRcdGlmIChleGlzdGluZ0lkZW50aWZpZXJzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBpZGVudGlmaWVyIG9mIGV4aXN0aW5nSWRlbnRpZmllcnMpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG5vZGVzID0gdGhpcy5pZGVudGlmaWVyVG9Ob2Rlc01hcC5nZXQoaWRlbnRpZmllcik7XG5cdFx0XHRcdGlmIChub2RlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZXMuZGVsZXRlKGRlYWROb2RlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChub2Rlcy5zaXplID09PSAwKVxuXHRcdFx0XHRcdHRoaXMuaWRlbnRpZmllclRvTm9kZXNNYXAuZGVsZXRlKGlkZW50aWZpZXIpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLm5vZGVzVG9JZGVudGlmaWVyc01hcC5kZWxldGUoZGVhZE5vZGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogXG5cdFx0ICogQHJldHVybnMgQW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgaWRlbnRpZmllcnMgYXNzb2NpYXRlZCB3aXRoXG5cdFx0ICogdGhlIHNwZWNpZmllZCBOb2RlLlxuXHRcdCAqL1xuXHRcdGdldEFzc29jaWF0ZWRJZGVudGlmaWVycyhub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGNvbnN0IGlkZW50aWZpZXJzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcilcblx0XHRcdFx0aWRlbnRpZmllcnMucHVzaChub2RlLnN1YmplY3QudHlwZU5hbWUpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHNtdCBvZiBub2RlLnN0YXRlbWVudHMpXG5cdFx0XHRcdGZvciAoY29uc3QgYW5ubyBvZiBzbXQuYWxsQW5ub3RhdGlvbnMpXG5cdFx0XHRcdFx0aWYgKGFubm8uYm91bmRhcnkuc3ViamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIpXG5cdFx0XHRcdFx0XHRpZGVudGlmaWVycy5wdXNoKGFubm8uYm91bmRhcnkuc3ViamVjdC50eXBlTmFtZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBpZGVudGlmaWVycztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIG9mIGFsbCBub2RlcyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQgaW50byB0aGUgcHJvZ3JhbSxcblx0XHQgKiBpbmRleGVkIGJ5IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0J3MgVVJJLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgdXJpVG9Ob2RlTWFwID0gbmV3IE1hcDxzdHJpbmcsIE5vZGU+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgbWFwIHdoaWNoIGlzIGluZGV4ZWQgYnkgYSB1bmlxdWUgaWRlbnRpZmllciwgYW5kIHdoaWNoIGFzXG5cdFx0ICogdmFsdWVzIHRoYXQgYXJlIHRoZSBub2RlcyB0aGF0IHVzZSB0aGF0IGlkZW50aWZpZXIsIGVpdGhlciBhcyBhIGRlY2xhcmF0aW9uXG5cdFx0ICogb3IgYW4gYW5ub3RhdGlvbi5cblx0XHQgKiBcblx0XHQgKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNhY2hlIGlzIHRvIGdldCBhIHF1aWNrIGFuc3dlciB0byB0aGUgcXVlc3Rpb246XG5cdFx0ICogXCJXZSBhZGRlZCBhIG5ldyBpZGVudGlmaWVyIGF0IHBvc2l0aW9uIFggLi4uIHdoYXQgbm9kZXMgbWlnaHQgcG9zc2libHlcblx0XHQgKiBoYXZlIGJlZW4gYWZmZWN0ZWQgYnkgdGhpcz9cIlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgaWRlbnRpZmllclRvTm9kZXNNYXAgPSBuZXcgTWFwPHN0cmluZywgU2V0PE5vZGU+PigpO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCB3aGljaCBpcyBlc3NlbnRpYWxseSBhIHJldmVyc2Ugb2YgaWRlbnRpZmllclRvTm9kZXNNYXAuXG5cdFx0ICogVGhpcyBpcyBzbyB0aGF0IHdoZW4gbm9kZXMgbmVlZCB0byBiZSBkZWxldGVkIG9yIHVwZGF0ZWQsIHdlIGNhblxuXHRcdCAqIHF1aWNrbHkgZmluZCB0aGUgcGxhY2UgaW4gaWRlbnRpZmllclRvTm9kZXNNYXAgd2hlcmUgdGhlIG5vZGUgaGFzXG5cdFx0ICogYmVlbiByZWZlcmVuY2VkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgbm9kZXNUb0lkZW50aWZpZXJzTWFwID0gbmV3IFdlYWtNYXA8Tm9kZSwgc3RyaW5nW10+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2VyaWFsaXplcyB0aGUgaW5kZXggaW50byBhIGZvcm1hdCBzdWl0YWJsZVxuXHRcdCAqIGZvciBkZWJ1Z2dpbmcgYW5kIGNvbXBhcmluZyBhZ2FpbnN0IGJhc2VsaW5lcy5cblx0XHQgKi9cblx0XHR0b1N0cmluZygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMudXJpVG9Ob2RlTWFwLnNpemUgPT09IDApXG5cdFx0XHRcdHJldHVybiBcIihlbXB0eSlcIjtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0Y29uc3Qga2V5cyA9IEFycmF5LmZyb20odGhpcy51cmlUb05vZGVNYXAua2V5cygpKS5tYXAocyA9PlxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB1cmkgPSBVcmkudHJ5UGFyc2Uocyk7XG5cdFx0XHRcdHJldHVybiB1cmkgPyB1cmkudG9TdHJpbmcoKSA6IHM7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnVyaVRvTm9kZU1hcC52YWx1ZXMoKSk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwga2V5cy5sZW5ndGg7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXS50b1N0cmluZyhmYWxzZSk7XG5cdFx0XHRcdG91dC5wdXNoKGAke2tleX1cXG5cXHQke3ZhbHVlfVxcbmApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRvdXQucHVzaChcIihJZGVudGlmaWVyIENhY2hlKVwiKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBbaWRlbnRpZmllciwgbm9kZXNdIG9mIHRoaXMuaWRlbnRpZmllclRvTm9kZXNNYXApXG5cdFx0XHR7XG5cdFx0XHRcdG91dC5wdXNoKFwiXFx0XCIgKyBpZGVudGlmaWVyKTtcblx0XHRcdFx0b3V0LnB1c2goXCJcXHRcXHQ6IFwiICsgQXJyYXkuZnJvbShub2Rlcylcblx0XHRcdFx0XHQubWFwKG5vZGUgPT4gbm9kZS51cmkudG9UeXBlU3RyaW5nKCkpXG5cdFx0XHRcdFx0LmpvaW4oXCIsIFwiKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBvdXQuam9pbihcIlxcblwiKS50cmltKCk7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBIeXBlckVkZ2UgY29ubmVjdHMgYW4gb3JpZ2luIHByZWRlY2Vzc29yIE5vZGUgdG8gYSBzZXJpZXMgb2Zcblx0ICogc3VjY2Vzc29yIE5vZGVzLiBGcm9tIGdyYXBoIHRoZW9yeSwgYSBcImh5cGVyIGVkZ2VcIiBpcyBkaWZmZXJlbnRcblx0ICogZnJvbSBhbiBcImVkZ2VcIiBpbiB0aGF0IGl0IGNhbiBoYXZlIG1hbnkgc3VjY2Vzc29yczpcblx0ICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSHlwZXJncmFwaFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIEh5cGVyRWRnZVxuXHR7XG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBOb2RlIGZyb20gd2hlcmUgdGhlIEh5cGVyRWRnZSBjb25uZWN0aW9uIGJlZ2lucy5cblx0XHRcdCAqIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZm9sbG93aW5nIGRvY3VtZW50OlxuXHRcdFx0ICogXG5cdFx0XHQgKiBGb29cblx0XHRcdCAqIFx0QmFyIDogRm9vXG5cdFx0XHQgKiBcblx0XHRcdCAqIFR3byBOb2RlIG9iamVjdHMgd291bGQgYmUgY3JlYXRlZCwgb25lIGZvciB0aGUgZmlyc3QgaW5zdGFuY2Vcblx0XHRcdCAqIG9mIFwiRm9vXCIsIGFuZCBhbm90aGVyIGZvciB0aGUgaW5zdGFuY2Ugb2YgXCJCYXJcIi4gQSBIeXBlckVkZ2Vcblx0XHRcdCAqIHdvdWxkIGJlIGNyZWF0ZWQgYmV0d2VlbiBcIkJhclwiIGFuZCBcIkZvb1wiLCBhbmQgaXQnc1xuXHRcdFx0ICogcHJlY2VkZXNzb3Igd291bGQgcmVmZXIgdG8gdGhlIE5vZGUgcmVwcmVzZW50aW5nIHRoZVxuXHRcdFx0ICogb2NjdXJlbmNlIG9mIFwiQmFyXCIuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IHByZWRlY2Vzc29yOiBOb2RlLFxuXHRcdFx0c291cmNlOiBTcGFuIHwgSW5maXhTcGFuLFxuXHRcdFx0c3VjY2Vzc29yczogcmVhZG9ubHkgU3VjY2Vzc29yW10pXG5cdFx0e1xuXHRcdFx0aWYgKCEoc291cmNlLmJvdW5kYXJ5LnN1YmplY3QgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdWNjZXNzb3JOb2RlcyA9IHN1Y2Nlc3NvcnNcblx0XHRcdFx0Lm1hcChzY3NyID0+IHNjc3Iubm9kZSlcblx0XHRcdFx0LmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTtcblx0XHRcdFxuXHRcdFx0aWYgKHN1Y2Nlc3Nvck5vZGVzLmxlbmd0aCAhPT0gc3VjY2Vzc29ycy5sZW5ndGgpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5pZGVudGlmaWVyID0gc291cmNlLmJvdW5kYXJ5LnN1YmplY3Q7XG5cdFx0XHR0aGlzLmZyYWdtZW50c011dGFibGUgPSBbc291cmNlXTtcblx0XHRcdHRoaXMuc3VjY2Vzc29yc011dGFibGUgPSBzdWNjZXNzb3JzLnNsaWNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIGFkZCBhbm90aGVyIGZyYWdtZW50IHRvIHRoZSBIeXBlckVkZ2UuXG5cdFx0ICogUmVwb3J0cyBhIGZhdWx0IGluc3RlYWQgaW4gdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIFxuXHRcdCAqIGxpc3QgY29uZmxpY3QgYmV0d2VlbiB0aGUgc291cmNlIHByb3ZpZGVkIGFuZCB0aGVcblx0XHQgKiBleGlzdGluZyBzb3VyY2VzLiAoSS5lLiBvbmUgb2YgdGhlIHNvdXJjZXMgaXMgZGVmaW5lZFxuXHRcdCAqIGFzIGEgbGlzdCwgYW5kIGFub3RoZXIgaXMgbm90KS5cblx0XHQgKi9cblx0XHRhZGRGcmFnbWVudChmcmFnbWVudDogU3BhbiB8IEluZml4U3Bhbilcblx0XHR7XG5cdFx0XHQvLy9jb25zdCBpc1BhdHRlcm4gPSB0aGlzLnByZWRlY2Vzc29yLnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuO1xuXHRcdFx0Ly8vY29uc3QgaXNJbmZpeCA9IHNvdXJjZSBpbnN0YW5jZW9mIEluZml4U3Bhbjtcblx0XHRcdC8vL2lmIChpc1BhdHRlcm4gIT09IGlzSW5maXgpXG5cdFx0XHQvLy9cdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQ2FsbCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5mcmFnbWVudHNNdXRhYmxlLmluY2x1ZGVzKGZyYWdtZW50KSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XG5cdFx0XHQvLyEgVGhlIG9yZGVyaW5nIG9mIHRoZSBzb3VyY2VzIGlzIG5vdCBiZWluZyBoYW5kbGVkIGhlcmUuXG5cdFx0XHRcblx0XHRcdHRoaXMuZnJhZ21lbnRzTXV0YWJsZS5wdXNoKGZyYWdtZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGFubm90YXRpb24tc2lkZSBTcGFuIG9yIEluZml4U3BhblxuXHRcdCAqIGZyb20gdGhpcyBlZGdlLlxuXHRcdCAqL1xuXHRcdHJlbW92ZUZyYWdtZW50KGZyYWdtZW50OiBTcGFuIHwgSW5maXhTcGFuKVxuXHRcdHtcblx0XHRcdGNvbnN0IGZyYWdQb3MgPSB0aGlzLmZyYWdtZW50c011dGFibGUuaW5kZXhPZihmcmFnbWVudCk7XG5cdFx0XHRpZiAoZnJhZ1BvcyA+PSAwKVxuXHRcdFx0XHR0aGlzLmZyYWdtZW50c011dGFibGUuc3BsaWNlKGZyYWdQb3MsIDEpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRjbGVhckZyYWdtZW50cygpXG5cdFx0e1xuXHRcdFx0dGhpcy5mcmFnbWVudHNNdXRhYmxlLmxlbmd0aCA9IDA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIHNldCBvZiBhbm5vdGF0aW9uLXNpZGUgU3BhbnMgb3IgYW5ub3RhdGlvbi1zaWRlXG5cdFx0ICogSW5maXhTcGFucyB0aGF0IGFyZSByZXNwb25zaWJsZSBmb3IgdGhlIGNvbmNlcHRpb24gb2YgdGhpc1xuXHRcdCAqIEh5cGVyRWRnZS5cblx0XHQgKiBcblx0XHQgKiBUaGUgYXJyYXkgY29udGFpbnMgZWl0aGVyIFNwYW4gaW5zdGFuY2VzIG9yIEluZml4U3BhbiBpbnN0YW5jZXMsXG5cdFx0ICogYnV0IG5ldmVyIGJvdGguIEluIHRoZSBjYXNlIHdoZW4gdGhlIGFycmF5IHN0b3JlcyBTcGFuIGluc3RhbmNlcyxcblx0XHQgKiB0aGUgbG9jYXRpb24gb2YgdGhvc2UgU3BhbnMgYXJlIHBvdGVudGlhbGx5IHNjYXR0ZXJlZCBhY3Jvc3MgbWFueVxuXHRcdCAqIHN0YXRlbWVudHMuXG5cdFx0ICovXG5cdFx0Z2V0IGZyYWdtZW50cygpOiByZWFkb25seSAoU3BhbiB8IEluZml4U3BhbilbXVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50c011dGFibGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZnJhZ21lbnRzTXV0YWJsZTogKFNwYW4gfCBJbmZpeFNwYW4pW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0YWRkU3VjY2Vzc29yKG5vZGU6IE5vZGUsIGxvbmdpdHVkZTogbnVtYmVyKVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5zdWNjZXNzb3JzTXV0YWJsZS5maW5kKHNjc3IgPT4gc2Nzci5ub2RlID09PSBub2RlKSlcblx0XHRcdFx0dGhpcy5zdWNjZXNzb3JzTXV0YWJsZS5wdXNoKG5ldyBTdWNjZXNzb3Iobm9kZSwgbG9uZ2l0dWRlKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHJlbW92ZVN1Y2Nlc3Nvcihub2RlOiBOb2RlKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLnN1Y2Nlc3NvcnNNdXRhYmxlLmxlbmd0aDsgaS0tID4gMDspXG5cdFx0XHRcdGlmICh0aGlzLnN1Y2Nlc3NvcnNNdXRhYmxlW2ldLm5vZGUgPT09IG5vZGUpXG5cdFx0XHRcdFx0dGhpcy5zdWNjZXNzb3JzTXV0YWJsZS5zcGxpY2UoaSwgMSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhbGwgcG9zc2libGUgc3VjY2VzcyBOb2RlcyB0byB3aGljaCB0aGUgcHJlZGVjZXNzb3IgXG5cdFx0ICogTm9kZSBpcyBwcmVlbXB0aXZlbHkgY29ubmVjdGVkIHZpYSB0aGlzIEh5cGVyRWRnZS4gVGhlIFxuXHRcdCAqIGNvbm5lY3Rpb24gaXMgc2FpZCB0byBiZSBwcmVlbXB0aXZlLCBiZWNhdXNlIHRoZSBjb25uZWN0aW9uXG5cdFx0ICogbWlnaHQgYmUgaWdub3JlZCBkdXJpbmcgcG9seW1vcnBoaWMgbmFtZSByZXNvbHV0aW9uLlxuXHRcdCAqL1xuXHRcdGdldCBzdWNjZXNzb3JzKCk6IHJlYWRvbmx5IFN1Y2Nlc3NvcltdXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuc3VjY2Vzc29yc011dGFibGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgc3VjY2Vzc29yc011dGFibGU6IFN1Y2Nlc3NvcltdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgd2hldGhlciB0aGlzIEh5cGVyRWRnZSBoYXMgbm8gaW1tZWRpYXRlbHkgcmVzb2x2YWJsZVxuXHRcdCAqIHN1Y2Nlc3NvcnMuIFRoaXMgbWVhbnMgdGhhdCB0aGUgc3ViamVjdCBiZWluZyByZWZlcnJlZCB0byBieVxuXHRcdCAqIHRoaXMgSHlwZXJFZGdlIGlzIGVpdGhlciBhIHR5cGUgYWxpYXMgd2hpY2ggd2lsbCBiZSBtYXRjaGVkIGJ5XG5cdFx0ICogYSBwYXR0ZXJuLCBvciBqdXN0IGEgcGxhaW4gb2xkIGZhdWx0LlxuXHRcdCAqL1xuXHRcdGdldCBpc0RhbmdsaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdWNjZXNzb3JzLmxlbmd0aCA9PT0gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNvdXJjZXMgb2YgdGhlIGVkZ2Vcblx0XHQgKiBjYXVzZXMgaW5jcmVtZW50YXRpb24gb2YgdGhlIGxpc3QgZGltZW5zaW9uYWxpdHkgb2YgdGhlIHR5cGVcblx0XHQgKiB0aGF0IGNvcnJlc3Bvbm5kcyB0byB0aGlzIEh5cGVyRWRnZSdzIHByZWRlY2Vzc29yIE5vZGUuXG5cdFx0ICogXG5cdFx0ICogKE5vdGUgdGhhdCBhbGwgc291cmNlcyBuZWVkIHRvIGFncmVlIG9uIHRoaXMgdmFsdWUsIGFuZCB0aGUgXG5cdFx0ICogbmVjZXNzYXJ5IGZhdWx0cyBhcmUgZ2VuZXJhdGVkIHRvIGVuc3VyZSB0aGF0IHRoaXMgaXMgYWx3YXlzXG5cdFx0ICogdGhlIGNhc2UuKVxuXHRcdCAqL1xuXHRcdGdldCBpc0xpc3QoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIHRoaXMuZnJhZ21lbnRzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzdWIgPSBzb3VyY2UuYm91bmRhcnkuc3ViamVjdDtcblx0XHRcdFx0cmV0dXJuIHN1YiBpbnN0YW5jZW9mIElkZW50aWZpZXIgJiYgc3ViLmlzTGlzdDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dHVhbCB2YWx1ZSBvZiBhbiBFZGdlIHJlcHJlc2VudHMgZGlmZmVyZW50IHRoaW5nc1xuXHRcdCAqIGRlcGVuZGluZyBvbiB0aGUgRWRnZSdzICpraW5kKiBwcm9wZXJ0eS5cblx0XHQgKiBcblx0XHQgKiBJZiAqa2luZCogaXMgKmxpdGVyYWwqLCB0aGUgdGV4dHVhbCB2YWx1ZSBpcyB0aGUgZ2l2ZW4gbmFtZVxuXHRcdCAqIG9mIHRoZSB0eXBlIGJlaW5nIHJlZmVyZW5jZWQsIGZvciBleGFtcGxlIFwiU3RyaW5nXCIgb3Jcblx0XHQgKiBcIkVtcGxveWVlXCIuXG5cdFx0ICogXG5cdFx0ICogSWYgKmtpbmQqIGlzICpjYXRlZ29yaWNhbCosIHRoZSB0ZXh0dWFsIHZhbHVlIGlzIGFuIGFsaWFzIHRoYXRcblx0XHQgKiB3aWxsIGxhdGVyIGJlIHJlc29sdmVkIHRvIGEgc3BlY2lmaWMgdHlwZSwgb3Igc2V0IG9mIHR5cGVzLCBmb3Jcblx0XHQgKiBleGFtcGxlIFwiMTBjbVwiIChwcmVzdW1hYmx5IHJlc29sdmluZyB0byBcIlVuaXRcIikgb3Jcblx0XHQgKiBcInVzZXJAZW1haWwuY29tXCIgKHByZXN1bWFibGUgcmVzb2x2aW5nIHRvIFwiRW1haWxcIikuXG5cdFx0ICogXG5cdFx0ICogSWYgKmtpbmQqIGlzICpzdW1tYXRpb24qICwgdGhlIHRleHR1YWwgdmFsdWUgaXMgdGhlIHJhd1xuXHRcdCAqIGxpdGVyYWwgdGV4dCBvZiB0aGUgYW5ub3RhdGlvbiBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuIEZvclxuXHRcdCAqIGV4YW1wbGUsIGlmIHRoZSBkb2N1bWVudCBoYWQgdGhlIGNvbnRlbnQ6XG5cdFx0ICogXG5cdFx0ICogRm9vLCBCYXIgOiBmb28sIGJhclxuXHRcdCAqIFxuXHRcdCAqIFRoaXMgd291bGQgcmVzdWx0IGluIHR3byBub2RlcyBuYW1lZCBcIkZvb1wiIGFuZCBcIkJhclwiLFxuXHRcdCAqIGVhY2ggd2l0aCB0aGVpciBvd24gSHlwZXJFZGdlcyB3aG9zZSB0ZXh0dWFsIHZhbHVlc1xuXHRcdCAqIHdvdWxkIGJvdGggYmU6IFwiZm9vLCBiYXJcIi4gSW4gdGhlIGNhc2Ugb2YgYSBmcmFnbWVudGVkXG5cdFx0ICogdHlwZSwgdGhlIGxhc3Qgc3VtIGluIGRvY3VtZW50IG9yZGVyIGlzIGNvdW50ZWQgYXMgdGhlXG5cdFx0ICogdGV4dHVhbCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmdcblx0XHQgKiBkb2N1bWVudDpcblx0XHQgKiBcblx0XHQgKiBUIDogYWEsIGJiXG5cdFx0ICogVCA6IHh4LCB5eVxuXHRcdCAqIFxuXHRcdCAqIFRoZSBcIlRcIiBub2RlIHdvdWxkIGhhdmUgYSBIeXBlckVkZ2Ugd2l0aCBhIHRleHR1YWwgXG5cdFx0ICogdmFsdWUgYmVpbmcgXCJ4eCwgeXlcIi5cblx0XHQgKiBcblx0XHQgKiBUaGUgKi1vdmVybGF5IGtpbmRzIGhhdmUgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlkZW50aWZpZXI6IElkZW50aWZpZXI7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBzcGVjaWZpYyBwYXJ0IG9mIHRoZVxuXHRcdCAqIHByZWRlY2Vzc29yIHdoZXJlIHRoaXMgSHlwZXJFZGdlIGJlZ2lucy5cblx0XHQgKi9cblx0XHRnZXQgcHJlZGVjZXNzb3JPcmlnaW4oKTogSHlwZXJFZGdlT3JpZ2luXG5cdFx0e1xuXHRcdFx0Ly8hIElzIHRoaXMgc3RpbGwgbmVjZXNzYXJ5P1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5mcmFnbWVudHNNdXRhYmxlLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzcmMgPSB0aGlzLmZyYWdtZW50c011dGFibGVbMF07XG5cdFx0XHRpZiAoc3JjIGluc3RhbmNlb2YgU3Bhbilcblx0XHRcdFx0cmV0dXJuIEh5cGVyRWRnZU9yaWdpbi5zdGF0ZW1lbnQ7XG5cdFx0XHRcblx0XHRcdGlmIChzcmMuY29udGFpbmluZ0luZml4LmlzUG9ydGFiaWxpdHkpXG5cdFx0XHRcdHJldHVybiBIeXBlckVkZ2VPcmlnaW4ucG9ydGFiaWxpdHlJbmZpeDtcblx0XHRcdFxuXHRcdFx0aWYgKHNyYy5jb250YWluaW5nSW5maXguaXNQb3B1bGF0aW9uKVxuXHRcdFx0XHRyZXR1cm4gSHlwZXJFZGdlT3JpZ2luLnBvcHVsYXRpb25JbmZpeDtcblx0XHRcdFxuXHRcdFx0aWYgKHNyYy5jb250YWluaW5nSW5maXguaXNQYXR0ZXJuKVxuXHRcdFx0XHRyZXR1cm4gSHlwZXJFZGdlT3JpZ2luLnBhdHRlcm5JbmZpeDtcblx0XHRcdFxuXHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEh5cGVyRWRnZSxcblx0XHQgKiBzdWl0YWJsZSBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nIHB1cnBvc2VzLlxuXHRcdCAqL1xuXHRcdHRvU3RyaW5nKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcIlZhbHVlPVwiICsgdGhpcy5pZGVudGlmaWVyLFxuXHRcdFx0XHRcIlByZWRlY2Vzc29ycz1cIiArIHRoaXMucHJlZGVjZXNzb3IubmFtZSxcblx0XHRcdFx0XCJTdWNjZXNzb3JzPVwiICsgdGhpcy5zdWNjZXNzb3JzXG5cdFx0XHRcdFx0Lm1hcChuID0+IG4ubm9kZS5uYW1lICsgXCIgPDwgXCIgKyBuLmxvbmdpdHVkZSlcblx0XHRcdFx0XHQuam9pbihcIiwgXCIpLFxuXHRcdFx0XHRcIlNvdXJjZXM9XCIgKyBBcnJheS5mcm9tKHRoaXMuZnJhZ21lbnRzKVxuXHRcdFx0XHRcdC5tYXAoc3JjID0+IHNyYy5ib3VuZGFyeS5zdWJqZWN0KS5qb2luKFwiLCBcIiksXG5cdFx0XHRcdFwiLS0tXCJcblx0XHRcdF0uam9pbihcIlxcblwiKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBTdWNjZXNzb3Jcblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgbm9kZTogTm9kZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHRoZSBudW1iZXIgb2YgbGV2ZWxzIG9mIGRlcHRoIGluIHRoZSBjb250YWlubWVudFxuXHRcdFx0ICogaGllcmFyY2h5IHRoYXQgbmVlZCB0byBiZSBjcm9zc2VkIGluIG9yZGVyIGZvciB0aGUgY29udGFpbmluZ1xuXHRcdFx0ICogSHlwZXJFZGdlIHRvIGJlIGVzdGFibGlzaGVkIGJldHdlZW4gdGhlIHByZWRlY2Vzc29yIGFuZFxuXHRcdFx0ICogdGhpcyBzdWNjZXNzb3IuXG5cdFx0XHQgKi9cblx0XHRcdHJlYWRvbmx5IGxvbmdpdHVkZTogbnVtYmVyKVxuXHRcdHsgfVxuXHRcdFxuXHRcdHJlYWRvbmx5IHN0YW1wID0gVmVyc2lvblN0YW1wLm5leHQoKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgcGxhY2UgaW4gYSBzdGF0ZW1lbnQgd2hlcmUgYSBIeXBlckVkZ2Ugc3RhcnRzLlxuXHQgKiAoSHlwZXJFZGdlcyBjYW4gc3RhcnQgZWl0aGVyIGF0IHRoZSBzdGF0ZW1lbnQgbGV2ZWwsIG9yIHdpdGhpblxuXHQgKiB2YXJpb3VzIGtpbmRzIG9mIGluZml4ZXMuKVxuXHQgKi9cblx0ZXhwb3J0IGVudW0gSHlwZXJFZGdlT3JpZ2luXG5cdHtcblx0XHRzdGF0ZW1lbnQsXG5cdFx0cG9wdWxhdGlvbkluZml4LFxuXHRcdHBvcnRhYmlsaXR5SW5maXgsXG5cdFx0cGF0dGVybkluZml4XG5cdH1cbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHRoYXQgbWFya3Mgb3V0IHRoZSBsb2NhdGlvbiBvZiBhbiBpbmZpeCBJZGVudGlmZXIgd2l0aGluXG5cdCAqIGl0J3MgY29udGFpbmluZyBJbmZpeCwgaXQncyBjb250YWluaW5nIFNwYW4sIGFuZCB0aGVuIGl0J3MgY29udGFpbmluZ1xuXHQgKiBTdGF0ZW1lbnQsIERvY3VtZW50LCBhbmQgUHJvZ3JhbS5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBJbmZpeFNwYW5cblx0e1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgY29udGFpbmluZ1NwYW46IFNwYW4sXG5cdFx0XHRyZWFkb25seSBjb250YWluaW5nSW5maXg6IEluZml4LFxuXHRcdFx0cmVhZG9ubHkgYm91bmRhcnk6IEJvdW5kYXJ5PElkZW50aWZpZXI+KVxuXHRcdHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIFN0YXRlbWVudCB0aGF0IGNvbnRhaW5zIHRoaXMgQW5jaG9yLlxuXHRcdCAqL1xuXHRcdGdldCBzdGF0ZW1lbnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5pbmdTcGFuLnN0YXRlbWVudDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIEluZml4U3BhblxuXHRcdCAqIGlzIGNvbnNpZGVyZWQgb2JqZWN0LWxldmVsIGNydWZ0LCBhbmQgc2hvdWxkIHRoZXJlZm9yZSBiZVxuXHRcdCAqIGlnbm9yZWQgZHVyaW5nIHR5cGUgYW5hbHlzaXMuXG5cdFx0ICovXG5cdFx0Z2V0IGlzQ3J1ZnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5pbmdTcGFuLnN0YXRlbWVudC5jcnVmdE9iamVjdHMuaGFzKHRoaXMpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgd29ya2VyIGNsYXNzIHRoYXQgaGFuZGxlcyB0aGUgY29uc3RydWN0aW9uIG9mIG5ldHdvcmtzXG5cdCAqIG9mIFBhcmFsbGVsIGluc3RhbmNlcywgd2hpY2ggYXJlIGV2ZW50dWFsbHkgdHJhbnNmb3JtZWRcblx0ICogaW50byB0eXBlIG9iamVjdHMuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgQ29uc3RydWN0aW9uV29ya2VyXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pXG5cdFx0e1xuXHRcdFx0dGhpcy5jcnVmdCA9IG5ldyBDcnVmdENhY2hlKHRoaXMucHJvZ3JhbSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdHMgdGhlIGNvcnJlc3BvbmRpbmcgUGFyYWxsZWwgaW5zdGFuY2VzIGZvclxuXHRcdCAqIGFsbCBzcGVjaWZpZWQgdHlwZXMgdGhhdCBleGlzdCB3aXRoaW4gdGhlIHByb3ZpZGVkIERvY3VtZW50LFxuXHRcdCAqIG9yIGJlbG93IHRoZSBwcm92aWRlZCBTcGVjaWZpZWRQYXJhbGxlbC5cblx0XHQgKi9cblx0XHRleGNhdmF0ZShmcm9tOiBEb2N1bWVudCB8IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmV4Y2F2YXRlZC5oYXMoZnJvbSkpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XG5cdFx0XHR0aGlzLmV4Y2F2YXRlZC5hZGQoZnJvbSk7XG5cdFx0XHRjb25zdCBxdWV1ZTogU3BlY2lmaWVkUGFyYWxsZWxbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwcm9jZXNzTm9kZXMgPSAoaXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4pID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiBpdGVyYXRvcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGRyaWxsZWRQYXJhbGxlbCA9IHRoaXMuZHJpbGxGcm9tTm9kZShub2RlKTtcblx0XHRcdFx0XHRpZiAoZHJpbGxlZFBhcmFsbGVsICE9PSBudWxsKVxuXHRcdFx0XHRcdFx0cXVldWUucHVzaChkcmlsbGVkUGFyYWxsZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZnJvbSBpbnN0YW5jZW9mIERvY3VtZW50KVxuXHRcdFx0XHRwcm9jZXNzTm9kZXModGhpcy5wcm9ncmFtLmdyYXBoLnJlYWRSb290cyhmcm9tKSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHF1ZXVlLnB1c2goZnJvbSk7XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgY3VycmVudFBhcmFsbGVsIG9mIHF1ZXVlKVxuXHRcdFx0XHRwcm9jZXNzTm9kZXMoY3VycmVudFBhcmFsbGVsLm5vZGUuY29udGVudHMudmFsdWVzKCkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGV4Y2F2YXRlZCA9IG5ldyBXZWFrU2V0PFNwZWNpZmllZFBhcmFsbGVsIHwgRG9jdW1lbnQ+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ29uc3RydWN0cyB0aGUgZmV3ZXN0IHBvc3NpYmxlIFBhcmFsbGVsIGluc3RhbmNlc1xuXHRcdCAqIHRvIGFycml2ZSBhdCB0aGUgdHlwZSBzcGVjaWZpZWQgYnkgdGhlIGRpcmVjdGl2ZS5cblx0XHQgKi9cblx0XHRkcmlsbChkaXJlY3RpdmU6IFVyaSlcblx0XHR7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aGlzLmRyaWxsRnJvbVVyaShkaXJlY3RpdmUpO1xuXHRcdFx0dGhpcy5kcmlsbFF1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGRyaWxsRnJvbVVyaShkaXJlY3RpdmU6IFVyaSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wYXJhbGxlbHMuaGFzKGRpcmVjdGl2ZSkpXG5cdFx0XHRcdHJldHVybiBOb3QudW5kZWZpbmVkKHRoaXMucGFyYWxsZWxzLmdldChkaXJlY3RpdmUpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgdHlwZVBhdGggPSBkaXJlY3RpdmUudHlwZXMuc2xpY2UoKS5tYXAodCA9PiB0LnZhbHVlKTtcblx0XHRcdGlmICh0eXBlUGF0aC5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5pbnZhbGlkQXJndW1lbnQoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc291cmNlRG9jID0gdGhpcy5wcm9ncmFtLmRvY3VtZW50cy5nZXQoZGlyZWN0aXZlKTtcblx0XHRcdGlmIChzb3VyY2VEb2MgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5kb2N1bWVudE5vdExvYWRlZCgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzdXJmYWNlTm9kZSA9IHRoaXMucHJvZ3JhbS5ncmFwaC5yZWFkKFxuXHRcdFx0XHRzb3VyY2VEb2MsXG5cdFx0XHRcdHR5cGVQYXRoWzBdKTtcblx0XHRcdFxuXHRcdFx0aWYgKHN1cmZhY2VOb2RlID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFxuXHRcdFx0bGV0IHR5cGVJZHggPSAwO1xuXHRcdFx0bGV0IGxhc3RTZWVkID0gXG5cdFx0XHRcdHRoaXMucGFyYWxsZWxzLmdldChkaXJlY3RpdmUucmV0cmFjdFR5cGVUbygxKSkgfHxcblx0XHRcdFx0dGhpcy5yYWtlKHRoaXMucGFyYWxsZWxzLmNyZWF0ZShzdXJmYWNlTm9kZSwgdGhpcy5jcnVmdCkpO1xuXHRcdFx0XG5cdFx0XHQvLyBXZSBjYW4gcGFzcyBieSBhbnkgUGFyYWxsZWwgaW5zdGFuY2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG5cdFx0XHQvLyBiZWVuIGNvbnN0cnVjdGVkLiBUaGUgcmVhbCB3b3JrIGJlZ2lucyB3aGVuIHdlIGdldCB0b1xuXHRcdFx0Ly8gdGhlIGZpcnN0IHBvaW50IGluIHRoZSBVUkkgd2hlcmUgdGhlcmUgaXMgbm8gY29uc3RydWN0ZWRcblx0XHRcdC8vIFBhcmFsbGVsIGluc3RhbmNlLlxuXHRcdFx0Zm9yICg7Oylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdXJpID0gZGlyZWN0aXZlLnJldHJhY3RUeXBlVG8odHlwZUlkeCArIDEpO1xuXHRcdFx0XHRpZiAoIXRoaXMucGFyYWxsZWxzLmhhcyh1cmkpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0bGFzdFNlZWQgPSBOb3QudW5kZWZpbmVkKHRoaXMucGFyYWxsZWxzLmdldCh1cmkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgrK3R5cGVJZHggPj0gdHlwZVBhdGgubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBsYXN0U2VlZDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0ZG9cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdHlwZU5hbWUgPSB0eXBlUGF0aFt0eXBlSWR4XTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGRlc2NlbmRlZCA9IHRoaXMuZGVzY2VuZChsYXN0U2VlZCwgdHlwZU5hbWUpO1xuXHRcdFx0XHRpZiAoZGVzY2VuZGVkID09PSBudWxsKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0bGFzdFNlZWQgPSB0aGlzLnJha2UoZGVzY2VuZGVkKTtcblx0XHRcdH1cblx0XHRcdHdoaWxlICgrK3R5cGVJZHggPCB0eXBlUGF0aC5sZW5ndGgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGFzdFNlZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFuIGVudHJ5cG9pbnQgaW50byB0aGUgZHJpbGwgZnVuY3Rpb24gdGhhdCBvcGVyYXRlc1xuXHRcdCAqIG9uIGEgTm9kZSBpbnN0ZWFkIG9mIGEgVXJpLiBFc3NlbnRpYWxseSwgdGhpcyBtZXRob2Rcblx0XHQgKiBjYWxscyBcImRyaWxsRnJvbVVyaSgpXCIgc2FmZWx5IChtZWFuaW5nIHRoYXQgaXQgZGV0ZWN0c1xuXHRcdCAqIGNpcmN1bGFyIGludm9rYXRpb25zLCBhbmQgcmV0dXJucyBudWxsIGluIHRoZXNlIGNhc2VzKS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGRyaWxsRnJvbU5vZGUobm9kZTogTm9kZSlcblx0XHR7XG5cdFx0XHQvLyBDaXJjdWxhciBkcmlsbGluZyBpcyBvbmx5IGEgcHJvYmxlbSBpZiB3ZSdyZVxuXHRcdFx0Ly8gZHJpbGxpbmcgb24gdGhlIHNhbWUgbGV2ZWwuXG5cdFx0XHRjb25zdCBxID0gdGhpcy5kcmlsbFF1ZXVlO1xuXHRcdFx0XG5cdFx0XHRpZiAocS5sZW5ndGggPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdHEucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHFbMF0uY29udGFpbmVyID09PSBub2RlLmNvbnRhaW5lcilcblx0XHRcdHtcblx0XHRcdFx0aWYgKHEuaW5jbHVkZXMobm9kZSkpXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHEubGVuZ3RoID0gMDtcblx0XHRcdFx0cS5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBkcmlsbFJlc3VsdCA9IHRoaXMuZHJpbGxGcm9tVXJpKG5vZGUudXJpKTtcblx0XHRcdGlmIChkcmlsbFJlc3VsdCA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIShkcmlsbFJlc3VsdCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKSlcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZHJpbGxSZXN1bHQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBBIGNhbGwgcXVldWUgdXNlZCB0byBwcmV2ZW50IGNpcmN1bGFyIGRyaWxsaW5nLiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgZHJpbGxRdWV1ZTogTm9kZVtdID0gW107XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXCJSYWtpbmdcIiBhIFBhcmFsbGVsIGlzIHRoZSBwcm9jZXNzIG9mIGRlZXBseSB0cmF2ZXJzaW5nIGl0J3Ncblx0XHQgKiBQYXJhbGxlbCBHcmFwaCAoZGVwdGggZmlyc3QpLCBhbmQgZm9yIGVhY2ggdmlzaXRlZCBQYXJhbGxlbCxcblx0XHQgKiBkZWVwbHkgdHJhdmVyc2luZyBpdCdzIEJhc2UgR3JhcGggYXMgd2VsbCAoYWxzbyBkZXB0aCBmaXJzdCkuXG5cdFx0ICogVGhyb3VnaCB0aGlzIGRvdWJsZS10cmF2ZXJzYWwgcHJvY2VzcywgdGhlIFBhcmFsbGVsJ3MgZWRnZXNcblx0XHQgKiBhcmUgY29uc3RydWN0ZWQgaW50byBhIHRyYXZlcnNhYmxlIGdyYXBoLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmFrZShzZWVkOiBQYXJhbGxlbClcblx0XHR7XG5cdFx0XHQvLyBJZiB0aGUgc2VlZCdzIGNvbnRhaW5lciBpcyBudWxsLCB0aGlzIG1lYW5zIHRoYXQgdGhlIHNlZWRcblx0XHRcdC8vIGlzIHJvb3QtbGV2ZWwsIGFuZCBzbyBpdCBjYW5ub3QgaGF2ZSBhbnkgUGFyYWxsZWwgdHlwZXMuXG5cdFx0XHQvLyBJdCBtYXkgaG93ZXZlciBoYXZlIEJhc2UgdHlwZXMsIGFuZCB0aGVzZSBuZWVkIHRvIGJlXG5cdFx0XHQvLyBoYW5kbGVkLlxuXHRcdFx0aWYgKHNlZWQuY29udGFpbmVyID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIShzZWVkIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpKVxuXHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMucmFrZVNwZWNpZmllZFBhcmFsbGVsKHNlZWQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB0aGlzLnJha2VQYXJhbGxlbEdyYXBoKHNlZWQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VlZDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZGlncyB0aHJvdWdoIHRoZSBwYXJhbGxlbCBncmFwaCxcblx0XHQgKiBhbmQgcmFrZXMgYWxsIFNwZWNpZmllZFBhcmFsbGVscyB0aGF0IGFyZSBkaXNjb3ZlcmVkLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmFrZVBhcmFsbGVsR3JhcGgocGFyOiBQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IGVkZ2VQYXIgb2YgcGFyLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHR0aGlzLnJha2VQYXJhbGxlbEdyYXBoKGVkZ2VQYXIpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGFyIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdHRoaXMucmFrZVNwZWNpZmllZFBhcmFsbGVsKHBhcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNwbGl0dGVyIG1ldGhvZCB0aGF0IHJha2VzIGJvdGggYSBwYXR0ZXJuIGFuZCBhIG5vbi1wYXR0ZXJuXG5cdFx0ICogY29udGFpbmluZyBTcGVjaWZpZWRQYXJhbGxlbC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VTcGVjaWZpZWRQYXJhbGxlbChwYXI6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnJha2VkUGFyYWxsZWxzLmhhcyhwYXIpKVxuXHRcdFx0XHRyZXR1cm4gcGFyO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnJha2VkUGFyYWxsZWxzLmFkZChwYXIpO1xuXHRcdFx0XG5cdFx0XHRpZiAocGFyLnBhdHRlcm4pXG5cdFx0XHRcdHRoaXMucmFrZVBhdHRlcm5CYXNlcyhwYXIpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLnJha2VCYXNlR3JhcGgocGFyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVjdXJzaXZlbHkgZm9sbG93cyB0aGUgYmFzZXMgb2YgdGhlIHNwZWNpZmllZCBzb3VyY2UgTm9kZS5cblx0XHQgKiBQYXJhbGxlbCBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgZm9yIGFueSB2aXNpdGVkIE5vZGUgaW5zdGFuY2Vcblx0XHQgKiB0aGF0IGRvZXMgbm90IGhhdmUgb25lIGFscmVhZHkgY3JlYXRlZC5cblx0XHQgKiBBbHRob3VnaCB0aGUgYWxnb3JpdGhtIGlzIGNhcmVmdWwgdG8gYXZvaWQgY2lyY3VsYXIgYmFzZXMsIGl0J3Ncblx0XHQgKiB0b28gZWFybHkgaW4gdGhlIHByb2Nlc3NpbmcgcGlwZWxpbmUgdG8gcmVwb3J0IHRoZXNlIGNpcmN1bGFyXG5cdFx0ICogYmFzZXMgYXMgZmF1bHRzLiBUaGlzIGlzIGJlY2F1c2UgcG9seW1vcnBoaWMgbmFtZSByZXNvbHV0aW9uXG5cdFx0ICogbmVlZHMgdG8gdGFrZSBwbGFjZSBiZWZvcmUgdGhlIHN5c3RlbSBjYW4gYmUgc3VyZSB0aGF0IGEgXG5cdFx0ICogc2VlbWluZ2x5LWNpcmN1bGFyIGJhc2Ugc3RydWN0dXJlIGlzIGluIGZhY3Qgd2hhdCBpdCBzZWVtcy5cblx0XHQgKiBUcnVlIGNpcmN1bGFyIGJhc2UgZGV0ZWN0aW9uIGlzIHRoZXJlZm9yZSBoYW5kbGVkIGF0IGEgZnV0dXJlXG5cdFx0ICogcG9pbnQgaW4gdGhlIHBpcGVsaW5lLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgcmFrZUJhc2VHcmFwaChzcmNQYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKHNyY1BhcmFsbGVsLnBhdHRlcm4pXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBoeXBlckVkZ2Ugb2Ygc3JjUGFyYWxsZWwubm9kZS5vdXRib3VuZHMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmNydWZ0LmhhcyhoeXBlckVkZ2UpKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcG9zc2liaWxpdGllcyA9IGh5cGVyRWRnZS5zdWNjZXNzb3JzXG5cdFx0XHRcdFx0LmZpbHRlcihzY3NyID0+ICF0aGlzLmNydWZ0LmhhcyhzY3NyLm5vZGUpKVxuXHRcdFx0XHRcdC5zb3J0KChhLCBiKSA9PiBhLmxvbmdpdHVkZSAtIGIubG9uZ2l0dWRlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwb3NzaWJpbGl0aWVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIHdoZXJlIHRoZSBwb2x5bW9ycGhpYyBuYW1lIHJlc29sdXRpb24gYWxnb3JpdGhtXG5cdFx0XHRcdFx0Ly8gdGFrZXMgcGxhY2UuIFRoZSBhbGdvcml0aG0gb3BlcmF0ZXMgYnkgd29ya2luZyBpdCdzIHdheVxuXHRcdFx0XHRcdC8vIHVwIHRoZSBsaXN0IG9mIG5vZGVzIChha2EgdGhlIHNjb3BlIGNoYWluKSwgbG9va2luZyBmb3Jcblx0XHRcdFx0XHQvLyBhIHBvc3NpYmxlIHJlc29sdXRpb24gdGFyZ2V0IHdoZXJlIHRoZSBhY3Qgb2YgYXBwbHlpbmcgdGhlXG5cdFx0XHRcdFx0Ly8gYXNzb2NpYXRlZCBQYXJhbGxlbCBhcyBhIGJhc2UsIGNhdXNlcyBhdCBsZWFzdCBvbmUgb2YgdGhlIFxuXHRcdFx0XHRcdC8vIGNvbmRpdGlvbnMgb24gdGhlIGNvbnRyYWN0IHRvIGJlIHNhdGlzZmllZC4gT3IsIGluIHRoZSBjYXNlXG5cdFx0XHRcdFx0Ly8gd2hlbiB0aGVyZSBhcmUgbm8gY29uZGl0aW9ucyBvbiB0aGUgY29udHJhY3QsIHRoZSBub2RlXG5cdFx0XHRcdFx0Ly8gdGhhdCBpcyB0aGUgY2xvc2VzdCBhbmNlc3RvciBpcyB1c2VkLlxuXHRcdFx0XHRcdGZvciAoY29uc3QgcG9zc2libGVTY3NyIG9mIHBvc3NpYmlsaXRpZXMpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3QgcG9zc2libGVOb2RlID0gcG9zc2libGVTY3NyLm5vZGU7XG5cdFx0XHRcdFx0XHRjb25zdCBiYXNlUGFyYWxsZWwgPSB0aGlzLmRyaWxsRnJvbU5vZGUocG9zc2libGVOb2RlKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gYmFzZVBhcmFsbGVsIHdpbGwgYmUgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIGEgY2lyY3VsYXJcblx0XHRcdFx0XHRcdC8vIHJlbGF0aW9uc2hpcCBoYXMgYmVlbiBkZXRlY3RlZCAoYW5kIHF1aXR0aW5nIGlzXG5cdFx0XHRcdFx0XHQvLyByZXF1aXJlZCBoZXJlIGluIG9yZGVyIHRvIGF2b2lkIGEgc3RhY2sgb3ZlcmZsb3cpLlxuXHRcdFx0XHRcdFx0aWYgKGJhc2VQYXJhbGxlbCA9PT0gbnVsbClcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHRoaXMucmFrZVNwZWNpZmllZFBhcmFsbGVsKGJhc2VQYXJhbGxlbCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVuIGFuIGVudGlyZSBwYXJhbGxlbCBuZWVkcyB0byBiZVxuXHRcdFx0XHRcdFx0Ly8gXCJleGNhdmF0ZWRcIiwgbWVhbmluZyB0aGF0IHRoZSBQYXJhbGxlbCdzIGVudGlyZSBzdWJ0cmVlXG5cdFx0XHRcdFx0XHQvLyBvZiBjb250ZW50cyBuZWVkcyB0byBiZSBhbmFseXplZCBhbmQgY29udmVydGVkIGludG9cblx0XHRcdFx0XHRcdC8vIHBhcmFsbGVscy4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhIGZ1bGx5IGRlZmluZWQgc2V0XG5cdFx0XHRcdFx0XHQvLyBvZiBwYXJhbGxlbHMgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gZGV0ZWN0IGRpc2NyZXBhbnRcblx0XHRcdFx0XHRcdC8vIHVuaW9ucyAoYW5kIHRoZXJlZm9yZSwgcmVwb3J0IHRoZSBhdHRlbXB0IGF0IGEgdHlwZVxuXHRcdFx0XHRcdFx0Ly8gdW5pb24gYXMgZmF1bHR5KS5cblx0XHRcdFx0XHRcdGlmIChzcmNQYXJhbGxlbC5iYXNlQ291bnQgPiAwKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoc3JjUGFyYWxsZWwuYmFzZUNvdW50ID09PSAxKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZXhjYXZhdGUoc3JjUGFyYWxsZWwuZmlyc3RCYXNlKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHRoaXMuZXhjYXZhdGUoYmFzZVBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCFzcmNQYXJhbGxlbC50cnlBZGRMaXRlcmFsQmFzZShiYXNlUGFyYWxsZWwsIGh5cGVyRWRnZSkpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5oYW5kbGVkSHlwZXJFZGdlcy5oYXMoaHlwZXJFZGdlKSlcblx0XHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR0aGlzLmhhbmRsZWRIeXBlckVkZ2VzLmFkZChoeXBlckVkZ2UpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlJ3ZlIGRpc2NvdmVyZWQgYW4gYW5ub3RhdGlvbiB0aGF0IHdlJ3JlXG5cdFx0XHRcdFx0Ly8gZ29pbmcgdG8gdHJ5IHRvIHJlc29sdmUgYXMgYW4gYWxpYXMuIElmIHRoaXMgZG9lc24ndCB3b3JrLFxuXHRcdFx0XHRcdC8vIHRoZSBlZGdlIHdpbGwgYmUgbWFya2VkIGFzIGNydWZ0LiBQb3NzaWJseSBhIGZ1dHVyZSB2ZXJzaW9uXG5cdFx0XHRcdFx0Ly8gb2YgdGhpcyBjb21waWxlciB3aWxsIGFsbG93IG90aGVyIGFnZW50cyB0byBob29rIGludG8gdGhpc1xuXHRcdFx0XHRcdC8vIHByb2Nlc3MgYW5kIGF1Z21lbnQgdGhlIHJlc29sdXRpb24gc3RyYXRlZ3kuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgY2FuZGlkYXRlUGF0dGVyblBhcnM6IFNwZWNpZmllZFBhcmFsbGVsW10gPSBbXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHsgcGF0dGVyblBhcmFsbGVsIH0gb2YgdGhpcy5hc2NlbmQoc3JjUGFyYWxsZWwpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMucmFrZVBhdHRlcm5CYXNlcyhwYXR0ZXJuUGFyYWxsZWwpO1xuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlUGF0dGVyblBhcnMucHVzaChwYXR0ZXJuUGFyYWxsZWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlUGF0dGVyblBhcnMubGVuZ3RoID4gMClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBpZGVudGlmaWVycyA9IGh5cGVyRWRnZS5mcmFnbWVudHNcblx0XHRcdFx0XHRcdFx0Lm1hcChzcmMgPT4gc3JjLmJvdW5kYXJ5LnN1YmplY3QpXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoKHMpOiBzIGlzIElkZW50aWZpZXIgPT4gcyBpbnN0YW5jZW9mIElkZW50aWZpZXIpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoaWRlbnRpZmllcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3QgYWxpYXMgPSBpZGVudGlmaWVyc1swXS5mdWxsTmFtZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHNyY1BhcmFsbGVsLnRyeUFkZEFsaWFzZWRCYXNlKGNhbmRpZGF0ZVBhdHRlcm5QYXJzLCBoeXBlckVkZ2UsIGFsaWFzKSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dGhpcy5oYW5kbGVkSHlwZXJFZGdlcy5hZGQoaHlwZXJFZGdlKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghdGhpcy5oYW5kbGVkSHlwZXJFZGdlcy5oYXMoaHlwZXJFZGdlKSlcblx0XHRcdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGh5cGVyRWRnZSwgRmF1bHRzLlVucmVzb2x2ZWRBbm5vdGF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIXNyY1BhcmFsbGVsLmlzQ29udHJhY3RTYXRpc2ZpZWQpXG5cdFx0XHRcdGZvciAoY29uc3Qgc210IG9mIHNyY1BhcmFsbGVsLm5vZGUuc3RhdGVtZW50cylcblx0XHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChuZXcgRmF1bHQoXG5cdFx0XHRcdFx0XHRGYXVsdHMuQ29udHJhY3RWaW9sYXRpb24sXG5cdFx0XHRcdFx0XHRzbXQpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNyY1BhcmFsbGVsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kcyB0aGUgc2V0IG9mIGJhc2VzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIHByb3ZpZGVkXG5cdFx0ICogcGF0dGVybi1jb250YWluaW5nIFNwZWNpZmllZFBhcmFsbGVsIGluc3RhbmNlLCBhbmQgYXR0ZW1wdHNcblx0XHQgKiB0byBoYXZlIHRoZW0gYXBwbGllZC5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJha2VQYXR0ZXJuQmFzZXMocGF0dGVyblBhcmFsbGVsOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRpZiAoIXBhdHRlcm5QYXJhbGxlbC5wYXR0ZXJuKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGJhc2VzID0gbmV3IE1hcDxTcGVjaWZpZWRQYXJhbGxlbCwgSHlwZXJFZGdlPigpO1xuXHRcdFx0Y29uc3Qgb2JzID0gcGF0dGVyblBhcmFsbGVsLm5vZGUub3V0Ym91bmRzO1xuXHRcdFx0Y29uc3QgbmFtZU9mID0gKGVkZ2U6IEh5cGVyRWRnZSkgPT5cblx0XHRcdFx0U3ViamVjdFNlcmlhbGl6ZXIuZm9ySW50ZXJuYWwoZWRnZS5mcmFnbWVudHNbMF0pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IG9icy5sZW5ndGg7KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBoeXBlckVkZ2UgPSBvYnNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5jcnVmdC5oYXMoaHlwZXJFZGdlKSlcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGxlbiA9IGh5cGVyRWRnZS5zdWNjZXNzb3JzLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEJlY2F1c2UgcmVzb2x2aW5nIHBhdHRlcm4gYmFzZXMgaGFzIG5vbi1wb2x5bW9ycGhpYyBiZWhhdmlvciwgXG5cdFx0XHRcdC8vIHdlIGNhbiBnZXQgYXdheSB3aXRoIGNoZWNraW5nIGZvciB0aGVzZSBmYXVsdHMgaGVyZSB3aXRob3V0IGdvaW5nXG5cdFx0XHRcdC8vIHRocm91Z2ggdGhlIHdob2xlIGRyaWxsaW5nIHByb2Nlc3MuXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobGVuID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQoaHlwZXJFZGdlLCBGYXVsdHMuVW5yZXNvbHZlZEFubm90YXRpb24pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob2JzLmZpbmRJbmRleChlID0+IG5hbWVPZihlKSA9PT0gbmFtZU9mKGh5cGVyRWRnZSkpICE9PSBpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jcnVmdC5hZGQoaHlwZXJFZGdlLCBGYXVsdHMuSWdub3JlZEFubm90YXRpb24pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobGVuID4gMSlcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBiYXNlTm9kZSA9IGh5cGVyRWRnZS5zdWNjZXNzb3JzWzBdLm5vZGU7XG5cdFx0XHRcdGNvbnN0IGJhc2VQYXJhbGxlbCA9IHRoaXMuZHJpbGxGcm9tTm9kZShiYXNlTm9kZSk7XG5cdFx0XHRcdGlmIChiYXNlUGFyYWxsZWwgIT09IG51bGwpXG5cdFx0XHRcdFx0YmFzZXMuc2V0KGJhc2VQYXJhbGxlbCwgaHlwZXJFZGdlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQ2lyY3VsYXIgYmFzZXMgc3RpbGwgbmVlZCB0byBiZSBjaGVja2VkLiBJdCdzIHVuY2xlYXIgaG93IGFuZFxuXHRcdFx0Ly8gd2hlcmUgdG8gYWN0dWFsbHkgZG8gdGhpcywgd2hpbGUgZmFjdG9yaW5nIGluIHRoZSBjb25zdHJhaW50XG5cdFx0XHQvLyB0aGF0IHRoZXNlIGNhbiBiZSBjYXVzZWQgdGhyb3VnaCB0aGUgdXNlIG9mIGFsaWFzZXMuXG5cdFx0XHRcblx0XHRcdC8vIEFueXRoaW5nIHRoYXQgaXMgYSBsaXN0ICh3aXRoIGFueSBkaW1lbnNpb25hbGl0eSkgbmVlZHMgdG8gYmVcblx0XHRcdC8vIGN1dCBvZmYsIGJlY2F1c2UgdGhlc2UgYmFzZXMgY2FuJ3QgYmUgYXBwbGllZCB0byBwYXR0ZXJucy5cblx0XHRcdGZvciAoY29uc3QgW2Jhc2UsIHZpYV0gb2YgYmFzZXMpXG5cdFx0XHRcdGlmIChiYXNlLmdldExpc3REaW1lbnNpb25hbGl0eSgpID4gMClcblx0XHRcdFx0XHR0aGlzLmNydWZ0LmFkZCh2aWEsIEZhdWx0cy5QYXR0ZXJuTWF0Y2hpbmdMaXN0KTtcblx0XHRcdFxuXHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGFueSBvZiB0aGVzZSBiYXNlcyBhcmUgcmVkdW5kYW50LlxuXHRcdFx0Ly8gVGhpcyBpcyBkb25lIGJ5IGNoZWNraW5nIHRvIHNlZSBpZiBhbnkgb2YgdGhlIGJhc2VzIGFyZSBzcGVjaWZpZWRcblx0XHRcdC8vIHNvbWV3aGVyZSBpbiB0aGUgYmFzZSBncmFwaCBvZiBhbGwgb3RoZXJzLlxuXHRcdFx0Zm9yIChjb25zdCBbYmFzZUFdIG9mIGJhc2VzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IFtiYXNlQiwgdmlhXSBvZiBiYXNlcylcblx0XHRcdFx0XHRpZiAoYmFzZUEgIT09IGJhc2VCKVxuXHRcdFx0XHRcdFx0aWYgKGJhc2VBLmhhc0Jhc2UoYmFzZUIpKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmNydWZ0LmFkZCh2aWEsIEZhdWx0cy5JZ25vcmVkQW5ub3RhdGlvbik7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuUGFyYWxsZWwubm9kZS5zdWJqZWN0IGFzIFBhdHRlcm47XG5cdFx0XHRjb25zdCBzcGFuID0gcGF0dGVyblBhcmFsbGVsLm5vZGUuZGVjbGFyYXRpb25zLnZhbHVlcygpLm5leHQoKS52YWx1ZSBhcyBTcGFuO1xuXHRcdFx0Y29uc3QgcG9ydEluZml4ZXMgPSBwYXR0ZXJuLmdldEluZml4ZXMoSW5maXhGbGFncy5wb3J0YWJpbGl0eSk7XG5cdFx0XHRcblx0XHRcdGlmIChwb3J0SW5maXhlcy5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB2YWxpZFBvcnRhYmlsaXR5SW5maXhlczogSW5maXhbXSA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCBwb3J0SW5maXggb2YgcG9ydEluZml4ZXMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBuZnhBbm5vc0l0ZXIgPSBzcGFuLmVhY2hBbm5vdGF0aW9uRm9ySW5maXgocG9ydEluZml4KTtcblx0XHRcdFx0XHRjb25zdCBuZnhBbm5vcyA9IEFycmF5LmZyb20obmZ4QW5ub3NJdGVyKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobmZ4QW5ub3MubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEF0IHRoaXMgdGltZSwgd2UncmUgY3VycmVudGx5IGdlbmVyYXRpbmcgYSBmYXVsdCBpbiB0aGUgY2FzZSB3aGVuXG5cdFx0XHRcdFx0Ly8gYSBwb3J0YWJpbGl0eSBpbmZpeCBoYXMgbXVsdGlwbGUgZGVmaW5pdGlvbnMuIEFsdGhvdWdoIHRoZSBwYXJzZXJcblx0XHRcdFx0XHQvLyBhbmQgdGhlIEdyYXBoLWxldmVsIGluZnJhc3RydWN0dXJlIHN1cHBvcnRzIHRoaXMsIG1vcmUgc3R1ZHkgaXNcblx0XHRcdFx0XHQvLyByZXF1aXJlZCBpbiBvcmRlciB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhIGNoYXJhY3RlcmlzdGljIG9mIFRydXRoLlxuXHRcdFx0XHRcdGlmIChuZnhBbm5vcy5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgbmZ4IG9mIG5meEFubm9zLnNsaWNlKDEpKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmNydWZ0LmFkZChuZngsIEZhdWx0cy5Qb3J0YWJpbGl0eUluZml4SGFzVW5pb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHZhbGlkUG9ydGFiaWxpdHlJbmZpeGVzLnB1c2gocG9ydEluZml4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhpcyBjb2RlIGNoZWNrcyBmb3Igb3ZlcmxhcHBpbmcgdHlwZXMuIFRoZSBhbGdvcml0aG0gdXNlZCBoZXJlIGlzXG5cdFx0XHRcdC8vIHNpbWlsYXIgdG8gdGhlIHJlZHVuZGFudCBiYXNlcyBjaGVjayB1c2VkIGFib3ZlLiBIb3dldmVyLCBpbiB0aGUgY2FzZVxuXHRcdFx0XHQvLyBvZiBpbmZpeGVzLCB0aGVzZSBhcmVuJ3QganVzdCByZWR1bmRhbnQsIHRoZXkgd291bGQgYmUgcHJvYmxlbWF0aWMgaWZcblx0XHRcdFx0Ly8gbGVmdCBpbi4gVG8gZXhwbGFpbiB3aHksIHRyeSB0byBmaWd1cmUgb3V0IGhvdyBhIFN0cmluZyB0eXBlIHdvdWxkIGRyYXdcblx0XHRcdFx0Ly8gaXQncyBkYXRhIG91dCBvZiBhbiBhbGlhcyBtYXRjaGluZyB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG5cdFx0XHRcdC8vIFx0LzwgOiBFbWFpbD48IDogU3RyaW5nPiA6IFR5cGVcblx0XHRcdFx0Ly8gKGhpbnQ6IGl0IGRvZXNuJ3Qgd29yaylcblx0XHRcdFx0XG5cdFx0XHRcdC8vISBOb3QgaW1wbGVtZW50ZWRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVE9ETzogQ2hlY2sgZm9yIHVzZSBvZiBsaXN0cyB3aXRoaW4gYW55IGtpbmQgb2YgaW5maXguXG5cdFx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBubyBjb2xsZWN0ZWQgYmFzZXMgdG8gYmUgcmV0dXJuZWRcblx0XHRcdC8vIGluIHRoZSBjYXNlIHdoZW4gdGhlcmUgd2VyZSBhY3R1YWxseSBhbm5vdGF0aW9uc1xuXHRcdFx0Ly8gc3BlY2lmaWVkIHdpdGhpbiB0aGUgZmlsZSwgYnV0IHRoZXkgd2VyZSBhbGwgZm91bmQgdG9cblx0XHRcdC8vIGJlIGNydWZ0LlxuXHRcdFx0aWYgKGJhc2VzLnNpemUgPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdFxuXHRcdFx0cGF0dGVyblBhcmFsbGVsLnRyeUFwcGx5UGF0dGVybkJhc2VzKGJhc2VzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCB3b3JrcyBpdHMgd2F5IHVwd2FyZHMsIHN0YXJ0aW5nIGF0IHRoZVxuXHRcdCAqIHByb3ZpZGVkIFNwZWNpZmllZFBhcmFsbGVsLiBUaGUgZnVuY3Rpb24geWllbGRzIHRoZSBzZXJpZXMgb2Zcblx0XHQgKiBQYXJhbGxlbHMgdGhhdCBjb250YWluIFBhdHRlcm5zIHRoYXQgYXJlIHZpc2libGUgdG8gdGhlIHByb3ZpZGVkXG5cdFx0ICogc3JjUGFyYWxsZWwuIFRoZSBiYXNlcyBvZiB0aGVzZSBwYXJhbGxlbHMgaGF2ZSBub3QgbmVjZXNzYXJpbHlcblx0XHQgKiBiZWVuIGFwcGxpZWQuXG5cdFx0ICogXG5cdFx0ICogVGhlIG9yZGVyaW5nIG9mIHRoZSBQYXJhbGxlbHMgeWllbGRlZCBpcyByZWxldmFudC4gVGhlIGluc3RhbmNlc1xuXHRcdCAqIHRoYXQgd2VyZSB5aWVsZGVkIGNsb3NlciB0byB0aGUgYmVnaW5uaW5nIHRha2UgcHJlc2NlZGVuY2Ugb3ZlclxuXHRcdCAqIHRoZSBvbmVzIHlpZWxkZWQgYXQgdGhlIGVuZC5cblx0XHQgKi9cblx0XHRwcml2YXRlICphc2NlbmQoc3JjUGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGNvbnN0IGRpc2NvdmVyZWRQYXR0ZXJuTm9kZXMgPSBuZXcgU2V0PE5vZGU+KCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHlpZWxkYWJsZSA9IChwYXR0ZXJuTm9kZTogTm9kZSkgPT5cblx0XHRcdHtcblx0XHRcdFx0ZGlzY292ZXJlZFBhdHRlcm5Ob2Rlcy5hZGQocGF0dGVybk5vZGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIE5vdC5udWxsKFxuXHRcdFx0XHRcdHRoaXMucGFyYWxsZWxzLmdldChwYXR0ZXJuTm9kZSkgfHxcblx0XHRcdFx0XHR0aGlzLnBhcmFsbGVscy5jcmVhdGUocGF0dGVybk5vZGUsIHRoaXMuY3J1ZnQpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlKGN1cnJlbnQ6IFNwZWNpZmllZFBhcmFsbGVsKTogXG5cdFx0XHRcdEl0ZXJhYmxlSXRlcmF0b3I8SVBhdHRlcm5QYXJhbGxlbD5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBjdXJyZW50LmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0eWllbGQgKnJlY3Vyc2UoYmFzZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdGZvciAoY29uc3Qgbm9kZSBvZiBjdXJyZW50Lm5vZGUuY29udGVudHMudmFsdWVzKCkpXG5cdFx0XHRcdFx0XHRpZiAobm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0XHRcdFx0aWYgKCFkaXNjb3ZlcmVkUGF0dGVybk5vZGVzLmhhcyhub2RlKSlcblx0XHRcdFx0XHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiBub2RlLnN1YmplY3QsXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuUGFyYWxsZWw6IHlpZWxkYWJsZShub2RlKVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBwcm9jZXNzIHN0YXJ0cyBhdCB0aGUgY29udGFpbmVyIG9mIHRoZSBjdXJyZW50IHBhcmFsbGVsLFxuXHRcdFx0Ly8gZXZlbiB0aG91Z2ggdGhpcyBmdW5jdGlvbiBuZWVkcyB0byB5aWVsZCBvdGhlciBwYXJhbGxlbHMgdGhhdFxuXHRcdFx0Ly8gYXJlIGFkamFjZW50IHRvIHNyY1BhcmFsbGVsLCBiZWNhdXNlIHdlIHJlYWNoIGJhY2sgaW50byB0aGVcblx0XHRcdC8vIGFkamFjZW50cyBmcm9tIHRoZSBjb250YWluZXIuXG5cdFx0XHRmb3IgKGxldCBjdXJyZW50ID0gc3JjUGFyYWxsZWwuY29udGFpbmVyO1xuXHRcdFx0XHRjdXJyZW50IGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWw7KVxuXHRcdFx0e1xuXHRcdFx0XHR5aWVsZCAqcmVjdXJzZShjdXJyZW50KTtcblx0XHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuY29udGFpbmVyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy5wcm9ncmFtLmdyYXBoLnJlYWRSb290cyhzcmNQYXJhbGxlbC5ub2RlLmRvY3VtZW50KSlcblx0XHRcdFx0aWYgKHJvb3Quc3ViamVjdCBpbnN0YW5jZW9mIFBhdHRlcm4pXG5cdFx0XHRcdFx0aWYgKCFkaXNjb3ZlcmVkUGF0dGVybk5vZGVzLmhhcyhyb290KSlcblx0XHRcdFx0XHRcdHlpZWxkIHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogcm9vdC5zdWJqZWN0LFxuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuUGFyYWxsZWw6IHlpZWxkYWJsZShyb290KVxuXHRcdFx0XHRcdFx0fTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXNlZCBmb3Igc2FmZXR5IHB1cnBvc2VzIHRvIGNhdGNoIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBoYW5kbGVkSHlwZXJFZGdlcyA9IG5ldyBXZWFrU2V0PEh5cGVyRWRnZT4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb25zdHJ1Y3RzIGFuZCByZXR1cm5zIGEgbmV3IHNlZWQgUGFyYWxsZWwgZnJvbSB0aGUgc3BlY2lmaWVkXG5cdFx0ICogemVuaXRoIFBhcmFsbGVsLCBuYXZpZ2F0aW5nIGRvd253YXJkcyB0byB0aGUgc3BlY2lmaWVkIHR5cGUgbmFtZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIGRlc2NlbmQoemVuaXRoOiBQYXJhbGxlbCwgdHlwZU5hbWU6IHN0cmluZylcblx0XHR7XG5cdFx0XHQvKipcblx0XHRcdCAqIEByZXR1cm5zIEEgbmV3IFBhcmFsbGVsIChlaXRoZXIgYmVpbmcgYSBTcGVjaWZpZWRQYXJhbGxlbFxuXHRcdFx0ICogb3IgYW4gVW5zcGVjaWZpZWRQYXJhbGxlbCBpbnN0YW5jZSksIHRoYXQgY29ycmVzcG9uZHMgdG9cblx0XHRcdCAqIHRoZSBzcGVjaWZpZWQgemVuaXRoIHBhcmFsbGVsLlxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCBkZXNjZW5kT25lID0gKHplbml0aDogUGFyYWxsZWwpOiBQYXJhbGxlbCA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoemVuaXRoIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBuZXh0Tm9kZSA9IHplbml0aC5ub2RlLmNvbnRlbnRzLmdldCh0eXBlTmFtZSk7XG5cdFx0XHRcdFx0aWYgKG5leHROb2RlKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IG91dCA9IHRoaXMucGFyYWxsZWxzLmdldChuZXh0Tm9kZSkgfHxcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuY3JlYXRlKG5leHROb2RlLCB0aGlzLmNydWZ0KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dGhpcy52ZXJpZnlEZXNjZW5kKHplbml0aCwgb3V0KTtcblx0XHRcdFx0XHRcdHJldHVybiBvdXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBuZXh0VXJpID0gemVuaXRoLnVyaS5leHRlbmRUeXBlKHR5cGVOYW1lKTtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHR0aGlzLnBhcmFsbGVscy5nZXQobmV4dFVyaSkgfHxcblx0XHRcdFx0XHR0aGlzLnBhcmFsbGVscy5jcmVhdGUobmV4dFVyaSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgYWN0XG5cdFx0XHQgKiBvZiBkZXNjZW5kaW5nIGZyb20gdGhlIHNwZWNpZmllZCBQYXJhbGxlbCB0byB0aGUgdHlwZU5hbWVcblx0XHRcdCAqIHBhc3NlZCB0byB0aGUgY29udGFpbmluZyBtZXRob2QgaXMgZ29pbmcgdG8gcmVzdWx0IGluIGFcblx0XHRcdCAqIFNwZWNpZmllZFBhcmFsbGVsIGluc3RhbmNlLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBjYW5EZXNjZW5kVG9TcGVjaWZpZWQocGFyYWxsZWw6IFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdHBhcmFsbGVsIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwgJiZcblx0XHRcdFx0XHRwYXJhbGxlbC5ub2RlLmNvbnRlbnRzLmhhcyh0eXBlTmFtZSkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvL1xuXHRcdFx0Ly8gVE9ETzogVGhlc2UgZnVuY3Rpb25zIGNhbiBwcm9iYWJseSBiZSByZXBsYWNlZCB3aXRoXG5cdFx0XHQvLyBhIGNhbGwgdG8gTWlzYy5yZWR1Y2VSZWN1cnNpdmUoKVxuXHRcdFx0Ly9cblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2VQYXJhbGxlbHMocGFyOiBQYXJhbGxlbCk6IEl0ZXJhYmxlSXRlcmF0b3I8UGFyYWxsZWw+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgcGFyRWRnZSBvZiBwYXIuZ2V0UGFyYWxsZWxzKCkpXG5cdFx0XHRcdFx0eWllbGQgKnJlY3Vyc2VQYXJhbGxlbHMocGFyRWRnZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR5aWVsZCBwYXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlQmFzZXMocGFyOiBTcGVjaWZpZWRQYXJhbGxlbCk6IEl0ZXJhYmxlSXRlcmF0b3I8UGFyYWxsZWw+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgcGFyLmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0eWllbGQgKnJlY3Vyc2VCYXNlcyhiYXNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHlpZWxkIHBhcjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24gKnJlY3Vyc2UocGFyOiBQYXJhbGxlbCk6IEl0ZXJhYmxlSXRlcmF0b3I8UGFyYWxsZWw+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAoY29uc3QgcGFyYWxsZWxFZGdlIG9mIHJlY3Vyc2VQYXJhbGxlbHMocGFyKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChwYXJhbGxlbEVkZ2UgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgYmFzZUVkZ2Ugb2YgcmVjdXJzZUJhc2VzKHBhcmFsbGVsRWRnZSkpXG5cdFx0XHRcdFx0XHRcdHlpZWxkIGJhc2VFZGdlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHlpZWxkIHBhcmFsbGVsRWRnZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBUaGUgZm9sbG93aW5nIGFsZ29yaXRobSBwZXJmb3JtcyBhIHJlY3Vyc2l2ZSByZWR1Y3Rpb24gb25cblx0XHRcdC8vIHRoZSB6ZW5pdGgsIGFuZCBwcm9kdWNlcyBhIHNldCBvZiBQYXJhbGxlbHMgdG8gcHJ1bmUgZnJvbSB0aGVcblx0XHRcdC8vIGRlc2NlbnNpb24gcHJvY2Vzcy4gVGhlIFBhcmFsbGVscyB0aGF0IGVuZCB1cCBnZXR0aW5nIHBydW5lZFxuXHRcdFx0Ly8gYXJlIHRoZSBvbmVzIHRoYXQsIGlmIHVucHJ1bmVkLCB3b3VsZCByZXN1bHQgaW4gYSBsYXllciB0aGF0XG5cdFx0XHQvLyBoYXMgVW5zcGVjaWZpZWRQYXJhbGxlbHMgdGhhdCBzaG91bGRuJ3QgYWN0dWFsbHkgZXhpc3QuIEZvclxuXHRcdFx0Ly8gZXhhbXBsZSwgY29uc2lkZXIgdGhlIGZvbGxvd2luZyBkb2N1bWVudDpcblx0XHRcdC8vXG5cdFx0XHQvLyBDbGFzc1xuXHRcdFx0Ly8gXG5cdFx0XHQvLyBTdWJDbGFzcyA6IENsYXNzXG5cdFx0XHQvLyBcdENoaWxkXG5cdFx0XHQvLyBcblx0XHRcdC8vIFwiQ2xhc3NcIiBzaG91bGQgbm90IGhhdmUgYW4gVW5zcGVjaWZpZWRQYXJhbGxlbCBjYWxsZWQgXCJDaGlsZFwiLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGF0IHdhcyBpbnRyb2R1Y2VkIGluIHRoZSBkZXJpdmVkIFwiU3ViQ2xhc3NcIiB0eXBlLlxuXHRcdFx0Ly8gQW5kIHNvIHRoaXMgYWxnb3JpdGhtIHN0YWtlcyBvdXQgY3V0IG9mZiBwb2ludHMgc28gdGhhdCB3ZSBkb24ndFxuXHRcdFx0Ly8gYmxpbmRseSBqdXN0IGRlc2NlbmQgYWxsIFBhcmFsbGVscyBpbiB0aGUgbGF5ZXIuXG5cdFx0XHRjb25zdCBwcnVuZWRQYXJhbGxlbHMgPSBuZXcgU2V0PFBhcmFsbGVsPigpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwcnVuZVBhcmFsbGVsc0ZvbGxvd0ZuID0gKHBhcjogUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHVwcGVyUGFyYWxsZWxzID0gcGFyLmdldFBhcmFsbGVscygpLnNsaWNlKCk7XG5cdFx0XHRcdGlmIChwYXIgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIHBhci5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdFx0dXBwZXJQYXJhbGxlbHMucHVzaChiYXNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB1cHBlclBhcmFsbGVscztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnN0IGhhc1NwZWNpZmllZENvbnRlbnRzID0gTWlzYy5yZWR1Y2VSZWN1cnNpdmUoXG5cdFx0XHRcdHplbml0aCxcblx0XHRcdFx0cHJ1bmVQYXJhbGxlbHNGb2xsb3dGbixcblx0XHRcdFx0KGN1cnJlbnQsIHJlc3VsdHM6IHJlYWRvbmx5IGJvb2xlYW5bXSkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHBydW5lID0gXG5cdFx0XHRcdFx0XHRyZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiAhcmVzdWx0KSAmJlxuXHRcdFx0XHRcdFx0IWNhbkRlc2NlbmRUb1NwZWNpZmllZChjdXJyZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAocHJ1bmUpXG5cdFx0XHRcdFx0XHRwcnVuZWRQYXJhbGxlbHMuYWRkKGN1cnJlbnQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiAhcHJ1bmU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBJbiB0aGUgY2FzZSB3aGVuIHRoZSBtZXRob2QgaXMgYXR0ZW1wdGluZyB0byBkZXNjZW5kXG5cdFx0XHQvLyB0byBhIGxldmVsIHdoZXJlIHRoZXJlIGFyZSBubyBub2RlcyB3aG9zZSBuYW1lIG1hdGNoXG5cdFx0XHQvLyB0aGUgdHlwZSBuYW1lIHNwZWNpZmllZCAoaS5lLiB0aGUgd2hvbGUgbGF5ZXIgd291bGQgYmUgXG5cdFx0XHQvLyB1bnNwZWNpZmllZCBwYXJhbGxlbHMpLCBudWxsIGlzIHJldHVybmVkIGJlY2F1c2UgYSBkZXNjZW5kXG5cdFx0XHQvLyB3b3VsZG4ndCBtYWtlIHNlbnNlLlxuXHRcdFx0aWYgKCFoYXNTcGVjaWZpZWRDb250ZW50cylcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGRlc2NlbmRQYXJhbGxlbHNGb2xsb3dGbiA9IChwYXI6IFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIShwYXIgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbCkpXG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYmFzZXMgPSBBcnJheS5mcm9tKHBhci5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdC5tYXAoZW50cnkgPT4gPFBhcmFsbGVsPmVudHJ5LmJhc2UpXG5cdFx0XHRcdFx0LnNsaWNlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBiYXNlc1xuXHRcdFx0XHRcdC5jb25jYXQocGFyLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRcdC5maWx0ZXIocGFyID0+ICFwcnVuZWRQYXJhbGxlbHMuaGFzKHBhcikpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNlZWQgPSBNaXNjLnJlZHVjZVJlY3Vyc2l2ZShcblx0XHRcdFx0emVuaXRoLFxuXHRcdFx0XHRkZXNjZW5kUGFyYWxsZWxzRm9sbG93Rm4sXG5cdFx0XHRcdChjdXJyZW50LCBuZXN0ZWQ6IHJlYWRvbmx5IFBhcmFsbGVsW10pID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBuZXh0UGFyID0gZGVzY2VuZE9uZShjdXJyZW50KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGVkZ2Ugb2YgbmVzdGVkKVxuXHRcdFx0XHRcdFx0bmV4dFBhci5hZGRQYXJhbGxlbChlZGdlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gbmV4dFBhcjtcblx0XHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWVkO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyB2ZXJpZmljYXRpb24gb24gdGhlIGRlc2NlbmQgb3BlcmF0aW9uLlxuXHRcdCAqIFJlcG9ydHMgYW55IGZhdWx0cyB0aGF0IGNhbiBvY2N1ciBkdXJpbmcgdGhpcyBwcm9jZXNzLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgdmVyaWZ5RGVzY2VuZChcblx0XHRcdHplbml0aFBhcmFsbGVsOiBTcGVjaWZpZWRQYXJhbGxlbCxcblx0XHRcdGRlc2NlbmRQYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKGRlc2NlbmRQYXJhbGxlbC5ub2RlLnN1YmplY3QgaW5zdGFuY2VvZiBBbm9uKVxuXHRcdFx0XHRpZiAoemVuaXRoUGFyYWxsZWwuaXNMaXN0SW50cmluc2ljKVxuXHRcdFx0XHRcdHRoaXMucHJvZ3JhbS5mYXVsdHMucmVwb3J0KG5ldyBGYXVsdChcblx0XHRcdFx0XHRcdEZhdWx0cy5Bbm9ueW1vdXNJbkxpc3RJbnRyaW5zaWMsXG5cdFx0XHRcdFx0XHRkZXNjZW5kUGFyYWxsZWwubm9kZS5zdGF0ZW1lbnRzWzBdKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgcmVhZG9ubHkgcGFyYWxsZWxzID0gbmV3IFBhcmFsbGVsQ2FjaGUoKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHNldCBvZiBQYXJhbGxlbCBpbnN0YW5jZXMgdGhhdCBoYXZlIGJlZW4gXCJyYWtlZFwiLFxuXHRcdCAqIHdoaWNoIG1lYW5zIHRoYXQgdGhhdCBoYXZlIGdvbmUgdGhyb3VnaCB0aGUgcHJvY2VzcyBvZlxuXHRcdCAqIGhhdmluZyB0aGVpciByZXF1ZXN0ZWQgYmFzZXMgYXBwbGllZC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIHNldCBtYXkgaW5jbHVkZSBib3RoIHBhdHRlcm4gYW5kIG5vbi1wYXR0ZXJucyBQYXJhbGxlbHMsXG5cdFx0ICogKGV2ZW4gdGhvdWdoIHRoZWlyIHJha2luZyBwcm9jZXNzZXMgYXJlIGNvbXBsZXRlbHkgZGlmZmVyZW50KS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHJha2VkUGFyYWxsZWxzID0gbmV3IFdlYWtTZXQ8UGFyYWxsZWw+KCk7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjcnVmdDogQ3J1ZnRDYWNoZTtcblx0fVxuXHRcblx0LyoqICovXG5cdGludGVyZmFjZSBJUGF0dGVyblBhcmFsbGVsXG5cdHtcblx0XHRyZWFkb25seSBwYXR0ZXJuOiBQYXR0ZXJuO1xuXHRcdHJlYWRvbmx5IHBhdHRlcm5QYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWw7XG5cdH1cblxuXHQvKiogKi9cblx0ZXhwb3J0IHR5cGUgVEJhc2VUYWJsZSA9IFJlYWRvbmx5TWFwPFNwZWNpZmllZFBhcmFsbGVsLCBIeXBlckVkZ2U+O1xufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhcmFsbGVsXG5cdHtcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBJbnZva2VkIGJ5IFBhcmFsbGVsQ2FjaGUuIERvIG5vdCBjYWxsLlxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKFxuXHRcdFx0cmVhZG9ubHkgdXJpOiBVcmksXG5cdFx0XHRyZWFkb25seSBjb250YWluZXI6IFBhcmFsbGVsIHwgbnVsbClcblx0XHR7XG5cdFx0XHR0aGlzLm5hbWUgPSB1cmkudG9UeXBlU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLm5hbWUuc3RhcnRzV2l0aChcIi9cIikpXG5cdFx0XHRcdHRoaXMubmFtZSA9IHVuZXNjYXBlKHRoaXMubmFtZSk7XG5cdFx0XHRcblx0XHRcdGlmIChjb250YWluZXIgIT09IG51bGwpXG5cdFx0XHRcdGNvbnRhaW5lci5fY29udGVudHMuc2V0KHVyaS50eXBlcy5zbGljZSgtMSlbMF0udmFsdWUsIHRoaXMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQYXJhbGxlbCxcblx0XHQgKiB1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblx0XHQgKi9cblx0XHRyZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgdmVyc2lvbiBudW1iZXIgZm9yIHRoaXMgaW5zdGFuY2UsXG5cdFx0ICogdXNlZnVsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdmVyc2lvbiA9IFZlcnNpb25TdGFtcC5uZXh0KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0IGNvbnRlbnRzKCk6IFJlYWRvbmx5TWFwPHN0cmluZywgUGFyYWxsZWw+XG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnRzO1xuXHRcdH1cblx0XHRwcml2YXRlIF9jb250ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBQYXJhbGxlbD4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXRQYXJhbGxlbHMoKVxuXHRcdHtcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMuX3BhcmFsbGVscy5zbGljZSgpKTtcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfcGFyYWxsZWxzOiBQYXJhbGxlbFtdID0gW107XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGhhc1BhcmFsbGVscygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhcmFsbGVscy5sZW5ndGggPiAwO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRhZGRQYXJhbGxlbChwYXJhbGxlbDogUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLl9wYXJhbGxlbHMuaW5jbHVkZXMocGFyYWxsZWwpKVxuXHRcdFx0XHR0aGlzLl9wYXJhbGxlbHMucHVzaChwYXJhbGxlbCk7XG5cdFx0fVxuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgU3BlY2lmaWVkUGFyYWxsZWwgZXh0ZW5kcyBQYXJhbGxlbFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW52b2tlZCBieSBQYXJhbGxlbENhY2hlLiBEbyBub3QgY2FsbC5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdG5vZGU6IE5vZGUsXG5cdFx0XHRjb250YWluZXI6IFNwZWNpZmllZFBhcmFsbGVsIHwgbnVsbCxcblx0XHRcdGNydWZ0OiBDcnVmdENhY2hlKVxuXHRcdHtcblx0XHRcdHN1cGVyKG5vZGUudXJpLCBjb250YWluZXIpO1xuXHRcdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHRcdHRoaXMuY3J1ZnQgPSBjcnVmdDtcblx0XHRcdFxuXHRcdFx0bm9kZS5kb2N1bWVudC5wcm9ncmFtLmZhdWx0cy5pbmZvcm0obm9kZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgTm9kZSBpbnN0YW5jZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoaXNcblx0XHQgKiBTcGVjaWZpZWRQYXJhbGxlbCBpbnN0YW5jZS5cblx0XHQgKi9cblx0XHRyZWFkb25seSBub2RlOiBOb2RlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBpc0NvbnRyYWN0U2F0aXNmaWVkKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250cmFjdC51bnNhdGlzZmllZENvbmRpdGlvbnMuc2l6ZSA9PT0gMDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBnZXQgY29udHJhY3QoKTogQ29udHJhY3Rcblx0XHR7XG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29udHJhY3QgaXMgY29tcHV0ZWQgbGF6aWx5LCBiZWNhdXNlXG5cdFx0XHQvLyBpZiB5b3UgdHJ5IHRvIGNvbXB1dGUgaXQgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgUGFyYWxsZWwgZ3JhcGhcblx0XHRcdC8vIHdvbid0IGJlIGNvbnN0cnVjdGVkLCBhbmQgeW91J2xsIGVuZCB1cCB3aXRoIGFuIGVtcHR5IGNvbnRyYWN0LlxuXHRcdFx0aWYgKHRoaXMuX2NvbnRyYWN0ID09PSBudWxsKVxuXHRcdFx0XHR0aGlzLl9jb250cmFjdCA9IG5ldyBDb250cmFjdCh0aGlzKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRyYWN0O1xuXHRcdH1cblx0XHRwcml2YXRlIF9jb250cmFjdDogQ29udHJhY3QgfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IGNydWZ0OiBDcnVmdENhY2hlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIGZpcnN0IGJhc2UgY29udGFpbmVkIGJ5IHRoaXMgaW5zdGFuY2UuXG5cdFx0ICogQHRocm93cyBJbiB0aGUgY2FzZSB3aGVuIHRoaXMgaW5zdGFuY2UgY29udGFpbnMgbm8gYmFzZXMuXG5cdFx0ICovXG5cdFx0Z2V0IGZpcnN0QmFzZSgpXG5cdFx0e1xuXHRcdFx0Zm9yIChjb25zdCBiYXNlRW50cnkgb2YgdGhpcy5fYmFzZXMudmFsdWVzKCkpXG5cdFx0XHRcdHJldHVybiBiYXNlRW50cnkucGFyYWxsZWxzWzBdO1xuXHRcdFx0XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm1zIGEgc2hhbGxvdyB0cmF2ZXJzYWwgb24gdGhlIG5vbi1jcnVmdCBiYXNlc1xuXHRcdCAqIGRlZmluZWQgZGlyZWN0bHkgb24gdGhpcyBQYXJhbGxlbC5cblx0XHQgKi9cblx0XHQqZWFjaEJhc2UoKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgW2VkZ2UsIGJhc2VFbnRyeV0gb2YgdGhpcy5fYmFzZXMpXG5cdFx0XHRcdGlmICghdGhpcy5jcnVmdC5oYXMoZWRnZSkpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBiYXNlIG9mIGJhc2VFbnRyeS5wYXJhbGxlbHMpXG5cdFx0XHRcdFx0XHR5aWVsZCB7IGJhc2UsIGVkZ2UsIGFsaWFzZWQ6IGJhc2VFbnRyeS5hbGlhc2VkIH07XG5cdFx0fVxuXHRcdHByaXZhdGUgcmVhZG9ubHkgX2Jhc2VzID0gbmV3IE1hcDxIeXBlckVkZ2UsIElCYXNlRW50cnk+KCk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSBhZGRCYXNlRW50cnkoXG5cdFx0XHRiYXNlOiBTcGVjaWZpZWRQYXJhbGxlbCxcblx0XHRcdGVkZ2U6IEh5cGVyRWRnZSxcblx0XHRcdGFsaWFzZWQ6IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXhpc3RpbmcgPSB0aGlzLl9iYXNlcy5nZXQoZWRnZSk7XG5cdFx0XHRpZiAoZXhpc3RpbmcpXG5cdFx0XHRcdGV4aXN0aW5nLnBhcmFsbGVscy5wdXNoKGJhc2UpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLl9iYXNlcy5zZXQoZWRnZSwgeyBwYXJhbGxlbHM6IFtiYXNlXSwgYWxpYXNlZCB9KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybXMgYSBkZWVwIHRyYXZlcnNhbCBvbiB0aGUgbm9uLWNydWZ0IGJhc2VzXG5cdFx0ICogZGVmaW5lZCBvbiB0aGlzIFBhcmFsbGVsLlxuXHRcdCAqL1xuXHRcdCplYWNoQmFzZURlZXAoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHF1ZXVlID0gQXJyYXkuZnJvbSh0aGlzLmVhY2hCYXNlKCkpLm1hcChlID0+IGUuYmFzZSk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcXVldWUubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudCA9IHF1ZXVlW2ldO1xuXHRcdFx0XHR5aWVsZCBjdXJyZW50O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBjdXJyZW50LmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0aWYgKCFxdWV1ZS5pbmNsdWRlcyhiYXNlKSlcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goYmFzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBwcm92aWRlZFxuXHRcdCAqIFNwZWNpZmllZFBhcmFsbGVsIGluc3RhbmNlIGV4aXN0cyBzb21ld2hlcmUsIHBvc3NpYmx5IG5lc3RlZCxcblx0XHQgKiBpbiB0aGUgYmFzZSBncmFwaCBvZiB0aGlzIGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdGhhc0Jhc2UodGVzdEJhc2U6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGNvbnN0IHF1ZXVlID0gQXJyYXkuZnJvbSh0aGlzLmVhY2hCYXNlKCkpLm1hcChlID0+IGUuYmFzZSk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcXVldWUubGVuZ3RoOylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY3VycmVudCA9IHF1ZXVlW2ldO1xuXHRcdFx0XHRpZiAoY3VycmVudCA9PT0gdGVzdEJhc2UpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSB9IG9mIGN1cnJlbnQuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHRpZiAoIXF1ZXVlLmluY2x1ZGVzKGJhc2UpKVxuXHRcdFx0XHRcdFx0cXVldWUucHVzaChiYXNlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRlbXB0cyB0byBhZGQgdGhlIHByb3ZpZGVkIFNwZWNpZmllZFBhcmFsbGVsIGFzIGEgYmFzZSBvZlxuXHRcdCAqIHRoaXMgaW5zdGFuY2UuIElmIHRoZSBhZGRpdGlvbiBvZiB0aGUgbmV3IGJhc2Ugd291bGQgbm90IGdlbmVyYXRlXG5cdFx0ICogYW55IGNyaXRpY2FsIGZhdWx0cywgaXQgaXMgYWRkZWQuIE90aGVyd2lzZSwgaXQncyBtYXJrZWQgYXMgY3J1ZnQuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJhc2Vcblx0XHQgKiB3YXMgYWRkZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqL1xuXHRcdHRyeUFkZExpdGVyYWxCYXNlKGJhc2U6IFNwZWNpZmllZFBhcmFsbGVsLCB2aWE6IEh5cGVyRWRnZSlcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYmFzZXMuaGFzKHZpYSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Ly8gSnVzdCBhcyBhIHJlbWluZGVyIC0tIHBhdHRlcm4tY29udGFpbmluZyBwYXJhbGxlbHMgXG5cdFx0XHQvLyBkb24ndCBjb21lIGludG8gdGhpcyBtZXRob2QuIEJhc2VzIGFyZSBhcHBsaWVkIHRvXG5cdFx0XHQvLyBwYXR0ZXJucyBpbiB0cnlBcHBseVBhdHRlcm5CYXNlcy5cblx0XHRcdGlmICh0aGlzLnBhdHRlcm4pXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbnVtU2F0aXNmaWVkID0gdGhpcy5jb250cmFjdC50cnlTYXRpc2Z5Q29uZGl0aW9uKGJhc2UpO1xuXHRcdFx0aWYgKG51bVNhdGlzZmllZCA9PT0gMCAmJiB0aGlzLmNvbnRyYWN0Lmhhc0NvbmRpdGlvbnMpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc2FuaXRpemVyID0gbmV3IFNhbml0aXplcih0aGlzLCBiYXNlLCB2aWEsIHRoaXMuY3J1ZnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgbmVlZCB0byBkbyBhIFxuXHRcdFx0Ly8gc2hhbGxvdyBjaGVjayBmb3IgY2lyY3VsYXIgaW5oZXJpdGFuY2UuXG5cdFx0XHRpZiAoc2FuaXRpemVyLmRldGVjdENpcmN1bGFyUmVmZXJlbmNlcygpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGlmIChzYW5pdGl6ZXIuZGV0ZWN0TGlzdEZyYWdtZW50Q29uZmxpY3RzKCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuYmFzZUNvdW50ID4gMClcblx0XHRcdHtcblx0XHRcdFx0aWYgKHNhbml0aXplci5kZXRlY3RMaXN0RGltZW5zaW9uYWxpdHlDb25mbGljdCgpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5hZGRCYXNlRW50cnkoYmFzZSwgdmlhLCBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0ZW1wdHMgdG8gaW5kaXJlY3RseSBhcHBseSBhIGJhc2UgdG8gdGhpcyBTcGVjaWZpZWRQYXJhbGxlbCB2aWEgYW4gYWxpYXNcblx0XHQgKiBhbmQgZWRnZS5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gcGF0dGVyblBhcmFsbGVsQ2FuZGlkYXRlcyBUaGUgcGF0dGVybi1jb250YWluaW5nXG5cdFx0ICogU3BlY2lmaWVkUGFyYWxsZWwgaW5zdGFuY2Ugd2hvc2UgYmFzZXMgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhpc1xuXHRcdCAqIFNwZWNpZmllZFBhcmFsbGVsLCBpZiB0aGUgcHJvdmlkZWQgYWxpYXMgaXMgYSBtYXRjaC5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0gdmlhRWRnZSBUaGUgSHlwZXJFZGdlIGluIHdoaWNoIHRoZSBhbGlhcyB3YXMgZm91bmQuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHZpYUFsaWFzIFRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0IHRoZSBwYXJhbGxlbCBlbWJlZGRlZFxuXHRcdCAqIHdpdGhpbiBwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzLlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgYmFzZSB3YXMgYWRkZWRcblx0XHQgKiBzdWNjZXNzZnVsbHkuXG5cdFx0ICovXG5cdFx0dHJ5QWRkQWxpYXNlZEJhc2UoXG5cdFx0XHRwYXR0ZXJuUGFyYWxsZWxDYW5kaWRhdGVzOiBTcGVjaWZpZWRQYXJhbGxlbFtdLFxuXHRcdFx0dmlhRWRnZTogSHlwZXJFZGdlLFxuXHRcdFx0dmlhQWxpYXM6IHN0cmluZylcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYmFzZXMuaGFzKHZpYUVkZ2UpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNob3NlblBhcmFsbGVscyA9IHBhdHRlcm5QYXJhbGxlbENhbmRpZGF0ZXMuc2xpY2UoKTtcblx0XHRcdGNvbnN0IGNvbmRpdGlvbnMgPSB0aGlzLmNvbnRyYWN0LnVuc2F0aXNmaWVkQ29uZGl0aW9ucztcblx0XHRcdGNvbnN0IGJlZ2FuV2l0aENvbmRpdGlvbnMgPSBjb25kaXRpb25zLnNpemUgPiAwO1xuXHRcdFx0XG5cdFx0XHRpZiAoYmVnYW5XaXRoQ29uZGl0aW9ucylcblx0XHRcdHtcblx0XHRcdFx0bGV0IG1heE1hdGNoQ291bnQgPSAxO1xuXHRcdFx0XHRcblx0XHRcdFx0bmV4dENhbmRpZGF0ZTogZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgcGF0dGVyblBhcmFsbGVsQ2FuZGlkYXRlcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKGNhbmRpZGF0ZS5fYmFzZXMudmFsdWVzKCkpO1xuXHRcdFx0XHRcdGNvbnN0IGNhbmRpZGF0ZUJhc2VzID0gZW50cmllc1xuXHRcdFx0XHRcdFx0Lm1hcChlID0+IGUucGFyYWxsZWxzKVxuXHRcdFx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlQmFzZXMubGVuZ3RoIDwgbWF4TWF0Y2hDb3VudClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgY2FuZGlkYXRlQmFzZSBvZiBjYW5kaWRhdGVCYXNlcylcblx0XHRcdFx0XHRcdGlmICghY29uZGl0aW9ucy5oYXMoY2FuZGlkYXRlQmFzZSkpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlIG5leHRDYW5kaWRhdGU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2hvc2VuUGFyYWxsZWxzLnB1c2goY2FuZGlkYXRlKTtcblx0XHRcdFx0XHRtYXhNYXRjaENvdW50ID0gY2FuZGlkYXRlQmFzZXMubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY2hvc2VuUGFyYWxsZWxzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGxldCB3YXNBZGRlZCA9IGZhbHNlO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGNob3NlblBhcmFsbGVsIG9mIGNob3NlblBhcmFsbGVscylcblx0XHRcdHtcblx0XHRcdFx0Ly8gSnVzdCBhcyBhIHJlbWluZGVyIC0tIHBhdHRlcm4tY29udGFpbmluZyBwYXJhbGxlbHMgZG9uJ3QgY29tZVxuXHRcdFx0XHQvLyBpbnRvIHRoaXMgbWV0aG9kIC4uLiBvbmx5IHRoZSBhbGlhc2VzIHRoYXQgbWlnaHQgbWF0Y2ggdGhlbS5cblx0XHRcdFx0aWYgKHRoaXMucGF0dGVybiB8fCAhY2hvc2VuUGFyYWxsZWwucGF0dGVybilcblx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0UGF0dGVybiBoYXMgbm8gaW5maXhlcywgd2UgY2FuIGdldCBhd2F5IHdpdGggYSBzaW1wbGVcblx0XHRcdFx0Ly8gY2hlY2sgdG8gc2VlIGlmIHRoZSBhbGlhcyBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXG5cdFx0XHRcdGlmICghY2hvc2VuUGFyYWxsZWwucGF0dGVybi5oYXNJbmZpeGVzKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIWNob3NlblBhcmFsbGVsLnBhdHRlcm4udGVzdCh2aWFBbGlhcykpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoYmVnYW5XaXRoQ29uZGl0aW9ucylcblx0XHRcdFx0XHRcdGlmICh0aGlzLmNvbnRyYWN0LnRyeVNhdGlzZnlDb25kaXRpb24oY2hvc2VuUGFyYWxsZWwpID09PSAwKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLmFkZEJhc2VFbnRyeShjaG9zZW5QYXJhbGxlbCwgdmlhRWRnZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0d2FzQWRkZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIE5vdCBpbXBsZW1lbnRlZCwgYnV0IHdlIHNob3VsZG4ndCB0aHJvdyBhbiBleGNlcHRpb24gaGVyZSB5ZXQuXG5cdFx0XHRyZXR1cm4gd2FzQWRkZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEF0dGVtcHRzIHRvIGFwcGx5IGEgc2V0IG9mIGJhc2VzIHRvIGEgcGF0dGVybi1jb250YWluaW5nIHBhcmFsbGVsLlxuXHRcdCAqIFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogL3BhdHRlcm4gOiBUaGlzLCBGdW5jdGlvbiwgQWRkcywgVGhlc2Vcblx0XHQgKi9cblx0XHR0cnlBcHBseVBhdHRlcm5CYXNlcyhiYXNlVGFibGU6IFRCYXNlVGFibGUpXG5cdFx0e1xuXHRcdFx0Y29uc3QgYmFzZXMgPSBBcnJheS5mcm9tKGJhc2VUYWJsZS5rZXlzKCkpO1xuXHRcdFx0XG5cdFx0XHQvLyBOb24tUGF0dGVybiBub2RlcyBzaG91bGQgbmV2ZXIgY29tZSB0byB0aGlzIG1ldGhvZC5cblx0XHRcdGlmICghdGhpcy5wYXR0ZXJuKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGJhc2VzRGVlcCA9IGJhc2VzXG5cdFx0XHRcdC5tYXAoYiA9PiBBcnJheS5mcm9tKGIuZWFjaEJhc2VEZWVwKCkpKVxuXHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pXG5cdFx0XHRcdC5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG5cdFx0XHRcblx0XHRcdC8vIFJlbWluZGVyOiB0aGUgU3BlY2lmaWVkUGFyYWxsZWxzIGluIHRoZSBiYXNlc0RlZXAgYXJyYXlcblx0XHRcdC8vIGFyZSBleHBlY3RlZCB0byBiZSBmdWxseSBwcm9jZXNzZWQgYnkgdGhlIHRpbWUgd2UgZ2V0IHRvXG5cdFx0XHQvLyB0aGlzIG1ldGhvZC4gSXQgc2hvdWxkIGJlIHNhZmUgdG8gdG91Y2ggdGhlbS5cblx0XHRcdFxuXHRcdFx0aWYgKGJhc2VzRGVlcC5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBiYXNlc05vZGVzID0gYmFzZXMubWFwKGIgPT4gYi5ub2RlKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEZpbmRzIGFsbCBwYXR0ZXJuIG5vZGVzIHRoYXQgaGF2ZSBhbiBlZGdlIHRoYXQgcG9pbnRzXG5cdFx0XHRcdC8vIHRvIGF0IGxlYXN0IG9uZSBvZiB0aGUgYmFzZXMgaW4gdGhlIGJhc2VzRGVlcCBhcnJheS5cblx0XHRcdFx0Y29uc3QgYmFzZXNEZWVwU3ByYXdsID0gYmFzZXNEZWVwXG5cdFx0XHRcdFx0Lm1hcChiID0+IEFycmF5LmZyb20oYi5ub2RlLmluYm91bmRzKSlcblx0XHRcdFx0XHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pXG5cdFx0XHRcdFx0Lm1hcChpbmIgPT4gaW5iLnByZWRlY2Vzc29yKVxuXHRcdFx0XHRcdC5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSlcblx0XHRcdFx0XHQuZmlsdGVyKG5vZGUgPT4gbm9kZS5zdWJqZWN0IGluc3RhbmNlb2YgUGF0dGVybilcblx0XHRcdFx0XHQuZmlsdGVyKG5vZGUgPT4gbm9kZS5vdXRib3VuZHNcblx0XHRcdFx0XHRcdC5maWx0ZXIob2IgPT4gb2Iuc3VjY2Vzc29ycy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHQubWFwKG9iID0+IG9iLnN1Y2Nlc3NvcnNbMF0ubm9kZSlcblx0XHRcdFx0XHRcdC5ldmVyeShub2RlID0+IGJhc2VzTm9kZXMuaW5jbHVkZXMobm9kZSkpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJhc2VzRGVlcFNwcmF3bFBhdHRlcm5zID0gYmFzZXNEZWVwU3ByYXdsXG5cdFx0XHRcdFx0Lm1hcChuID0+IG4uc3ViamVjdClcblx0XHRcdFx0XHQuZmlsdGVyKChzKTogcyBpcyBQYXR0ZXJuID0+IHMgaW5zdGFuY2VvZiBQYXR0ZXJuKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHRlc3QgZXZlcnkgc2luZ2xlIG9uZSBvZiB0aGUgXG5cdFx0XHRcdCAqIHBhdHRlcm5zIGluIGJhc2VzRGVlcFNwcmF3bFBhdHRlcm5zIGFnYWluc3QgdGhpc1xuXHRcdFx0XHQgKiB0aGlzLm5vZGUuc3ViamVjdCB0byBtYWtlIHN1cmUgdGhlIHR3byBwYXR0ZXJucyBhcmVcblx0XHRcdFx0ICogY29tcGxpYW50LlxuXHRcdFx0XHQgKiBcblx0XHRcdFx0ICogSWYgdGhleSdyZSBub3QgY29tcGxpYW50LCB3ZSBuZWVkIHRvIHN0YXJ0IG1hcmtpbmdcblx0XHRcdFx0ICogYmFzZXMgYXMgY3J1ZnQgdW50aWwgdGhleSBhcmUuXG5cdFx0XHRcdCAqIFxuXHRcdFx0XHQgKiBUaGVyZSBpcyBhbHNvIGEgcmVjdXJzaXZlIGluZml4IGVtYmVkIHByb2Nlc3MgdGhhdFxuXHRcdFx0XHQgKiBuZWVkcyB0byBoYXBwZW4gaGVyZSwgYnV0IG1heWJlIHdlIHNob3VsZCBqdXN0XG5cdFx0XHRcdCAqIHB1dCB0aGlzIG9mZiB1bnRpbCB0aGUgYmFzaWMgcGF0dGVybiBmdW5jdGlvbmFsaXR5XG5cdFx0XHRcdCAqIGlzIHdvcmtpbmc/XG5cdFx0XHRcdCAqL1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgYWxzbyBuZWVkcyB0byB0YWtlIGludG8gYWNjb3VudCBhbnkgb3RoZXIgcGF0dGVybnNcblx0XHRcdCAqIHRoYXQgYXJlIGFwcGxpZWQgdG8gYW55IG9mIHRoZSBiYXNlcyBkZWZpbmVkIGRpcmVjdGx5XG5cdFx0XHQgKiBpbmxpbmUuXG5cdFx0XHQgKi9cblx0XHRcdFxuXHRcdFx0Ly8gSGVyZSB3ZSdyZSBqdXN0IGFkZGluZyBhbGwgdGhlIGJhc2VzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlclxuXHRcdFx0Ly8gb3Igbm90IGFueSBvZiB0aGUgYXNzb2NpYXRlZCBlZGdlcyB3ZXJlIG1hcmtlZCBhcyBjcnVmdC5cblx0XHRcdC8vIFRoZSBvdGhlciBlbnVtZXJhdG9ycyBza2lwIG92ZXIgY3J1ZnQgZWRnZXMsIHNvIHRoaXMgbGlrZWx5XG5cdFx0XHQvLyBpc24ndCBhIHByb2JsZW0sIGFuZCBpdCBrZWVwcyBpdCBjb25zaXN0ZW50IHdpdGggdGhlIHdheSB0aGVcblx0XHRcdC8vIHJlc3Qgb2YgdGhlIHN5c3RlbSB3b3Jrcy5cblx0XHRcdGZvciAoY29uc3QgW2Jhc2UsIHZpYV0gb2YgYmFzZVRhYmxlKVxuXHRcdFx0XHR0aGlzLmFkZEJhc2VFbnRyeShiYXNlLCB2aWEsIGZhbHNlKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgbnVtYmVyIG9mIGJhc2VzIHRoYXQgaGF2ZSBcblx0XHQgKiBiZWVuIGV4cGxpY2l0bHkgYXBwbGllZCB0byB0aGlzIFBhcmFsbGVsLlxuXHRcdCAqL1xuXHRcdGdldCBiYXNlQ291bnQoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9iYXNlcy5zaXplO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRnZXQgaXNMaXN0SW50cmluc2ljKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlLmlzTGlzdEludHJpbnNpYztcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ludHJpbnNpY0V4dHJpbnNpY0JyaWRnZTtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfaW50cmluc2ljRXh0cmluc2ljQnJpZGdlOiBTcGVjaWZpZWRQYXJhbGxlbCB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEVzdGFibGlzaGVzIGEgYnJpZGdlIGJldHdlZW4gdGhpcyBTcGVjaWZpZWRQYXJhbGxlbCBhbmQgdGhlXG5cdFx0ICogb25lIHByb3ZpZGVkLiBcblx0XHQgKi9cblx0XHRjcmVhdGVJbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UocGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UgIT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhcmFsbGVsLl9pbnRyaW5zaWNFeHRyaW5zaWNCcmlkZ2UgIT09IG51bGwpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHBhcmFsbGVsLm5vZGUuaXNMaXN0SW50cmluc2ljID09PSB0aGlzLm5vZGUuaXNMaXN0SW50cmluc2ljKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuX2ludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSA9IHBhcmFsbGVsO1xuXHRcdFx0cGFyYWxsZWwuX2ludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSA9IHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldExpc3REaW1lbnNpb25hbGl0eSgpOiBudW1iZXJcblx0XHR7XG5cdFx0XHQvLyBOT1RFOiBUaGlzIGFjdHVhbGx5IG5lZWRzIHRvIGJlIFwiZWFjaCBiYXNlIGluZmVycmVkXCJcblx0XHRcdFxuXHRcdFx0Ly8gVGhpcyBpcyBwdXJwb3NlbHkgb25seSByZXR1cm5pbmcgdGhlIGRpbWVuc2lvbmFsaXR5IG9mXG5cdFx0XHQvLyB0aGUgZmlyc3QgYmFzZS4gVGhlcmUgaXMgYSBndWFyYW50ZWUgdGhhdCBhbGwgZGltZW5zaW9uYWxpdGllc1xuXHRcdFx0Ly8gd2lsbCBiZSB0aGUgc2FtZSBoZXJlLlxuXHRcdFx0Zm9yIChjb25zdCB7IGJhc2UsIGVkZ2UgfSBvZiB0aGlzLmVhY2hCYXNlKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGluaXRpYWxEaW0gPSBiYXNlLmdldExpc3REaW1lbnNpb25hbGl0eSgpO1xuXHRcdFx0XHRyZXR1cm4gZWRnZS5pc0xpc3QgPyBpbml0aWFsRGltICsgMSA6IGluaXRpYWxEaW07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIGNvbXBhcmVQYXR0ZXJuVG8ob3RoZXI6IFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdHtcblx0XHRcdFxuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIG1heWJlQ29tcGlsZVBhdHRlcm4oKVxuXHRcdHtcblx0XHRcdC8vL2lmICghdGhpcy5wYXR0ZXJuKVxuXHRcdFx0Ly8vXHRyZXR1cm47XG5cdFx0XHRcblx0XHRcdC8vL2lmICghcGF0dGVybi5oYXNJbmZpeGVzKCkpXG5cdFx0XHQvLy9cdHRoaXMuY29tcGlsZWRFeHByZXNzaW9uID0gcGF0dGVybi5cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyB0aGUgUGF0dGVybiBpbnN0YW5jZSB0aGF0IHJlc2lkZXMgaW5zaWRlIHRoaXMgU3BlY2lmaWVkUGFyYWxsZWwsXG5cdFx0ICogb3IgbnVsbCBpbiB0aGUgY2FzZSB3aGVuIHRoaXMgU3BlY2lmaWVkUGFyYWxsZWwgZG9lcyBub3QgaGF2ZSBhblxuXHRcdCAqIGlubmVyIFBhdHRlcm4uXG5cdFx0ICovXG5cdFx0Z2V0IHBhdHRlcm4oKTogUGF0dGVybiB8IG51bGxcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlLnN1YmplY3QgaW5zdGFuY2VvZiBQYXR0ZXJuID9cblx0XHRcdFx0dGhpcy5ub2RlLnN1YmplY3QgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBpbGVkIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHRcdCAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLCBpbiB0aGUgY2FzZSB3aGVuIHRoaXMgaW5zdGFuY2UgaXNcblx0XHQgKiBhIHBhdHRlcm4gcGFyYWxsZWwuXG5cdFx0ICogXG5cdFx0ICogVGhpcyBzdHJpbmcgcmVwcmVzZW50YXRpb24gc2hvdWxkIGhhdmUgYW55IGluZml4ZXMgY29tcGlsZWQgYXdheSxcblx0XHQgKiBhbmQgc2hvdWxkIGJlIHBhc3NhYmxlIHRvIGEgSmF2YVNjcmlwdCBSZWdFeHAsIG9yIHRvIHRoZSBGc20gc3lzdGVtLlxuXHRcdCAqL1xuXHRcdHByaXZhdGUgY29tcGlsZWRFeHByZXNzaW9uOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHR5cGUgdGhhdCBkZXNjcmliZXMgYW4gZW50cnkgaW4gdGhlIGJhc2VzIG1hcFxuXHQgKiBvZiBhIFNwZWNpZmllZFBhcmFsbGVsLlxuXHQgKi9cblx0aW50ZXJmYWNlIElCYXNlRW50cnlcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgc2V0IG9mIFNwZWNpZmllZFBhcmFsbGVscyB0aGF0IGNhdXNlZCB0aGUgYmFzZSB0byBiZSBjb25zdHJ1Y3RlZC5cblx0XHQgKiBOb3RlIHRoYXQgYSBiYXNlIGVudHJ5IGNhbiBoYXZlIG11bHRpcGxlIHBhcmFsbGVscyBpbiB0aGUgY2FzZSB3aGVuIHRoZSBiYXNlXG5cdFx0ICogaXMgYWN0dWFsbHkgYSBwYXR0ZXJuIHdpdGggdHdvIGVxdWFsbHkgdmlhYmxlIG1hdGNoZXMgaW4gc2NvcGUsIGFuZCBubyBjb250cmFjdFxuXHRcdCAqIGJlaW5nIGltcG9zZWQsIGZvciBleGFtcGxlOlxuXHRcdCAqIFxuXHRcdCAqIC9wYXR0ZXJuIDogQVxuXHRcdCAqIC9wYXR0ZXJuIDogQlxuXHRcdCAqIFxuXHRcdCAqIFZhbHVlIDogcGF0dGVybiB+IEEsIEJcblx0XHQgKi9cblx0XHRwYXJhbGxlbHM6IFNwZWNpZmllZFBhcmFsbGVsW107XG5cdFx0XG5cdFx0LyoqIFN0b3JlcyB3aGV0aGVyIHRoZSBpZGVudGlmaWVyIGlzIGFuIGFsaWFzIChtYXRjaGVkIGJ5IGEgcGF0dGVybikuICovXG5cdFx0YWxpYXNlZDogYm9vbGVhbjtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFVuc3BlY2lmaWVkUGFyYWxsZWwgZXh0ZW5kcyBQYXJhbGxlbFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogSW52b2tlZCBieSBQYXJhbGxlbENhY2hlLiBEbyBub3QgY2FsbC5cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHVyaTogVXJpLFxuXHRcdFx0Y29udGFpbmVyOiBQYXJhbGxlbCB8IG51bGwpXG5cdFx0e1xuXHRcdFx0c3VwZXIodXJpLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBBdm9pZHMgZXJyb25lb3VzIHN0cnVjdHVyYWwgdHlwZSBjb21wYXRpYmlsaXR5IHdpdGggUGFyYWxsZWwuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSB1bmlxdWU6IHVuZGVmaW5lZDtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEEgc2ltcGxlIGNsYXNzIGZvciBoYW5kbGluZyBvYmplY3RzIG1hcmtlZCBhcyBjcnVmdC5cblx0ICovXG5cdGV4cG9ydCBjbGFzcyBDcnVmdENhY2hlXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0pIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYSBmYXVsdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgdG8gdGhlIGludGVybmFsIHNldCxcblx0XHQgKiBtYXJrcyBhbGwgcmVsZXZhbnQgb2JqZWN0cyBhcyBjcnVmdCwgYW5kIHJlcG9ydHMgdGhlXG5cdFx0ICogcmVsZXZhbnQgZmF1bHQgdHlwZS5cblx0XHQgKi9cblx0XHRhZGQoY3J1ZnQ6IFRDcnVmdCwgcmVsZXZhbnRGYXVsdFR5cGU6IEZhdWx0VHlwZSlcblx0XHR7XG5cdFx0XHRjb25zdCBmYXVsdFNvdXJjZXM6IHJlYWRvbmx5IFRGYXVsdFNvdXJjZVtdID1cblx0XHRcdFx0Y3J1ZnQgaW5zdGFuY2VvZiBOb2RlID8gY3J1ZnQuc3RhdGVtZW50cyA6IFxuXHRcdFx0XHRjcnVmdCBpbnN0YW5jZW9mIEh5cGVyRWRnZSA/IGNydWZ0LmZyYWdtZW50cyA6XG5cdFx0XHRcdFtjcnVmdF07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgZmF1bHRTcmMgb2YgZmF1bHRTb3VyY2VzKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBmYXVsdCA9IG5ldyBGYXVsdChyZWxldmFudEZhdWx0VHlwZSwgZmF1bHRTcmMpO1xuXHRcdFx0XHR0aGlzLnByb2dyYW0uZmF1bHRzLnJlcG9ydChmYXVsdCk7XG5cdFx0XHRcdHRoaXMuY3J1ZnQuYWRkKGZhdWx0U3JjKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5jcnVmdC5hZGQoY3J1ZnQpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcblx0XHQgKiBzcGVjaWZpZWQgb2JqZWN0IGhhcyBiZWVuIG1hcmtlZCBhcyBjcnVmdC5cblx0XHQgKi9cblx0XHRoYXMoc291cmNlOiBUQ3J1ZnQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuY3J1ZnQuaGFzKHNvdXJjZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiBTdG9yZXMgYSBzZXQgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgY3J1ZnQuICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBjcnVmdCA9IG5ldyBTZXQ8VENydWZ0PigpO1xuXHR9XG5cblxuXHQvKiogKi9cblx0ZXhwb3J0IHR5cGUgVENydWZ0ID0gVEZhdWx0U291cmNlIHwgTm9kZSB8IEh5cGVyRWRnZTtcbn1cbiIsIlxubmFtZXNwYWNlIFRydXRoXG57XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdGV4cG9ydCBjbGFzcyBQYXJhbGxlbENhY2hlXG5cdHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGEgUGFyYWxsZWwgaW5zdGFuY2UgZnJvbSB0aGUgc3BlY2lmaWVkIE5vZGUgb3Jcblx0XHQgKiBVcmkgaW5zdGFuY2UuIFxuXHRcdCAqIFxuXHRcdCAqIEB0aHJvd3MgSW4gdGhlIGNhc2Ugd2hlbiBhbGwgY29udGFpbmluZyBQYXJhbGxlbFR5cGVzIHRvIGhhdmVcblx0XHQgKiBub3QgYmVlbiBjcmVhdGVkIGJlZm9yZWhhbmQuXG5cdFx0ICogXG5cdFx0ICogQHRocm93IEluIHRoZSBjYXNlIHdoZW4gYSBQYXJhbGxlbFR5cGUgY29ycmVzcG9uZGluZyB0byB0aGVcblx0XHQgKiBpbnB1dCB3YXMgYWxyZWFkeSBjcmVhdGVkLlxuXHRcdCAqL1xuXHRcdGNyZWF0ZShub2RlOiBOb2RlLCBjcnVmdDogQ3J1ZnRDYWNoZSk6IFNwZWNpZmllZFBhcmFsbGVsO1xuXHRcdGNyZWF0ZSh1cmk6IFVyaSk6IFVuc3BlY2lmaWVkUGFyYWxsZWw7XG5cdFx0Y3JlYXRlKGtleTogTm9kZSB8IFVyaSwgY3J1ZnQ/OiBDcnVmdENhY2hlKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmhhcyhrZXkpKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IHNhdmUgPSAocGFyOiBQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qga2V5VmFsID0gdGhpcy5nZXRLZXlWYWwoa2V5KTtcblx0XHRcdFx0dGhpcy5wYXJhbGxlbHMuc2V0KGtleVZhbCwgcGFyKTtcblx0XHRcdFx0cmV0dXJuIHBhcjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvbnRhaW5lciA9ICgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgTm9kZSlcblx0XHRcdFx0XHRyZXR1cm4ga2V5LmNvbnRhaW5lciAhPT0gbnVsbCA/XG5cdFx0XHRcdFx0XHROb3QudW5kZWZpbmVkKHRoaXMuZ2V0KGtleS5jb250YWluZXIpKSA6XG5cdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIGtleS50eXBlcy5sZW5ndGggPiAxID9cblx0XHRcdFx0XHROb3QudW5kZWZpbmVkKHRoaXMuZ2V0KGtleS5yZXRyYWN0VHlwZSgxKSkpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fSkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIFVyaSlcblx0XHRcdFx0cmV0dXJuIHNhdmUobmV3IFVuc3BlY2lmaWVkUGFyYWxsZWwoa2V5LCBjb250YWluZXIpKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpICYmIGNvbnRhaW5lciAhPT0gbnVsbClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoY3J1ZnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBvdXRQYXIgPSBuZXcgU3BlY2lmaWVkUGFyYWxsZWwoa2V5LCBjb250YWluZXIsIGNydWZ0KTtcblx0XHRcdGlmIChrZXkuaW50cmluc2ljRXh0cmluc2ljQnJpZGdlID09PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gc2F2ZShvdXRQYXIpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXMoa2V5LmludHJpbnNpY0V4dHJpbnNpY0JyaWRnZSkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgYnJpZGdlUGFyID0gbmV3IFNwZWNpZmllZFBhcmFsbGVsKFxuXHRcdFx0XHRrZXkuaW50cmluc2ljRXh0cmluc2ljQnJpZGdlLFxuXHRcdFx0XHRjb250YWluZXIsXG5cdFx0XHRcdGNydWZ0KTtcblx0XHRcdFxuXHRcdFx0b3V0UGFyLmNyZWF0ZUludHJpbnNpY0V4dHJpbnNpY0JyaWRnZShicmlkZ2VQYXIpO1xuXHRcdFx0cmV0dXJuIHNhdmUob3V0UGFyKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0KGtleTogVXJpKTogUGFyYWxsZWwgfCB1bmRlZmluZWQ7XG5cdFx0Z2V0KGtleTogTm9kZSk6IFNwZWNpZmllZFBhcmFsbGVsIHwgdW5kZWZpbmVkO1xuXHRcdGdldChrZXk6IE5vZGUgfCBVcmkpXG5cdFx0e1xuXHRcdFx0Y29uc3Qga2V5VmFsID0gdGhpcy5nZXRLZXlWYWwoa2V5KTtcblx0XHRcdGNvbnN0IG91dCA9IHRoaXMucGFyYWxsZWxzLmdldChrZXlWYWwpO1xuXHRcdFx0XG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgTm9kZSlcblx0XHRcdFx0aWYgKG91dCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGlmICghKG91dCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKSlcblx0XHRcdFx0XHRcdHRocm93IEV4Y2VwdGlvbi51bmtub3duU3RhdGUoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0aGFzKGtleTogTm9kZSB8IFVyaSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJhbGxlbHMuaGFzKHRoaXMuZ2V0S2V5VmFsKGtleSkpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGdldEtleVZhbChrZXk6IE5vZGUgfCBVcmkpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdXJpID0ga2V5IGluc3RhbmNlb2YgTm9kZSA/IGtleS51cmkgOiBrZXk7XG5cdFx0XHRyZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyBhIG1hcCBvZiBhbGwgUGFyYWxsZWwgaW5zdGFuY2VzIHRoYXQgaGF2ZSBiZWVuXG5cdFx0ICogY29uc3RydWN0ZWQgYnkgdGhpcyBvYmplY3QuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBwYXJhbGxlbHMgPSBuZXcgTWFwPHN0cmluZywgUGFyYWxsZWw+KCk7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGRlYnVnKClcblx0XHR7XG5cdFx0XHRjb25zdCB0ZXh0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnBhcmFsbGVscylcblx0XHRcdFx0dGV4dC5wdXNoKHZhbHVlLm5hbWUpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGV4dC5qb2luKFwiXFxuXCIpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIENvbnRyYWN0XG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihzb3VyY2VQYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcmVjdXJzZSA9IChzcmNQYXJhbGxlbDogUGFyYWxsZWwpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChzcmNQYXJhbGxlbCBpbnN0YW5jZW9mIFVuc3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG5lc3RlZFBhcmFsbGVsIG9mIHNyY1BhcmFsbGVsLmdldFBhcmFsbGVscygpKVxuXHRcdFx0XHRcdFx0cmVjdXJzZShuZXN0ZWRQYXJhbGxlbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoc3JjUGFyYWxsZWwgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2Ygc3JjUGFyYWxsZWwuZWFjaEJhc2UoKSlcblx0XHRcdFx0XHRcdHRoaXMuX3Vuc2F0aXNmaWVkQ29uZGl0aW9ucy5hZGQoYmFzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgaGlnaGVyUGFyYWxsZWwgb2Ygc291cmNlUGFyYWxsZWwuZ2V0UGFyYWxsZWxzKCkpXG5cdFx0XHRcdHJlY3Vyc2UoaGlnaGVyUGFyYWxsZWwpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFsbENvbmRpdGlvbnMgPSBPYmplY3QuZnJlZXplKEFycmF5LmZyb20odGhpcy5fdW5zYXRpc2ZpZWRDb25kaXRpb25zKSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbXB1dGVzIHdoZXRoZXIgdGhlIGlucHV0IFNwZWNpZmllZFBhcmFsbGVsIGlzIGEgbW9yZSBkZXJpdmVkXG5cdFx0ICogdHlwZSBvZiB0aGUgU3BlY2lmaWVkUGFyYWxsZWwgdGhhdCBjb3JyZXNwb25kcyB0byB0aGlzIENvbnRyYWN0LlxuXHRcdCAqIFxuXHRcdCAqIEByZXR1cm5zIEEgbnVtYmVyIHRoYXQgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgY29uZGl0aW9ucyB0aGF0XG5cdFx0ICogd2VyZSBzYXRpc2ZpZWQgYXMgYSByZXN1bHQgb2YgYWRkaW5nIHRoZSBwcm92aWRlZCBTcGVjaWZpZWRQYXJhbGxlbFxuXHRcdCAqIHRvIHRoZSBDb250cmFjdC5cblx0XHQgKi9cblx0XHR0cnlTYXRpc2Z5Q29uZGl0aW9uKGZvcmVpZ25QYXJhbGxlbDogU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuYWxsQ29uZGl0aW9ucy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBmb3JlaWduUGFyYWxsZWxCYXNlcyA9IG5ldyBTZXQ8U3BlY2lmaWVkUGFyYWxsZWw+KCk7XG5cdFx0XHRmb3JlaWduUGFyYWxsZWxCYXNlcy5hZGQoZm9yZWlnblBhcmFsbGVsKTtcblx0XHRcdFxuXHRcdFx0bGV0IHNhdGlzZmllZCA9IDA7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGFkZEZvcmVpZ25QYXJhbGxlbEJhc2VzID0gKHNyY1BhcmFsbGVsOiBTcGVjaWZpZWRQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UgfSBvZiBzcmNQYXJhbGxlbC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdGFkZEZvcmVpZ25QYXJhbGxlbEJhc2VzKGJhc2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yZWlnblBhcmFsbGVsQmFzZXMuYWRkKHNyY1BhcmFsbGVsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZvciAoY29uc3QgeyBiYXNlIH0gb2YgZm9yZWlnblBhcmFsbGVsLmVhY2hCYXNlKCkpXG5cdFx0XHRcdGFkZEZvcmVpZ25QYXJhbGxlbEJhc2VzKGJhc2UpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGZvcmVpZ25CYXNlIG9mIGZvcmVpZ25QYXJhbGxlbEJhc2VzKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiB0aGlzLmFsbENvbmRpdGlvbnMpXG5cdFx0XHRcdFx0aWYgKGZvcmVpZ25CYXNlID09PSBjb25kaXRpb24pXG5cdFx0XHRcdFx0XHRzYXRpc2ZpZWQgKz0gdGhpcy5fdW5zYXRpc2ZpZWRDb25kaXRpb25zLmRlbGV0ZShjb25kaXRpb24pID8gMSA6IDA7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzYXRpc2ZpZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCBoYXNDb25kaXRpb25zKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hbGxDb25kaXRpb25zLmxlbmd0aCA+IDA7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGdldCB1bnNhdGlzZmllZENvbmRpdGlvbnMoKTogUmVhZG9ubHlTZXQ8U3BlY2lmaWVkUGFyYWxsZWw+XG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Vuc2F0aXNmaWVkQ29uZGl0aW9ucztcblx0XHR9XG5cdFx0cHJpdmF0ZSByZWFkb25seSBfdW5zYXRpc2ZpZWRDb25kaXRpb25zID0gbmV3IFNldDxTcGVjaWZpZWRQYXJhbGxlbD4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGFyYWxsZWxzIHRoYXQgYW55IHN1cHBsaWVkXG5cdFx0ICogcGFyYWxsZWwgbXVzdCBoYXZlIGluIGl0J3MgYmFzZSBncmFwaCBpbiBvcmRlciB0byBiZSBkZWVtZWRcblx0XHQgKiBjb21wbGlhbnQuXG5cdFx0ICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBhbGxDb25kaXRpb25zOiByZWFkb25seSBTcGVjaWZpZWRQYXJhbGxlbFtdO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQSBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyB0aGUgYWN0dWFsIGZhdWx0IGRldGVjdGlvbiBiZWhhdmlvcixcblx0ICogd2l0aCBmYWNpbGl0aWVzIHRvIHBlcmZvcm0gYW5hbHlzaXMgb24gUGFyYWxsZWwgaW5zdGFuY2VzLCBiZWZvcmVcblx0ICogdGhlIGFjdHVhbCBiYXNlIGhhcyBiZWVuIGFwcGxpZWQgdG8gaXQuXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgU2FuaXRpemVyXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0UGFyYWxsZWw6IFNwZWNpZmllZFBhcmFsbGVsLFxuXHRcdFx0cHJpdmF0ZSByZWFkb25seSBwcm9wb3NlZEJhc2U6IFNwZWNpZmllZFBhcmFsbGVsLFxuXHRcdFx0cHJpdmF0ZSByZWFkb25seSBwcm9wb3NlZEVkZ2U6IEh5cGVyRWRnZSxcblx0XHRcdHByaXZhdGUgcmVhZG9ubHkgY3J1ZnQ6IENydWZ0Q2FjaGUpIHsgfVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERldGVjdHMgbGlzdCBvcGVyYXJ0b3IgY29uZmxpY3RzIGJldHdlZW4gdGhlIGZyYWdtZW50cyBvZiBhblxuXHRcdCAqIGFubm90YXRpb24uIEZvciBleGFtcGxlLCBjb25mbGljdHMgb2YgdGhlIGZvbGxvd2luZyB0eXBlIGFyZVxuXHRcdCAqIGNhdWdodCBoZXJlOlxuXHRcdCAqIFxuXHRcdCAqIExpc3QgOiBJdGVtXG5cdFx0ICogTGlzdCA6IEl0ZW0uLi5cblx0XHQgKi9cblx0XHRkZXRlY3RMaXN0RnJhZ21lbnRDb25mbGljdHMoKVxuXHRcdHtcblx0XHRcdGNvbnN0IHNvdXJjZXMgPSB0aGlzLnByb3Bvc2VkRWRnZS5mcmFnbWVudHM7XG5cdFx0XHRpZiAoc291cmNlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3BhbnMgPSBzb3VyY2VzLmZpbHRlcigoc3JjKTogc3JjIGlzIFNwYW4gPT4gc3JjIGluc3RhbmNlb2YgU3Bhbik7XG5cdFx0XHRjb25zdCBpZGVudGlmaWVycyA9IHNwYW5zXG5cdFx0XHRcdC5tYXAoZiA9PiBmLmJvdW5kYXJ5LnN1YmplY3QpXG5cdFx0XHRcdC5maWx0ZXIoKHN1Yik6IHN1YiBpcyBJZGVudGlmaWVyID0+IHN1YiBpbnN0YW5jZW9mIElkZW50aWZpZXIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpZGVudGlmaWVyc0xpc3QgPSBpZGVudGlmaWVycy5maWx0ZXIoaWQgPT4gaWQuaXNMaXN0KTtcblx0XHRcdGNvbnN0IGlkZW50aWZpZXJzTm9uTGlzdCA9IGlkZW50aWZpZXJzLmZpbHRlcihpZCA9PiAhaWQuaXNMaXN0KTtcblx0XHRcdFxuXHRcdFx0aWYgKGlkZW50aWZpZXJzTGlzdC5sZW5ndGggPiAwICYmIGlkZW50aWZpZXJzTm9uTGlzdC5sZW5ndGggPiAwKVxuXHRcdFx0XHRmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpXG5cdFx0XHRcdFx0dGhpcy5hZGRGYXVsdChzcGFuLCBGYXVsdHMuTGlzdEFubm90YXRpb25Db25mbGljdCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZvdW5kQ3J1ZnQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGRldGVjdENpcmN1bGFyUmVmZXJlbmNlcygpXG5cdFx0e1xuXHRcdFx0Y29uc3QgY2lyY3VsYXJFZGdlUGF0aHM6IEh5cGVyRWRnZVtdW10gPSBbXTtcblx0XHRcdGNvbnN0IHJlY3Vyc2UgPSAoXG5cdFx0XHRcdHNyY0Jhc2U6IFNwZWNpZmllZFBhcmFsbGVsLFxuXHRcdFx0XHRwYXRoOiBIeXBlckVkZ2VbXSkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGJhc2UsIGVkZ2UgfSBvZiB0aGlzLmJhc2VzT2Yoc3JjQmFzZSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAocGF0aC5pbmNsdWRlcyhlZGdlKSlcblx0XHRcdFx0XHRcdGNpcmN1bGFyRWRnZVBhdGhzLnB1c2gocGF0aC5zbGljZSgpKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZWN1cnNlKGJhc2UsIHBhdGguY29uY2F0KGVkZ2UpKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB7IGJhc2UsIGVkZ2UgfSBvZiB0aGlzLmJhc2VzT2YodGhpcy50YXJnZXRQYXJhbGxlbCkpXG5cdFx0XHRcdHJlY3Vyc2UoYmFzZSwgW10pO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgY2lyY3VsYXJFZGdlUGF0aHMpXG5cdFx0XHRcdGZvciAoY29uc3QgY2lyY3VsYXJFZGdlIG9mIGl0ZW0pXG5cdFx0XHRcdFx0dGhpcy5hZGRGYXVsdChjaXJjdWxhckVkZ2UsIEZhdWx0cy5DaXJjdWxhclR5cGVSZWZlcmVuY2UpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mb3VuZENydWZ0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRkZXRlY3RMaXN0RGltZW5zaW9uYWxpdHlDb25mbGljdCgpXG5cdFx0e1xuXHRcdFx0Y29uc3QgdGFyZ2V0RGltID0gdGhpcy50YXJnZXRQYXJhbGxlbC5nZXRMaXN0RGltZW5zaW9uYWxpdHkoKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJvcG9zZWREaW0gPSBcblx0XHRcdFx0dGhpcy5wcm9wb3NlZEJhc2UuZ2V0TGlzdERpbWVuc2lvbmFsaXR5KCkgK1xuXHRcdFx0XHQodGhpcy5wcm9wb3NlZEVkZ2UuaXNMaXN0ID8gMSA6IDApO1xuXHRcdFx0XG5cdFx0XHRpZiAodGFyZ2V0RGltICE9PSBwcm9wb3NlZERpbSlcblx0XHRcdFx0dGhpcy5hZGRGYXVsdCh0aGlzLnByb3Bvc2VkRWRnZSwgRmF1bHRzLkxpc3REaW1lbnNpb25hbERpc2NyZXBhbmN5RmF1bHQpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5mb3VuZENydWZ0O1xuXHRcdH1cblx0XHRcblx0XHQvKiogR2V0cyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGZhdWx0IGhhcyBiZWVuIHJlcG9ydGVkLiAqL1xuXHRcdGdldCBmb3VuZENydWZ0KClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZm91bmRDcnVmdDtcblx0XHR9XG5cdFx0cHJpdmF0ZSBfZm91bmRDcnVmdCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgKmJhc2VzT2YocGFyOiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHR7XG5cdFx0XHRmb3IgKGNvbnN0IHsgYmFzZSwgZWRnZSB9IG9mIHBhci5lYWNoQmFzZSgpKVxuXHRcdFx0XHR5aWVsZCB7IGJhc2UsIGVkZ2UgfTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMudGFyZ2V0UGFyYWxsZWwgPT09IHBhcilcblx0XHRcdFx0eWllbGQgeyBiYXNlOiB0aGlzLnByb3Bvc2VkQmFzZSwgZWRnZTogdGhpcy5wcm9wb3NlZEVkZ2UgfTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBhZGRGYXVsdChzb3VyY2U6IFRDcnVmdCwgcmVsZXZhbnRGYXVsdFR5cGU6IEZhdWx0VHlwZSlcblx0XHR7XG5cdFx0XHR0aGlzLl9mb3VuZENydWZ0ID0gdHJ1ZTtcblx0XHRcdHRoaXMuY3J1ZnQuYWRkKHNvdXJjZSwgcmVsZXZhbnRGYXVsdFR5cGUpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqICovXG5cdGludGVyZmFjZSBJU3RvcmVkQ29udGV4dFxuXHR7XG5cdFx0dmVyc2lvbjogVmVyc2lvblN0YW1wO1xuXHRcdHdvcmtlcjogQ29uc3RydWN0aW9uV29ya2VyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZnVsbHkgY29uc3RydWN0ZWQgdHlwZSB3aXRoaW4gdGhlIHByb2dyYW0uXG5cdCAqL1xuXHRleHBvcnQgY2xhc3MgVHlwZVxuXHR7XG5cdFx0LyoqIFxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIENvbnN0cnVjdHMgb25lIG9yIG1vcmUgVHlwZSBvYmplY3RzIGZyb20gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cblx0XHQgKi9cblx0XHRzdGF0aWMgY29uc3RydWN0KHVyaTogVXJpLCBwcm9ncmFtOiBQcm9ncmFtKTogVHlwZSB8IG51bGw7XG5cdFx0c3RhdGljIGNvbnN0cnVjdChzcGluZTogU3BpbmUsIHByb2dyYW06IFByb2dyYW0pOiBUeXBlO1xuXHRcdHN0YXRpYyBjb25zdHJ1Y3QocGFyYW06IFVyaSB8IFNwaW5lLCBwcm9ncmFtOiBQcm9ncmFtKTogVHlwZSB8IG51bGxcblx0XHR7XG5cdFx0XHRjb25zdCB1cmkgPSBVcmkuY2xvbmUocGFyYW0pO1xuXHRcdFx0aWYgKHVyaS50eXBlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAoVHlwZUNhY2hlLmhhcyh1cmksIHByb2dyYW0pKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBjYWNoZWQgPSBUeXBlQ2FjaGUuZ2V0KHVyaSwgcHJvZ3JhbSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB0aGUgY2FjaGVkIHR5cGUgZXhpc3RzLCBidXQgaGFzbid0IGJlZW4gY29tcGlsZWQgeWV0LFxuXHRcdFx0XHQvLyB3ZSBjYW4ndCByZXR1cm4gaXQsIHdlIG5lZWQgdG8gY29tcGlsZSBpdCBmaXJzdC5cblx0XHRcdFx0aWYgKGNhY2hlZCA9PT0gbnVsbCB8fCBjYWNoZWQgaW5zdGFuY2VvZiBUeXBlKVxuXHRcdFx0XHRcdHJldHVybiBjYWNoZWQgYXMgVHlwZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3Qgd29ya2VyID0gKCgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHN0b3JlZCA9IHRoaXMucGFyYWxsZWxDb250ZXh0TWFwLmdldChwcm9ncmFtKTtcblx0XHRcdFx0aWYgKHN0b3JlZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbmV3U3RvcmVkOiBJU3RvcmVkQ29udGV4dCA9IHtcblx0XHRcdFx0XHRcdHZlcnNpb246IHByb2dyYW0udmVyc2lvbixcblx0XHRcdFx0XHRcdHdvcmtlcjogbmV3IENvbnN0cnVjdGlvbldvcmtlcihwcm9ncmFtKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5wYXJhbGxlbENvbnRleHRNYXAuc2V0KHByb2dyYW0sIG5ld1N0b3JlZCk7XG5cdFx0XHRcdFx0cmV0dXJuIG5ld1N0b3JlZC53b3JrZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocHJvZ3JhbS52ZXJzaW9uLm5ld2VyVGhhbihzdG9yZWQudmVyc2lvbikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdG9yZWQudmVyc2lvbiA9IHByb2dyYW0udmVyc2lvbjtcblx0XHRcdFx0XHRzdG9yZWQud29ya2VyID0gbmV3IENvbnN0cnVjdGlvbldvcmtlcihwcm9ncmFtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHN0b3JlZC53b3JrZXI7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJhbGxlbCA9IHdvcmtlci5kcmlsbCh1cmkpO1xuXHRcdFx0aWYgKHBhcmFsbGVsID09PSBudWxsKVxuXHRcdFx0e1xuXHRcdFx0XHRUeXBlQ2FjaGUuc2V0KHVyaSwgcHJvZ3JhbSwgbnVsbCk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBwYXJhbGxlbExpbmVhZ2UgPSBbcGFyYWxsZWxdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCBjdXJyZW50UGFyYWxsZWwgPSBwYXJhbGxlbC5jb250YWluZXI7IGN1cnJlbnRQYXJhbGxlbCAhPT0gbnVsbDspXG5cdFx0XHR7XG5cdFx0XHRcdHBhcmFsbGVsTGluZWFnZS51bnNoaWZ0KGN1cnJlbnRQYXJhbGxlbCk7XG5cdFx0XHRcdGN1cnJlbnRQYXJhbGxlbCA9IGN1cnJlbnRQYXJhbGxlbC5jb250YWluZXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGxldCBsYXN0VHlwZTogVHlwZSB8IG51bGwgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IGN1cnJlbnRQYXJhbGxlbCBvZiBwYXJhbGxlbExpbmVhZ2UpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChUeXBlQ2FjaGUuaGFzKGN1cnJlbnRQYXJhbGxlbC51cmksIHByb2dyYW0pKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmdUeXBlID0gVHlwZUNhY2hlLmdldChjdXJyZW50UGFyYWxsZWwudXJpLCBwcm9ncmFtKTtcblx0XHRcdFx0XHRpZiAoZXhpc3RpbmdUeXBlIGluc3RhbmNlb2YgVHlwZVByb3h5KVxuXHRcdFx0XHRcdFx0dGhyb3cgRXhjZXB0aW9uLnVua25vd25TdGF0ZSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChleGlzdGluZ1R5cGUgPT09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGFzdFR5cGUgPSBleGlzdGluZ1R5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZTogVHlwZSA9IG5ldyBUeXBlKGN1cnJlbnRQYXJhbGxlbCwgbGFzdFR5cGUsIHByb2dyYW0pO1xuXHRcdFx0XHRcdFR5cGVDYWNoZS5zZXQoY3VycmVudFBhcmFsbGVsLnVyaSwgcHJvZ3JhbSwgdHlwZSk7XG5cdFx0XHRcdFx0bGFzdFR5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBsYXN0VHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICogQ29uc3RydWN0cyB0aGUgaW52aXNpYmxlIHJvb3QtbGV2ZWwgVHlwZSBvYmplY3QgdGhhdCBjb3JyZXNwb25kc1xuXHRcdCAqIHRvIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0c3RhdGljIGNvbnN0cnVjdFJvb3RzKGRvY3VtZW50OiBEb2N1bWVudClcblx0XHR7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gZG9jdW1lbnQucHJvZ3JhbTtcblx0XHRcdGNvbnN0IHJvb3RzOiBUeXBlW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBub2RlIG9mIHByb2dyYW0uZ3JhcGgucmVhZFJvb3RzKGRvY3VtZW50KSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuY29uc3RydWN0KG5vZGUudXJpLCBwcm9ncmFtKTtcblx0XHRcdFx0aWYgKHR5cGUgIT09IG51bGwpXG5cdFx0XHRcdFx0cm9vdHMucHVzaCh0eXBlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUocm9vdHMpO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIHN0YXRpYyBwYXJhbGxlbENvbnRleHRNYXAgPSBuZXcgV2Vha01hcDxQcm9ncmFtLCBJU3RvcmVkQ29udGV4dD4oKTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRwcml2YXRlIGNvbnN0cnVjdG9yKFxuXHRcdFx0c2VlZDogUGFyYWxsZWwsXG5cdFx0XHRjb250YWluZXI6IFR5cGUgfCBudWxsLFxuXHRcdFx0cHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHR0aGlzLnByaXZhdGUgPSBuZXcgVHlwZVByaXZhdGUocHJvZ3JhbSwgc2VlZCk7XG5cdFx0XHR0aGlzLm5hbWUgPSBzZWVkLnVyaS50eXBlc1tzZWVkLnVyaS50eXBlcy5sZW5ndGggLSAxXS52YWx1ZTtcblx0XHRcdHRoaXMudXJpID0gc2VlZC51cmk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnBhcmFsbGVscyA9IG5ldyBUeXBlUHJveHlBcnJheShcblx0XHRcdFx0c2VlZC5nZXRQYXJhbGxlbHMoKS5tYXAoZWRnZSA9PlxuXHRcdFx0XHRcdG5ldyBUeXBlUHJveHkoZWRnZS51cmksIHByb2dyYW0pKSk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGdldEJhc2VzID0gKHNwOiBTcGVjaWZpZWRQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYmFzZXMgPSBBcnJheS5mcm9tKHNwLmVhY2hCYXNlKCkpO1xuXHRcdFx0XHRyZXR1cm4gYmFzZXMubWFwKGVudHJ5ID0+IFxuXHRcdFx0XHRcdG5ldyBUeXBlUHJveHkoZW50cnkuYmFzZS5ub2RlLnVyaSwgcHJvZ3JhbSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlZWQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5wcml2YXRlLmJhc2VzID0gbmV3IFR5cGVQcm94eUFycmF5KGdldEJhc2VzKHNlZWQpKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHNlZWQgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBxdWV1ZTogUGFyYWxsZWxbXSA9IFtzZWVkXTtcblx0XHRcdFx0Y29uc3Qgc3BlY2lmaWVkUGFyYWxsZWxzOiBTcGVjaWZpZWRQYXJhbGxlbFtdID0gW107XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IHF1ZXVlLmxlbmd0aDspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50ID0gcXVldWVbaV07XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0cXVldWUucHVzaCguLi5jdXJyZW50LmdldFBhcmFsbGVscygpKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRzcGVjaWZpZWRQYXJhbGxlbHMucHVzaChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgYmFzZXMgPSBzcGVjaWZpZWRQYXJhbGxlbHNcblx0XHRcdFx0XHQubWFwKHBhciA9PiBnZXRCYXNlcyhwYXIpKVxuXHRcdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSlcblx0XHRcdFx0XHQuZmlsdGVyKCh2LCBpLCBhKSA9PiBhLmluZGV4T2YodikgPT09IGkpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5wcml2YXRlLmJhc2VzID0gbmV3IFR5cGVQcm94eUFycmF5KGJhc2VzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5pc0xpc3QgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlZWQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc3ViID0gc2VlZC5ub2RlLnN1YmplY3Q7XG5cdFx0XHRcdHRoaXMuaXNQYXR0ZXJuID0gc3ViIGluc3RhbmNlb2YgUGF0dGVybjtcblx0XHRcdFx0dGhpcy5pc1VyaSA9IHN1YiBpbnN0YW5jZW9mIFVyaTtcblx0XHRcdFx0dGhpcy5pc0Fub255bW91cyA9IHN1YiBpbnN0YW5jZW9mIEFub247XG5cdFx0XHRcdHRoaXMuaXNTcGVjaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmlzRnJlc2ggPSBzZWVkLmdldFBhcmFsbGVscygpLmxlbmd0aCA9PT0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbmFtZSBvZiB0aGUgdHlwZSxcblx0XHQgKiBvciBhIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgcGF0dGVybiBjb250ZW50IGluIHRoZVxuXHRcdCAqIGNhc2Ugd2hlbiB0aGUgdHlwZSBpcyBhY3R1YWxseSBhIHBhdHRlcm4uXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB0aGUgVVJJIHRoYXQgc3BlY2lmaWVzIHdoZXJlIHRoaXMgVHlwZSB3YXNcblx0XHQgKiBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgdXJpOiBVcmk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSB0eXBlLCBhcyBpdCdzIGRlZmluZWQgaW4gaXQnc1xuXHRcdCAqIG5leHQgbW9zdCBhcHBsaWNhYmxlIHR5cGUuXG5cdFx0ICovXG5cdFx0Z2V0IHBhcmFsbGVscygpXG5cdFx0e1xuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIE5vdC5udWxsKHRoaXMucHJpdmF0ZS5wYXJhbGxlbHMpLm1heWJlQ29tcGlsZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmFsbGVsIHJvb3RzIG9mIHRoaXMgdHlwZS5cblx0XHQgKiBUaGUgcGFyYWxsZWwgcm9vdHMgYXJlIHRoZSBlbmRwb2ludHMgZm91bmQgd2hlblxuXHRcdCAqIHRyYXZlcnNpbmcgdXB3YXJkIHRocm91Z2ggdGhlIHBhcmFsbGVsIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGdldCBwYXJhbGxlbFJvb3RzKClcblx0XHR7XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLnByaXZhdGUucGFyYWxsZWxSb290cyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5wYXJhbGxlbFJvb3RzO1xuXHRcdFx0XG5cdFx0XHRjb25zdCByb290czogVHlwZVtdID0gW107XG5cdFx0XHRmb3IgKGNvbnN0IHsgdHlwZSB9IG9mIHRoaXMuaXRlcmF0ZSh0ID0+IHQucGFyYWxsZWxzKSlcblx0XHRcdFx0aWYgKHR5cGUgIT09IHRoaXMgJiYgdHlwZS5wYXJhbGxlbHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJvb3RzLnB1c2godHlwZSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUucGFyYWxsZWxSb290cyA9IE9iamVjdC5mcmVlemUocm9vdHMpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIFR5cGUgdGhhdCBjb250YWlucyB0aGlzIFR5cGUsIG9yIG51bGwgaW5cblx0XHQgKiB0aGUgY2FzZSB3aGVuIHRoaXMgVHlwZSBpcyB0b3AtbGV2ZWwuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgY29udGFpbmVyOiBUeXBlIHwgbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgYXJlIGNvbnRhaW5lZCBkaXJlY3RseSBieSB0aGlzXG5cdFx0ICogb25lLiBJbiB0aGUgY2FzZSB3aGVuIHRoaXMgdHlwZSBpcyBhIGxpc3QgdHlwZSwgdGhpcyBhcnJheSBkb2VzXG5cdFx0ICogbm90IGluY2x1ZGUgdGhlIGxpc3QncyBpbnRyaW5zaWMgdHlwZXMuXG5cdFx0ICovXG5cdFx0Z2V0IGNvbnRlbnRzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmNvbnRlbnRzICE9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmNvbnRlbnRzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRjb25zdCBjb250YWluZWROYW1lczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gRGlnIHRocm91Z2ggdGhlIHBhcmFsbGVsIGdyYXBoIHJlY3Vyc2l2ZWx5LCBhbmQgYXQgZWFjaCBwYXJhbGxlbCxcblx0XHRcdC8vIGRpZyB0aHJvdWdoIHRoZSBiYXNlIGdyYXBoIHJlY3Vyc2l2ZWx5LCBhbmQgY29sbGVjdCBhbGwgdGhlIG5hbWVzXG5cdFx0XHQvLyB0aGF0IGFyZSBmb3VuZC5cblx0XHRcdGZvciAoY29uc3QgeyB0eXBlOiBwYXJhbGxlbFR5cGUgfSBvZiB0aGlzLml0ZXJhdGUodCA9PiB0LnBhcmFsbGVscywgdHJ1ZSkpXG5cdFx0XHRcdGZvciAoY29uc3QgeyB0eXBlOiBiYXNlVHlwZSB9IG9mIHBhcmFsbGVsVHlwZS5pdGVyYXRlKHQgPT4gdC5iYXNlcywgdHJ1ZSkpXG5cdFx0XHRcdFx0aWYgKGJhc2VUeXBlLnByaXZhdGUuc2VlZCBpbnN0YW5jZW9mIFNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIGJhc2VUeXBlLnByaXZhdGUuc2VlZC5ub2RlLmNvbnRlbnRzLmtleXMoKSlcblx0XHRcdFx0XHRcdFx0aWYgKCFjb250YWluZWROYW1lcy5pbmNsdWRlcyhuYW1lKSlcblx0XHRcdFx0XHRcdFx0XHRjb250YWluZWROYW1lcy5wdXNoKG5hbWUpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb250ZW50cyA9IGNvbnRhaW5lZE5hbWVzXG5cdFx0XHRcdC5tYXAoY29udGFpbmVkTmFtZSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgbWF5YmVDb250YWluZWRVcmkgPSB0aGlzLnVyaS5leHRlbmRUeXBlKGNvbnRhaW5lZE5hbWUpO1xuXHRcdFx0XHRcdHJldHVybiBUeXBlLmNvbnN0cnVjdChtYXliZUNvbnRhaW5lZFVyaSwgdGhpcy5wcml2YXRlLnByb2dyYW0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZmlsdGVyKCh0KTogdCBpcyBUeXBlID0+IHQgIT09IG51bGwpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmNvbnRlbnRzID0gT2JqZWN0LmZyZWV6ZShjb250ZW50cyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIFN0b3JlcyB0aGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBhcmUgY29udGFpbmVkIGRpcmVjdGx5IGJ5IHRoaXNcblx0XHQgKiBvbmUuIEluIHRoZSBjYXNlIHdoZW4gdGhpcyB0eXBlIGlzIG5vdCBhIGxpc3QgdHlwZSwgdGhpcyBhcnJheVxuXHRcdCAqIGlzIGVtcHR5LlxuXHRcdCAqL1xuXHRcdGdldCBjb250ZW50c0ludHJpbnNpYygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5jb250ZW50c0ludHJpbnNpYyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5jb250ZW50c0ludHJpbnNpYztcblx0XHRcdFxuXHRcdFx0aWYgKCF0aGlzLmlzTGlzdClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5jb250ZW50c0ludHJpbnNpYyA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRcblx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIGFycmF5IG9mIHR5cGVzIGZyb20gd2hpY2ggdGhpcyB0eXBlIGV4dGVuZHMuXG5cdFx0ICogSWYgdGhpcyBUeXBlIGV4dGVuZHMgZnJvbSBhIHBhdHRlcm4sIGl0IGlzIGluY2x1ZGVkIGluIHRoaXNcblx0XHQgKiBhcnJheS5cblx0XHQgKi9cblx0XHRnZXQgYmFzZXMoKTogcmVhZG9ubHkgVHlwZVtdXG5cdFx0e1xuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmJhc2VzID09PSBudWxsKVxuXHRcdFx0XHR0aHJvdyBFeGNlcHRpb24udW5rbm93blN0YXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuYmFzZXMubWF5YmVDb21waWxlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIE5vdCBpbXBsZW1lbnRlZC5cblx0XHQgKi9cblx0XHRnZXQgc3VwZXJvcmRpbmF0ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuc3VwZXJvcmRpbmF0ZXMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuc3VwZXJvcmRpbmF0ZXM7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdHRocm93IEV4Y2VwdGlvbi5ub3RJbXBsZW1lbnRlZCgpO1xuXHRcdFx0XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuc3VwZXJvcmRpbmF0ZXMgPSBPYmplY3QuZnJlZXplKFtdKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQGludGVybmFsXG5cdFx0ICovXG5cdFx0Z2V0IHN1Ym9yZGluYXRlcygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5zdWJvcmRpbmF0ZXMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuc3Vib3JkaW5hdGVzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHR0aHJvdyBFeGNlcHRpb24ubm90SW1wbGVtZW50ZWQoKTtcblx0XHRcdFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLnN1Ym9yZGluYXRlcyA9IE9iamVjdC5mcmVlemUoW10pO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHR5cGVzIHRoYXQgZGVyaXZlIGZyb20gdGhlIFxuXHRcdCAqIHRoaXMgVHlwZSBpbnN0YW5jZS5cblx0XHQgKiBcblx0XHQgKiBUaGUgdHlwZXMgdGhhdCBkZXJpdmUgZnJvbSB0aGlzIG9uZSBhcyBhIHJlc3VsdCBvZiB0aGUgdXNlIG9mXG5cdFx0ICogYW4gYWxpYXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhpcyBhcnJheS5cblx0XHQgKi9cblx0XHRnZXQgZGVyaXZhdGlvbnMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuZGVyaXZhdGlvbnMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuZGVyaXZhdGlvbnM7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbCkpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUuZGVyaXZhdGlvbnMgPSBPYmplY3QuZnJlZXplKFtdKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgZGVyaXZhdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMucHJpdmF0ZS5zZWVkLm5vZGUuaW5ib3VuZHMpXG5cdFx0XHRcdC5tYXAoaWIgPT4gaWIucHJlZGVjZXNzb3IudXJpKVxuXHRcdFx0XHQubWFwKHVyaSA9PiBUeXBlLmNvbnN0cnVjdCh1cmksIHRoaXMucHJpdmF0ZS5wcm9ncmFtKSlcblx0XHRcdFx0LmZpbHRlcigodCk6IHQgaXMgVHlwZSA9PiB0IGluc3RhbmNlb2YgVHlwZSlcblx0XHRcdFx0LmZpbHRlcih0eXBlID0+IHR5cGUuYmFzZXMuaW5jbHVkZXModGhpcykpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmRlcml2YXRpb25zID0gT2JqZWN0LmZyZWV6ZShkZXJpdmF0aW9ucyk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdGhhdCBzaGFyZSB0aGUgc2FtZSBjb250YWluaW5nXG5cdFx0ICogdHlwZSBhcyB0aGlzIG9uZS5cblx0XHQgKi9cblx0XHRnZXQgYWRqYWNlbnRzKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLmFkamFjZW50cyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5hZGphY2VudHM7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJpdmF0ZS50aHJvd09uRGlydHkoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuY29udGFpbmVyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmFkamFjZW50cyA9IHRoaXMuY29udGFpbmVyLmNvbnRlbnRzLmZpbHRlcih0ID0+IHQgIT09IHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5wcml2YXRlLnByb2dyYW07XG5cdFx0XHRjb25zdCBkb2N1bWVudCA9IE5vdC5udWxsKHByb2dyYW0uZG9jdW1lbnRzLmdldCh0aGlzLnVyaSkpO1xuXHRcdFx0Y29uc3Qgcm9vdHMgPSBBcnJheS5mcm9tKHRoaXMucHJpdmF0ZS5wcm9ncmFtLmdyYXBoLnJlYWRSb290cyhkb2N1bWVudCkpO1xuXHRcdFx0Y29uc3QgYWRqYWNlbnRzID0gcm9vdHNcblx0XHRcdFx0Lm1hcChub2RlID0+IFR5cGUuY29uc3RydWN0KG5vZGUudXJpLCBwcm9ncmFtKSlcblx0XHRcdFx0LmZpbHRlcigodCk6IHQgaXMgVHlwZSA9PiB0ICE9PSBudWxsICYmIHQgIT09IHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5wcml2YXRlLmFkamFjZW50cyA9IE9iamVjdC5mcmVlemUoYWRqYWNlbnRzKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0cyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBwYXR0ZXJucyB0aGF0IHJlc29sdmUgdG8gdGhpcyB0eXBlLlxuXHRcdCAqL1xuXHRcdGdldCBwYXR0ZXJucygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5wYXR0ZXJucyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5wYXR0ZXJucztcblx0XHRcdFxuXHRcdFx0dGhpcy5wcml2YXRlLnRocm93T25EaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBTdG9yZXMgYSBtYXAgd2hvc2Uga2V5cyBhcmUgYSBjb25jYXRlbmF0aW9uIG9mIHRoZSBVcmlzIG9mIGFsbFxuXHRcdFx0Ly8gdGhlIGJhc2VzIHRoYXQgYXJlIG1hdGNoZWQgYnkgYSBwYXJ0aWN1bGFyIHBhdHRlcm4sIGFuZCB3aG9zZVxuXHRcdFx0Ly8gdmFsdWVzIGFyZSB0aGUgdHlwZSBvYmplY3QgY29udGFpbmluZyB0aGF0IHBhdHRlcm4uIFRoaXMgbWFwXG5cdFx0XHQvLyBwcm92aWRlcyBhbiBlYXN5IHdheSB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHBhdHRlcm5cblx0XHRcdC8vIHRoYXQgbWF0Y2hlcyBhIHBhcnRpY3VsYXIgc2V0IG9mIHR5cGVzIGluIHRoZSB0eXBlIHNjb3BlLlxuXHRcdFx0Y29uc3QgcGF0dGVybk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBUeXBlPigpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGNvbnN0IHsgdHlwZSB9IG9mIHRoaXMuaXRlcmF0ZSh0ID0+IHQuY29udGFpbmVyKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgYXBwbGljYWJsZVBhdHRlcm5UeXBlcyA9IHR5cGUuYWRqYWNlbnRzXG5cdFx0XHRcdFx0LmZpbHRlcih0ID0+IHQuaXNQYXR0ZXJuKVxuXHRcdFx0XHRcdC5maWx0ZXIodCA9PiB0LmJhc2VzLmluY2x1ZGVzKHR5cGUpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGFwcGxpY2FibGVQYXR0ZXJuc0Jhc2VzTGFiZWxzID1cblx0XHRcdFx0XHRhcHBsaWNhYmxlUGF0dGVyblR5cGVzLm1hcChwID0+IHAuYmFzZXNcblx0XHRcdFx0XHRcdC5tYXAoYiA9PiBiLnVyaS50b1N0cmluZygpKVxuXHRcdFx0XHRcdFx0LmpvaW4oU3ludGF4LnRlcm1pbmFsKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gLTE7ICsraSA8IGFwcGxpY2FibGVQYXR0ZXJuVHlwZXMubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VMYWJlbCA9IGFwcGxpY2FibGVQYXR0ZXJuc0Jhc2VzTGFiZWxzW2ldO1xuXHRcdFx0XHRcdGlmICghcGF0dGVybk1hcC5oYXMoYmFzZUxhYmVsKSlcblx0XHRcdFx0XHRcdHBhdHRlcm5NYXAuc2V0KGJhc2VMYWJlbCwgYXBwbGljYWJsZVBhdHRlcm5UeXBlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3Qgb3V0ID0gQXJyYXkuZnJvbShwYXR0ZXJuTWFwLnZhbHVlcygpKTtcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUucGF0dGVybnMgPSBPYmplY3QuZnJlZXplKG91dCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgcmF3IHN0cmluZyB2YWx1ZXMgcmVwcmVzZW50aW5nXG5cdFx0ICogdGhlIHR5cGUgYWxpYXNlcyB3aXRoIHdoaWNoIHRoaXMgdHlwZSBoYXMgYmVlbiBhbm5vdGF0ZWQuXG5cdFx0ICogXG5cdFx0ICogSWYgdGhpcyB0eXBlIGlzIHVuc3BlY2lmaWVkLCB0aGUgcGFyYWxsZWwgZ3JhcGggaXMgc2VhcmNoZWQsXG5cdFx0ICogYW5kIGFueSBhcHBsaWNhYmxlIHR5cGUgYWxpYXNlcyB3aWxsIGJlIHByZXNlbnQgaW4gdGhlIHJldHVybmVkXG5cdFx0ICogYXJyYXkuXG5cdFx0ICovXG5cdFx0Z2V0IGFsaWFzZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByaXZhdGUuYWxpYXNlcyAhPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5hbGlhc2VzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRjb25zdCBhbGlhc2VzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBleHRyYWN0QWxpYXMgPSAoc3A6IFNwZWNpZmllZFBhcmFsbGVsKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGNvbnN0IHsgZWRnZSwgYWxpYXNlZCB9IG9mIHNwLmVhY2hCYXNlKCkpXG5cdFx0XHRcdFx0aWYgKGFsaWFzZWQpXG5cdFx0XHRcdFx0XHRhbGlhc2VzLnB1c2goZWRnZS5pZGVudGlmaWVyLnRvU3RyaW5nKCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS5zZWVkIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdGV4dHJhY3RBbGlhcyh0aGlzLnByaXZhdGUuc2VlZCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLnByaXZhdGUuc2VlZCBpbnN0YW5jZW9mIFVuc3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHF1ZXVlOiBVbnNwZWNpZmllZFBhcmFsbGVsW10gPSBbdGhpcy5wcml2YXRlLnNlZWRdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yIChsZXQgaSA9IC0xOyArK2kgPCBxdWV1ZS5sZW5ndGg7KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudCA9IHF1ZXVlW2ldO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgcGFyYWxsZWwgb2YgY3VycmVudC5nZXRQYXJhbGxlbHMoKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAocGFyYWxsZWwgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdFx0XHRcdFx0ZXh0cmFjdEFsaWFzKHBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocGFyYWxsZWwgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmFsbGVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS5hbGlhc2VzID0gYWxpYXNlcztcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0Z2V0IHZhbHVlcygpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJpdmF0ZS52YWx1ZXMgIT09IG51bGwpXG5cdFx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUudmFsdWVzO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnByaXZhdGUudGhyb3dPbkRpcnR5KCk7XG5cdFx0XHRjb25zdCB2YWx1ZXM6IHsgdmFsdWU6IHN0cmluZywgYmFzZTogVHlwZSB8IG51bGwsIGFsaWFzZWQ6IGJvb2xlYW4gfVtdID0gW107XG5cdFx0XHRcblx0XHRcdGNvbnN0IGV4dHJhY3RUeXBlID0gKHNwOiBTcGVjaWZpZWRQYXJhbGxlbCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChjb25zdCB7IGVkZ2UsIGFsaWFzZWQgfSBvZiBzcC5lYWNoQmFzZSgpKVxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHtcblx0XHRcdFx0XHRcdGFsaWFzZWQsXG5cdFx0XHRcdFx0XHR2YWx1ZTogZWRnZS5pZGVudGlmaWVyLnRvU3RyaW5nKCksXG5cdFx0XHRcdFx0XHRiYXNlOiBUeXBlLmNvbnN0cnVjdChlZGdlLnByZWRlY2Vzc29yLnVyaSwgdGhpcy5wcml2YXRlLnByb2dyYW0pXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBTcGVjaWZpZWRQYXJhbGxlbClcblx0XHRcdHtcblx0XHRcdFx0ZXh0cmFjdFR5cGUodGhpcy5wcml2YXRlLnNlZWQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5wcml2YXRlLnNlZWQgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBxdWV1ZTogVW5zcGVjaWZpZWRQYXJhbGxlbFtdID0gW3RoaXMucHJpdmF0ZS5zZWVkXTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAtMTsgKytpIDwgcXVldWUubGVuZ3RoOylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZVtpXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhcmFsbGVsIG9mIGN1cnJlbnQuZ2V0UGFyYWxsZWxzKCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFsbGVsIGluc3RhbmNlb2YgU3BlY2lmaWVkUGFyYWxsZWwpXG5cdFx0XHRcdFx0XHRcdGV4dHJhY3RUeXBlKHBhcmFsbGVsKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocGFyYWxsZWwgaW5zdGFuY2VvZiBVbnNwZWNpZmllZFBhcmFsbGVsKVxuXHRcdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmFsbGVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMucHJpdmF0ZS52YWx1ZXMgPSB2YWx1ZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIGZpcnN0IGFsaWFzIHN0b3JlZCBpbiB0aGUgLnZhbHVlcyBhcnJheSwgb3IgbnVsbCBpZiB0aGVcblx0XHQgKiB2YWx1ZXMgYXJyYXkgaXMgZW1wdHkuXG5cdFx0ICovXG5cdFx0Z2V0IHZhbHVlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hbGlhc2VzLmxlbmd0aCA+IDAgPyB0aGlzLmFsaWFzZXNbMF0gOiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBTdG9yZXMgd2hldGhlciB0aGlzIHR5cGUgcmVwcmVzZW50cyB0aGUgaW50cmluc2ljXG5cdFx0ICogc2lkZSBvZiBhIGxpc3QuXG5cdFx0ICovXG5cdFx0cmVhZG9ubHkgaXNMaXN0SW50cmluc2ljOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIHdoZXRoZXIgdGhpcyB0eXBlIHJlcHJlc2VudHMgdGhlIGV4dHJpbnNpY1xuXHRcdCAqIHNpZGUgb2YgYSBsaXN0LlxuXHRcdCAqL1xuXHRcdHJlYWRvbmx5IGlzTGlzdEV4dHJpbnNpYzogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlcyB3aGV0aGVyIHRoaXMgVHlwZSBpbnN0YW5jZSBoYXMgbm8gYW5ub3RhdGlvbnMgYXBwbGllZCB0byBpdC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc0ZyZXNoOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzT3ZlcnJpZGUoKSB7IHJldHVybiB0aGlzLnBhcmFsbGVscy5sZW5ndGggPiAwOyB9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0Z2V0IGlzSW50cm9kdWN0aW9uKCkgeyByZXR1cm4gdGhpcy5wYXJhbGxlbHMubGVuZ3RoID09PSAwOyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgaWYgdGhpcyBUeXBlIHdhcyBkaXJlY3RseSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgZG9jdW1lbnQsIG9yIGlmIGl0J3MgZXhpc3RlbmNlIHdhcyBpbmZlcnJlZC5cblx0XHQgKi9cblx0XHRyZWFkb25seSBpc1NwZWNpZmllZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHJlYWRvbmx5IGlzQW5vbnltb3VzOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgaXNQYXR0ZXJuOiBib29sZWFuID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cmVhZG9ubHkgaXNVcmk6IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBpc0xpc3Q6IGJvb2xlYW4gPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXRzIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoaXMgVHlwZVxuXHRcdCAqIGluc3RhbmNlIHdhcyBjcmVhdGVkIGZyb20gYSBwcmV2aW91cyBlZGl0IGZyYW1lLCBhbmRcblx0XHQgKiBzaG91bGQgbm8gbG9uZ2VyIGJlIHVzZWQuXG5cdFx0ICovXG5cdFx0Z2V0IGlzRGlydHkoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnByaXZhdGUucHJvZ3JhbS52ZXJzaW9uLm5ld2VyVGhhbih0aGlzLnByaXZhdGUuc3RhbXApO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhbiBhcmJpdHJhcnkgcmVjdXJzaXZlLCBicmVhZHRoLWZpcnN0IHRyYXZlcnNhbFxuXHRcdCAqIHRoYXQgYmVnaW5zIGF0IHRoaXMgVHlwZSBpbnN0YW5jZS4gRW5zdXJlcyB0aGF0IG5vIHR5cGVzXG5cdFx0ICogdHlwZXMgYXJlIHlpZWxkZWQgbXVsdGlwbGUgdGltZXMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIG5leHRGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHR5cGUsIG9yIGFuXG5cdFx0ICogaXRlcmFibGUgb2YgdHlwZXMgdGhhdCBhcmUgdG8gYmUgdmlzaXRlZCBuZXh0LlxuXHRcdCAqIEBwYXJhbSByZXZlcnNlIEFuIG9wdGlvbmFsIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXNcblx0XHQgKiB3aGV0aGVyIHR5cGVzIGluIHRoZSByZXR1cm5lZCBhcnJheSBzaG91bGQgYmUgc29ydGVkXG5cdFx0ICogd2l0aCB0aGUgbW9zdCBkZWVwbHkgdmlzaXRlZCBub2RlcyBvY2N1cmluZyBmaXJzdC5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJucyBBbiBhcnJheSB0aGF0IHN0b3JlcyB0aGUgbGlzdCBvZiB0eXBlcyB0aGF0IHdlcmVcblx0XHQgKiB2aXNpdGVkLlxuXHRcdCAqL1xuXHRcdHZpc2l0KG5leHRGbjogKHR5cGU6IFR5cGUpID0+IEl0ZXJhYmxlPFR5cGUgfCBudWxsPiB8IFR5cGUgfCBudWxsLCByZXZlcnNlPzogYm9vbGVhbilcblx0XHR7XG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbSh0aGlzLml0ZXJhdGUobmV4dEZuLCByZXZlcnNlKSkubWFwKGVudHJ5ID0+IGVudHJ5LnR5cGUpO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtcyBhbiBhcmJpdHJhcnkgcmVjdXJzaXZlLCBicmVhZHRoLWZpcnN0IGl0ZXJhdGlvblxuXHRcdCAqIHRoYXQgYmVnaW5zIGF0IHRoaXMgVHlwZSBpbnN0YW5jZS4gRW5zdXJlcyB0aGF0IG5vIHR5cGVzXG5cdFx0ICogdHlwZXMgYXJlIHlpZWxkZWQgbXVsdGlwbGUgdGltZXMuXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIG5leHRGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHR5cGUsIG9yIGFuIGl0ZXJhYmxlXG5cdFx0ICogb2YgdHlwZXMgdGhhdCBhcmUgdG8gYmUgdmlzaXRlZCBuZXh0LlxuXHRcdCAqIEBwYXJhbSByZXZlcnNlIEFuIG9wdGlvbmFsIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXNcblx0XHQgKiB3aGV0aGVyIHRoZSBpdGVyYXRvciBzaG91bGQgeWllbGQgdHlwZXMgc3RhcnRpbmcgd2l0aCB0aGVcblx0XHQgKiBtb3N0IGRlZXBseSBuZXN0ZWQgdHlwZXMgZmlyc3QuXG5cdFx0ICogXG5cdFx0ICogQHlpZWxkcyBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhIGB0eXBlYCBwcm9wZXJ0eSB0aGF0IGlzIHRoZVxuXHRcdCAqIHRoZSBUeXBlIGJlaW5nIHZpc2l0ZWQsIGFuZCBhIGB2aWFgIHByb3BlcnR5IHRoYXQgaXMgdGhlIFR5cGVcblx0XHQgKiB0aGF0IHdhcyByZXR1cm5lZCBpbiB0aGUgcHJldmlvdXMgY2FsbCB0byBgbmV4dEZuYC5cblx0XHQgKi9cblx0XHQqaXRlcmF0ZShuZXh0Rm46ICh0eXBlOiBUeXBlKSA9PiBJdGVyYWJsZTxUeXBlIHwgbnVsbD4gfCBUeXBlIHwgbnVsbCwgcmV2ZXJzZT86IGJvb2xlYW4pXG5cdFx0e1xuXHRcdFx0Y29uc3QgeWllbGRlZDogVHlwZVtdID0gW107XG5cdFx0XHRcblx0XHRcdHR5cGUgUmVjdXJzZVR5cGUgPSBJdGVyYWJsZUl0ZXJhdG9yPHsgdHlwZTogVHlwZTsgdmlhOiBUeXBlIHwgbnVsbCB9Pjtcblx0XHRcdGZ1bmN0aW9uICpyZWN1cnNlKHR5cGU6IFR5cGUsIHZpYTogVHlwZSB8IG51bGwpOiBSZWN1cnNlVHlwZVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoeWllbGRlZC5pbmNsdWRlcyh0eXBlKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXJldmVyc2UpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aWVsZGVkLnB1c2godHlwZSk7XG5cdFx0XHRcdFx0eWllbGQgeyB0eXBlLCB2aWEgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgcmVkdWNlZCA9IG5leHRGbih0eXBlKTtcblx0XHRcdFx0aWYgKHJlZHVjZWQgIT09IG51bGwgJiYgcmVkdWNlZCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHJlZHVjZWQgaW5zdGFuY2VvZiBUeXBlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHlpZWxkICpyZWN1cnNlKHJlZHVjZWQsIHR5cGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgbmV4dFR5cGUgb2YgcmVkdWNlZClcblx0XHRcdFx0XHRcdGlmIChuZXh0VHlwZSBpbnN0YW5jZW9mIFR5cGUpXG5cdFx0XHRcdFx0XHRcdHlpZWxkICpyZWN1cnNlKG5leHRUeXBlLCB0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHJldmVyc2UpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aWVsZGVkLnB1c2godHlwZSk7XG5cdFx0XHRcdFx0eWllbGQgeyB0eXBlLCB2aWEgfTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR5aWVsZCAqcmVjdXJzZSh0aGlzLCBudWxsKTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVlcmllcyBmb3IgYSBUeXBlIHRoYXQgaXMgbmVzdGVkIHVuZGVybmVhdGggdGhpcyBUeXBlLFxuXHRcdCAqIGF0IHRoZSBzcGVjaWZpZWQgdHlwZSBwYXRoLlxuXHRcdCAqL1xuXHRcdHF1ZXJ5KC4uLnR5cGVQYXRoOiBzdHJpbmdbXSlcblx0XHR7XG5cdFx0XHRsZXQgY3VycmVudFR5cGU6IFR5cGUgfCBudWxsID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCB0eXBlTmFtZSBvZiB0eXBlUGF0aClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbmV4dFR5cGUgPSB0aGlzLmNvbnRlbnRzLmZpbmQodHlwZSA9PiB0eXBlLm5hbWUgPT09IHR5cGVOYW1lKTtcblx0XHRcdFx0aWYgKCFuZXh0VHlwZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGN1cnJlbnRUeXBlID0gbmV4dFR5cGU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBjdXJyZW50VHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBUeXBlIGhhcyB0aGUgc3BlY2lmaWVkIHR5cGVcblx0XHQgKiBzb21ld2hlcmUgaW4gaXQncyBiYXNlIGdyYXBoLlxuXHRcdCAqL1xuXHRcdGlzKGJhc2VUeXBlOiBUeXBlKVxuXHRcdHtcblx0XHRcdGZvciAoY29uc3QgeyB0eXBlIH0gb2YgdGhpcy5pdGVyYXRlKHQgPT4gdC5iYXNlcykpXG5cdFx0XHRcdGlmICh0eXBlID09PSBiYXNlVHlwZSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgaW4gdGhpcyBUeXBlJ3Ncblx0XHQgKiBgLmNvbnRlbnRzYCBwcm9wZXJ0eSwgZWl0aGVyIGRpcmVjdGx5LCBvciBpbmRpcmVjdGx5IHZpYVxuXHRcdCAqIHRoZSBwYXJhbGxlbCBncmFwaHMgb2YgdGhlIGAuY29udGVudHNgIFR5cGVzLlxuXHRcdCAqL1xuXHRcdGhhcyh0eXBlOiBUeXBlKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbnRlbnRzLmluY2x1ZGVzKHR5cGUpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Zm9yIChjb25zdCBjb250YWluZWRUeXBlIG9mIHRoaXMuY29udGVudHMpXG5cdFx0XHRcdGlmICh0eXBlLm5hbWUgPT09IGNvbnRhaW5lZFR5cGUubmFtZSlcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhcmFsbGVsIG9mIGNvbnRhaW5lZFR5cGUuaXRlcmF0ZSh0ID0+IHQucGFyYWxsZWxzKSlcblx0XHRcdFx0XHRcdGlmIChwYXJhbGxlbC50eXBlID09PSB0eXBlKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBJbnRlcm5hbCBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIHByaXZhdGUgbWVtYmVyc1xuXHRcdCAqIG9mIHRoZSBUeXBlIG9iamVjdC4gRG8gbm90IHVzZS5cblx0XHQgKi9cblx0XHRwcml2YXRlIHJlYWRvbmx5IHByaXZhdGU6IFR5cGVQcml2YXRlO1xuXHR9XG5cblxuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqIEEgaGlkZGVuIGNsYXNzIHRoYXQgc3RvcmVzIHRoZSBwcml2YXRlIGluZm9ybWF0aW9uIG9mXG5cdCAqIGEgVHlwZSBpbnN0YW5jZSwgdXNlZCB0byBtaXRpZ2F0ZSB0aGUgcmlzayBvZiBsb3ctcmFua1xuXHQgKiBkZXZlbG9wZXJzIGZyb20gZ2V0dGluZyB0aGVtc2VsdmVzIGludG8gdHJvdWJsZS5cblx0ICovXG5cdGNsYXNzIFR5cGVQcml2YXRlXG5cdHtcblx0XHRjb25zdHJ1Y3Rvcihcblx0XHRcdHJlYWRvbmx5IHByb2dyYW06IFByb2dyYW0sXG5cdFx0XHRyZWFkb25seSBzZWVkOiBQYXJhbGxlbClcblx0XHR7XG5cdFx0XHR0aGlzLnN0YW1wID0gcHJvZ3JhbS52ZXJzaW9uO1xuXHRcdH1cblx0XHRcblx0XHQvKiogKi9cblx0XHRyZWFkb25seSBzdGFtcDogVmVyc2lvblN0YW1wO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdGNvbnRlbnRzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRjb250ZW50c0ludHJpbnNpYzogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YmFzZXM6IFR5cGVQcm94eUFycmF5IHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cGFyYWxsZWxzOiBUeXBlUHJveHlBcnJheSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHBhcmFsbGVsUm9vdHM6IHJlYWRvbmx5IFR5cGVbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHBhdHRlcm5zOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRhbGlhc2VzOiByZWFkb25seSBzdHJpbmdbXSB8IG51bGwgPSBudWxsO1xuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHZhbHVlczogcmVhZG9ubHkgeyB2YWx1ZTogc3RyaW5nOyBiYXNlOiBUeXBlIHwgbnVsbDsgYWxpYXNlZDogYm9vbGVhbiB9W10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRzdXBlcm9yZGluYXRlczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3Vib3JkaW5hdGVzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHRkZXJpdmF0aW9uczogcmVhZG9ubHkgVHlwZVtdIHwgbnVsbCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0YWRqYWNlbnRzOiByZWFkb25seSBUeXBlW10gfCBudWxsID0gbnVsbDtcblx0XHRcblx0XHQvKiogKi9cblx0XHR0aHJvd09uRGlydHkoKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLnByb2dyYW0udmVyc2lvbi5uZXdlclRoYW4odGhpcy5zdGFtcCkpXG5cdFx0XHRcdHRocm93IEV4Y2VwdGlvbi5vYmplY3REaXJ0eSgpO1xuXHRcdH1cblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFR5cGVQcm94eVxuXHR7XG5cdFx0LyoqICovXG5cdFx0Y29uc3RydWN0b3IoXG5cdFx0XHRwcml2YXRlIHJlYWRvbmx5IHVyaTogVXJpLFxuXHRcdFx0cHJpdmF0ZSByZWFkb25seSBwcm9ncmFtOiBQcm9ncmFtKVxuXHRcdHsgfVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdG1heWJlQ29tcGlsZSgpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuY29tcGlsZWRUeXBlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbXBpbGVkVHlwZTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRUeXBlID0gVHlwZS5jb25zdHJ1Y3QodGhpcy51cmksIHRoaXMucHJvZ3JhbSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgY29tcGlsZWRUeXBlOiBUeXBlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblx0fVxufVxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFR5cGVQcm94eUFycmF5XG5cdHtcblx0XHQvKipcblx0XHQgKiBcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGFycmF5OiByZWFkb25seSBUeXBlUHJveHlbXSkgeyB9XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0bWF5YmVDb21waWxlKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5jb21waWxlZEFycmF5ICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbXBpbGVkQXJyYXk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG91dCA9IHRoaXMuYXJyYXlcblx0XHRcdFx0Lm1hcChsYXp5ID0+IGxhenkubWF5YmVDb21waWxlKCkpXG5cdFx0XHRcdC5maWx0ZXIoKHR5cGUpOiB0eXBlIGlzIFR5cGUgPT4gdHlwZSAhPT0gbnVsbCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbXBpbGVkQXJyYXkgPSBPYmplY3QuZnJlZXplKG91dCk7XG5cdFx0fVxuXHRcdFxuXHRcdHByaXZhdGUgY29tcGlsZWRBcnJheTogcmVhZG9ubHkgVHlwZVtdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXHR9XG59XG4iLCJcbm5hbWVzcGFjZSBUcnV0aFxue1xuXHQvKipcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRleHBvcnQgdHlwZSBUQ2FjaGVkVHlwZSA9IFR5cGUgfCBUeXBlUHJveHkgfCBudWxsO1xuXG5cblx0LyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFR5cGVDYWNoZVxuXHR7XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGhhcyh1cmk6IFVyaSwgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUocHJvZ3JhbSk7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gY2FjaGUubWFwLmhhcyh1cmlUZXh0KTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIGdldCh1cmk6IFVyaSwgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUocHJvZ3JhbSk7XG5cdFx0XHRjb25zdCB1cmlUZXh0ID0gdXJpLnRvU3RyaW5nKCk7XG5cdFx0XHRcblx0XHRcdGlmIChjYWNoZS5tYXAuaGFzKHVyaVRleHQpKVxuXHRcdFx0XHRyZXR1cm4gTm90LnVuZGVmaW5lZChjYWNoZS5tYXAuZ2V0KHVyaVRleHQpKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgcHJveHkgPSBuZXcgVHlwZVByb3h5KHVyaSwgcHJvZ3JhbSk7XG5cdFx0XHR0aGlzLnNldCh1cmksIHByb2dyYW0sIHByb3h5KTtcblx0XHRcdHJldHVybiBwcm94eTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0c3RhdGljIHNldCh1cmk6IFVyaSwgcHJvZ3JhbTogUHJvZ3JhbSwgdHlwZTogVENhY2hlZFR5cGUpOiBUQ2FjaGVkVHlwZVxuXHRcdHtcblx0XHRcdGNvbnN0IGNhY2hlID0gdGhpcy5nZXRDYWNoZShwcm9ncmFtKTtcblx0XHRcdGNvbnN0IHVyaVRleHQgPSB1cmkudG9TdHJpbmcoKTtcblx0XHRcdGNhY2hlLm1hcC5zZXQodXJpVGV4dCwgdHlwZSk7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSBzdGF0aWMgZ2V0Q2FjaGUocHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHRoaXMuYWxsQ2FjaGVzLmdldChwcm9ncmFtKSB8fCAoKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2FjaGUgPSBuZXcgVHlwZUNhY2hlKHByb2dyYW0pO1xuXHRcdFx0XHR0aGlzLmFsbENhY2hlcy5zZXQocHJvZ3JhbSwgY2FjaGUpO1xuXHRcdFx0XHRyZXR1cm4gY2FjaGU7XG5cdFx0XHR9KSgpO1xuXHRcdFx0XG5cdFx0XHRjYWNoZS5tYXliZUNsZWFyKCk7XG5cdFx0XHRyZXR1cm4gY2FjaGU7XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGFsbENhY2hlcyA9IG5ldyBXZWFrTWFwPFByb2dyYW0sIFR5cGVDYWNoZT4oKTtcblx0XHRcblx0XHQvKiogKi9cblx0XHRwcml2YXRlIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvZ3JhbTogUHJvZ3JhbSlcblx0XHR7XG5cdFx0XHR0aGlzLnZlcnNpb24gPSBwcm9ncmFtLnZlcnNpb247XG5cdFx0fVxuXHRcdFxuXHRcdC8qKiAqL1xuXHRcdHByaXZhdGUgbWF5YmVDbGVhcigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMucHJvZ3JhbS52ZXJzaW9uLm5ld2VyVGhhbih0aGlzLnZlcnNpb24pKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLm1hcC5jbGVhcigpO1xuXHRcdFx0XHR0aGlzLnZlcnNpb24gPSB0aGlzLnByb2dyYW0udmVyc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSB2ZXJzaW9uOiBWZXJzaW9uU3RhbXA7XG5cdFx0XG5cdFx0LyoqICovXG5cdFx0cHJpdmF0ZSByZWFkb25seSBtYXAgPSBuZXcgTWFwPHN0cmluZywgVENhY2hlZFR5cGU+KCk7XG5cdH1cbn1cbiIsIlxuLy8gVXRpbFxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vdXRpbC9IZWxwZXJzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3V0aWwvTXVsdGlNYXAudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vdXRpbC9Gcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi91dGlsL0ZldGNoLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3V0aWwvSGFzaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi91dGlsL0hpZ2hlck9yZGVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3V0aWwvTm90LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3V0aWwvUGFyc2VyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3V0aWwvVW5pY29kZUJsb2Nrcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi91dGlsL01pc2MudHNcIiAvPlxuXG4vLyBTeXN0ZW1cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9Qcm9ncmFtLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9BZ2VudENhY2hlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9DYXVzZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9zeXN0ZW0vRXhjZXB0aW9uLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9VcmkudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vc3lzdGVtL1VyaVByb3RvY29sLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9VcmlQYXJzZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vc3lzdGVtL1VyaUNvbXBvbmVudC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9zeXN0ZW0vVXJpUmVhZGVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9TeW50YXgudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vc3lzdGVtL0ZhdWx0U2VydmljZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9zeXN0ZW0vRmF1bHRzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3N5c3RlbS9WZXJzaW9uU3RhbXAudHNcIiAvPlxuXG4vLyBGaW5pdGUgU3RhdGUgTWFjaGluZVxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZnNtL0FscGhhYmV0LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2ZzbS9UcmFuc2l0aW9uTWFwLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2ZzbS9UcmFuc2l0aW9uU3RhdGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZnNtL0d1aWRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2ZzbS9Gc20udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZnNtL0ZzbVRyYW5zbGF0b3IudHNcIiAvPlxuXG4vLyBQaGFzZXMgLyBGaWxlIFJlcHJlc2VudGF0aW9uXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9Eb2N1bWVudC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9Eb2N1bWVudEdyYXBoLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9maWxlL0RvY3VtZW50SGVhZGVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9maWxlL0xpbmVQYXJzZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL2ZpbGUvQW5vbi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9MaW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9maWxlL0JvdW5kcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9TdGF0ZW1lbnQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL2ZpbGUvUGF0dGVybi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9QYXR0ZXJuUHJlY29tcGlsZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL2ZpbGUvUmVnZXhUeXBlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9JbmZpeC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZmlsZS9JZGVudGlmaWVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9maWxlL1NwYW4udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL2ZpbGUvU3BpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL2ZpbGUvU3ViamVjdC50c1wiIC8+XG5cbi8vIFBoYXNlcyAvIEdyYXBoIFJlcHJlc2VudGF0aW9uXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZ3JhcGgvSHlwZXJHcmFwaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZ3JhcGgvTm9kZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvZ3JhcGgvTm9kZUluZGV4LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9ncmFwaC9IeXBlckVkZ2UudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL2dyYXBoL0luZml4U3Bhbi50c1wiIC8+XG5cbi8vIFBoYXNlcyAvIFBhcmFsbGVsIFJlcHJlc2VudGF0aW9uXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvcGFyYWxsZWwvQ29uc3RydWN0aW9uV29ya2VyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9wYXJhbGxlbC9QYXJhbGxlbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvcGFyYWxsZWwvU3BlY2lmaWVkUGFyYWxsZWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL3BhcmFsbGVsL1Vuc3BlY2lmaWVkUGFyYWxsZWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL3BhcmFsbGVsL0NydWZ0Q2FjaGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL3BhcmFsbGVsL1BhcmFsbGVsQ2FjaGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vcGhhc2VzL3BhcmFsbGVsL0NvbnRyYWN0LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy9wYXJhbGxlbC9TYW5pdGl6ZXIudHNcIiAvPlxuXG4vLyBQaGFzZXMgLyBUeXBlIFJlcHJlc2VudGF0aW9uXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvdHlwZS9UeXBlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL3BoYXNlcy90eXBlL1R5cGVQcm94eS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvdHlwZS9UeXBlUHJveHlBcnJheS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9waGFzZXMvdHlwZS9UeXBlQ2FjaGUudHNcIiAvPlxuIiwiXG5uYW1lc3BhY2UgVHJ1dGhcbntcblx0LyoqIFxuXHQgKiBAaW50ZXJuYWxcblx0ICogKE5vdCBpbXBsZW1lbnRlZClcblx0ICogQSBjbGFzcyB0aGF0IHNwZWNpZmllcyBiZWhhdmlvciBhcm91bmQgdGhlIHJlY29nbml0aW9uIFxuXHQgKiBvZiBwYXR0ZXJucyBmb3VuZCB3aXRoaW4gZG9jdW1lbnRzLlxuXHQgKi9cblx0ZXhwb3J0IGNsYXNzIFJlY29nbml0aW9uXG5cdHtcblx0XHQvKiogKi9cblx0XHRjb25zdHJ1Y3RvcigpIHsgfVxuXHRcdFxuXHRcdC8qKiBXaGV0aGVyIEZpbGUgVVJJcyBzaG91bGQgYmUgcmVjb2duaXplZCBpbiBzdGF0ZW1lbnRzLiAqL1xuXHRcdGZpbGVVcmlzID0gUmVjb2duaXRpb25TdGF0ZS5vbjtcblx0XHRcblx0XHQvKiogV2hldGhlciBIVFRQIFVSSXMgc2hvdWxkIGJlIHJlY29nbml6ZWQgaW4gc3RhdGVtZW50cy4gKi9cblx0XHRodHRwVXJpcyA9IFJlY29nbml0aW9uU3RhdGUub247XG5cdFx0XG5cdFx0LyoqIFdoZXRoZXIgcmVndWxhciBleHByZXNzaW9ucyBzaG91bGQgYmUgcmVjb2duaXplZCBpbiBzdGF0ZW1lbnRzLiAqL1xuXHRcdHJlZ3VsYXJFeHByZXNzaW9ucyA9IFJlY29nbml0aW9uU3RhdGUub247XG5cdFx0XG5cdFx0LyoqIFdoZXRoZXIgY29tbWVudHMgc2hvdWxkIGJlIHJlY29nbml6ZWQgaW4gc3RhdGVtZW50cy4gKi9cblx0XHRjb21tZW50cyA9IFJlY29nbml0aW9uU3RhdGUub247XG5cdH1cblx0XG5cdGV4cG9ydCBjb25zdCBlbnVtIFJlY29nbml0aW9uU3RhdGVcblx0e1xuXHRcdC8qKiBJbmRpY2F0ZXMgdGhhdCBhIHBhdHRlcm4gaXMgcmVjb2duaXplZCBieSB0aGUgc3lzdGVtLiAqL1xuXHRcdG9uLFxuXHRcdFxuXHRcdC8qKiBJbmRpY2F0ZXMgdGhhdCBhIHBhdHRlcm4gaXMgbm90IHJlY29nbml6ZWQgYnkgdGhlIHN5c3RlbS4gKi9cblx0XHRvZmYsXG5cdFx0XG5cdFx0LyoqIEluZGljYXRlcyB0aGF0IGEgcGF0dGVybiBpcyByZWNvZ25pemVkIGJ5IHRoZSBzeXN0ZW0sIGFuZCBvbWl0dGVkLiAqL1xuXHRcdG9taXR0ZWRcblx0fVxufVxuIl19